{"text": "informal statement For all odd $n$ show that $8 \\mid n^{2}-1$.formal statement theorem exercise_1_27 {n : \u2115} (hn : odd n) : 8 \u2223 (n^2 - 1) :="}
{"text": "informal statement Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$.formal statement theorem exercise_29_10 {X : Type*}\n  [topological_space X] [t2_space X] (x : X)\n  (hx : \u2203 U : set X, x \u2208 U \u2227 is_open U \u2227 (\u2203 K : set X, U \u2282 K \u2227 is_compact K))\n  (U : set X) (hU : is_open U) (hxU : x \u2208 U) :\n  \u2203 (V : set X), is_open V \u2227 x \u2208 V \u2227 is_compact (closure V) \u2227 closure V \u2286 U :="}
{"text": "informal statement Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$.formal statement theorem exercise_2018_b2 (n : \u2115) (hn : n > 0) (f : \u2115 \u2192 \u2102 \u2192 \u2102) \n  (hf : \u2200 n : \u2115, f n = \u03bb z, (\u2211 (i : fin n), (n-i)* z^(i : \u2115))) : \n  \u00ac (\u2203 z : \u2102, \u2016z\u2016 \u2264 1 \u2227 f n z = 0) :="}
{"text": "informal statement Show that a group of order 5 must be abelian.formal statement theorem exercise_2_1_21 (G : Type*) [group G] [fintype G]\n  (hG : card G = 5) :\n  comm_group G :="}
{"text": "informal statement Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.formal statement theorem exercise_25_4 {X : Type*} [topological_space X]\n  [loc_path_connected_space X] (U : set X) (hU : is_open U)\n  (hcU : is_connected U) : is_path_connected U :="}
{"text": "informal statement If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.formal statement theorem exercise_1_11a (z : \u2102) : \n  \u2203 (r : \u211d) (w : \u2102), abs w = 1 \u2227 z = r * w :="}
{"text": "informal statement Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.formal statement theorem exercise_7_10 {V : Type*} [inner_product_space \u2102 V]\n  [finite_dimensional \u2102 V] (T : End \u2102 V)\n  (hT : T * T.adjoint = T.adjoint * T) (hT1 : T^9 = T^8) :\n  is_self_adjoint T \u2227 T^2 = T :="}
{"text": "informal statement Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$.formal statement theorem exercise_3_14 {p q n : \u2115} (hp0 : p.prime \u2227 p > 2) \n  (hq0 : q.prime \u2227 q > 2) (hpq0 : p \u2260 q) (hpq1 : p - 1 \u2223 q - 1)\n  (hn : n.gcd (p*q) = 1) : \n  n^(q-1) \u2261 1 [MOD p*q] :="}
{"text": "informal statement Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$.formal statement theorem exercise_9_3_2 {f g : polynomial \u211a} (i j : \u2115)\n  (hfg : \u2200 n : \u2115, \u2203 a : \u2124, (f*g).coeff = a) :\n  \u2203 a : \u2124, f.coeff i * g.coeff j = a :="}
{"text": "informal statement Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected.formal statement theorem exercise_23_2 {X : Type*}\n  [topological_space X] {A : \u2115 \u2192 set X} (hA : \u2200 n, is_connected (A n))\n  (hAn : \u2200 n, A n \u2229 A (n + 1) \u2260 \u2205) :\n  is_connected (\u22c3 n, A n) :="}
{"text": "informal statement If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$.formal statement theorem exercise_2_5_37 (G : Type*) [group G] [fintype G]\n  (hG : card G = 6) (hG' : is_empty (comm_group G)) :\n  G \u2243* equiv.perm (fin 3) :="}
{"text": "informal statement Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.formal statement theorem exercise_2_27a (k : \u2115) (E P : set (euclidean_space \u211d (fin k)))\n  (hE : E.nonempty \u2227 \u00ac set.countable E)\n  (hP : P = {x | \u2200 U \u2208 \ud835\udcdd x, \u00ac set.countable (P \u2229 E)}) :\n  is_closed P \u2227 P = {x | cluster_pt x (\ud835\udcdf P)}  :="}
{"text": "informal statement Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.formal statement theorem exercise_2_27a (k : \u2115) (E P : set (euclidean_space \u211d (fin k)))\n  (hE : E.nonempty \u2227 \u00ac set.countable E)\n  (hP : P = {x | \u2200 U \u2208 \ud835\udcdd x, \u00ac set.countable (P \u2229 E)}) :\n  is_closed P \u2227 P = {x | cluster_pt x (\ud835\udcdf P)}  :="}
{"text": "informal statement Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.formal statement theorem exercise_3_5_6 {K V : Type*} [field K] [add_comm_group V]\n  [module K V] {S : set V} (hS : set.countable S)\n  (hS1 : span K S = \u22a4) {\u03b9 : Type*} (R : \u03b9 \u2192 V)\n  (hR : linear_independent K R) : countable \u03b9 :="}
{"text": "informal statement Show that the rationals $\\mathbb{Q}$ are not locally compact.formal statement theorem exercise_29_10 {X : Type*}\n  [topological_space X] [t2_space X] (x : X)\n  (hx : \u2203 U : set X, x \u2208 U \u2227 is_open U \u2227 (\u2203 K : set X, U \u2282 K \u2227 is_compact K))\n  (U : set X) (hU : is_open U) (hxU : x \u2208 U) :\n  \u2203 (V : set X), is_open V \u2227 x \u2208 V \u2227 is_compact (closure V) \u2227 closure V \u2286 U :="}
{"text": "informal statement Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).formal statement theorem exercise_3_4_1 (G : Type*) [comm_group G] [is_simple_group G] :\n    is_cyclic G \u2227 \u2203 G_fin : fintype G, nat.prime (@card G G_fin) :="}
{"text": "informal statement Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle.formal statement theorem exercise_1_19b (z : \u2102) (hz : abs z = 1) (s : \u2115 \u2192 \u2102)\n    (h : s = (\u03bb n, \u2211 i in (finset.range n), i * z / i ^ 2)) :\n    \u2203 y, tendsto s at_top (\ud835\udcdd y) :="}
{"text": "/-- `try_solve t` either solves the goal using `t` or does not change the proof state. -/\nmacro \"try_solve \" t:tacticSeq : tactic =>\n  `(tactic| first | (solve | $t) | skip)\n\n-- example : True \u2228 False := by (try_solve apply Or.inr); trivial\n\n/-- `lax_exact h` completes the goal using `h`, adding a subgoal to\nrewrite the goal to the type of `h`.\n\nIt tries to automatically prove this subgoal using `trivial`.\n\nThe disadvantage is that no inference is possible at all in `h`. -/\nmacro \"lax_exact \" t:term : tactic =>\n  /- `Eq.subst (Eq.symm ?_) $t` seems to get the motive wrong, so use\n  `cast` and `congr` afterwards instead. -/\n  `(tactic| focus refine cast (Eq.symm ?_) $t; congr; try_solve trivial)\n\n/-- `lax_apply h` is essentially the same as `lax_exact (h ..)`.\n\nAs a result, it is currently useless (see end of docstring of `lax_exact`). -/\n-- In fact, currently, it _is_ the same.\nmacro \"lax_apply\" t:term : tactic =>\n  `(tactic| lax_exact $t ..)\n\n/- example (a b : Nat) : a + b - b \u2264 a + b := by\n  lax_exact Nat.le_add_right a b\n  apply Nat.add_sub_cancel -/\n"}
{"text": "informal statement Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.formal statement theorem exercise_18_4 {n : \u2115} (hn : \u2203 x y z w : \u2124, \n  x^3 + y^3 = n \u2227 z^3 + w^3 = n \u2227 x \u2260 z \u2227 x \u2260 w \u2227 y \u2260 z \u2227 y \u2260 w) : \n  n \u2265 1729 :="}
{"text": "informal statement Prove that if $|G|=1365$ then $G$ is not simple.formal statement theorem exercise_4_5_20 {G : Type*} [fintype G] [group G]\n  (hG : card G = 1365) : \u00ac is_simple_group G :="}
{"text": "informal statement Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$.formal statement theorem exercise_21_6a\n  (f : \u2115 \u2192 I \u2192 \u211d )\n  (h : \u2200 x n, f n x = x ^ n) :\n  \u2200 x, \u2203 y, tendsto (\u03bb n, f n x) at_top (\ud835\udcdd y) :="}
{"text": "informal statement Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.formal statement theorem exercise_4_5_18 {G : Type*} [fintype G] [group G] \n  (hG : card G = 200) : \n  \u2203 N : sylow 5 G, N.normal :="}
{"text": "informal statement Prove that if $|G|=132$ then $G$ is not simple.formal statement theorem exercise_4_5_22 {G : Type*} [fintype G] [group G]\n  (hG : card G = 132) : \u00ac is_simple_group G :="}
{"text": "informal statement Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.formal statement theorem exercise_4_3_25 (I : ideal (matrix (fin 2) (fin 2) \u211d)) : \n  I = \u22a5 \u2228 I = \u22a4 :="}
{"text": "informal statement Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.formal statement theorem exercise_30_13 {X : Type*} [topological_space X]\n  (h : \u2203 (s : set X), countable s \u2227 dense s) (U : set (set X))\n  (hU : \u2200 (x y : set X), x \u2208 U \u2192 y \u2208 U \u2192 x \u2260 y \u2192 x \u2229 y = \u2205) :\n  countable U :="}
{"text": "informal statement Let $X$ be completely regular. Show that $X$ is connected if and only if the Stone-\u010cech compactification of $X$ is connected.formal statement theorem exercise_38_6 {X : Type*}\n  (X : Type*) [topological_space X] [regular_space X]\n  (h : \u2200 x A, is_closed A \u2227 \u00ac x \u2208 A \u2192\n  \u2203 (f : X \u2192 I), continuous f \u2227 f x = (1 : I) \u2227 f '' A = {0}) :\n  is_connected (univ : set X) \u2194 is_connected (univ : set (stone_cech X)) :="}
{"text": "informal statement Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.formal statement theorem exercise_4_5 {p t : \u2115} (hp0 : p.prime) (hp1 : p = 4*t + 3)\n  (a : zmod p) :\n  is_primitive_root a p \u2194 ((-a) ^ ((p-1)/2) = 1 \u2227 \u2200 (k : \u2115), k < (p-1)/2 \u2192 (-a)^k \u2260 1) :="}
{"text": "informal statement Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.formal statement theorem exercise_2_5_30 {G : Type*} [group G] [fintype G]\n  {p m : \u2115} (hp : nat.prime p) (hp1 : \u00ac p \u2223 m) (hG : card G = p*m) \n  {H : subgroup G} [fintype H] [H.normal] (hH : card H = p):\n  characteristic H :="}
{"text": "informal statement Suppose that $|G| = pm$, where $p \\nmid m$ and $p$ is a prime. If $H$ is a normal subgroup of order $p$ in $G$, prove that $H$ is characteristic.formal statement theorem exercise_2_5_37 (G : Type*) [group G] [fintype G]\n  (hG : card G = 6) (hG' : is_empty (comm_group G)) :\n  G \u2243* equiv.perm (fin 3) :="}
{"text": "informal statement Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$.formal statement theorem exercise_9_4_2d {p : \u2115} (hp : p.prime \u2227 p > 2) \n  {f : polynomial \u2124} (hf : f = (X + 2)^p): \n  irreducible (\u2211 n in (f.support \\ {0}), (f.coeff n) * X ^ (n-1) : \n  polynomial \u2124) :="}
{"text": "informal statement Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.formal statement theorem exercise_1_19\n  (n : \u2115)\n  (a b c x : euclidean_space \u211d (fin n))\n  (r : \u211d)\n  (h\u2081 : r > 0)\n  (h\u2082 : 3 \u2022 c = 4 \u2022 b - a)\n  (h\u2083 : 3 * r = 2 * \u2016x - b\u2016)\n  : \u2016x - a\u2016 = 2 * \u2016x - b\u2016 \u2194 \u2016x - c\u2016 = r :="}
{"text": "informal statement Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.formal statement theorem exercise_2_1_5 {G : Type*} [group G] [fintype G] \n  (hG : card G > 2) (H : subgroup G) [fintype H] : \n  card H \u2260 card G - 1 :="}
{"text": "informal statement Prove that $-(-v) = v$ for every $v \\in V$.formal statement theorem exercise_1_3 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {v : V} : -(-v) = v :="}
{"text": "informal statement Show that a closed subspace of a normal space is normal.formal statement theorem exercise_32_2b\n  {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, topological_space (X i)]\n  (h : \u2200 i, nonempty (X i)) (h2 : regular_space (\u03a0 i, X i)) :\n  \u2200 i, regular_space (X i) :="}
{"text": "informal statement If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.formal statement theorem exercise_1_1a\n  (x : \u211d) (y : \u211a) :\n  ( irrational x ) -> irrational ( x + y ) :="}
{"text": "informal statement Show that a closed subspace of a normal space is normal.formal statement theorem exercise_32_1 {X : Type*} [topological_space X]\n  (hX : normal_space X) (A : set X) (hA : is_closed A) :\n  normal_space {x // x \u2208 A} :="}
{"text": "informal statement Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.formal statement theorem exercise_10_7_10 {R : Type*} [ring R]\n  (M : ideal R) (hM : \u2200 (x : R), x \u2209 M \u2192 is_unit x) :\n  is_maximal M \u2227 \u2200 (N : ideal R), is_maximal N \u2192 N = M :="}
{"text": "informal statement Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$.formal statement theorem exercise_21_6a\n  (f : \u2115 \u2192 I \u2192 \u211d )\n  (h : \u2200 x n, f n x = x ^ n) :\n  \u2200 x, \u2203 y, tendsto (\u03bb n, f n x) at_top (\ud835\udcdd y) :="}
{"text": "informal statement Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.formal statement theorem exercise_1_13c {f : \u2102 \u2192 \u2102} (\u03a9 : set \u2102) (a b : \u03a9) (h : is_open \u03a9)\n  (hf : differentiable_on \u2102 f \u03a9) (hc : \u2203 (c : \u211d), \u2200 z \u2208 \u03a9, abs (f z) = c) :\n  f a = f b :="}
{"text": "informal statement If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.formal statement theorem exercise_2_6_15 {G : Type*} [comm_group G] {m n : \u2115} \n  (hm : \u2203 (g : G), order_of g = m) \n  (hn : \u2203 (g : G), order_of g = n) \n  (hmn : m.coprime n) :\n  \u2203 (g : G), order_of g = m * n :="}
{"text": "informal statement Prove that if $|G|=1365$ then $G$ is not simple.formal statement theorem exercise_4_5_22 {G : Type*} [fintype G] [group G]\n  (hG : card G = 132) : \u00ac is_simple_group G :="}
{"text": "informal statement If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.formal statement theorem exercise_5_4 {n : \u2115}\n  (C : \u2115 \u2192 \u211d)\n  (hC : \u2211 i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\n  \u2203 x, x \u2208 (set.Icc (0 : \u211d) 1) \u2227 \u2211 i in finset.range (n + 1), (C i) * (x^i) = 0 :="}
{"text": "informal statement Show that a connected metric space having more than one point is uncountable.formal statement theorem exercise_27_4\n  {X : Type*} [metric_space X] [connected_space X] (hX : \u2203 x y : X, x \u2260 y) :\n  \u00ac countable (univ : set X) :="}
{"text": "informal statement Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.formal statement theorem exercise_4_2_14 {G : Type*} [fintype G] [group G] \n  (hG : \u00ac (card G).prime) (hG1 : \u2200 k \u2223 card G, \n  \u2203 (H : subgroup G) (fH : fintype H), @card H fH = k) : \n  \u00ac is_simple_group G :="}
{"text": "informal statement Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.formal statement theorem exercise_31_2 {X : Type*}\n  [topological_space X] [normal_space X] {A B : set X}\n  (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\n  \u2203 (U V : set X), is_open U \u2227 is_open V \u2227 A \u2286 U \u2227 B \u2286 V \u2227 closure U \u2229 closure V = \u2205 :="}
{"text": "informal statement Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant.formal statement theorem exercise_1_13a {f : \u2102 \u2192 \u2102} (\u03a9 : set \u2102) (a b : \u03a9) (h : is_open \u03a9)\n  (hf : differentiable_on \u2102 f \u03a9) (hc : \u2203 (c : \u211d), \u2200 z \u2208 \u03a9, (f z).re = c) :\n  f a = f b :="}
{"text": "informal statement Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable.formal statement theorem exercise_13_6 :\n  \u00ac (\u2200 U, Rl.is_open U \u2192 K_topology.is_open U) \u2227 \u00ac (\u2200 U, K_topology.is_open U \u2192 Rl.is_open U) :="}
{"text": "informal statement Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected.formal statement theorem exercise_24_2 {f : (metric.sphere 0 1 : set \u211d) \u2192 \u211d}\n  (hf : continuous f) : \u2203 x, f x = f (-x) :="}
{"text": "informal statement Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.formal statement theorem exercise_2_2_9 {G : Type*} [group G] {a b : G}\n  (h : a * b = b * a) :\n  \u2200 x y : closure {x | x = a \u2228 x = b}, x*y = y*x :="}
{"text": "informal statement Show that every locally compact Hausdorff space is regular.formal statement theorem exercise_32_3 {X : Type*} [topological_space X]\n  (hX : locally_compact_space X) (hX' : t2_space X) :\n  regular_space X :="}
{"text": "informal statement Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$.formal statement theorem exercise_3_1 {F V : Type*}  \n  [add_comm_group V] [field F] [module F V] [finite_dimensional F V]\n  (T : V \u2192\u2097[F] V) (hT : finrank F V = 1) :\n  \u2203 c : F, \u2200 v : V, T v = c \u2022 v:="}
{"text": "informal statement Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.formal statement theorem exercise_1_6_17 {G : Type*} [group G] (f : G \u2192 G) \n  (hf : f = \u03bb g, g\u207b\u00b9) :\n  \u2200 x y : G, f x * f y = f (x*y) \u2194 \u2200 x y : G, x*y = y*x :="}
{"text": "informal statement Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.formal statement theorem exercise_1_8 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {\u03b9 : Type*} (u : \u03b9 \u2192 submodule F V) :\n  \u2203 U : submodule F V, (\u22c2 (i : \u03b9), (u i).carrier) = \u2191U :="}
{"text": "informal statement Show that 1729 is the smallest positive integer expressible as the sum of two different integral cubes in two ways.formal statement theorem exercise_1_13a {f : \u2102 \u2192 \u2102} (\u03a9 : set \u2102) (a b : \u03a9) (h : is_open \u03a9)\n  (hf : differentiable_on \u2102 f \u03a9) (hc : \u2203 (c : \u211d), \u2200 z \u2208 \u03a9, (f z).re = c) :\n  f a = f b :="}
{"text": "informal statement Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.formal statement theorem exercise_17_4 {X : Type*} [topological_space X]\n  (U A : set X) (hU : is_open U) (hA : is_closed A) :\n  is_open (U \\ A) \u2227 is_closed (A \\ U) :="}
{"text": "informal statement Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.formal statement theorem exercise_2_28 (X : Type*) [metric_space X] [separable_space X]\n  (A : set X) (hA : is_closed A) :\n  \u2203 P\u2081 P\u2082 : set X, A = P\u2081 \u222a P\u2082 \u2227\n  is_closed P\u2081 \u2227 P\u2081 = {x | cluster_pt x (\ud835\udcdf P\u2081)} \u2227\n  set.countable P\u2082 :="}
{"text": "informal statement A uniformly continuous function of a uniformly continuous function is uniformly continuous.formal statement theorem exercise_4_19\n  {f : \u211d \u2192 \u211d} (hf : \u2200 a b c, a < b \u2192 f a < c \u2192 c < f b \u2192 \u2203 x, a < x \u2227 x < b \u2227 f x = c)\n  (hg : \u2200 r : \u211a, is_closed {x | f x = r}) : continuous f :="}
{"text": "informal statement Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$.formal statement theorem exercise_4_2_9 {p : \u2115} (hp : nat.prime p) (hp1 : odd p) :\n  \u2203 (a b : \u2124), (a / b : \u211a) = \u2211 i in finset.range p, 1 / (i + 1) \u2192 \u2191p \u2223 a :="}
{"text": "informal statement For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$formal statement theorem exercise_2020_b5 (z : fin 4 \u2192 \u2102) (hz0 : \u2200 n, \u2016z n\u2016 < 1) \n  (hz1 : \u2200 n : fin 4, z n \u2260 1) : \n  3 - z 0 - z 1 - z 2 - z 3 + (z 0) * (z 1) * (z 2) * (z 3) \u2260 0 :="}
{"text": "informal statement Prove that a group of even order contains an element of order $2 .$formal statement theorem exercise_3_5_6 {K V : Type*} [field K] [add_comm_group V]\n  [module K V] {S : set V} (hS : set.countable S)\n  (hS1 : span K S = \u22a4) {\u03b9 : Type*} (R : \u03b9 \u2192 V)\n  (hR : linear_independent K R) : countable \u03b9 :="}
{"text": "informal statement Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian.formal statement theorem exercise_2_2_5 {G : Type*} [group G] \n  (h : \u2200 (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3 \u2227 (a * b) ^ 5 = a ^ 5 * b ^ 5) :\n  comm_group G :="}
{"text": "informal statement Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$.formal statement theorem exercise_13_4_10 \n    {p : \u2115} {hp : nat.prime p} (h : \u2203 r : \u2115, p = 2 ^ r + 1) :\n    \u2203 (k : \u2115), p = 2 ^ (2 ^ k) + 1 :="}
{"text": "informal statement Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.formal statement theorem exercise_13_4_10 \n    {p : \u2115} {hp : nat.prime p} (h : \u2203 r : \u2115, p = 2 ^ r + 1) :\n    \u2203 (k : \u2115), p = 2 ^ (2 ^ k) + 1 :="}
{"text": "informal statement Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$.formal statement theorem exercise_1_6 : \u2203 U : set (\u211d \u00d7 \u211d),\n  (U \u2260 \u2205) \u2227\n  (\u2200 (u v : \u211d \u00d7 \u211d), u \u2208 U \u2227 v \u2208 U \u2192 u + v \u2208 U) \u2227\n  (\u2200 (u : \u211d \u00d7 \u211d), u \u2208 U \u2192 -u \u2208 U) \u2227\n  (\u2200 U' : submodule \u211d (\u211d \u00d7 \u211d), U \u2260 \u2191U') :="}
{"text": "informal statement Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.formal statement theorem exercise_5_2_20 {F V \u03b9: Type*} [infinite F] [field F] \n  [add_comm_group V] [module F V] {u : \u03b9 \u2192 submodule F V} \n  (hu : \u2200 i : \u03b9, u i \u2260 \u22a4) : \n  (\u22c3 i : \u03b9, (u i : set V)) \u2260 \u22a4 :="}
{"text": "informal statement Let $X$ be a metric space in which every infinite subset has a limit point. Prove that $X$ is separable.formal statement theorem exercise_2_24 {X : Type*} [metric_space X]\n  (hX : \u2200 (A : set X), infinite A \u2192 \u2203 (x : X), x \u2208 closure A) :\n  separable_space X :="}
{"text": "informal statement Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$.formal statement theorem exercise_3_4 (n : \u2115) :\n  tendsto (\u03bb n, (sqrt (n + 1) - sqrt n)) at_top (\ud835\udcdd 0) :="}
{"text": "informal statement Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact.formal statement theorem exercise_2_41 (m : \u2115) {X : Type*} [normed_space \u211d ((fin m) \u2192 \u211d)] :\n  is_compact (metric.closed_ball 0 1) :="}
{"text": "informal statement Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.formal statement theorem exercise_6_4_3 {G : Type*} [group G] [fintype G] {p q : \u2115}\n  (hp : prime p) (hq : prime q) (hG : card G = p^2 *q) :\n  is_simple_group G \u2192 false :="}
{"text": "informal statement Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex.formal statement theorem exercise_4_24 {f : \u211d \u2192 \u211d}\n  (hf : continuous f) (a b : \u211d) (hab : a < b)\n  (h : \u2200 x y : \u211d, a < x \u2192 x < b \u2192 a < y \u2192 y < b \u2192 f ((x + y) / 2) \u2264 (f x + f y) / 2) :\n  convex_on \u211d (set.Ioo a b) f :="}
{"text": "informal statement Show that if $X$ has a countable dense subset, every collection of disjoint open sets in $X$ is countable.formal statement theorem exercise_31_2 {X : Type*}\n  [topological_space X] [normal_space X] {A B : set X}\n  (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\n  \u2203 (U V : set X), is_open U \u2227 is_open V \u2227 A \u2286 U \u2227 B \u2286 V \u2227 closure U \u2229 closure V = \u2205 :="}
{"text": "informal statement Prove that in the ring $\\mathbb{Z}[x],(2) \\cap(x)=(2 x)$.formal statement theorem exercise_10_2_4 :\n  span ({2} : set $ polynomial \u2124) \u2293 (span {X}) =\n  span ({2 * X} : set $ polynomial \u2124) :="}
{"text": "informal statement Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $\\text{Re}(f)$ is constant, then $f$ is constant.formal statement theorem exercise_1_13c {f : \u2102 \u2192 \u2102} (\u03a9 : set \u2102) (a b : \u03a9) (h : is_open \u03a9)\n  (hf : differentiable_on \u2102 f \u03a9) (hc : \u2203 (c : \u211d), \u2200 z \u2208 \u03a9, abs (f z) = c) :\n  f a = f b :="}
{"text": "informal statement Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$.formal statement theorem exercise_4_3_26 {\u03b1 : Type*} [fintype \u03b1] (ha : fintype.card \u03b1 > 1)\n  (h_tran : \u2200 a b: \u03b1, \u2203 \u03c3 : equiv.perm \u03b1, \u03c3 a = b) : \n  \u2203 \u03c3 : equiv.perm \u03b1, \u2200 a : \u03b1, \u03c3 a \u2260 a :="}
{"text": "informal statement Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.formal statement theorem exercise_1_1_16 {G : Type*} [group G] \n  (x : G) (hx : x ^ 2 = 1) :\n  order_of x = 1 \u2228 order_of x = 2 :="}
{"text": "informal statement Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).formal statement theorem exercise_3_1_22b {G : Type*} [group G] (I : Type*)\n  (H : I \u2192 subgroup G) (hH : \u2200 i : I, subgroup.normal (H i)) : \n  subgroup.normal (\u2a05 (i : I), H i):="}
{"text": "informal statement Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent.formal statement theorem exercise_10_4_6 {R : Type*} [comm_ring R] \n  [no_zero_divisors R] {I J : ideal R} (x : I \u2293 J) : \n  is_nilpotent ((ideal.quotient.mk (I*J)) x) :="}
{"text": "informal statement An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$.formal statement theorem exercise_8_1_12 {N : \u2115} (hN : N > 0) {M M': \u2124} {d : \u2115}\n  (hMN : M.gcd N = 1) (hMd : d.gcd N.totient = 1) \n  (hM' : M' \u2261 M^d [ZMOD N]) : \n  \u2203 d' : \u2115, d' * d \u2261 1 [ZMOD N.totient] \u2227 \n  M \u2261 M'^d' [ZMOD N] :="}
{"text": "informal statement If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function.formal statement theorem exercise_2_4_36 {a n : \u2115} (h : a > 1) :\n  n \u2223 (a ^ n - 1).totient :="}
{"text": "informal statement Prove that any two nonabelian groups of order 21 are isomorphic.formal statement theorem exercise_2_8_12 {G H : Type*} [fintype G] [fintype H] \n  [group G] [group H] (hG : card G = 21) (hH : card H = 21) \n  (hG1 : is_empty(comm_group G)) (hH1 : is_empty (comm_group H)) :\n  G \u2243* H :="}
{"text": "informal statement Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$.formal statement theorem exercise_3_63b (p : \u211d) (f : \u2115 \u2192 \u211d) (hp : p \u2264 1)\n  (h : f = \u03bb k, (1 : \u211d) / (k * (log k) ^ p)) :\n  \u00ac \u2203 l, tendsto f at_top (\ud835\udcdd l) :="}
{"text": "informal statement A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative.formal statement theorem exercise_7_1_15 {R : Type*} [ring R] (hR : \u2200 a : R, a^2 = a) :\n  comm_ring R :="}
{"text": "informal statement Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$formal statement theorem exercise_6_16 {K V : Type*} [is_R_or_C K] [inner_product_space K V]\n  {U : submodule K V} : \n  U.orthogonal = \u22a5  \u2194 U = \u22a4 :="}
{"text": "informal statement Let $(p_n)$ be a sequence and $f:\\mathbb{N}\\to\\mathbb{N}$. The sequence $(q_k)_{k\\in\\mathbb{N}}$ with $q_k=p_{f(k)}$ is called a rearrangement of $(p_n)$. Show that if $f$ is an injection, the limit of a sequence is unaffected by rearrangement.formal statement theorem exercise_2_12a (f : \u2115 \u2192 \u2115) (p : \u2115 \u2192 \u211d) (a : \u211d)\n  (hf : injective f) (hp : tendsto p at_top (\ud835\udcdd a)) :\n  tendsto (\u03bb n, p (f n)) at_top (\ud835\udcdd a) :="}
{"text": "informal statement Let $p$ be an odd prime and let $1 + \\frac{1}{2} + ... + \\frac{1}{p - 1} = \\frac{a}{b}$, where $a, b$ are integers. Show that $p \\mid a$.formal statement theorem exercise_4_3_25 (I : ideal (matrix (fin 2) (fin 2) \u211d)) : \n  I = \u22a5 \u2228 I = \u22a4 :="}
{"text": "informal statement Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.formal statement theorem exercise_5_2_20 {F V \u03b9: Type*} [infinite F] [field F] \n  [add_comm_group V] [module F V] {u : \u03b9 \u2192 submodule F V} \n  (hu : \u2200 i : \u03b9, u i \u2260 \u22a4) : \n  (\u22c3 i : \u03b9, (u i : set V)) \u2260 \u22a4 :="}
{"text": "informal statement Prove that every closed set in a separable metric space is the union of a (possibly empty) perfect set and a set which is at most countable.formal statement theorem exercise_3_1a\n  (f : \u2115 \u2192 \u211d)\n  (h : \u2203 (a : \u211d), tendsto (\u03bb (n : \u2115), f n) at_top (\ud835\udcdd a))\n  : \u2203 (a : \u211d), tendsto (\u03bb (n : \u2115), |f n|) at_top (\ud835\udcdd a) :="}
{"text": "informal statement If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.formal statement theorem exercise_2_9_2 {G H : Type*} [fintype G] [fintype H] [group G] \n  [group H] (hG : is_cyclic G) (hH : is_cyclic H) :\n  is_cyclic (G \u00d7 H) \u2194 (card G).coprime (card H) :="}
{"text": "informal statement Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$.formal statement theorem exercise_5_37 {p q : \u2115} [fact(p.prime)] [fact(q.prime)] {a : \u2124}\n  (ha : a < 0) (h0 : p \u2261 q [ZMOD 4*a]) (h1 : \u00ac ((p : \u2124) \u2223 a)) :\n  legendre_sym p a = legendre_sym q a :="}
{"text": "informal statement Consider a prime $p$ of the form $4 t+3$. Show that $a$ is a primitive root modulo $p$ iff $-a$ has order $(p-1) / 2$.formal statement theorem exercise_4_8 {p a : \u2115} (hp : odd p) : \n  is_primitive_root a p \u2194 (\u2200 q \u2223 (p-1), q.prime \u2192 \u00ac a^(p-1) \u2261 1 [MOD p]) :="}
{"text": "informal statement Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$.formal statement theorem exercise_38_6 {X : Type*}\n  (X : Type*) [topological_space X] [regular_space X]\n  (h : \u2200 x A, is_closed A \u2227 \u00ac x \u2208 A \u2192\n  \u2203 (f : X \u2192 I), continuous f \u2227 f x = (1 : I) \u2227 f '' A = {0}) :\n  is_connected (univ : set X) \u2194 is_connected (univ : set (stone_cech X)) :="}
{"text": "informal statement Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such thatformal statement theorem exercise_2_12a (f : \u2115 \u2192 \u2115) (p : \u2115 \u2192 \u211d) (a : \u211d)\n  (hf : injective f) (hp : tendsto p at_top (\ud835\udcdd a)) :\n  tendsto (\u03bb n, p (f n)) at_top (\ud835\udcdd a) :="}
{"text": "informal statement Show that $ \\int_{-\\infty}^{\\infty} \\frac{\\cos x}{x^2 + a^2} dx = \\pi \\frac{e^{-a}}{a}$ for $a > 0$.formal statement theorem exercise_3_3 (a : \u211d) (ha : 0 < a) :\n    tendsto (\u03bb y, \u222b x in -y..y, real.cos x / (x ^ 2 + a ^ 2))\n    at_top (\ud835\udcdd (real.pi * (real.exp (-a) / a))) :="}
{"text": "informal statement Prove that any two nonabelian groups of order 21 are isomorphic.formal statement theorem exercise_2_9_2 {G H : Type*} [fintype G] [fintype H] [group G] \n  [group H] (hG : is_cyclic G) (hH : is_cyclic H) :\n  is_cyclic (G \u00d7 H) \u2194 (card G).coprime (card H) :="}
{"text": "informal statement Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.formal statement theorem exercise_2_5_44 {G : Type*} [group G] [fintype G] {p : \u2115}\n  (hp : nat.prime p) (hG : card G = p^2) :\n  \u2203 (N : subgroup G) (fin : fintype N), @card N fin = p \u2227 N.normal :="}
{"text": "informal statement Show that if $X$ is an infinite set, it is connected in the finite complement topology.formal statement theorem exercise_23_9 {X Y : Type*}\n  [topological_space X] [topological_space Y]\n  (A\u2081 A\u2082 : set X)\n  (B\u2081 B\u2082 : set Y)\n  (hA : A\u2081 \u2282 A\u2082)\n  (hB : B\u2081 \u2282 B\u2082)\n  (hA : is_connected A\u2082)\n  (hB : is_connected B\u2082) :\n  is_connected ({x | \u2203 a b, x = (a, b) \u2227 a \u2208 A\u2082 \u2227 b \u2208 B\u2082} \\\n      {x | \u2203 a b, x = (a, b) \u2227 a \u2208 A\u2081 \u2227 b \u2208 B\u2081}) :="}
{"text": "informal statement Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.formal statement theorem exercise_2_4_16b {n : \u2115} {hn : n \u2260 0} \n  {R : subgroup (dihedral_group n)} \n  (hR : R = subgroup.closure {dihedral_group.r 1}) : \n  R \u2260 \u22a4 \u2227 \n  \u2200 K : subgroup (dihedral_group n), R \u2264 K \u2192 K = R \u2228 K = \u22a4 :="}
{"text": "informal statement Prove that a group of order 200 has a normal Sylow 5-subgroup.formal statement theorem exercise_4_5_20 {G : Type*} [fintype G] [group G]\n  (hG : card G = 1365) : \u00ac is_simple_group G :="}
{"text": "informal statement Suppose that $f$ is holomorphic in an open set $\\Omega$. Prove that if $|f|$ is constant, then $f$ is constant.formal statement theorem exercise_1_19b (z : \u2102) (hz : abs z = 1) (s : \u2115 \u2192 \u2102)\n    (h : s = (\u03bb n, \u2211 i in (finset.range n), i * z / i ^ 2)) :\n    \u2203 y, tendsto s at_top (\ud835\udcdd y) :="}
{"text": "informal statement Suppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal operator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.formal statement theorem exercise_7_14 {\ud835\udd5c V : Type*} [is_R_or_C \ud835\udd5c]\n  [inner_product_space \ud835\udd5c V] [finite_dimensional \ud835\udd5c V]\n  {T : End \ud835\udd5c V} (hT : is_self_adjoint T)\n  {l : \ud835\udd5c} {\u03b5 : \u211d} (he : \u03b5 > 0) : \u2203 v : V, \u2016v\u2016= 1 \u2227 (\u2016T v - l \u2022 v\u2016 < \u03b5 \u2192\n  (\u2203 l' : T.eigenvalues, \u2016l - l'\u2016 < \u03b5)) :="}
{"text": "informal statement Let $|G|=p q r$, where $p, q$ and $r$ are primes with $p<q<r$. Prove that $G$ has a normal Sylow subgroup for either $p, q$ or $r$.formal statement theorem exercise_4_5_16 {p q r : \u2115} {G : Type*} [group G] \n  [fintype G]  (hpqr : p < q \u2227 q < r) \n  (hpqr1 : p.prime \u2227 q.prime \u2227 r.prime)(hG : card G = p*q*r) : \n  nonempty (sylow p G) \u2228 nonempty(sylow q G) \u2228 nonempty(sylow r G) :="}
{"text": "informal statement If $a > 1$ is an integer, show that $n \\mid \\varphi(a^n - 1)$, where $\\phi$ is the Euler $\\varphi$-function.formal statement theorem exercise_2_5_30 {G : Type*} [group G] [fintype G]\n  {p m : \u2115} (hp : nat.prime p) (hp1 : \u00ac p \u2223 m) (hG : card G = p*m) \n  {H : subgroup G} [fintype H] [H.normal] (hH : card H = p):\n  characteristic H :="}
{"text": "informal statement Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous.formal statement theorem exercise_19_6a\n  {n : \u2115}\n  {f : fin n \u2192 Type*} {x : \u2115 \u2192 \u03a0a, f a}\n  (y : \u03a0i, f i)\n  [\u03a0a, topological_space (f a)] :\n  tendsto x at_top (\ud835\udcdd y) \u2194 \u2200 i, tendsto (\u03bb j, (x j) i) at_top (\ud835\udcdd (y i)) :="}
{"text": "informal statement Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.formal statement theorem exercise_4_5_28 {G : Type*} [group G] [fintype G] \n  (hG : card G = 105) (P : sylow 3 G) [hP : P.normal] : \n  comm_group G :="}
{"text": "informal statement Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.formal statement theorem exercise_9_3_2 {f g : polynomial \u211a} (i j : \u2115)\n  (hfg : \u2200 n : \u2115, \u2203 a : \u2124, (f*g).coeff = a) :\n  \u2203 a : \u2124, f.coeff i * g.coeff j = a :="}
{"text": "informal statement Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$.formal statement theorem exercise_5_2 {a b : \u211d}\n  {f g : \u211d \u2192 \u211d} (hf : \u2200 x \u2208 set.Ioo a b, deriv f x > 0)\n  (hg : g = f\u207b\u00b9)\n  (hg_diff : differentiable_on \u211d g (set.Ioo a b)) :\n  differentiable_on \u211d g (set.Ioo a b) \u2227\n  \u2200 x \u2208 set.Ioo a b, deriv g x = 1 / deriv f x :="}
{"text": "informal statement Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty.formal statement theorem exercise_3_22 (X : Type*) [metric_space X] [complete_space X]\n  (G : \u2115 \u2192 set X) (hG : \u2200 n, is_open (G n) \u2227 dense (G n)) :\n  \u2203 x, \u2200 n, x \u2208 G n :="}
{"text": "informal statement Suppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly increasing in $(a, b)$, and let $g$ be its inverse function. Prove that $g$ is differentiable, and that $g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$.formal statement theorem exercise_5_4 {n : \u2115}\n  (C : \u2115 \u2192 \u211d)\n  (hC : \u2211 i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\n  \u2203 x, x \u2208 (set.Icc (0 : \u211d) 1) \u2227 \u2211 i in finset.range (n + 1), (C i) * (x^i) = 0 :="}
{"text": "informal statement Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$.formal statement theorem exercise_3_1a\n  (f : \u2115 \u2192 \u211d)\n  (h : \u2203 (a : \u211d), tendsto (\u03bb (n : \u2115), f n) at_top (\ud835\udcdd a))\n  : \u2203 (a : \u211d), tendsto (\u03bb (n : \u2115), |f n|) at_top (\ud835\udcdd a) :="}
{"text": "informal statement Prove that $\\sqrt{n+1}-\\sqrt{n} \\rightarrow 0$ as $n \\rightarrow \\infty$.formal statement theorem exercise_3_63b (p : \u211d) (f : \u2115 \u2192 \u211d) (hp : p \u2264 1)\n  (h : f = \u03bb k, (1 : \u211d) / (k * (log k) ^ p)) :\n  \u00ac \u2203 l, tendsto f at_top (\ud835\udcdd l) :="}
{"text": "informal statement Let $G$ be a transitive permutation group on the finite set $A$ with $|A|>1$. Show that there is some $\\sigma \\in G$ such that $\\sigma(a) \\neq a$ for all $a \\in A$.formal statement theorem exercise_4_2_14 {G : Type*} [fintype G] [group G] \n  (hG : \u00ac (card G).prime) (hG1 : \u2200 k \u2223 card G, \n  \u2203 (H : subgroup G) (fH : fintype H), @card H fH = k) : \n  \u00ac is_simple_group G :="}
{"text": "informal statement Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. Prove that $P$ is perfect.formal statement theorem exercise_2_28 (X : Type*) [metric_space X] [separable_space X]\n  (A : set X) (hA : is_closed A) :\n  \u2203 P\u2081 P\u2082 : set X, A = P\u2081 \u222a P\u2082 \u2227\n  is_closed P\u2081 \u2227 P\u2081 = {x | cluster_pt x (\ud835\udcdf P\u2081)} \u2227\n  set.countable P\u2082 :="}
{"text": "informal statement If $z$ is a complex number, prove that there exists an $r\\geq 0$ and a complex number $w$ with $| w | = 1$ such that $z = rw$.formal statement theorem exercise_1_13 (x y : \u2102) : \n  |(abs x) - (abs y)| \u2264 abs (x - y) :="}
{"text": "informal statement Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.formal statement theorem exercise_13_6 :\n  \u00ac (\u2200 U, Rl.is_open U \u2192 K_topology.is_open U) \u2227 \u00ac (\u2200 U, K_topology.is_open U \u2192 Rl.is_open U) :="}
{"text": "/-\n  Copyright (c) 2021 Arthur Paulino. All rights reserved.\n  Released under Apache 2.0 license as described in the file LICENSE.\n  Authors: Arthur Paulino\n-/\n\ntheorem Int.ZeroAdd (a : Int) :\n    0 + a = a := sorry\n\ntheorem Int.AddAssoc (a b c : Int) :\n    a + b + c = a + (b + c) := sorry\n\ntheorem Int.zeroLtSubOfLt (a b : Int) (h : a < b) :\n    0 < b - a := sorry\n\ntheorem Int.what (a b c : Int) (h : 0 < c) :\n    a + (b - (c + a) + 0) < b := sorry\n"}
{"text": "informal statement Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .formal statement theorem exercise_5_37 {p q : \u2115} [fact(p.prime)] [fact(q.prime)] {a : \u2124}\n  (ha : a < 0) (h0 : p \u2261 q [ZMOD 4*a]) (h1 : \u00ac ((p : \u2124) \u2223 a)) :\n  legendre_sym p a = legendre_sym q a :="}
{"text": "informal statement Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.formal statement theorem exercise_2_4_19 {G : Type*} [group G] {x : G}\n  (hx : order_of x = 2) (hx1 : \u2200 y, order_of y = 2 \u2192 y = x) :\n  x \u2208 center G :="}
{"text": "informal statement Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$.formal statement theorem exercise_13_1 (X : Type*) [topological_space X] (A : set X)\n  (h1 : \u2200 x \u2208 A, \u2203 U : set X, x \u2208 U \u2227 is_open U \u2227 U \u2286 A) :\n  is_open A :="}
{"text": "informal statement Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.formal statement theorem exercise_6_1_14 (G : Type*) [group G]\n  (hG : is_cyclic $ G \u29f8 (center G)) :\n  center G = \u22a4  :="}
{"text": "informal statement Prove that a group of order $p^2$, $p$ a prime, has a normal subgroup of order $p$.formal statement theorem exercise_2_6_15 {G : Type*} [comm_group G] {m n : \u2115} \n  (hm : \u2203 (g : G), order_of g = m) \n  (hn : \u2203 (g : G), order_of g = n) \n  (hmn : m.coprime n) :\n  \u2203 (g : G), order_of g = m * n :="}
{"text": "informal statement If $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.formal statement theorem exercise_1_2 : \u00ac \u2203 (x : \u211a), ( x ^ 2 = 12 ) :="}
{"text": "informal statement Let $X$ be a topological space; let $A$ be a subset of $X$. Suppose that for each $x \\in A$ there is an open set $U$ containing $x$ such that $U \\subset A$. Show that $A$ is open in $X$.formal statement theorem exercise_13_4a1 (X I : Type*) (T : I \u2192 set (set X)) (h : \u2200 i, is_topology X (T i)) :\n  is_topology X (\u22c2 i : I, T i) :="}
{"text": "informal statement Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.formal statement theorem exercise_10_2_4 :\n  span ({2} : set $ polynomial \u2124) \u2293 (span {X}) =\n  span ({2 * X} : set $ polynomial \u2124) :="}
{"text": "informal statement Show that if $\\mathcal{A}$ is a basis for a topology on $X$, then the topology generated by $\\mathcal{A}$ equals the intersection of all topologies on $X$ that contain $\\mathcal{A}$.formal statement theorem exercise_13_5a {X : Type*}\n  [topological_space X] (A : set (set X)) (hA : is_topological_basis A) :\n  generate_from A = generate_from (sInter {T | is_topology X T \u2227 A \u2286 T}) :="}
{"text": "informal statement Let $p$ be a prime integer. Prove that the polynomial $x^n-p$ is irreducible in $\\mathbb{Q}[x]$.formal statement theorem exercise_11_4_8 {p : \u2115} (hp : prime p) (n : \u2115) :\n  irreducible (X ^ n - p : polynomial \u211a) :="}
{"text": "informal statement If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$.formal statement theorem exercise_4_5_25 {p : \u2115} (hp : nat.prime p) :\n  irreducible (\u2211 i : finset.range p, X ^ p : polynomial \u211a) :="}
{"text": "informal statement For $j \\in\\{1,2,3,4\\}$, let $z_{j}$ be a complex number with $\\left|z_{j}\\right|=1$ and $z_{j} \\neq 1$. Prove that $3-z_{1}-z_{2}-z_{3}-z_{4}+z_{1} z_{2} z_{3} z_{4} \\neq 0 .$formal statement theorem exercise_2018_b2 (n : \u2115) (hn : n > 0) (f : \u2115 \u2192 \u2102 \u2192 \u2102) \n  (hf : \u2200 n : \u2115, f n = \u03bb z, (\u2211 (i : fin n), (n-i)* z^(i : \u2115))) : \n  \u00ac (\u2203 z : \u2102, \u2016z\u2016 \u2264 1 \u2227 f n z = 0) :="}
{"text": "informal statement Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.formal statement theorem exercise_4_5_14 {G : Type*} [group G] [fintype G]\n  (hG : card G = 312) :\n  \u2203 (p : \u2115) (P : sylow p G), P.normal :="}
{"text": "informal statement Let $p$ and $q$ be distinct odd primes such that $p-1$ divides $q-1$. If $(n, p q)=1$, show that $n^{q-1} \\equiv 1(p q)$.formal statement theorem exercise_4_5 {p t : \u2115} (hp0 : p.prime) (hp1 : p = 4*t + 3)\n  (a : zmod p) :\n  is_primitive_root a p \u2194 ((-a) ^ ((p-1)/2) = 1 \u2227 \u2200 (k : \u2115), k < (p-1)/2 \u2192 (-a)^k \u2260 1) :="}
{"text": "informal statement If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges.formal statement theorem exercise_3_8\n  (a b : \u2115 \u2192 \u211d)\n  (h1 : \u2203 y, (tendsto (\u03bb n, (\u2211 i in (finset.range n), a i)) at_top (\ud835\udcdd y)))\n  (h2 : monotone b)\n  (h3 : metric.bounded (set.range b)) :\n  \u2203 y, tendsto (\u03bb n, (\u2211 i in (finset.range n), (a i) * (b i))) at_top (\ud835\udcdd y) :="}
{"text": "informal statement Let $\\mathbf{x}_1, \\mathbf{x}_2, \\ldots$ be a sequence of the points of the product space $\\prod X_\\alpha$.  Show that this sequence converges to the point $\\mathbf{x}$ if and only if the sequence $\\pi_\\alpha(\\mathbf{x}_i)$ converges to $\\pi_\\alpha(\\mathbf{x})$ for each $\\alpha$.formal statement theorem exercise_19_6a\n  {n : \u2115}\n  {f : fin n \u2192 Type*} {x : \u2115 \u2192 \u03a0a, f a}\n  (y : \u03a0i, f i)\n  [\u03a0a, topological_space (f a)] :\n  tendsto x at_top (\ud835\udcdd y) \u2194 \u2200 i, tendsto (\u03bb j, (x j) i) at_top (\ud835\udcdd (y i)) :="}
{"text": "informal statement Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian.formal statement theorem exercise_3_4_11 {G : Type*} [group G] [is_solvable G] \n  {H : subgroup G} (hH : H \u2260 \u22a5) [H.normal] : \n  \u2203 A \u2264 H, A.normal \u2227 \u2200 a b : A, a*b = b*a :="}
{"text": "informal statement If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$.formal statement theorem exercise_13_4a1 (X I : Type*) (T : I \u2192 set (set X)) (h : \u2200 i, is_topology X (T i)) :\n  is_topology X (\u22c2 i : I, T i) :="}
{"text": "informal statement Show that every locally compact Hausdorff space is regular.formal statement theorem exercise_33_8\n  (X : Type*) [topological_space X] [regular_space X]\n  (h : \u2200 x A, is_closed A \u2227 \u00ac x \u2208 A \u2192\n  \u2203 (f : X \u2192 I), continuous f \u2227 f x = (1 : I) \u2227 f '' A = {0})\n  (A B : set X) (hA : is_closed A) (hB : is_closed B)\n  (hAB : disjoint A B)\n  (hAc : is_compact A) :\n  \u2203 (f : X \u2192 I), continuous f \u2227 f '' A = {0} \u2227 f '' B = {1} :="}
{"text": "informal statement Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.formal statement theorem exercise_2_11_22 {p : \u2115} {n : \u2115} {G : Type*} [fintype G] \n  [group G] (hp : nat.prime p) (hG : card G = p ^ n) {K : subgroup G}\n  [fintype K] (hK : card K = p ^ (n-1)) : \n  K.normal :="}
{"text": "informal statement If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$.formal statement theorem exercise_1_13 (x y : \u2102) : \n  |(abs x) - (abs y)| \u2264 abs (x - y) :="}
{"text": "informal statement Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes.formal statement theorem exercise_1_1_5 (n : \u2115) (hn : 1 < n) : \n  is_empty (group (zmod n)) :="}
{"text": "informal statement Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$.formal statement theorem exercise_6_2 {V : Type*} [add_comm_group V] [module \u2102 V]\n  [inner_product_space \u2102 V] (u v : V) :\n  \u27eau, v\u27eb_\u2102 = 0 \u2194 \u2200 (a : \u2102), \u2016u\u2016  \u2264 \u2016u + a \u2022 v\u2016 :="}
{"text": "informal statement Let $A$ be a proper subset of $X$, and let $B$ be a proper subset of $Y$. If $X$ and $Y$ are connected, show that $(X \\times Y)-(A \\times B)$ is connected.formal statement theorem exercise_23_9 {X Y : Type*}\n  [topological_space X] [topological_space Y]\n  (A\u2081 A\u2082 : set X)\n  (B\u2081 B\u2082 : set Y)\n  (hA : A\u2081 \u2282 A\u2082)\n  (hB : B\u2081 \u2282 B\u2082)\n  (hA : is_connected A\u2082)\n  (hB : is_connected B\u2082) :\n  is_connected ({x | \u2203 a b, x = (a, b) \u2227 a \u2208 A\u2082 \u2227 b \u2208 B\u2082} \\\n      {x | \u2203 a b, x = (a, b) \u2227 a \u2208 A\u2081 \u2227 b \u2208 B\u2081}) :="}
{"text": "informal statement Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2.formal statement theorem exercise_9_1_6 : \u00ac is_principal \n  (ideal.span ({X 0, X 1} : set (mv_polynomial (fin 2) \u211a))) :="}
{"text": "informal statement If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.formal statement theorem exercise_4_5_1a {p : \u2115} {G : Type*} [group G] \n  {P : subgroup G} (hP : is_p_group p P) (H : subgroup G) \n  (hH : P \u2264 H) : is_p_group p H :="}
{"text": "informal statement If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.formal statement theorem exercise_4_5a\n  (f : \u211d \u2192 \u211d)\n  (E : set \u211d)\n  (h\u2081 : is_closed E)\n  (h\u2082 : continuous_on f E)\n  : \u2203 (g : \u211d \u2192 \u211d), continuous g \u2227 \u2200 x \u2208 E, f x = g x :="}
{"text": "informal statement If $\\mathcal{T}_\\alpha$ is a family of topologies on $X$, show that $\\bigcap \\mathcal{T}_\\alpha$ is a topology on $X$.formal statement theorem exercise_13_4b1 (X I : Type*) (T : I \u2192 set (set X)) (h : \u2200 i, is_topology X (T i)) :\n  \u2203! T', is_topology X T' \u2227 (\u2200 i, T i \u2286 T') \u2227\n  \u2200 T'', is_topology X T'' \u2192 (\u2200 i, T i \u2286 T'') \u2192 T'' \u2286 T' :="}
{"text": "informal statement Give an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition and under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), but $U$ is not a subspace of $\\mathbf{R}^2$.formal statement theorem exercise_1_8 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {\u03b9 : Type*} (u : \u03b9 \u2192 submodule F V) :\n  \u2203 U : submodule F V, (\u22c2 (i : \u03b9), (u i).carrier) = \u2191U :="}
{"text": "informal statement Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.formal statement theorem exercise_3_14 {p q n : \u2115} (hp0 : p.prime \u2227 p > 2) \n  (hq0 : q.prime \u2227 q > 2) (hpq0 : p \u2260 q) (hpq1 : p - 1 \u2223 q - 1)\n  (hn : n.gcd (p*q) = 1) : \n  n^(q-1) \u2261 1 [MOD p*q] :="}
{"text": "informal statement Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$.formal statement theorem exercise_5_13 {p x: \u2124} (hp : prime p) \n  (hpx : p \u2223 (x^4 - x^2 + 1)) : p \u2261 1 [ZMOD 12] :="}
{"text": "informal statement Prove that $G$ cannot have a subgroup $H$ with $|H|=n-1$, where $n=|G|>2$.formal statement theorem exercise_2_4_4 {G : Type*} [group G] (H : subgroup G) : \n  subgroup.closure ((H : set G) \\ {1}) = \u22a4 :="}
{"text": "informal statement Suppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$formal statement theorem exercise_7_6 {V : Type*} [inner_product_space \u2102 V]\n  [finite_dimensional \u2102 V] (T : End \u2102 V)\n  (hT : T * T.adjoint = T.adjoint * T) :\n  T.range = T.adjoint.range :="}
{"text": "informal statement Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.formal statement theorem exercise_4_24 {f : \u211d \u2192 \u211d}\n  (hf : continuous f) (a b : \u211d) (hab : a < b)\n  (h : \u2200 x y : \u211d, a < x \u2192 x < b \u2192 a < y \u2192 y < b \u2192 f ((x + y) / 2) \u2264 (f x + f y) / 2) :\n  convex_on \u211d (set.Ioo a b) f :="}
{"text": "informal statement Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.formal statement theorem exercise_5_12 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {S : End F V}\n  (hS : \u2200 v : V, \u2203 c : F, v \u2208 eigenspace S c) :\n  \u2203 c : F, S = c \u2022 id :="}
{"text": "informal statement Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses.formal statement theorem exercise_3_4 (n : \u2115) :\n  tendsto (\u03bb n, (sqrt (n + 1) - sqrt n)) at_top (\ud835\udcdd 0) :="}
{"text": "informal statement Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.formal statement theorem exercise_8_3_4 {R : Type*} {n : \u2124} {r s : \u211a} \n  (h : r^2 + s^2 = n) : \n  \u2203 a b : \u2124, a^2 + b^2 = n :="}
{"text": "informal statement Show that if $S$ is connected, it is not true in general that its interior is connected.formal statement theorem exercise_2_126 {E : set \u211d}\n  (hE : \u00ac set.countable E) : \u2203 (p : \u211d), cluster_pt p (\ud835\udcdf E) :="}
{"text": "informal statement Show that any prime divisor of $x^{4}-x^{2}+1$ is congruent to 1 modulo 12 .formal statement theorem exercise_5_13 {p x: \u2124} (hp : prime p) \n  (hpx : p \u2223 (x^4 - x^2 + 1)) : p \u2261 1 [ZMOD 12] :="}
{"text": "informal statement Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.formal statement theorem exercise_4_1_19 : infinite {x : quaternion \u211d | x^2 = -1} :="}
{"text": "informal statement Prove that a group of order 200 has a normal Sylow 5-subgroup.formal statement theorem exercise_4_5_18 {G : Type*} [fintype G] [group G] \n  (hG : card G = 200) : \n  \u2203 N : sylow 5 G, N.normal :="}
{"text": "informal statement Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common.formal statement theorem exercise_4_4 (p : polynomial \u2102) :\n  p.degree = @card (root_set p \u2102) (polynomial.root_set_fintype p \u2102) \u2194\n  disjoint\n  (@card (root_set p.derivative \u2102) (polynomial.root_set_fintype p.derivative \u2102))\n  (@card (root_set p \u2102) (polynomial.root_set_fintype p \u2102)) :="}
{"text": "informal statement Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.formal statement theorem exercise_1_26\n  (f F\u2081 F\u2082 : \u2102 \u2192 \u2102) (\u03a9 : set \u2102) (h1 : is_open \u03a9) (h2 : is_connected \u03a9)\n  (hF\u2081 : differentiable_on \u2102 F\u2081 \u03a9) (hF\u2082 : differentiable_on \u2102 F\u2082 \u03a9)\n  (hdF\u2081 : \u2200 x \u2208 \u03a9, deriv F\u2081 x = f x) (hdF\u2082 : \u2200 x \u2208 \u03a9, deriv F\u2082 x = f x)\n  : \u2203 c : \u2102, \u2200 x, F\u2081 x = F\u2082 x + c :="}
{"text": "informal statement Prove that subgroups of a solvable group are solvable.formal statement theorem exercise_3_4_11 {G : Type*} [group G] [is_solvable G] \n  {H : subgroup G} (hH : H \u2260 \u22a5) [H.normal] : \n  \u2203 A \u2264 H, A.normal \u2227 \u2200 a b : A, a*b = b*a :="}
{"text": "informal statement A ring $R$ is called a Boolean ring if $a^{2}=a$ for all $a \\in R$. Prove that every Boolean ring is commutative.formal statement theorem exercise_7_2_12 {R G : Type*} [ring R] [group G] [fintype G] : \n  \u2211 g : G, monoid_algebra.of R G g \u2208 center (monoid_algebra R G) :="}
{"text": "informal statement Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.formal statement theorem exercise_24_2 {f : (metric.sphere 0 1 : set \u211d) \u2192 \u211d}\n  (hf : continuous f) : \u2203 x, f x = f (-x) :="}
{"text": "informal statement Prove that if $G$ is an abelian simple group then $G \\cong Z_{p}$ for some prime $p$ (do not assume $G$ is a finite group).formal statement theorem exercise_3_4_5a {G : Type*} [group G] \n  (H : subgroup G) [is_solvable G] : is_solvable H :="}
{"text": "informal statement Let $X$ be locally path connected. Show that every connected open set in $X$ is path connected.formal statement theorem exercise_26_11\n  {X : Type*} [topological_space X] [compact_space X] [t2_space X]\n  (A : set (set X)) (hA : \u2200 (a b : set X), a \u2208 A \u2192 b \u2208 A \u2192 a \u2286 b \u2228 b \u2286 a)\n  (hA' : \u2200 a \u2208 A, is_closed a) (hA'' : \u2200 a \u2208 A, is_connected a) :\n  is_connected (\u22c2\u2080 A) :="}
{"text": "informal statement Show that if $S$ is connected, it is not true in general that its interior is connected.formal statement theorem exercise_2_57 {X : Type*} [topological_space X]\n  : \u2203 (S : set X), is_connected S \u2227 \u00ac is_connected (interior S) :="}
{"text": "informal statement Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.formal statement theorem exercise_2010_a4 (n : \u2115) : \n  \u00ac nat.prime (10^10^10^n + 10^10^n + 10^n - 1) :="}
{"text": "informal statement Show that a group of order 5 must be abelian.formal statement theorem exercise_2_1_27 {G : Type*} [group G] \n  [fintype G] : \u2203 (m : \u2115), \u2200 (a : G), a ^ m = 1 :="}
{"text": "informal statement Show that if $a$ is negative then $p \\equiv q(4 a) together with p\\not | a$ imply $(a / p)=(a / q)$.formal statement theorem exercise_18_4 {n : \u2115} (hn : \u2203 x y z w : \u2124, \n  x^3 + y^3 = n \u2227 z^3 + w^3 = n \u2227 x \u2260 z \u2227 x \u2260 w \u2227 y \u2260 z \u2227 y \u2260 w) : \n  n \u2265 1729 :="}
{"text": "informal statement If $G$ is an abelian group and if $G$ has an element of order $m$ and one of order $n$, where $m$ and $n$ are relatively prime, prove that $G$ has an element of order $mn$.formal statement theorem exercise_2_8_12 {G H : Type*} [fintype G] [fintype H] \n  [group G] [group H] (hG : card G = 21) (hH : card H = 21) \n  (hG1 : is_empty(comm_group G)) (hH1 : is_empty (comm_group H)) :\n  G \u2243* H :="}
{"text": "informal statement Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$.formal statement theorem exercise_2_29 (M : Type*) [metric_space M]\n  (O C : set (set M))\n  (hO : O = {s | is_open s})\n  (hC : C = {s | is_closed s}) :\n  \u2203 f : O \u2192 C, bijective f :="}
{"text": "informal statement Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.formal statement theorem exercise_32_2b\n  {\u03b9 : Type*} {X : \u03b9 \u2192 Type*} [\u2200 i, topological_space (X i)]\n  (h : \u2200 i, nonempty (X i)) (h2 : regular_space (\u03a0 i, X i)) :\n  \u2200 i, regular_space (X i) :="}
{"text": "informal statement If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$formal statement theorem exercise_2_3_17 {G : Type*} [has_mul G] [group G] (a x : G) :  \n  set.centralizer {x\u207b\u00b9*a*x} = \n  (\u03bb g : G, x\u207b\u00b9*g*x) '' (set.centralizer {a}) :="}
{"text": "informal statement Prove that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$.formal statement theorem exercise_3_3\n  : \u2203 (x : \u211d), tendsto f at_top (\ud835\udcdd x) \u2227 \u2200 n, f n < 2 :="}
{"text": "informal statement Show that there is an infinite number of integers a such that $f(x) = x^7 + 15x^2 - 30x + a$ is irreducible in $Q[x]$.formal statement theorem exercise_4_6_3 :\n  infinite {a : \u2124 | irreducible (X^7 + 15*X^2 - 30*X + a : polynomial \u211a)} :="}
{"text": "informal statement Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.formal statement theorem exercise_4_8b\n  (E : set \u211d) :\n  \u2203 f : \u211d \u2192 \u211d, uniform_continuous_on f E \u2227 \u00ac metric.bounded (set.image f E) :="}
{"text": "informal statement Assume that $f$ is a continuous real function defined in $(a, b)$ such that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. Prove that $f$ is convex.formal statement theorem exercise_5_2 {a b : \u211d}\n  {f g : \u211d \u2192 \u211d} (hf : \u2200 x \u2208 set.Ioo a b, deriv f x > 0)\n  (hg : g = f\u207b\u00b9)\n  (hg_diff : differentiable_on \u211d g (set.Ioo a b)) :\n  differentiable_on \u211d g (set.Ioo a b) \u2227\n  \u2200 x \u2208 set.Ioo a b, deriv g x = 1 / deriv f x :="}
{"text": "informal statement Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$.formal statement theorem exercise_9_4_2d {p : \u2115} (hp : p.prime \u2227 p > 2) \n  {f : polynomial \u2124} (hf : f = (X + 2)^p): \n  irreducible (\u2211 n in (f.support \\ {0}), (f.coeff n) * X ^ (n-1) : \n  polynomial \u2124) :="}
{"text": "informal statement Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$formal statement theorem exercise_7_10 {V : Type*} [inner_product_space \u2102 V]\n  [finite_dimensional \u2102 V] (T : End \u2102 V)\n  (hT : T * T.adjoint = T.adjoint * T) (hT1 : T^9 = T^8) :\n  is_self_adjoint T \u2227 T^2 = T :="}
{"text": "import data.nat.basic\n\ntheorem nat.sum_four_squares (n : \u2115 ):\n  \u2203 (a b c d : \u2115), a^2+b^2+c^2+d^2 = n :=\n  sorry\n"}
{"text": "informal statement Let $G$ be a group in which $(a b)^{3}=a^{3} b^{3}$ and $(a b)^{5}=a^{5} b^{5}$ for all $a, b \\in G$. Show that $G$ is abelian.formal statement theorem exercise_2_3_17 {G : Type*} [has_mul G] [group G] (a x : G) :  \n  set.centralizer {x\u207b\u00b9*a*x} = \n  (\u03bb g : G, x\u207b\u00b9*g*x) '' (set.centralizer {a}) :="}
{"text": "informal statement Prove that $(x, y)$ is not a principal ideal in $\\mathbb{Q}[x, y]$.formal statement theorem exercise_9_1_6 : \u00ac is_principal \n  (ideal.span ({X 0, X 1} : set (mv_polynomial (fin 2) \u211a))) :="}
{"text": "informal statement If $G$ is a nonabelian group of order 6, prove that $G \\simeq S_3$.formal statement theorem exercise_2_5_44 {G : Type*} [group G] [fintype G] {p : \u2115}\n  (hp : nat.prime p) (hG : card G = p^2) :\n  \u2203 (N : subgroup G) (fin : fintype N), @card N fin = p \u2227 N.normal :="}
{"text": "informal statement Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$.formal statement theorem exercise_9_4_11 : \n  irreducible ((X 0)^2 + (X 1)^2 - 1 : mv_polynomial (fin 2) \u211a) :="}
{"text": "section\n  parameters {\u03b1 : Type} {r : \u03b1 \u2192 \u03b1 \u2192 Type}\n  parameter transr : \u2200 {x y z}, r x y \u2192 r y z \u2192 r x z\n\n  variables {a b c d e : \u03b1}\n\n  theorem t1 (h\u2081 : r a b) (h\u2082 : r b c) (h\u2083 : r c d) : r a d :=\n    transr (transr h\u2081 h\u2082) h\u2083\n\n  theorem t2 (h\u2081 : r a b) (h\u2082 : r b c) (h\u2083 : r c d) (h\u2084 : r d e) : r a e :=\n    transr h\u2081 (t1 h\u2082 h\u2083 h\u2084)\n\n  #check t1\n  #check t2\nend\n\n#check t1\n#check t2\n\n"}
{"text": "informal statement Prove that if $|G|=132$ then $G$ is not simple.formal statement theorem exercise_4_5_28 {G : Type*} [group G] [fintype G] \n  (hG : card G = 105) (P : sylow 3 G) [hP : P.normal] : \n  comm_group G :="}
{"text": "informal statement Prove that if a prime integer $p$ has the form $2^r+1$, then it actually has the form $2^{2^k}+1$.formal statement theorem exercise_1_1_3 (n : \u2124) : \n  \u2200 (a b c : \u2124), (a+b)+c \u2261 a+(b+c) [ZMOD n] :="}
{"text": "informal statement Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$.formal statement theorem exercise_2020_b5 (z : fin 4 \u2192 \u2102) (hz0 : \u2200 n, \u2016z n\u2016 < 1) \n  (hz1 : \u2200 n : fin 4, z n \u2260 1) : \n  3 - z 0 - z 1 - z 2 - z 3 + (z 0) * (z 1) * (z 2) * (z 3) \u2260 0 :="}
{"text": "informal statement Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative.formal statement theorem exercise_4_2_9 {p : \u2115} (hp : nat.prime p) (hp1 : odd p) :\n  \u2203 (a b : \u2124), (a / b : \u211a) = \u2211 i in finset.range p, 1 / (i + 1) \u2192 \u2191p \u2223 a :="}
{"text": "informal statement Prove that $x^6+30x^5-15x^3 + 6x-120$ is irreducible in $\\mathbb{Z}[x]$.formal statement theorem exercise_9_4_2b : irreducible \n  (X^6 + 30*X^5 - 15*X^3 + 6*X - 120 : polynomial \u2124) :="}
{"text": "namespace Nat\n\ntheorem example1 (x y z : Nat) : x * y + z = x * y + z :=\n  rfl\n\ntheorem example2 (x y : Nat) (h : y = x + 7) : 2 * y = 2 * (x + 7) :=\n  rw\n\nend Nat\n\n\n"}
{"text": "informal statement Prove that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$formal statement theorem exercise_7_6 {V : Type*} [inner_product_space \u2102 V]\n  [finite_dimensional \u2102 V] (T : End \u2102 V)\n  (hT : T * T.adjoint = T.adjoint * T) :\n  T.range = T.adjoint.range :="}
{"text": "informal statement Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$.formal statement theorem exercise_13_4b1 (X I : Type*) (T : I \u2192 set (set X)) (h : \u2200 i, is_topology X (T i)) :\n  \u2203! T', is_topology X T' \u2227 (\u2200 i, T i \u2286 T') \u2227\n  \u2200 T'', is_topology X T'' \u2192 (\u2200 i, T i \u2286 T'') \u2192 T'' \u2286 T' :="}
{"text": "informal statement Suppose $a \\in R^{1}, f$ is a twice-differentiable real function on $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper bounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, respectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$formal statement theorem exercise_5_15 {f : \u211d \u2192 \u211d} (a M0 M1 M2 : \u211d)\n  (hf' : differentiable_on \u211d f (set.Ici a))\n  (hf'' : differentiable_on \u211d (deriv f) (set.Ici a))\n  (hM0 : M0 = Sup {(| f x | )| x \u2208 (set.Ici a)})\n  (hM1 : M1 = Sup {(| deriv f x | )| x \u2208 (set.Ici a)})\n  (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \u2208 (set.Ici a)}) :\n  (M1 ^ 2) \u2264 4 * M0 * M2 :="}
{"text": "informal statement Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$.formal statement theorem exercise_1_11a (z : \u2102) : \n  \u2203 (r : \u211d) (w : \u2102), abs w = 1 \u2227 z = r * w :="}
{"text": "informal statement Let $Z$ be the center of a group $G$. Prove that if $G / Z$ is a cyclic group, then $G$ is abelian and hence $G=Z$.formal statement theorem exercise_6_4_3 {G : Type*} [group G] [fintype G] {p q : \u2115}\n  (hp : prime p) (hq : prime q) (hG : card G = p^2 *q) :\n  is_simple_group G \u2192 false :="}
{"text": "import data.real.basic\n\n/-\nIranian Mathematical Olympiad 1998, problem 11\n\nLet f\u2081, f\u2082, f\u2083 : \u211d \u2192 \u211d be functions such that\n\n  a\u2081f\u2081 + a\u2082f\u2082 + a\u2083f\u2083\n\nis monotonic for all a\u2081,a\u2082,a\u2083 \u2208 \u211d. Prove that there exist c\u2081,c\u2082,c\u2083 \u2208 \u211d, not all zero,\nsuch that\n\n  c\u2081f\u2081(x) + c\u2082f\u2082(x) + c\u2083f\u2083(x) = 0\n\nfor all x \u2208 \u211d.\n-/\n\ntheorem iran1998_q11\n  (f\u2081 f\u2082 f\u2083 : \u211d -> \u211d)\n  (hf : (\u2200a\u2081 a\u2082 a\u2083 : \u211d, monotone (\u03bb x, a\u2081 * f\u2081 x + a\u2082 * f\u2082 x + a\u2083 * f\u2083 x))) :\n  \u2203c\u2081 c\u2082 c\u2083 : \u211d, (\u00ac (c\u2081 = 0 \u2227 c\u2082 = 0 \u2227 c\u2083 = 0) \u2227\n                  \u2200 x, c\u2081 * f\u2081 x + c\u2082 * f\u2082 x + c\u2083 * f\u2083 x = 0) :=\nbegin\n  sorry\nend\n"}
{"text": "informal statement Show that if $U$ is open in $X$ and $A$ is closed in $X$, then $U-A$ is open in $X$, and $A-U$ is closed in $X$.formal statement theorem exercise_18_8b {X Y : Type*} [topological_space X] [topological_space Y]\n  [linear_order Y] [order_topology Y] {f g : X \u2192 Y}\n  (hf : continuous f) (hg : continuous g) :\n  continuous (\u03bb x, min (f x) (g x)) :="}
{"text": "informal statement If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.formal statement theorem exercise_2_11_22 {p : \u2115} {n : \u2115} {G : Type*} [fintype G] \n  [group G] (hp : nat.prime p) (hG : card G = p ^ n) {K : subgroup G}\n  [fintype K] (hK : card K = p ^ (n-1)) : \n  K.normal :="}
{"text": "informal statement Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.formal statement theorem exercise_2017_b3 (f : \u211d \u2192 \u211d) (c : \u2115 \u2192 \u211d)\n  (hf : f = \u03bb x, (\u2211' (i : \u2115), (c i) * x^i)) \n  (hc : \u2200 n, c n = 0 \u2228 c n = 1)\n  (hf1 : f (2/3) = 3/2) : \n  irrational (f (1/2)) :="}
{"text": "informal statement Show that a connected metric space having more than one point is uncountable.formal statement theorem exercise_28_5\n  (X : Type*) [topological_space X] :\n  countably_compact X \u2194 \u2200 (C : \u2115 \u2192 set X), (\u2200 n, is_closed (C n)) \u2227\n  (\u2200 n, C n \u2260 \u2205) \u2227 (\u2200 n, C n \u2286 C (n + 1)) \u2192 \u2203 x, \u2200 n, x \u2208 C n :="}
{"text": "\n/-- Convert a character into a `UInt8`, by truncating (reducing modulo 256) if necessary. -/\ndef Char.toUInt8 (n : Char) : UInt8 := n.1.toUInt8\n\ntheorem Char.utf8Size_pos (c : Char) : 0 < c.utf8Size := by\n  simp only [utf8Size]\n  repeat (split; decide)\n  decide\n\ntheorem String.csize_pos : (c : Char) \u2192 0 < String.csize c := Char.utf8Size_pos\n"}
{"text": "informal statement If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$formal statement theorem exercise_1_19\n  (n : \u2115)\n  (a b c x : euclidean_space \u211d (fin n))\n  (r : \u211d)\n  (h\u2081 : r > 0)\n  (h\u2082 : 3 \u2022 c = 4 \u2022 b - a)\n  (h\u2083 : 3 * r = 2 * \u2016x - b\u2016)\n  : \u2016x - a\u2016 = 2 * \u2016x - b\u2016 \u2194 \u2016x - c\u2016 = r :="}
{"text": "informal statement Prove that $-(-v) = v$ for every $v \\in V$.formal statement theorem exercise_1_6 : \u2203 U : set (\u211d \u00d7 \u211d),\n  (U \u2260 \u2205) \u2227\n  (\u2200 (u v : \u211d \u00d7 \u211d), u \u2208 U \u2227 v \u2208 U \u2192 u + v \u2208 U) \u2227\n  (\u2200 (u : \u211d \u00d7 \u211d), u \u2208 U \u2192 -u \u2208 U) \u2227\n  (\u2200 U' : submodule \u211d (\u211d \u00d7 \u211d), U \u2260 \u2191U') :="}
{"text": "informal statement Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection.formal statement theorem exercise_29_1 : \u00ac locally_compact_space \u211a :="}
{"text": "informal statement Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$.formal statement theorem exercise_3_22 (D : set \u2102) (hD : D = ball 0 1) (f : \u2102 \u2192 \u2102)\n    (hf : differentiable_on \u2102 f D) (hfc : continuous_on f (closure D)) :\n    \u00ac \u2200 z \u2208 (sphere (0 : \u2102) 1), f z = 1 / z :="}
{"text": "theorem Q1007 (r : \u2124 \u2192 \u2124 \u2192 Prop) [is_equiv \u2124 r] (h\u2081 : \u2200 n : \u2124, r n (n + 5))\n(h\u2082 : \u2200 n : \u2124, r n (n + 8)) (x y : \u2124) : r x y := sorry "}
{"text": "informal statement If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map.formal statement theorem exercise_22_2b {X : Type*} [topological_space X]\n  {A : set X} (r : X \u2192 A) (hr : continuous r) (h : \u2200 x : A, r x = x) :\n  quotient_map r :="}
{"text": "informal statement If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.formal statement theorem exercise_4_6\n  (f : \u211d \u2192 \u211d)\n  (E : set \u211d)\n  (G : set (\u211d \u00d7 \u211d))\n  (h\u2081 : is_compact E)\n  (h\u2082 : G = {(x, f x) | x \u2208 E})\n  : continuous_on f E \u2194 is_compact G :="}
{"text": "informal statement Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$.formal statement theorem exercise_5_12 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {S : End F V}\n  (hS : \u2200 v : V, \u2203 c : F, v \u2208 eigenspace S c) :\n  \u2203 c : F, S = c \u2022 id :="}
{"text": "import topology.instances.real \n\nopen filter real\nopen_locale topological_space \n\ntheorem problem_5 (a : \u211d) (f : \u2115 \u2192 \u211d) :\n  (\u2203 N, \u2200 \u03b5 > 0, \u2200 n \u2265 N, abs (f n - a) < \u03b5) \u2194 (\u2203 N, \u2200 n \u2265 N, f n = a) :=\nbegin \n  sorry \nend \n"}
{"text": "open tactic\n\nlemma a1 : true :=\nbegin\n  sleep 20000,\n  trivial\nend\n\nlemma a2 : true :=\nbegin\n  sleep 10000,\n  trivial\nend\n"}
{"text": "informal statement Show that if $X$ is a Hausdorff space that is locally compact at the point $x$, then for each neighborhood $U$ of $x$, there is a neighborhood $V$ of $x$ such that $\\bar{V}$ is compact and $\\bar{V} \\subset U$.formal statement theorem exercise_30_13 {X : Type*} [topological_space X]\n  (h : \u2203 (s : set X), countable s \u2227 dense s) (U : set (set X))\n  (hU : \u2200 (x y : set X), x \u2208 U \u2192 y \u2208 U \u2192 x \u2260 y \u2192 x \u2229 y = \u2205) :\n  countable U :="}
{"text": "informal statement If $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ is monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges.formal statement theorem exercise_3_20 {X : Type*} [metric_space X]\n  (p : \u2115 \u2192 X) (l : \u2115) (r : X)\n  (hp : cauchy_seq p)\n  (hpl : tendsto (\u03bb n, p (l * n)) at_top (\ud835\udcdd r)) :\n  tendsto p at_top (\ud835\udcdd r) :="}
{"text": "informal statement Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$.formal statement theorem exercise_7_1_11 {R : Type*} [ring R] [is_domain R] \n  {x : R} (hx : x^2 = 1) : x = 1 \u2228 x = -1 :="}
{"text": "informal statement Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$.formal statement theorem exercise_3_8\n  (a b : \u2115 \u2192 \u211d)\n  (h1 : \u2203 y, (tendsto (\u03bb n, (\u2211 i in (finset.range n), a i)) at_top (\ud835\udcdd y)))\n  (h2 : monotone b)\n  (h3 : metric.bounded (set.range b)) :\n  \u2203 y, tendsto (\u03bb n, (\u2211 i in (finset.range n), (a i) * (b i))) at_top (\ud835\udcdd y) :="}
{"text": "informal statement Prove that if a group contains exactly one element of order 2 , then that element is in the center of the group.formal statement theorem exercise_2_11_3 {G : Type*} [group G] [fintype G]\n  (hG : even (card G)) : \u2203 x : G, order_of x = 2 :="}
{"text": "\n\nopen Classical\n\ntheorem dne (p : Prop) (h : \u00ac\u00acp) : p :=\n  Or.elim (em p)\n  (fun (hp : p) => hp)\n  (fun (hnp: \u00acp) => absurd hnp h)\n\ntheorem step (p : Prop) (h : \u00ac(p \u2228 \u00ac p)) : \u00acp :=\n  fun (hp : p) => h (Or.intro_left (\u00acp) (hp))\n\ntheorem exclmid (p : Prop) : p \u2228 \u00acp :=\n  dne (p \u2228 \u00acp) (\n    fun (h : \u00ac(p \u2228 \u00acp)) => \n    h (Or.intro_right (p) (step p h))\n  )"}
{"text": "informal statement If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$.formal statement theorem exercise_3_3\n  : \u2203 (x : \u211d), tendsto f at_top (\ud835\udcdd x) \u2227 \u2200 n, f n < 2 :="}
{"text": "informal statement Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear.formal statement theorem exercise_2_9\n  {f : \u2102 \u2192 \u2102} (\u03a9 : set \u2102) (b : metric.bounded \u03a9) (h : is_open \u03a9)\n  (hf : differentiable_on \u2102 f \u03a9) (z \u2208 \u03a9) (hz : f z = z) (h'z : deriv f z = 1) :\n  \u2203 (f_lin : \u2102 \u2192L[\u2102] \u2102), \u2200 x \u2208 \u03a9, f x = f_lin x :="}
{"text": "informal statement Show that if $X$ is an infinite set, it is connected in the finite complement topology.formal statement theorem exercise_23_4 {X : Type*} [topological_space X] [cofinite_topology X]\n  (s : set X) : set.infinite s \u2192 is_connected s :="}
{"text": "informal statement Let $Y$ be an ordered set in the order topology. Let $f, g: X \\rightarrow Y$ be continuous. Let $h: X \\rightarrow Y$ be the function $h(x)=\\min \\{f(x), g(x)\\}.$ Show that $h$ is continuous.formal statement theorem exercise_18_8b {X Y : Type*} [topological_space X] [topological_space Y]\n  [linear_order Y] [order_topology Y] {f g : X \u2192 Y}\n  (hf : continuous f) (hg : continuous g) :\n  continuous (\u03bb x, min (f x) (g x)) :="}
{"text": "informal statement Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$.formal statement theorem exercise_4_5_14 {G : Type*} [group G] [fintype G]\n  (hG : card G = 312) :\n  \u2203 (p : \u2115) (P : sylow p G), P.normal :="}
{"text": "informal statement Let $\\mathcal{T}$ be the collection of open subsets of a metric space $\\mathrm{M}$, and $\\mathcal{K}$ the collection of closed subsets. Show that there is a bijection from $\\mathcal{T}$ onto $\\mathcal{K}$.formal statement theorem exercise_2_41 (m : \u2115) {X : Type*} [normed_space \u211d ((fin m) \u2192 \u211d)] :\n  is_compact (metric.closed_ball 0 1) :="}
{"text": "informal statement Prove that $\\mathbb{Q}$ has no proper subgroups of finite index.formal statement theorem exercise_3_4_1 (G : Type*) [comm_group G] [is_simple_group G] :\n    is_cyclic G \u2227 \u2203 G_fin : fintype G, nat.prime (@card G G_fin) :="}
{"text": "informal statement Prove that subgroups of a solvable group are solvable.formal statement theorem exercise_3_4_5a {G : Type*} [group G] \n  (H : subgroup G) [is_solvable G] : is_solvable H :="}
{"text": "informal statement Suppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.formal statement theorem exercise_5_20 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] [finite_dimensional F V] {S T : End F V}\n  (h1 : @card T.eigenvalues (eigenvalues.fintype T) = finrank F V)\n  (h2 : \u2200 v : V, \u2203 c : F, v \u2208 eigenspace S c \u2194 \u2203 c : F, v \u2208 eigenspace T c) :\n  S * T = T * S :="}
{"text": "informal statement If $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, for $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, the graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is continuous on $E$ if and only if its graph is compact.formal statement theorem exercise_4_8b\n  (E : set \u211d) :\n  \u2203 f : \u211d \u2192 \u211d, uniform_continuous_on f E \u2227 \u00ac metric.bounded (set.image f E) :="}
{"text": "informal statement Let $f$ be a real function on the real line with continuous third derivative. Prove that there exists a point $a$ such thatformal statement theorem exercise_1998_a3 (f : \u211d \u2192 \u211d) (hf : cont_diff \u211d 3 f) : \n  \u2203 a : \u211d, (f a) * (deriv f a) * (iterated_deriv 2 f a) * (iterated_deriv 3 f a) \u2265 0 :="}
{"text": "informal statement Prove that the power series $\\sum zn/n^2$ converges at every point of the unit circle.formal statement theorem exercise_1_26\n  (f F\u2081 F\u2082 : \u2102 \u2192 \u2102) (\u03a9 : set \u2102) (h1 : is_open \u03a9) (h2 : is_connected \u03a9)\n  (hF\u2081 : differentiable_on \u2102 F\u2081 \u03a9) (hF\u2082 : differentiable_on \u2102 F\u2082 \u03a9)\n  (hdF\u2081 : \u2200 x \u2208 \u03a9, deriv F\u2081 x = f x) (hdF\u2082 : \u2200 x \u2208 \u03a9, deriv F\u2082 x = f x)\n  : \u2203 c : \u2102, \u2200 x, F\u2081 x = F\u2082 x + c :="}
{"text": "informal statement Prove that $\\frac{(x+2)^p-2^p}{x}$, where $p$ is an odd prime, is irreducible in $\\mathbb{Z}[x]$.formal statement theorem exercise_9_4_11 : \n  irreducible ((X 0)^2 + (X 1)^2 - 1 : mv_polynomial (fin 2) \u211a) :="}
{"text": "informal statement Prove that there is no rational number whose square is $12$.formal statement theorem exercise_1_2 : \u00ac \u2203 (x : \u211a), ( x ^ 2 = 12 ) :="}
{"text": "informal statement Suppose $f$ is continuous in a region $\\Omega$. Prove that any two primitives of $f$ (if they exist) differ by a constant.formal statement theorem exercise_2_9\n  {f : \u2102 \u2192 \u2102} (\u03a9 : set \u2102) (b : metric.bounded \u03a9) (h : is_open \u03a9)\n  (hf : differentiable_on \u2102 f \u03a9) (z \u2208 \u03a9) (hz : f z = z) (h'z : deriv f z = 1) :\n  \u2203 (f_lin : \u2102 \u2192L[\u2102] \u2102), \u2200 x \u2208 \u03a9, f x = f_lin x :="}
{"text": "informal statement Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$.formal statement theorem exercise_5_5_2 : irreducible (X^3 - 3*X - 1 : polynomial \u211a) :="}
{"text": "informal statement Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$.formal statement theorem exercise_2_4_16b {n : \u2115} {hn : n \u2260 0} \n  {R : subgroup (dihedral_group n)} \n  (hR : R = subgroup.closure {dihedral_group.r 1}) : \n  R \u2260 \u22a4 \u2227 \n  \u2200 K : subgroup (dihedral_group n), R \u2264 K \u2192 K = R \u2228 K = \u22a4 :="}
{"text": "informal statement Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian.formal statement theorem exercise_1_1_34 {G : Type*} [group G] {x : G} \n  (hx_inf : order_of x = 0) (n m : \u2124) :\n  x ^ n \u2260 x ^ m :="}
{"text": "informal statement Prove that $x^3 - 3x - 1$ is irreducible over $\\mathbb{Q}$.formal statement theorem exercise_2_2_9 {G : Type*} [group G] {a b : G}\n  (h : a * b = b * a) :\n  \u2200 x y : closure {x | x = a \u2228 x = b}, x*y = y*x :="}
{"text": "informal statement Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$.formal statement theorem exercise_13_8b :\n  (topological_space.generate_from {S : set \u211d | \u2203 a b : \u211a, a < b \u2227 S = Ico a b}).is_open \u2260\n  (lower_limit_topology \u211d).is_open :="}
{"text": "informal statement Prove that the quotient ring $\\mathbb{Z}[i] /(1+i)$ is a field of order 2.formal statement theorem exercise_8_3_6a {R : Type*} [ring R]\n  (hR : R = (gaussian_int \u29f8 ideal.span ({\u27e80, 1\u27e9} : set gaussian_int))) :\n  is_field R \u2227 \u2203 finR : fintype R, @card R finR = 2 :="}
{"text": "informal statement Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite).formal statement theorem exercise_3_2_21a (H : add_subgroup \u211a) (hH : H \u2260 \u22a4) : H.index = 0 :="}
{"text": "import data.real.basic\nopen classical\nattribute [instance] prop_decidable\n\n/-\n  Rigorous definition of a limit\n  For a sequence x_n, we say that \\lim_{n \\to \\infty} x_n = l if\n    \u2200 \u03b5 > 0, \u2203 N, n \u2265 N \u2192 |x_n - l| < \u03b5\n-/\n\ndef lim_to_inf (x : \u2115 \u2192 \u211d) (l : \u211d) :=\n  \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, abs (x n - l) < \u03b5\n\ntheorem exercise_1p3 (x y : \u2115 \u2192 \u211d) (l : \u211d)\n  (h\u2081 : \u2200 n, abs (x n - l) \u2264 y n) (h\u2082 : lim_to_inf y 0) :\n  lim_to_inf x l := \nbegin\n    intros \u03b5 \u03b5_pos,\n    rcases h\u2082 \u03b5 \u03b5_pos with \u27e8N, hN\u27e9,\n    use N,\n    intros n hn,\n    specialize h\u2081 n,\n    specialize hN n hn,\n    calc \n    abs (x n - l) \u2264 y n   : h\u2081\n    ... \u2264 abs (y n)       : le_abs_self (y n)\n    ... \u2264 abs (y n - 0)   : by rw sub_zero (y n)\n    ... < \u03b5               : hN,\nend"}
{"text": "informal statement A uniformly continuous function of a uniformly continuous function is uniformly continuous.formal statement theorem exercise_4_12\n  {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1] [uniform_space \u03b2] [uniform_space \u03b3]\n  {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}\n  (hf : uniform_continuous f) (hg : uniform_continuous g) :\n  uniform_continuous (g \u2218 f) :="}
{"text": "informal statement Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$.formal statement theorem exercise_8_1_12 {N : \u2115} (hN : N > 0) {M M': \u2124} {d : \u2115}\n  (hMN : M.gcd N = 1) (hMd : d.gcd N.totient = 1) \n  (hM' : M' \u2261 M^d [ZMOD N]) : \n  \u2203 d' : \u2115, d' * d \u2261 1 [ZMOD N.totient] \u2227 \n  M \u2261 M'^d' [ZMOD N] :="}
{"text": "informal statement If $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that there exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$formal statement theorem exercise_1_18a\n  (n : \u2115)\n  (h : n > 1)\n  (x : euclidean_space \u211d (fin n)) -- R^n\n  : \u2203 (y : euclidean_space \u211d (fin n)), y \u2260 0 \u2227 (inner x y) = (0 : \u211d) :="}
{"text": "informal statement Let $\\|\\cdot\\|$ be any norm on $\\mathbb{R}^{m}$ and let $B=\\left\\{x \\in \\mathbb{R}^{m}:\\|x\\| \\leq 1\\right\\}$. Prove that $B$ is compact.formal statement theorem exercise_2_57 {X : Type*} [topological_space X]\n  : \u2203 (S : set X), is_connected S \u2227 \u00ac is_connected (interior S) :="}
{"text": "informal statement Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$.formal statement theorem exercise_7_2_12 {R G : Type*} [ring R] [group G] [fintype G] : \n  \u2211 g : G, monoid_algebra.of R G g \u2208 center (monoid_algebra R G) :="}
{"text": "informal statement If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$.formal statement theorem exercise_1_1_22a {G : Type*} [group G] (x g : G) :\n  order_of x = order_of (g\u207b\u00b9 * x * g) :="}
{"text": "def f {\u03b1} (a b : \u03b1) := a\n\ntheorem f_Eq {\u03b1} (a b : \u03b1) : f a b = a :=\n  rfl\n\ntheorem ex1 (a b c : \u03b1) : f (f a b) c = a := by\n  simp [f_Eq]\n\n#print ex1\n\ntheorem ex2 (p : Nat \u2192 Bool) (x : Nat) (h : p x = true) : (if p x then 1 else 2) = 1 := by\n  simp [h]\n\n#print ex2\n"}
{"text": "informal statement If $H$ is the unique subgroup of a given order in a group $G$ prove $H$ is characteristic in $G$.formal statement theorem exercise_4_4_7 {G : Type*} [group G] {H : subgroup G} [fintype H]\n  (hH : \u2200 (K : subgroup G) (fK : fintype K), card H = @card K fK \u2192 H = K) : \n  H.characteristic :="}
{"text": "informal statement Let $R$ be a ring in which $x^3 = x$ for every $x \\in R$. Prove that $R$ is commutative.formal statement theorem exercise_4_2_5 {R : Type*} [ring R] \n  (h : \u2200 x : R, x ^ 3 = x) : comm_ring R :="}
{"text": "informal statement Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.formal statement theorem exercise_3_1_3a {A : Type*} [comm_group A] (B : subgroup A) :\n  \u2200 a b : A \u29f8 B, a*b = b*a :="}
{"text": "informal statement Let $A$ be an abelian group and let $B$ be a subgroup of $A$. Prove that $A / B$ is abelian.formal statement theorem exercise_3_1_22b {G : Type*} [group G] (I : Type*)\n  (H : I \u2192 subgroup G) (hH : \u2200 i : I, subgroup.normal (H i)) : \n  subgroup.normal (\u2a05 (i : I), H i):="}
{"text": "informal statement Let $N$ be a positive integer. Let $M$ be an integer relatively prime to $N$ and let $d$ be an integer relatively prime to $\\varphi(N)$, where $\\varphi$ denotes Euler's $\\varphi$-function. Prove that if $M_{1} \\equiv M^{d} \\pmod N$ then $M \\equiv M_{1}^{d^{\\prime}} \\pmod N$ where $d^{\\prime}$ is the inverse of $d \\bmod \\varphi(N)$: $d d^{\\prime} \\equiv 1 \\pmod {\\varphi(N)}$.formal statement theorem exercise_8_3_4 {R : Type*} {n : \u2124} {r s : \u211a} \n  (h : r^2 + s^2 = n) : \n  \u2203 a b : \u2124, a^2 + b^2 = n :="}
{"text": "/-\nCopyright (c) 2020 Kevin Lacker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Lacker\n-/\n\nimport Mathlib.Algebra.Divisibility.Basic\nimport Mathlib.Tactic.Ring\nimport Mathlib.Data.Nat.Prime\n\n/-!\n# IMO 1959 Q1\nProve that the fraction `(21n+4)/(14n+3)` is irreducible for every\nnatural number `n`.\n\nSince Lean doesn't have a concept of \"irreducible fractions\" per se,\nwe just formalize this as saying the numerator and denominator are\nrelatively prime.\n-/\n\nlemma calculation\n    (n k : \u2115)\n    (h1 : k \u2223 21 * n + 4)\n    (h2 : k \u2223 14 * n + 3) :\n    k \u2223 1 := by\n  have h3 : k \u2223 2 * (21 * n + 4) := h1.mul_left 2\n  have h4 : k \u2223 3 * (14 * n + 3) := h2.mul_left 3\n  have h5 : 3 * (14 * n + 3) = 2 * (21 * n + 4) + 1 := by ring\n  exact (Nat.dvd_add_right h3).mp (h5 \u25b8 h4)\n\ntheorem imo1959_q1 : \u2200 n : \u2115, Nat.coprime (21 * n + 4) (14 * n + 3) :=\nfun n => Nat.coprime_of_dvd' <| \u03bb k _ h1 h2 => calculation n k h1 h2\n\n"}
{"text": "informal statement Prove that if $H$ is a nontrivial normal subgroup of the solvable group $G$ then there is a nontrivial subgroup $A$ of $H$ with $A \\unlhd G$ and $A$ abelian.formal statement theorem exercise_4_3_26 {\u03b1 : Type*} [fintype \u03b1] (ha : fintype.card \u03b1 > 1)\n  (h_tran : \u2200 a b: \u03b1, \u2203 \u03c3 : equiv.perm \u03b1, \u03c3 a = b) : \n  \u2203 \u03c3 : equiv.perm \u03b1, \u2200 a : \u03b1, \u03c3 a \u2260 a :="}
{"text": "informal statement Prove that if $x^{2}=1$ for all $x \\in G$ then $G$ is abelian.formal statement theorem exercise_1_1_25 {G : Type*} [group G] \n  (h : \u2200 x : G, x ^ 2 = 1) : \u2200 a b : G, a*b = b*a :="}
{"text": "informal statement Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$.formal statement theorem exercise_3_22 (X : Type*) [metric_space X] [complete_space X]\n  (G : \u2115 \u2192 set X) (hG : \u2200 n, is_open (G n) \u2227 dense (G n)) :\n  \u2203 x, \u2200 n, x \u2208 G n :="}
{"text": "informal statement Prove that a group of even order contains an element of order $2 .$formal statement theorem exercise_2_11_3 {G : Type*} [group G] [fintype G]\n  (hG : even (card G)) : \u2203 x : G, order_of x = 2 :="}
{"text": "import tactic --hide\nlemma not_iff_imp_false (P : Prop) : \u00ac P \u2194 P \u2192 false := iff.rfl -- hide\n\n\n/-Hint : Hint\nTry using `rw not_iff_imp_false,`.\n-/\n\n/-Lemma\nIf $P$ is a logical statement then $P \\implies \u00ac \u00acP$.\n-/\nlemma P_not_not_P (P : Prop) : P \u2192 \u00ac (\u00ac P) :=\nbegin\n  intro P,\n  rw not_iff_imp_false,\n  intro hp,\n  apply hp,\n  exact P,\n\n\n  \nend\n"}
{"text": "informal statement Show that X is countably compact if and only if every nested sequence $C_1 \\supset C_2 \\supset \\cdots$ of closed nonempty sets of X has a nonempty intersection.formal statement theorem exercise_28_5\n  (X : Type*) [topological_space X] :\n  countably_compact X \u2194 \u2200 (C : \u2115 \u2192 set X), (\u2200 n, is_closed (C n)) \u2227\n  (\u2200 n, C n \u2260 \u2205) \u2227 (\u2200 n, C n \u2286 C (n + 1)) \u2192 \u2203 x, \u2200 n, x \u2208 C n :="}
{"text": "informal statement If $x, y$ are complex, prove that $||x|-|y|| \\leq |x-y|$.formal statement theorem exercise_1_16a\n  (n : \u2115)\n  (d r : \u211d)\n  (x y z : euclidean_space \u211d (fin n)) -- R^n\n  (h\u2081 : n \u2265 3)\n  (h\u2082 : \u2016x - y\u2016 = d)\n  (h\u2083 : d > 0)\n  (h\u2084 : r > 0)\n  (h\u2085 : 2 * r > d)\n  : set.infinite {z : euclidean_space \u211d (fin n) | \u2016z - x\u2016 = r \u2227 \u2016z - y\u2016 = r} :="}
{"text": "informal statement If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$.formal statement theorem exercise_2_1_27 {G : Type*} [group G] \n  [fintype G] : \u2203 (m : \u2115), \u2200 (a : G), a ^ m = 1 :="}
{"text": "informal statement Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing.formal statement theorem exercise_5_15 {f : \u211d \u2192 \u211d} (a M0 M1 M2 : \u211d)\n  (hf' : differentiable_on \u211d f (set.Ici a))\n  (hf'' : differentiable_on \u211d (deriv f) (set.Ici a))\n  (hM0 : M0 = Sup {(| f x | )| x \u2208 (set.Ici a)})\n  (hM1 : M1 = Sup {(| deriv f x | )| x \u2208 (set.Ici a)})\n  (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \u2208 (set.Ici a)}) :\n  (M1 ^ 2) \u2264 4 * M0 * M2 :="}
{"text": "import Smt\n\ntheorem triv (p : Prop) : p \u2192 p := by\n  smt\n"}
{"text": "informal statement If $G$ is a finite group, prove that there is an integer $m > 0$ such that $a^m = e$ for all $a \\in G$.formal statement theorem exercise_2_2_5 {G : Type*} [group G] \n  (h : \u2200 (a b : G), (a * b) ^ 3 = a ^ 3 * b ^ 3 \u2227 (a * b) ^ 5 = a ^ 5 * b ^ 5) :\n  comm_group G :="}
{"text": "import tactic\n\nopen function\n\ntheorem challenge4 (X Y Z : Type) (f : X \u2192 Y) (g : Y \u2192 Z) : surjective (g \u2218 f) \u2192 surjective g :=\nbegin\n  intro h,\n  intro z,\n  cases h z with a ha,\n  use f a,\n  assumption,\nend\n"}
{"text": "informal statement Let $p$ be an odd prime. Show that $a$ is a primitive root modulo $p$ iff $a^{(p-1) / q} \\not \\equiv 1(p)$ for all prime divisors $q$ of $p-1$.formal statement theorem exercise_4_8 {p a : \u2115} (hp : odd p) : \n  is_primitive_root a p \u2194 (\u2200 q \u2223 (p-1), q.prime \u2192 \u00ac a^(p-1) \u2261 1 [MOD p]) :="}
{"text": "informal statement Let $X$ be completely regular, let $A$ and $B$ be disjoint closed subsets of $X$. Show that if $A$ is compact, there is a continuous function $f \\colon X \\rightarrow [0, 1]$ such that $f(A) = \\{0\\}$ and $f(B) = \\{1\\}$.formal statement theorem exercise_33_8\n  (X : Type*) [topological_space X] [regular_space X]\n  (h : \u2200 x A, is_closed A \u2227 \u00ac x \u2208 A \u2192\n  \u2203 (f : X \u2192 I), continuous f \u2227 f x = (1 : I) \u2227 f '' A = {0})\n  (A B : set X) (hA : is_closed A) (hB : is_closed B)\n  (hAB : disjoint A B)\n  (hAc : is_compact A) :\n  \u2203 (f : X \u2192 I), continuous f \u2227 f '' A = {0} \u2227 f '' B = {1} :="}
{"text": "informal statement Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$.formal statement theorem exercise_11_4_1b {F : Type*} [field F] [fintype F] (hF : card F = 2) :\n  irreducible (12 + 6 * X + X ^ 3 : polynomial F) :="}
{"text": "informal statement Suppose that $f(x)=\\sum_{i=0}^{\\infty} c_{i} x^{i}$ is a power series for which each coefficient $c_{i}$ is 0 or 1 . Show that if $f(2 / 3)=3 / 2$, then $f(1 / 2)$ must be irrational.formal statement theorem exercise_2010_a4 (n : \u2115) : \n  \u00ac nat.prime (10^10^10^n + 10^10^n + 10^n - 1) :="}
{"text": "informal statement Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.formal statement theorem exercise_4_5_16 {p n: \u2115} (hp : nat.prime p) \n  {q : polynomial (zmod p)} (hq : irreducible q) (hn : q.degree = n) :\n  \u2203 is_fin : fintype $ polynomial (zmod p) \u29f8 ideal.span ({q} : set (polynomial $ zmod p)), \n  @card (polynomial (zmod p) \u29f8 ideal.span {q}) is_fin = p ^ n \u2227 \n  is_field (polynomial $ zmod p):="}
{"text": "informal statement Prove that $x^3 + 6x + 12$ is irreducible in $\\mathbb{Q}$.formal statement theorem exercise_11_4_6b {F : Type*} [field F] [fintype F] (hF : card F = 31) :\n  irreducible (X ^ 3 - 9 : polynomial F) :="}
{"text": "informal statement Suppose that $E$ is an uncountable subset of $\\mathbb{R}$. Prove that there exists a point $p \\in \\mathbb{R}$ at which $E$ condenses.formal statement theorem exercise_2_126 {E : set \u211d}\n  (hE : \u00ac set.countable E) : \u2203 (p : \u211d), cluster_pt p (\ud835\udcdf E) :="}
{"text": "informal statement Prove that $\\sum 1/k(\\log(k))^p$ diverges when $p \\leq 1$.formal statement theorem exercise_2_1_21 (G : Type*) [group G] [fintype G]\n  (hG : card G = 5) :\n  comm_group G :="}
{"text": "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\nprelude\nimport Init.Data.Option.Basic\n\nuniverse u v\n\ntheorem Option.eqOfEqSome {\u03b1 : Type u} : \u2200 {x y : Option \u03b1}, (\u2200z, x = some z \u2194 y = some z) \u2192 x = y\n  | none,   none,   h => rfl\n  | none,   some z, h => Option.noConfusion ((h z).2 rfl)\n  | some z, none,   h => Option.noConfusion ((h z).1 rfl)\n  | some z, some w, h => Option.noConfusion ((h w).2 rfl) (congrArg some)\n\ntheorem Option.eqNoneOfIsNone {\u03b1 : Type u} : \u2200 {o : Option \u03b1}, o.isNone \u2192 o = none\n  | none, h => rfl\n"}
{"text": "informal statement Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.formal statement theorem exercise_4_5a\n  (f : \u211d \u2192 \u211d)\n  (E : set \u211d)\n  (h\u2081 : is_closed E)\n  (h\u2082 : continuous_on f E)\n  : \u2203 (g : \u211d \u2192 \u211d), continuous g \u2227 \u2200 x \u2208 E, f x = g x :="}
{"text": "informal statement Prove that $x^2+y^2-1$ is irreducible in $\\mathbb{Q}[x,y]$.formal statement theorem exercise_1_1a\n  (x : \u211d) (y : \u211a) :\n  ( irrational x ) -> irrational ( x + y ) :="}
{"text": "informal statement Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$formal statement theorem exercise_11_4_8 {p : \u2115} (hp : prime p) (n : \u2115) :\n  irreducible (X ^ n - p : polynomial \u211a) :="}
{"text": "informal statement Let $G$ be a group of order 105. Prove that if a Sylow 3-subgroup of $G$ is normal then $G$ is abelian.formal statement theorem exercise_5_4_2 {G : Type*} [group G] (H : subgroup G) : \n  H.normal \u2194 \u2045(\u22a4 : subgroup G), H\u2046 \u2264 H :="}
{"text": "import Smt\n\ntheorem addition (p q : Prop) : p \u2192 p \u2228 q := by\n  smt\n"}
{"text": "informal statement Let $\\left\\{A_{n}\\right\\}$ be a sequence of connected subspaces of $X$, such that $A_{n} \\cap A_{n+1} \\neq \\varnothing$ for all $n$. Show that $\\bigcup A_{n}$ is connected.formal statement theorem exercise_23_4 {X : Type*} [topological_space X] [cofinite_topology X]\n  (s : set X) : set.infinite s \u2192 is_connected s :="}
{"text": "informal statement Suppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. Prove that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$.formal statement theorem exercise_5_4 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (S T : V \u2192\u2097[F] V) (hST : S \u2218 T = T \u2218 S) (c : F):\n  map S (T - c \u2022 id).ker = (T - c \u2022 id).ker :="}
{"text": "informal statement Prove that the intersection of any collection of subspaces of $V$ is a subspace of $V$.formal statement theorem exercise_3_1 {F V : Type*}  \n  [add_comm_group V] [field F] [module F V] [finite_dimensional F V]\n  (T : V \u2192\u2097[F] V) (hT : finrank F V = 1) :\n  \u2203 c : F, \u2200 v : V, T v = c \u2022 v:="}
{"text": "informal statement Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative.formal statement theorem exercise_1_1_5 (n : \u2115) (hn : 1 < n) : \n  is_empty (group (zmod n)) :="}
{"text": "informal statement If $p$ is a prime, show that $q(x) = 1 + x + x^2 + \\cdots x^{p - 1}$ is irreducible in $Q[x]$.formal statement theorem exercise_4_6_3 :\n  infinite {a : \u2124 | irreducible (X^7 + 15*X^2 - 30*X + a : polynomial \u211a)} :="}
{"text": "informal statement Show that there is no holomorphic function $f$ in the unit disc $D$ that extends continuously to $\\partial D$ such that $f(z) = 1/z$ for $z \\in \\partial D$.formal statement theorem exercise_3_22 (D : set \u2102) (hD : D = ball 0 1) (f : \u2102 \u2192 \u2102)\n    (hf : differentiable_on \u2102 f D) (hfc : continuous_on f (closure D)) :\n    \u00ac \u2200 z \u2208 (sphere (0 : \u2102) 1), f z = 1 / z :="}
{"text": "informal statement Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.formal statement theorem exercise_5_20 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] [finite_dimensional F V] {S T : End F V}\n  (h1 : @card T.eigenvalues (eigenvalues.fintype T) = finrank F V)\n  (h2 : \u2200 v : V, \u2203 c : F, v \u2208 eigenspace S c \u2194 \u2203 c : F, v \u2208 eigenspace T c) :\n  S * T = T * S :="}
{"text": "import data.finset.basic\nimport data.finset.lattice\nimport data.nat.basic\nimport data.nat.gcd.basic\nimport data.pnat.basic\n\n/-\n\nIndian Mathematical Olympiad 1998, Problem 8.\n\nLet M be a positive integer and consider the set\n\n    S = { n \u2208 \u2115 : M\u00b2 \u2264 n < (M + 1)\u00b2 }.\n\nProve that the products of the form a * b with a,b \u2208 S are all distinct.\n\n-/\n\ntheorem lemma_1\n  (M : \u2115)\n  (hM : 0 < M)\n  (a b c d : {x : \u2115 // M^2 \u2264 x \u2227 x < (M + 1)^2})\n  (h_ne : ({a, b}: finset \u2115) \u2260 {c, d})\n  (h_wlog : a < c \u2227 a < d)\n  : a.val * b.val \u2260 c.val * d.val :=\nbegin\n  intro heq,\n  let p := nat.gcd a c,\n  -- let q = a / p and r = c / p\n  -- then gcd(q,r) = 1\n  -- Since q \u2223(ab/p) = cd / p = rd, we have q\u2223d.\n  -- Now let s = d/q so that b = cd /a = rs.\n  -- Therefore, a = pq, b = rs, c = pr, d = qs for some positive integers p,q,r,s.\n\n  -- Since c > a, r > q, and r \u2265 q + 1.\n  -- Since d > a, s > p, and s \u2265 p + 1.\n  -- Therefore,,\n  --    b = rs \u2265 (p + 1)(q + 1) = pq + p + q + 1\n  --           \u2265 pq + 2 sqrt(pq) + 1 = a + 2 sqrt(a) + 1\n  --           \u2265 M^2 + 2 M + 1 = (M + 1)^2\n  -- Then b is not in S, a contradiction.\n  sorry\nend\n\ntheorem india1998_q8\n  (M : \u2115)\n  (hM : 0 < M)\n  (a b c d : {x : \u2115 // M^2 \u2264 x \u2227 x < (M + 1)^2})\n  (h_ne : ({a, b}: finset \u2115) \u2260 {c, d})\n  : a.val * b.val \u2260 c.val * d.val :=\nbegin\n  let m : option \u2115 := finset.min {a,b,c,d},\n  \n  -- delegate to lemma_1 ...\n  sorry,\nend\n\n"}
{"text": "informal statement Show that there is an infinite number of solutions to $x^2 = -1$ in the quaternions.formal statement theorem exercise_4_2_5 {R : Type*} [ring R] \n  (h : \u2200 x : R, x ^ 3 = x) : comm_ring R :="}
{"text": "informal statement Suppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, and some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$. Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$.formal statement theorem exercise_3_20 {X : Type*} [metric_space X]\n  (p : \u2115 \u2192 X) (l : \u2115) (r : X)\n  (hp : cauchy_seq p)\n  (hpl : tendsto (\u03bb n, p (l * n)) at_top (\ud835\udcdd r)) :\n  tendsto p at_top (\ud835\udcdd r) :="}
{"text": "import data.real.basic\nopen classical\nattribute [instance] prop_decidable\n\n/-\n  Rigorous definition of a limit\n  For a sequence x_n, we say that \\lim_{n \\to \\infty} x_n = l if\n    \u2200 \u03b5 > 0, \u2203 N, n \u2265 N \u2192 |x_n - l| < \u03b5\n-/\n\ndef lim_to_inf (x : \u2115 \u2192 \u211d) (l : \u211d) :=\n  \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, abs (x n - l) < \u03b5\n\ntheorem exercise_1p4 (x : \u2115 \u2192 \u211d) (l : \u211d) (h\u2081 : lim_to_inf x l) :\n  lim_to_inf (\u03bb n, abs (x n)) (abs l) := \nbegin\n    intros \u03b5 \u03b5_pos,\n    rcases h\u2081 \u03b5 \u03b5_pos with \u27e8N, hN\u27e9,\n    use N,\n    intros n hn,\n    calc \n    abs (abs (x n) - abs l) \u2264 abs ((x n) - l) : abs_abs_sub_le_abs_sub (x n) l\n    ... < \u03b5 : hN n hn\nend"}
{"text": "informal statement If $x$ is an element of infinite order in $G$, prove that the elements $x^{n}, n \\in \\mathbb{Z}$ are all distinct.formal statement theorem exercise_1_1_34 {G : Type*} [group G] {x : G} \n  (hx_inf : order_of x = 0) (n m : \u2124) :\n  x ^ n \u2260 x ^ m :="}
{"text": "informal statement Suppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property: if $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational $r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.formal statement theorem exercise_4_19\n  {f : \u211d \u2192 \u211d} (hf : \u2200 a b c, a < b \u2192 f a < c \u2192 c < f b \u2192 \u2203 x, a < x \u2227 x < b \u2227 f x = c)\n  (hg : \u2200 r : \u211a, is_closed {x | f x = r}) : continuous f :="}
{"text": "informal statement Let $G$ be a finite group of composite order $n$ with the property that $G$ has a subgroup of order $k$ for each positive integer $k$ dividing $n$. Prove that $G$ is not simple.formal statement theorem exercise_4_4_6a {G : Type*} [group G] (H : subgroup G)\n  [subgroup.characteristic H] : subgroup.normal H  :="}
{"text": "informal statement Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$.formal statement theorem exercise_5_4_2 {G : Type*} [group G] (H : subgroup G) : \n  H.normal \u2194 \u2045(\u22a4 : subgroup G), H\u2046 \u2264 H :="}
{"text": "informal statement If $A \\subset X$, a retraction of $X$ onto $A$ is a continuous map $r: X \\rightarrow A$ such that $r(a)=a$ for each $a \\in A$. Show that a retraction is a quotient map.formal statement theorem exercise_23_2 {X : Type*}\n  [topological_space X] {A : \u2115 \u2192 set X} (hA : \u2200 n, is_connected (A n))\n  (hAn : \u2200 n, A n \u2229 A (n + 1) \u2260 \u2205) :\n  is_connected (\u22c3 n, A n) :="}
{"text": "open classical\n\ntheorem Ex007(a b : Prop): (( a \u2192 b) \u2192 a) \u2192 a := \nassume H1:( a \u2192 b) \u2192 a,\n  have A:\u00ac\u00aca,from not.intro \n  (\n    assume H2:\u00aca,\n    have B:a, from H1 \n      (\n        assume H3:a,\n        show b, from absurd H3 H2\n      ),\n    show false, from H2 B\n  ),\n  by_contradiction\n  (\n    assume C:\u00aca,\n    show false, from A C\n  )\n"}
{"text": "informal statement Prove that $x^2+1$ is irreducible in $\\mathbb{F}_7$formal statement theorem exercise_11_4_6b {F : Type*} [field F] [fintype F] (hF : card F = 31) :\n  irreducible (X ^ 3 - 9 : polynomial F) :="}
{"text": "informal statement If $G_1$ and $G_2$ are cyclic groups of orders $m$ and $n$, respectively, prove that $G_1 \\times G_2$ is cyclic if and only if $m$ and $n$ are relatively prime.formal statement theorem exercise_2_11_6 {G : Type*} [group G] {p : \u2115} (hp : nat.prime p) \n  {P : sylow p G} (hP : P.normal) :\n  \u2200 (Q : sylow p G), P = Q :="}
{"text": "informal statement Let $H$ be the subgroup generated by two elements $a, b$ of a group $G$. Prove that if $a b=b a$, then $H$ is an abelian group.formal statement theorem exercise_2_4_19 {G : Type*} [group G] {x : G}\n  (hx : order_of x = 2) (hx1 : \u2200 y, order_of y = 2 \u2192 y = x) :\n  x \u2208 center G :="}
{"text": "informal statement Prove that if $P \\in \\operatorname{Syl}_{p}(G)$ and $H$ is a subgroup of $G$ containing $P$ then $P \\in \\operatorname{Syl}_{p}(H)$.formal statement theorem exercise_4_5_1a {p : \u2115} {G : Type*} [group G] \n  {P : subgroup G} (hP : is_p_group p P) (H : subgroup G) \n  (hH : P \u2264 H) : is_p_group p H :="}
{"text": "informal statement Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.formal statement theorem exercise_1_16a\n  (n : \u2115)\n  (d r : \u211d)\n  (x y z : euclidean_space \u211d (fin n)) -- R^n\n  (h\u2081 : n \u2265 3)\n  (h\u2082 : \u2016x - y\u2016 = d)\n  (h\u2083 : d > 0)\n  (h\u2084 : r > 0)\n  (h\u2085 : 2 * r > d)\n  : set.infinite {z : euclidean_space \u211d (fin n) | \u2016z - x\u2016 = r \u2227 \u2016z - y\u2016 = r} :="}
{"text": "import topology.instances.real \n\nopen filter real\nopen_locale topological_space \n\ntheorem leibeck_23_3 (S : set \u211d) (c : \u211d) (hc : is_lub S c) :\n  \u2203 (f : \u2115 \u2192 \u211d), (\u2200 n, f n \u2208 S) \u2227 tendsto f at_top (\ud835\udcdd c) :=\nbegin \n  sorry \nend \n"}
{"text": "informal statement Let $R$ be a ring, with $M$ an ideal of $R$. Suppose that every element of $R$ which is not in $M$ is a unit of $R$. Prove that $M$ is a maximal ideal and that moreover it is the only maximal ideal of $R$.formal statement theorem exercise_11_4_1b {F : Type*} [field F] [fintype F] (hF : card F = 2) :\n  irreducible (12 + 6 * X + X ^ 3 : polynomial F) :="}
{"text": "informal statement Suppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.formal statement theorem exercise_6_2 {V : Type*} [add_comm_group V] [module \u2102 V]\n  [inner_product_space \u2102 V] (u v : V) :\n  \u27eau, v\u27eb_\u2102 = 0 \u2194 \u2200 (a : \u2102), \u2016u\u2016  \u2264 \u2016u + a \u2022 v\u2016 :="}
{"text": "constants (p q : Prop)\ntheorem t_and_intro  (Hp : p) (Hq : q) : p \u2227 q := and.intro Hp Hq\ncheck t_and_intro           -- t_and_intro : \u2200 p q, p \u2192 q \u2192 p \u2227 q\n"}
{"text": "import LeanUtils\nopen Nat\n\ntheorem square_of_even_number_is_even (m : Nat) (h\u2080 : even m) : (even (m ^ 2)) := by\n\n  have \u27e8n, h\u2081\u27e9 : \u2203 (n : Nat), m = 2 * n := by \n    simp at *; assumption\n  have h\u2082 : m^2 = 2*(2*n^2) := by \n    calc\n      m^2 = (2*n)^2 := by \n        repeat (first | ring | simp_all)\n      _ = 4*n^2 := by \n        repeat (first | ring | simp_all)\n      _ = 2*(2*n^2) := by \n        repeat (first | ring | simp_all)\n  \n  simp_all\n\n"}
{"text": "informal statement Show that the equation $7 x^{3}+2=y^{3}$ has no solution in integers.formal statement theorem exercise_3_5 : \u00ac \u2203 x y : \u2124, 7*x^3 + 2 = y^3 :="}
{"text": "informal statement Suppose (a) $f$ is continuous for $x \\geq 0$, (b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, (d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ and prove that $g$ is monotonically increasing.formal statement theorem exercise_5_6\n  {f : \u211d \u2192 \u211d}\n  (hf1 : continuous f)\n  (hf2 : \u2200 x, differentiable_at \u211d f x)\n  (hf3 : f 0 = 0)\n  (hf4 : monotone (deriv f)) :\n  monotone_on (\u03bb x, f x / x) (set.Ioi 0) :="}
{"text": "open Nat\n\ntheorem add_assoc (m n k : Nat) : m + n + k = m + (n + k) :=\n  Nat.recOn (motive := fun k => m + n + k = m + (n + k)) k rfl (fun k ih => by simp [Nat.add_succ, ih]; done)\n"}
{"text": "informal statement Prove that the addition of residue classes $\\mathbb{Z}/n\\mathbb{Z}$ is associative.formal statement theorem exercise_1_1_3 (n : \u2124) : \n  \u2200 (a b c : \u2124), (a+b)+c \u2261 a+(b+c) [ZMOD n] :="}
{"text": "informal statement Prove that if $H$ is a subgroup of $G$ then $H$ is generated by the set $H-\\{1\\}$.formal statement theorem exercise_2_4_4 {G : Type*} [group G] (H : subgroup G) : \n  subgroup.closure ((H : set G) \\ {1}) = \u22a4 :="}
{"text": "import advice\n\nlemma conj (P Q : Prop)\n      (P \u2227 Q) : P :=\n{! !}\n"}
{"text": "-- Homework 5 due 9.26\n\ntheorem problem1 (A B : Prop) : (A \u2192 B) \u2192 (\u00ac B \u2192 \u00ac A) := sorry\n\ntheorem problem2 (A B : Prop) : \u00ac (A \u2228 B) \u2194 \u00ac A \u2227 \u00ac B := sorry\n\ntheorem problem3 (A B C : Prop) (h : B \u2194 C) : (A \u2228 B) \u2194 A \u2228 C := sorry\n\ntheorem problem4 (A B : Prop) : (A \u2192 B) \u2194 \u00ac A \u2228 B := sorry \n\ntheorem problem5 (A B : Prop) : \u00ac A \u2192 A \u2192 B := sorry \n"}
{"text": "informal statement Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$.formal statement theorem exercise_6_7 {V : Type*} [inner_product_space \u2102 V] (u v : V) :\n  \u27eau, v\u27eb_\u2102 = (\u2016u + v\u2016^2 - \u2016u - v\u2016^2 + I*\u2016u + I\u2022v\u2016^2 - I*\u2016u-I\u2022v\u2016^2) / 4 :="}
{"text": "informal statement Let $G$ be any group. Prove that the map from $G$ to itself defined by $g \\mapsto g^{-1}$ is a homomorphism if and only if $G$ is abelian.formal statement theorem exercise_2_1_5 {G : Type*} [group G] [fintype G] \n  (hG : card G > 2) (H : subgroup G) [fintype H] : \n  card H \u2260 card G - 1 :="}
{"text": "informal statement Let $E$ be a bounded set in $R^{1}$. Prove that there exists a real function $f$ such that $f$ is uniformly continuous and is not bounded on $E$.formal statement theorem exercise_4_12\n  {\u03b1 \u03b2 \u03b3 : Type*} [uniform_space \u03b1] [uniform_space \u03b2] [uniform_space \u03b3]\n  {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3}\n  (hf : uniform_continuous f) (hg : uniform_continuous g) :\n  uniform_continuous (g \u2218 f) :="}
{"text": "informal statement Prove that if $V$ is a complex inner-product space, then $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ for all $u, v \\in V$.formal statement theorem exercise_6_16 {K V : Type*} [is_R_or_C K] [inner_product_space K V]\n  {U : submodule K V} : \n  U.orthogonal = \u22a5  \u2194 U = \u22a4 :="}
{"text": "[GOAL]\n\u22a2 \u00acUnivLE.{u + 1, u}\n[PROOFSTEP]\nsimp only [Small_iff, not_forall, not_exists, not_nonempty_iff]\n[GOAL]\n\u22a2 \u2203 x, \u2200 (x_1 : Type u), IsEmpty (x \u2243 x_1)\n[PROOFSTEP]\nexact \u27e8Type u, fun \u03b1 => \u27e8fun f => Function.not_surjective_Type.{u, u} f.symm f.symm.surjective\u27e9\u27e9\n"}
{"text": "import data.complex.exponential\nimport algebra.polynomial.big_operators\nimport analysis.special_functions.trigonometric.basic\n\ntheorem AMC_2021_A_22 (a b c :\u211d)(P:\u211d \u2192 \u211d)\n(hP: \u2200 (x:\u211d), P x = x^3+a*x^2*b*x+c)\n(hroots:(P (real.cos 2*real.pi/7) = 0)\u2227(P (real.cos 4*real.pi/7) = 0)\u2227(P (real.cos 6*real.pi/7) = 0)):\na*b*c = 1/32\n:=\nbegin\n  sorry\nend"}
{"text": "informal statement Let $n$ be a positive integer, and let $f_{n}(z)=n+(n-1) z+$ $(n-2) z^{2}+\\cdots+z^{n-1}$. Prove that $f_{n}$ has no roots in the closed unit disk $\\{z \\in \\mathbb{C}:|z| \\leq 1\\}$.formal statement theorem exercise_2017_b3 (f : \u211d \u2192 \u211d) (c : \u2115 \u2192 \u211d)\n  (hf : f = \u03bb x, (\u2211' (i : \u2115), (c i) * x^i)) \n  (hc : \u2200 n, c n = 0 \u2228 c n = 1)\n  (hf1 : f (2/3) = 3/2) : \n  irrational (f (1/2)) :="}
{"text": "informal statement Prove that there is no rational number whose square is $12$.formal statement theorem exercise_1_5 (A minus_A : set \u211d) (hA : A.nonempty) \n  (hA_bdd_below : bdd_below A) (hminus_A : minus_A = {x | -x \u2208 A}) :\n  Inf A = Sup minus_A :="}
{"text": "informal statement Suppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. Prove that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ have no roots in common.formal statement theorem exercise_5_4 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (S T : V \u2192\u2097[F] V) (hST : S \u2218 T = T \u2218 S) (c : F):\n  map S (T - c \u2022 id).ker = (T - c \u2022 id).ker :="}
{"text": "informal statement Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic.formal statement theorem exercise_1_6_17 {G : Type*} [group G] (f : G \u2192 G) \n  (hf : f = \u03bb g, g\u207b\u00b9) :\n  \u2200 x y : G, f x * f y = f (x*y) \u2194 \u2200 x y : G, x*y = y*x :="}
{"text": "import smt2\n\nlemma negation_of_conj :\n    forall (P Q : Prop),\n        not (P \u2227 Q) \u2194 not P \u2228 not Q :=\nby intros; z3 \"d1.log\"\n\nlemma negation_of_disj :\n    forall (P Q : Prop),\n        \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\nbegin\n    intros, z3\nend\n"}
{"text": "import data.real.basic\n\ntheorem IMO_Shortlist_A4_2001 (f : \u211d \u2192 \u211d) : \n(\u2200 x y : \u211d, f(x^2 - y^2) = x*f(x) - y * f(y)) \u2192 \u2203 l : \u211d, \u2200 x  : \u211d, f(x) = l*x := sorry \n"}
{"text": "theory Filter1 \n  imports Main \nbegin \n  \n  lemma \"\" "}
{"text": "informal statement Suppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$.formal statement theorem exercise_7_14 {\ud835\udd5c V : Type*} [is_R_or_C \ud835\udd5c]\n  [inner_product_space \ud835\udd5c V] [finite_dimensional \ud835\udd5c V]\n  {T : End \ud835\udd5c V} (hT : is_self_adjoint T)\n  {l : \ud835\udd5c} {\u03b5 : \u211d} (he : \u03b5 > 0) : \u2203 v : V, \u2016v\u2016= 1 \u2227 (\u2016T v - l \u2022 v\u2016 < \u03b5 \u2192\n  (\u2203 l' : T.eigenvalues, \u2016l - l'\u2016 < \u03b5)) :="}
{"text": "informal statement Show that the rationals $\\mathbb{Q}$ are not locally compact.formal statement theorem exercise_29_1 : \u00ac locally_compact_space \u211a :="}
{"text": "informal statement Prove that no group of order $p^2 q$, where $p$ and $q$ are prime, is simple.formal statement theorem exercise_6_8_1 {G : Type*} [group G]\n  (a b : G) : closure ({a, b} : set G) = closure {b*a*b^2, b*a*b^3} :="}
{"text": "[GOAL]\na b : \u2124\n\u22a2 a = b \u2194 \u2191a = \u2191b\n[PROOFSTEP]\nsimp only [Int.cast_inj]\n[GOAL]\na b : \u2124\n\u22a2 a \u2260 b \u2194 \u2191a \u2260 \u2191b\n[PROOFSTEP]\nsimp only [ne_eq, Int.cast_inj]\n"}
{"text": "informal statement A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps.formal statement theorem exercise_17_4 {X : Type*} [topological_space X]\n  (U A : set X) (hU : is_open U) (hA : is_closed A) :\n  is_open (U \\ A) \u2227 is_closed (A \\ U) :="}
{"text": "example : \u2203 x, x + 2 = 8 :=\nbegin\n  let a : \u2115 := 3 * 2,\n  existsi a,\n  reflexivity\nend\n"}
{"text": "[GOAL]\n\u22a2 AbsoluteValue.uniformSpace AbsoluteValue.abs = PseudoMetricSpace.toUniformSpace\n[PROOFSTEP]\next s\n[GOAL]\ncase a.a\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 s \u2208 uniformity \u211a \u2194 s \u2208 uniformity \u211a\n[PROOFSTEP]\nrw [(AbsoluteValue.hasBasis_uniformity _).mem_iff, Metric.uniformity_basis_dist_rat.mem_iff]\n[GOAL]\ncase a.a\ns : Set (\u211a \u00d7 \u211a)\n\u22a2 (\u2203 i, 0 < i \u2227 {p | \u2191AbsoluteValue.abs (p.snd - p.fst) < i} \u2286 s) \u2194 \u2203 i, 0 < i \u2227 {p | dist p.fst p.snd < \u2191i} \u2286 s\n[PROOFSTEP]\nsimp only [Rat.dist_eq, AbsoluteValue.abs_apply, \u2190 Rat.cast_sub, \u2190 Rat.cast_abs, Rat.cast_lt, abs_sub_comm]\n[GOAL]\n\u22a2 UniformSpace \u211d\n[PROOFSTEP]\ninfer_instance\n[GOAL]\n\u22a2 CompleteSpace \u211d\n[PROOFSTEP]\ninfer_instance\n[GOAL]\n\u22a2 SeparatedSpace \u211d\n[PROOFSTEP]\ninfer_instance\n[GOAL]\n\u22a2 UniformInducing Rat.cast\n[PROOFSTEP]\nrw [Rat.uniformSpace_eq]\n[GOAL]\n\u22a2 UniformInducing Rat.cast\n[PROOFSTEP]\nexact Rat.uniformEmbedding_coe_real.toUniformInducing\n"}
{"text": "universes u v\n\ntheorem eqLitOfSize0 {\u03b1 : Type u} (a : Array \u03b1) (hsz : a.size = 0) : a = #[] :=\na.toArrayLitEq 0 hsz\n\ntheorem eqLitOfSize1 {\u03b1 : Type u} (a : Array \u03b1) (hsz : a.size = 1) : a = #[a.getLit 0 hsz (ofDecideEqTrue rfl)] :=\na.toArrayLitEq 1 hsz\n\ntheorem eqLitOfSize2 {\u03b1 : Type u} (a : Array \u03b1) (hsz : a.size = 2) : a = #[a.getLit 0 hsz (ofDecideEqTrue rfl), a.getLit 1 hsz (ofDecideEqTrue rfl)] :=\na.toArrayLitEq 2 hsz\n\ntheorem eqLitOfSize3 {\u03b1 : Type u} (a : Array \u03b1) (hsz : a.size = 3) :\n  a = #[a.getLit 0 hsz (ofDecideEqTrue rfl), a.getLit 1 hsz (ofDecideEqTrue rfl), a.getLit 2 hsz (ofDecideEqTrue rfl)] :=\na.toArrayLitEq 3 hsz\n\n/-\nMatcher for the following patterns\n```\n| #[]           => _\n| #[a\u2081]         => _\n| #[a\u2081, a\u2082, a\u2083] => _\n| a             => _\n``` -/\ndef matchArrayLit {\u03b1 : Type u} (C : Array \u03b1 \u2192 Sort v) (a : Array \u03b1)\n    (h\u2081 : Unit \u2192      C #[])\n    (h\u2082 : \u2200 a\u2081,       C #[a\u2081])\n    (h\u2083 : \u2200 a\u2081 a\u2082 a\u2083, C #[a\u2081, a\u2082, a\u2083])\n    (h\u2084 : \u2200 a,        C a)\n    : C a :=\nif h : a.size = 0 then\n  @Eq.rec _ _ (fun x _ => C x) (h\u2081 ()) _ (a.toArrayLitEq 0 h).symm\nelse if h : a.size = 1 then\n  @Eq.rec _ _ (fun x _ => C x) (h\u2082 (a.getLit 0 h (ofDecideEqTrue rfl))) _ (a.toArrayLitEq 1 h).symm\nelse if h : a.size = 3 then\n  @Eq.rec _ _ (fun x _ => C x) (h\u2083 (a.getLit 0 h (ofDecideEqTrue rfl)) (a.getLit 1 h (ofDecideEqTrue rfl)) (a.getLit 2 h (ofDecideEqTrue rfl))) _ (a.toArrayLitEq 3 h).symm\nelse\n  h\u2084 a\n\n/- Equational lemmas that should be generated automatically. -/\ntheorem matchArrayLit.eq1 {\u03b1 : Type u} (C : Array \u03b1 \u2192 Sort v)\n    (h\u2081 : Unit \u2192      C #[])\n    (h\u2082 : \u2200 a\u2081,       C #[a\u2081])\n    (h\u2083 : \u2200 a\u2081 a\u2082 a\u2083, C #[a\u2081, a\u2082, a\u2083])\n    (h\u2084 : \u2200 a,        C a)\n    : matchArrayLit C #[] h\u2081 h\u2082 h\u2083 h\u2084 = h\u2081 () :=\nrfl\n\ntheorem matchArrayLit.eq2 {\u03b1 : Type u} (C : Array \u03b1 \u2192 Sort v)\n    (h\u2081 : Unit \u2192      C #[])\n    (h\u2082 : \u2200 a\u2081,       C #[a\u2081])\n    (h\u2083 : \u2200 a\u2081 a\u2082 a\u2083, C #[a\u2081, a\u2082, a\u2083])\n    (h\u2084 : \u2200 a,        C a)\n    (a\u2081 : \u03b1)\n    : matchArrayLit C #[a\u2081] h\u2081 h\u2082 h\u2083 h\u2084 = h\u2082 a\u2081 :=\nrfl\n\ntheorem matchArrayLit.eq3 {\u03b1 : Type u} (C : Array \u03b1 \u2192 Sort v)\n    (h\u2081 : Unit \u2192      C #[])\n    (h\u2082 : \u2200 a\u2081,       C #[a\u2081])\n    (h\u2083 : \u2200 a\u2081 a\u2082 a\u2083, C #[a\u2081, a\u2082, a\u2083])\n    (h\u2084 : \u2200 a,        C a)\n    (a\u2081 a\u2082 a\u2083 : \u03b1)\n    : matchArrayLit C #[a\u2081, a\u2082, a\u2083] h\u2081 h\u2082 h\u2083 h\u2084 = h\u2083 a\u2081 a\u2082 a\u2083 :=\nrfl\n"}
{"text": "import LeanUtils\nopen Nat\n\ntheorem n_cube_plus_2_n (n : Nat) : divisible 3 (n^3 + 2*n) := by\n  match n with\n  | 0 => repeat (first | trivial | ring | simp_all)\n  | k+1 => \n    have h\u2081 : divisible 3 (k ^ 3 + 2 * k) := n_cube_plus_2_n _\n\n    have \u27e8z, h\u2082\u27e9 : \u2203 z, k^3 + 2*k = 3*z := by\n      repeat (first | ring | simp_all)\n    \n    have h\u2083 : (k + 1) ^ 3 + 2 * (k + 1) = 3*(z + k^2 + k + 1) := by\n      calc\n        (k + 1) ^ 3 + 2 * (k + 1) = k^3 + 3*k^2 + 5*k + 3 := by \n          repeat (first | ring | simp_all)\n        _ = k^3 + 2*k + 3 * (k^2 + k + 1) := by \n          repeat (first | ring | simp_all)\n        _ = 3*z + 3 * (k^2 + k + 1) := by\n          repeat (first | ring | simp_all)\n        _ = 3 * (z + k^2 + k + 1) := by\n          repeat (first | ring | simp_all)\n    try rw [h\u2083]\n  \n    apply mod_rewrite.mpr\n    exact \u27e8_, by repeat (first | trivial | ring | simp_all)\u27e9\n\n\n\n"}
{"text": "/-\nCopyright (c) 2019 Reid Barton. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Reid Barton\n\n! This file was ported from Lean 3 source module topology.category.Top.epi_mono\n! leanprover-community/mathlib commit 70fd9563a21e7b963887c9360bd29b2393e6225a\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Topology.Category.Top.Adjunctions\n\n/-!\n# Epi- and monomorphisms in `Top`\n\nThis file shows that a continuous function is an epimorphism in the category of topological spaces\nif and only if it is surjective, and that a continuous function is a monomorphism in the category of\ntopological spaces if and only if it is injective.\n-/\n\n\nuniverse u\n\nopen CategoryTheory\n\nopen TopCat\n\nnamespace TopCat\n\ntheorem epi_iff_surjective {X Y : TopCat.{u}} (f : X \u27f6 Y) : Epi f \u2194 Function.Surjective f :=\n  by\n  suffices epi f \u2194 epi ((forget TopCat).map f)\n    by\n    rw [this, CategoryTheory.epi_iff_surjective]\n    rfl\n  constructor\n  \u00b7 intro\n    infer_instance\n  \u00b7 apply functor.epi_of_epi_map\n#align Top.epi_iff_surjective TopCat.epi_iff_surjective\n\ntheorem mono_iff_injective {X Y : TopCat.{u}} (f : X \u27f6 Y) : Mono f \u2194 Function.Injective f :=\n  by\n  suffices mono f \u2194 mono ((forget TopCat).map f)\n    by\n    rw [this, CategoryTheory.mono_iff_injective]\n    rfl\n  constructor\n  \u00b7 intro\n    infer_instance\n  \u00b7 apply functor.mono_of_mono_map\n#align Top.mono_iff_injective TopCat.mono_iff_injective\n\nend TopCat\n\n"}
{"text": "lemma closure_empty [simp]: \"closure {} = {}\""}
{"text": "informal statement Show that every linear map from a one-dimensional vector space to itself is multiplication by some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ and $T \\in \\mathcal{L}(V, V)$, then there exists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$.formal statement theorem exercise_4_4 (p : polynomial \u2102) :\n  p.degree = @card (root_set p \u2102) (polynomial.root_set_fintype p \u2102) \u2194\n  disjoint\n  (@card (root_set p.derivative \u2102) (polynomial.root_set_fintype p.derivative \u2102))\n  (@card (root_set p \u2102) (polynomial.root_set_fintype p \u2102)) :="}
{"text": "informal statement Prove that characteristic subgroups are normal.formal statement theorem exercise_4_4_7 {G : Type*} [group G] {H : subgroup G} [fintype H]\n  (hH : \u2200 (K : subgroup G) (fK : fintype K), card H = @card K fK \u2192 H = K) : \n  H.characteristic :="}
{"text": "/-\nCopyright (c) 2021 Yourong Zang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yourong Zang\n-/\nimport analysis.calculus.conformal.normed_space\nimport analysis.inner_product_space.conformal_linear_map\n\n/-!\n# Conformal maps between inner product spaces\n\nA function between inner product spaces is which has a derivative at `x`\nis conformal at `x` iff the derivative preserves inner products up to a scalar multiple.\n-/\n\nnoncomputable theory\n\nvariables {E F : Type*} [inner_product_space \u211d E] [inner_product_space \u211d F]\n\nopen_locale real_inner_product_space\n\n/-- A real differentiable map `f` is conformal at point `x` if and only if its\n    differential `fderiv \u211d f x` at that point scales every inner product by a positive scalar. -/\nlemma conformal_at_iff' {f : E \u2192 F} {x : E} :\n  conformal_at f x \u2194\n  \u2203 (c : \u211d), 0 < c \u2227 \u2200 (u v : E), \u27eafderiv \u211d f x u, fderiv \u211d f x v\u27eb = c * \u27eau, v\u27eb :=\nby rw [conformal_at_iff_is_conformal_map_fderiv, is_conformal_map_iff]\n\n/-- A real differentiable map `f` is conformal at point `x` if and only if its\n    differential `f'` at that point scales every inner product by a positive scalar. -/\nlemma conformal_at_iff {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F} (h : has_fderiv_at f f' x) :\n  conformal_at f x \u2194 \u2203 (c : \u211d), 0 < c \u2227 \u2200 (u v : E), \u27eaf' u, f' v\u27eb = c * \u27eau, v\u27eb :=\nby simp only [conformal_at_iff', h.fderiv]\n\n/-- The conformal factor of a conformal map at some point `x`. Some authors refer to this function\n    as the characteristic function of the conformal map. -/\ndef conformal_factor_at {f : E \u2192 F} {x : E} (h : conformal_at f x) : \u211d :=\nclassical.some (conformal_at_iff'.mp h)\n\nlemma conformal_factor_at_pos {f : E \u2192 F} {x : E} (h : conformal_at f x) :\n  0 < conformal_factor_at h :=\n(classical.some_spec $ conformal_at_iff'.mp h).1\n\nlemma conformal_factor_at_inner_eq_mul_inner' {f : E \u2192 F} {x : E}\n  (h : conformal_at f x) (u v : E) :\n  \u27ea(fderiv \u211d f x) u, (fderiv \u211d f x) v\u27eb = (conformal_factor_at h : \u211d) * \u27eau, v\u27eb :=\n(classical.some_spec $ conformal_at_iff'.mp h).2 u v\n\nlemma conformal_factor_at_inner_eq_mul_inner {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F}\n  (h : has_fderiv_at f f' x) (H : conformal_at f x) (u v : E) :\n  \u27eaf' u, f' v\u27eb = (conformal_factor_at H : \u211d) * \u27eau, v\u27eb :=\n(H.differentiable_at.has_fderiv_at.unique h) \u25b8 conformal_factor_at_inner_eq_mul_inner' H u v\n"}
{"text": "import Smt\n\ntheorem assoc (f : Bool \u2192 Bool \u2192 Bool) (p q r : Bool) :\n  f p (f q r) == f (f p q) r := by\n  smt\n  admit\n"}
{"text": "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\nprelude\nimport Init.Data.Option.Basic\n\nuniverse u v\n\ntheorem Option.eq_of_eq_some {\u03b1 : Type u} : \u2200 {x y : Option \u03b1}, (\u2200z, x = some z \u2194 y = some z) \u2192 x = y\n  | none,   none,   h => rfl\n  | none,   some z, h => Option.noConfusion ((h z).2 rfl)\n  | some z, none,   h => Option.noConfusion ((h z).1 rfl)\n  | some z, some w, h => Option.noConfusion ((h w).2 rfl) (congrArg some)\n\ntheorem Option.eq_none_of_isNone {\u03b1 : Type u} : \u2200 {o : Option \u03b1}, o.isNone \u2192 o = none\n  | none, h => rfl\n"}
{"text": "informal statement Show that the lower limit topology $\\mathbb{R}_l$ and $K$-topology $\\mathbb{R}_K$ are not comparable.formal statement theorem exercise_13_8b :\n  (topological_space.generate_from {S : set \u211d | \u2203 a b : \u211a, a < b \u2227 S = Ico a b}).is_open \u2260\n  (lower_limit_topology \u211d).is_open :="}
{"text": "def inc (x : Nat) := x + 1\n\n@[simp] theorem inc_eq : inc x = x + 1 := rfl\n\ntheorem ex (a b : Fin (inc n)) (h : a = b) : b = a := by\n  simp only [inc_eq] at a\n  trace_state\n  exact h.symm\n"}
{"text": "Formal statement is: lemma interior_hyperplane [simp]: assumes \"a \\<noteq> 0\" shows \"interior {x. a \\<bullet> x = b} = {}\" Informal statement is: If $a \\neq 0$, then the interior of the hyperplane $\\{x \\in \\mathbb{R}^n \\mid a \\cdot x = b\\}$ is empty."}
{"text": "constants (p q : Prop) (H : p \u2227 q)\ntheorem t_proof_left : p := and.elim_left H\ntheorem t_proof_right : q := and.elim_right H\ncheck t_proof_left    -- t_proof_left : p\ncheck t_proof_right   -- t_proof_right : q\n"}
{"text": "\ntheorem Ex003_1 (a b: Prop) : \u00aca \u2192 a \u2192 b :=\nassume A:\u00aca,\n  assume B:a,\n  have C:false, from  A B,\n  show b, from false.elim C\n\n\ntheorem Ex003_2 (a b : Prop) : \u00aca \u2192 a \u2192 b := \nbegin\n  intro,\n  intro,\n  contradiction\nend \n\n\n\n\n"}
{"text": "informal statement If $P$ is a $p$-Sylow subgroup of $G$ and $P \\triangleleft G$, prove that $P$ is the only $p$-Sylow subgroup of $G$.formal statement theorem exercise_2_11_6 {G : Type*} [group G] {p : \u2115} (hp : nat.prime p) \n  {P : sylow p G} (hP : P.normal) :\n  \u2200 (Q : sylow p G), P = Q :="}
{"text": "informal statement Let $\\mathcal{T}_\\alpha$ be a family of topologies on $X$. Show that there is a unique smallest topology on $X$ containing all the collections $\\mathcal{T}_\\alpha$.formal statement theorem exercise_13_5a {X : Type*}\n  [topological_space X] (A : set (set X)) (hA : is_topological_basis A) :\n  generate_from A = generate_from (sInter {T | is_topology X T \u2227 A \u2286 T}) :="}
{"text": "informal statement Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$.formal statement theorem exercise_5_5_2 : irreducible (X^3 - 3*X - 1 : polynomial \u211a) :="}
{"text": "-- You can even write it as a function!\n\ntheorem contrapositive (P Q : Prop) :\n (P \u2192 Q) \u2192  (\u00ac Q \u2192 \u00ac P) :=\n  \u03bb HPQ HnQ HP, HnQ (HPQ HP)\n"}
{"text": "informal statement Let $I, J$ be ideals in a ring $R$. Prove that the residue of any element of $I \\cap J$ in $R / I J$ is nilpotent.formal statement theorem exercise_10_7_10 {R : Type*} [ring R]\n  (M : ideal R) (hM : \u2200 (x : R), x \u2209 M \u2192 is_unit x) :\n  is_maximal M \u2227 \u2200 (N : ideal R), is_maximal N \u2192 N = M :="}
{"text": "informal statement Prove that if $R$ is an integral domain and $x^{2}=1$ for some $x \\in R$ then $x=\\pm 1$.formal statement theorem exercise_7_1_15 {R : Type*} [ring R] (hR : \u2200 a : R, a^2 = a) :\n  comm_ring R :="}
{"text": "informal statement A map $f: X \\rightarrow Y$ is said to be an open map if for every open set $U$ of $X$, the set $f(U)$ is open in $Y$. Show that $\\pi_{1}: X \\times Y \\rightarrow X$ and $\\pi_{2}: X \\times Y \\rightarrow Y$ are open maps.formal statement theorem exercise_16_4 {X Y : Type*} [topological_space X] [topological_space Y]\n  (\u03c0\u2081 : X \u00d7 Y \u2192 X)\n  (\u03c0\u2082 : X \u00d7 Y \u2192 Y)\n  (h\u2081 : \u03c0\u2081 = prod.fst)\n  (h\u2082 : \u03c0\u2082 = prod.snd) :\n  is_open_map \u03c0\u2081 \u2227 is_open_map \u03c0\u2082 :="}
{"text": "Module first.\n  Polymorphic Record BAR (A:Type) :=\n  { foo: A->Prop; bar: forall (x y: A), foo x -> foo y}.\n\nSection A.\nContext {A:Type}.\n\nSet Printing Universes.\n\nHint Resolve bar.\nGoal forall (P:BAR A) x y, foo _ P x -> foo _ P y.\nintros.\neauto.\nQed.\nEnd A.\nEnd first.\n\nModule firstbest.\n  Polymorphic Record BAR (A:Type) :=\n  { foo: A->Prop; bar: forall (x y: A), foo x -> foo y}.\n\nSection A.\nContext {A:Type}.\n\nSet Printing Universes.\n\nPolymorphic Hint Resolve bar.\nGoal forall (P:BAR A) x y, foo _ P x -> foo _ P y.\nintros.\neauto.\nQed.\nEnd A.\nEnd firstbest.\n\nModule second.\nAxiom foo: Set.\nAxiom foo': Set.\n\nPolymorphic Record BAR (A:Type) :=\n  { bar: foo' -> foo}.\nSet Printing Universes.\n\nLemma baz@{i}: forall (P:BAR@{Set} nat), foo' -> foo.\n  eauto using bar.\nQed.\nEnd second.\n"}
{"text": "import mynat.definition\nimport mynat.add\nimport mynat.mul\n\nlemma example2 (x y : mynat) (h : y = x + 7) : 2 * y = 2 * (x + 7) :=\nbegin\nrw h,\nrefl,\nend\n"}
{"text": "import data.real.basic\nimport data.real.nnreal\n\ntheorem USAMO_Problem_1_2011 (a b c : real) [a > 0] [b > 0] [c > 0]:\na^2 + b^2 + c^2 +(a+b+c)^4 \u2264 4 \u2192 \n((a*b + 1) / (a+b)^2) +(b*c+1) / (b+c)^2 + (c*a+1) / (c+a)^2 \u2265 3 \n := sorry\n\n"}
{"text": "informal statement Prove that $\\lim_{n \\rightarrow \\infty} \\sum_{i<n} a_i = \\infty$, where $a_i = \\sqrt{i + 1} -\\sqrt{i}$.formal statement theorem exercise_3_6a\n: tendsto (\u03bb (n : \u2115), (\u2211 i in finset.range n, g i)) at_top at_top :="}
{"text": "def fact : Nat \u2192 Nat\n| 0     => 1\n| (n+1) => (n+1)*fact n\n\n#check fact 6\n\n#eval fact 10\n\n-- set_option pp.all true\ntheorem tst1 : 100000000000 + 200000000000 = 300000000000 :=\nrfl\n\ntheorem tst2 : 100000000000 * 200000000000 = 20000000000000000000000 :=\nrfl\n\ntheorem tst3 : fact 7 = 5040 :=\nrfl\n\ntheorem tst4 : fact 10 = 3628800 :=\nrfl\n\ntheorem tst5 : 100000000001 < 300000000000 :=\nof_decide_eq_true rfl\n\ntheorem tst6 : \"hello\".length = 5 :=\nrfl\n\ntheorem tst7 : \"helloworld\".length = 10 :=\nrfl\n\ntheorem tst8 : \"hello\" ++ \"world\" = \"helloworld\" :=\nrfl\n\ntheorem tst9 : \"abc\" \u2260 \"cde\" :=\nby decide\n\ntheorem tst10 : \"helloWorld\" \u2260 \"helloworld\" :=\nby decide\n\ntheorem tst11 : \"helloWorld\" = \"helloWorld\" :=\nby decide\n\ntheorem tst12 : 'a' \u2260 'c' :=\nby decide\n\n#check tst10\n"}
{"text": "def f (x : Nat) := 0\n\ntheorem ex1 (h : f x = 1) : False := by\n  simp [f] at h\n\ndef g (x : Nat) := [x]\n\ntheorem ex2 (h : g x = []) : 0 = 1 := by\n  simp [g] at h\n\ntheorem ex3 (x : \u03b1) (h : id x \u2260 x) : 0 = 1 := by\n  simp at h\n"}
{"text": "informal statement Suppose $X$ is a nonempty complete metric space, and $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. Prove Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty.formal statement theorem exercise_4_2a\n  {\u03b1 : Type} [metric_space \u03b1]\n  {\u03b2 : Type} [metric_space \u03b2]\n  (f : \u03b1 \u2192 \u03b2)\n  (h\u2081 : continuous f)\n  : \u2200 (x : set \u03b1), f '' (closure x) \u2286 closure (f '' x) :="}
{"text": "informal statement Suppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$.formal statement theorem exercise_6_7 {V : Type*} [inner_product_space \u2102 V] (u v : V) :\n  \u27eau, v\u27eb_\u2102 = (\u2016u + v\u2016^2 - \u2016u - v\u2016^2 + I*\u2016u + I\u2022v\u2016^2 - I*\u2016u-I\u2022v\u2016^2) / 4 :="}
{"text": "import algebra.big_operators.order\nimport tactic.ring\n\n\nopen_locale big_operators\n\n\ntheorem finset.mem_le_pos_sum {\u03b1 : Type*} {\u03b2 : Type*} [linear_ordered_add_comm_group \u03b2] (f : \u03b1 \u2192 \u03b2) (s : finset \u03b1) (h1 : \u2200 x, x \u2208 s \u2192 0 < f x) \n:  \u2200 y (H : y \u2208 s), f y \u2264 \u2211 x in s, f x :=\nbegin\n  apply finset.single_le_sum,\n  intros x h,\n  apply le_of_lt (h1 x h),\n\nend\n"}
{"text": "\n(* the only way to compute zero is for p to become canonical.\nThe only canonical member of A=A is eq_refl.\nHowever, it is impossible to that p is propositionally equal to eq_refl.\nIn particular the univalence axiom allows for non-refl proofs. *)\nFixpoint zero (A : Set)  (p : A = A) {struct p} : nat := 0.\n\n\n(* although this axiom breaks canonicity, it is believed to be consistent *)\nAxiom strong_exm : Set -> nat.\nAxiom strong_exm_true : strong_exm True = 0.\nAxiom strong_exm_false : strong_exm False = 1.\n\n\n(* same type as [zero] above, but provably non parametric *)\nDefinition nonParam (A : Set)  (p : A = A) : nat := strong_exm A.\n\n(* because zero cannot be unfolded, it seems safe to assume the following *)\nAxiom zeroOpaque :(forall x, zero x = nonParam x).\n\n\nInductive eq_R (A\u2081 A\u2082 : Type) (A_R : A\u2081 -> A\u2082 -> Type) (x\u2081 : A\u2081) (x\u2082 : A\u2082)\n(x_R : A_R x\u2081 x\u2082)\n  : forall (H : A\u2081) (H0 : A\u2082), A_R H H0 -> x\u2081 = H -> x\u2082 = H0 -> Prop :=\n    eq_refl_R : eq_R A\u2081 A\u2082 A_R x\u2081 x\u2082 x_R x\u2081 x\u2082 x_R eq_refl eq_refl.\n\n\nLemma zero_not_parametric :\n(forall (A\u2081 A\u2082 : Set) (A_R : A\u2081 -> A\u2082 -> Set) (p\u2081 : A\u2081 = A\u2081) (p\u2082 : A\u2082 = A\u2082),\neq_R Set Set (fun H1 H2 : Set => H1 -> H2 -> Set) A\u2081 A\u2082 A_R A\u2081 A\u2082 A_R p\u2081\n  p\u2082 -> (zero A\u2081 p\u2081) = (zero A\u2082 p\u2082)) -> False.\nProof using.\n  intros Hc.\n  specialize (Hc True False (fun _ _ => True) eq_refl eq_refl).\n  do 2 rewrite zeroOpaque in Hc.\n  unfold nonParam in Hc. simpl in Hc.\n  rewrite strong_exm_true in Hc.\n  rewrite strong_exm_false in Hc.\n  specialize (Hc (@eq_refl_R _ _ _ _ _ _)).\n  discriminate.\nQed.\n\n"}
{"text": "import data.real.irrational\nimport topology.basic\nimport algebra.order.floor\n\n\n--OUTPUT 1\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h\u03b1 : \u00ac is_rat \u03b1) : \u2200 y \u2208 Icc 0 1, \u2203 x \u2208 Icc 0 1, x \u2260 y \u2227 x \u2208 {n : \u2124 // n * \u03b1} :=\nbegin\n  assume y h,\n  have h1 : \u2200 i j : \u2124, i \u2260 j \u2192 {i * \u03b1} \u2260 {j * \u03b1}, from by {\n    assume i j h2,\n    assume h3,\n    have h4 : i * \u03b1 - (i * \u03b1).floor = {i * \u03b1}, from by {\n      rw \u2190 h3,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw \u2190 floor_eq_of_mem_Icc,\n      rw\nend --Needs more than 2000 tokens!\n\n--OUTPUT 2\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h\u03b1 : \u00ac is_rat \u03b1) : \n\u2200 y \u2208 Icc 0 1, \u2203 x \u2208 set.range (\u03bb n : \u2124, n \u2022 \u03b1 % 1), abs (x - y) < 1 :=\nbegin\n  assume y h1,\n  have h2 : \u2200 i j : \u2124, i \u2260 j \u2192 (i \u2022 \u03b1 % 1) \u2260 (j \u2022 \u03b1 % 1), from\n    assume i j h2,\n    have h3 : i \u2022 \u03b1 - (i \u2022 \u03b1 % 1) = (i \u2022 \u03b1 % 1), from by {rw \u2190 sub_eq_add_neg, rw \u2190 floor_add, rw floor_eq_self, rw add_comm, rw add_neg_self, rw zero_add,},\n    have h4 : j \u2022 \u03b1 - (j \u2022 \u03b1 % 1) = (j \u2022 \u03b1 % 1), from by {rw \u2190 sub_eq_add_neg, rw \u2190 floor_add, rw floor_eq_self, rw add_comm, rw add_neg_self, rw zero_add,},\n    have h5 : i \u2022 \u03b1 = j \u2022 \u03b1, from by {rw [h3,h4], rw sub_eq_zero, rw h2,},\n    have h6 : \u03b1 = (j - i)\u207b\u00b9 \u2022 (j \u2022 \u03b1 - i \u2022 \u03b1), from by {rw [mul_sub,mul_sub,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm,mul_assoc,mul_comm\nend --Needs more than 2000 tokens!\n\n--OUTPUT 3\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h\u03b1 : \u00ac is_rat \u03b1) : \u2200 y \u2208 Icc 0 1, \u2203 x \u2208 Icc 0 1, x \u2260 y :=\nbegin\n  assume y h,\n  have h1 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n    have h2 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n      have h3 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n        have h4 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n          have h5 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n            have h6 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n              have h7 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                have h8 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                  have h9 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                    have h10 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                      have h11 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                        have h12 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                          have h13 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                            have h14 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                              have h15 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                have h16 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                  have h17 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                    have h18 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                      have h19 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                        have h20 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                          have h21 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                            have h22 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                              have h23 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                have h24 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                  have h25 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                    have h26 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                      have h27 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                        have h28 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                          have h29 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                            have h30 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                              have h31 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                have h32 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                  have h33 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                    have h34 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                      have h35 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                        have h36 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                          have h37 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                            have h38 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                              have h39 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                have h40 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                  have h41 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                    have h42 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                      have h43 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                        have h44 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                          have h45 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                            have h46 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                              have h47 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                have h48 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                  have h49 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                    have h50 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                      have h51 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                        have h52 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                          have h53 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                            have h54 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                              have h55 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                have h56 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                  have h57 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                    have h58 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                      have h59 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                        have h60 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                          have h61 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                            have h62 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                              have h63 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                have h64 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                  have h65 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                    have h66 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                      have h67 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                        have h68 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                          have h69 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                            have h70 : \u2203 x \u2208 Icc 0 1, x \u2260 y, from by {\n                                                                                                                                              have h71 : \u2203 x \u2208 I\nend --Needs more than 2000 tokens!\n\n/- FEW SHOT PROMPTS TO CODEX(START)\n/--`theorem`\nPower Set is Closed under Intersection\nLet $S$ be a set.\n\nLet $\\powerset S$ be the power set of $S$.\n\n\nThen:\n:$\\forall A, B \\in \\powerset S: A \\cap B \\in \\powerset S$\n`proof`\nLet $A, B \\in \\powerset S$.\n\nThen by the definition of power set, $A \\subseteq S$ and $B \\subseteq S$.\n\nFrom Intersection is Subset we have that $A \\cap B \\subseteq A$.\n\nIt follows from Subset Relation is Transitive that $A \\cap B \\subseteq S$.\n\nThus $A \\cap B \\in \\powerset S$ and closure is proved.\n{{qed}}\n-/\ntheorem power_set_intersection_closed {\u03b1 : Type*} (S : set \u03b1) : \u2200 A B \u2208 \ud835\udcab S, (A \u2229 B) \u2208 \ud835\udcab S :=\nbegin\n  -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\n  assume (A : set \u03b1) (hA : A \u2208 \ud835\udcab S) (B : set \u03b1) (hB : B \u2208 \ud835\udcab S),\n  -- Then $A \u2286 S$ and $B \u2286 S$, by power set definition\n  have h1 : (A \u2286 S) \u2227 (B \u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\n  -- Then $(A \u2229 B) \u2286 A$, by intersection of set is a subset\n  have h2 : (A \u2229 B) \u2286 A, from by apply set.inter_subset_left,\n  -- Then $(A \u2229 B) \u2286 S$, by subset relation is transitive \n  have h3 : (A \u2229 B) \u2286 S, from by {apply set.subset.trans h2 h1.left},\n  -- Hence $(A \u2229 B) \u2208  \ud835\udcab S$, by power set definition\n  show (A \u2229 B) \u2208  \ud835\udcab S, from by {apply set.mem_powerset h3},\nend\n\n/--`theorem`\nSquare of Sum\n :$\\forall x, y \\in \\R: \\paren {x + y}^2 = x^2 + 2 x y + y^2$\n`proof`\nFollows from the distribution of multiplication over addition:\n\n{{begin-eqn}}\n{{eqn | l = \\left({x + y}\\right)^2\n      | r = \\left({x + y}\\right) \\cdot \\left({x + y}\\right)\n}}\n{{eqn | r = x \\cdot \\left({x + y}\\right) + y \\cdot \\left({x + y}\\right)\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x \\cdot x + x \\cdot y + y \\cdot x + y \\cdot y\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x^2 + 2xy + y^2\n      | c = \n}}\n{{end-eqn}}\n{{qed}}\n-/\ntheorem square_of_sum (x y : \u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \nbegin\n  -- expand the power\n  calc (x + y)^2 = (x+y)*(x+y) : by rw sq\n  -- distributive property of multiplication over addition gives:\n  ... = x*(x+y) + y*(x+y) : by rw add_mul\n  -- applying the above property further gives:\n  ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\n  -- rearranging the terms using commutativity and adding gives:\n  ... = x^2 + 2*x*y + y^2 : by {repeat {rw \u2190 sq}, rw mul_comm y x, ring}\nend\n\n/--`theorem`\nIdentity of Group is Unique\nLet $\\struct {G, \\circ}$ be a group. Then there is a unique identity element $e \\in G$.\n`proof`\nFrom Group has Latin Square Property, there exists a unique $x \\in G$ such that:\n:$a x = b$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = b$\n\nSetting $b = a$, this becomes:\n\nThere exists a unique $x \\in G$ such that:\n:$a x = a$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = a$\n\nThese $x$ and $y$ are both $e$, by definition of identity element.\n{{qed}}\n-/\ntheorem group_identity_unique {G : Type*} [group G] : \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a :=\nbegin\n  -- Group has Latin Square Property\n  have h1 : \u2200 a b : G, \u2203! x : G, a * x = b, from by {\n    assume a b : G, use a\u207b\u00b9 * b, obviously, },\n  have h2 : \u2200 a b : G, \u2203! y : G, y * a = b, from by {\n    assume a b : G, use b * a\u207b\u00b9, obviously, }, \n\n  -- Setting $b = a$, this becomes:\n  have h3 : \u2200 a : G, \u2203! x : G, a * x = a, from \n    assume a : G, h1 a a,\n  have h4 : \u2200 a : G, \u2203! y : G, y * a = a, from\n    assume a : G, h2 a a,\n\n  -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\n  have h5 : \u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\n    exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\n    (mul_one a),\n  have h6 : \u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\n    exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \n\n  show \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a, from by {\n    use (1 : G),\n    have h7 : \u2200 e : G, (\u2200 a : G, e * a = a \u2227 a * e = a) \u2192 e = 1, from by {\n      assume (e : G) (hident : \u2200 a : G, e * a = a \u2227 a * e = a),\n      have h8 : \u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\n        exists_unique.unique (h3 a) (hident a).right\n        (classical.some_spec (exists_unique.exists (h3 a))), \n      have h9 : \u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\n        exists_unique.unique (h4 a) (hident a).left\n        (classical.some_spec (exists_unique.exists (h4 a))),\n      show e = (1 : G), from eq.trans (h9 e) (h6 _),     \n    },\n    exact \u27e8by obviously, h7\u27e9,\n  }\nend\n\n/--`theorem`\nSqueeze Theorem for Real Numbers\nLet $\\sequence {x_n}$, $\\sequence {y_n}$ and $\\sequence {z_n}$ be sequences in $\\R$.\n\nLet $\\sequence {y_n}$ and $\\sequence {z_n}$ both be convergent to the following limit:\n:$\\ds \\lim_{n \\mathop \\to \\infty} y_n = l, \\lim_{n \\mathop \\to \\infty} z_n = l$\n\nSuppose that:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\n\nThen:\n:$x_n \\to l$ as $n \\to \\infty$\nthat is:\n:$\\ds \\lim_{n \\mathop \\to \\infty} x_n = l$\n\n`proof`\nFrom Negative of Absolute Value:\n:$\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n\nLet $\\epsilon > 0$.\n\nWe need to prove that:\n:$\\exists N: \\forall n > N: \\size {x_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that:\n:$\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that:\n:$\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n\n\nLet $N = \\max \\set {N_1, N_2}$.\n\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n:$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n\nBut:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n\nand so:\n:$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n\nSo:\n:$\\forall n > N: \\size {x_n - l} < \\epsilon$\n\nHence the result.\n{{qed}}\n\n-/\ntheorem squeeze_theorem_real_numbers (x y z : \u2115 \u2192 \u211d) (l : \u211d) : \nlet seq_limit : (\u2115 \u2192 \u211d) \u2192 \u211d \u2192 Prop :=  \u03bb (u : \u2115 \u2192 \u211d) (l : \u211d), \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, |u n - l| < \u03b5 in\n seq_limit y l \u2192 seq_limit z l \u2192  (\u2200 n : \u2115, (y n) \u2264 (x n) \u2227 (x n) \u2264 (z n)) \u2192 seq_limit x l :=\nbegin\n  assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \u2200 (n : \u2115), y n \u2264 x n \u2227 x n \u2264 z n) (\u03b5), \n\n  --From Negative of Absolute Value: $\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n  have h5 : \u2200 x, |x - l| < \u03b5 \u2194 (((l - \u03b5) < x) \u2227 (x < (l + \u03b5))), \n  from by \n  {\n    intro x0,\n    have h6 : |x0 - l| < \u03b5 \u2194 ((x0 - l) < \u03b5) \u2227 ((l - x0) < \u03b5), \n    from abs_sub_lt_iff, rw h6,\n    split, \n    rintro \u27e8 S_1, S_2 \u27e9, \n    split; linarith, \n    rintro \u27e8 S_3, S_4 \u27e9, \n    split; linarith,\n    },\n  \n  --Let $\\epsilon > 0$.\n  assume (h7 : \u03b5 > 0),\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that $\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n  cases h2 \u03b5 h7 with N1 h8,\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that $\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n  cases h3 \u03b5 h7 with N2 h9,\n  \n  --Let $N = \\max \\set {N_1, N_2}$.\n  let N := max N1 N2,\n  use N,\n\n  --Then if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n  have h10 : \u2200 n > N, n > N1 \u2227 n > N2 := by {\n    assume n h,\n    split,\n    exact lt_of_le_of_lt (le_max_left N1 N2) h, \n    exact lt_of_le_of_lt (le_max_right N1 N2) h,\n  },\n  \n  --$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n  --$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n  --$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n  --So $\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n  have h11 : \u2200 n > N, (((l - \u03b5) < (y n)) \u2227 ((y n) \u2264 (x n))) \u2227 (((x n) \u2264 (z n)) \u2227 ((z n) < l+\u03b5)), \n  from by {\n    intros n h12,\n    split,\n    {\n\n      have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\n      split,\n      exact h13.left,\n      exact (h4 n).left,\n    },\n    {        \n      have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\n      split,\n      exact (h4 n).right,\n      exact h14.right,\n    },\n    \n  },\n\n  --$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n  have h15 : \u2200 n > N, ((l - \u03b5) < (x n)) \u2227 ((x n) < (l+\u03b5)), \n  from by {\n    intros n1 h16, cases (h11 n1 h16);\n    split; linarith,\n  },\n\n  --So $\\forall n > N: \\size {x_n - l} < \\epsilon$\n  --Hence the result\n  show  \u2200 (n : \u2115), n > N \u2192 |x n - l| < \u03b5, \n  from by {\n    intros n h17,\n    cases h5 (x n) with h18 h19,\n    apply h19, exact h15 n h17,\n  },\nend\n\n/--`theorem`\nDensity of irrational orbit\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\n`proof`\nLet $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n$$\ni \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n$$\nwhich yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$. Hence,\n$$\nS:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n$$\nis an infinite subset of $\\left[0,1\\right]$.\n\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\n\nTo show that $S$ is dense in $[0, 1]$, consider $y \\in[0,1]$, and $\\epsilon>0$. Then by selecting $x \\in S$ such that $\\{x\\}<\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\cdot\\{x\\} \\leq y<(N+1) \\cdot\\{x\\}$, we get: $|y-\\{N x\\}|<\\epsilon$.\n\nQED\n-/\ntheorem \nFEW SHOT PROMPTS TO CODEX(END)-/\n"}
{"text": "informal statement Show that the collection $\\{(a,b) \\mid a < b, a \\text{ and } b \\text{ rational}\\}$ is a basis that generates a topology different from the lower limit topology on $\\mathbb{R}$.formal statement theorem exercise_16_4 {X Y : Type*} [topological_space X] [topological_space Y]\n  (\u03c0\u2081 : X \u00d7 Y \u2192 X)\n  (\u03c0\u2082 : X \u00d7 Y \u2192 Y)\n  (h\u2081 : \u03c0\u2081 = prod.fst)\n  (h\u2082 : \u03c0\u2082 = prod.snd) :\n  is_open_map \u03c0\u2081 \u2227 is_open_map \u03c0\u2082 :="}
{"text": "import logic.function\nimport data.fintype\n\ndef list.chain'' {\u03b1} (R : \u03b1 \u2192 \u03b1 \u2192 Prop) : (\u03b1 \u2192 Prop) \u2192 list \u03b1 \u2192 \u03b1 \u2192 Prop\n| P [] a := P a\n| P (a::l) b := P a \u2227 list.chain'' (R a) l b\n\ndef flip_one {\u03b1} [decidable_eq \u03b1] (f : \u03b1 \u2192 bool) (i : \u03b1) : \u03b1 \u2192 bool :=\nfunction.update f i (bnot (f i))\n\ndef admissible {\u03b1} [decidable_eq \u03b1] (f g : \u03b1 \u2192 bool) : Prop :=\n\u2203 i, g = flip_one f i\n\ndef restricted_admissible {\u03b1} [decidable_eq \u03b1] (f g : \u03b1 \u2295 \u03b1 \u2192 bool) : Prop :=\n\u2203 i, g = flip_one f (sum.inl i)\n\ndef end_state {\u03b1} : \u03b1 \u2295 \u03b1 \u2192 bool\n| (sum.inl _) := tt\n| (sum.inr _) := ff\n\ndef lamp_seq {\u03b1} (R : \u2200 (f g : \u03b1 \u2295 \u03b1 \u2192 bool), Prop) (l : list (\u03b1 \u2295 \u03b1 \u2192 bool)) : Prop :=\nlist.chain'' R (\u03bb s, end_state = s) l (\u03bb _, ff)\n\nopen_locale classical\ntheorem C4 {\u03b1} [fintype \u03b1] [decidable_eq \u03b1] (k n : \u2115)\n  (h1 : 2 \u2223 k + n) (h2 : n \u2264 k) (h3 : fintype.card \u03b1 = n) :\n  fintype.card {f : vector (\u03b1 \u2295 \u03b1 \u2192 bool) k // lamp_seq admissible f.1} =\n  2 ^ (k - n) *\n  fintype.card {f : vector (\u03b1 \u2295 \u03b1 \u2192 bool) k // lamp_seq restricted_admissible f.1} :=\nsorry\n"}
{"text": "import AutograderTests.Util\n\nin_exercise\n\n  inductive Example\n    | ctor (h : False)\n\n  theorem exercise : Example :=\n    sorry\n\nin_solution\n\n  inductive Example\n    | ctor (h : True) -- clever change\n\n  theorem exercise : Example :=\n    \u27e8\u27e8\u27e9\u27e9\n"}
{"text": "import tactic\n\nlemma my_lemma: \u2200 n : \u2115, n \u2265 0 :=\n\u03bb n, nat.zero_le n\n\nlemma my_lemma2: \u2200 n : \u2115, n \u2265 0 :=\nbegin\n  intro n,\n  apply nat.zero_le,\nend\n\n#print my_lemma2\n\n-- Comentario: Al colocar el cursor sobre print se obtiene\n--    theorem my_lemma2 : \u2200 (n : \u2115), n \u2265 0 :=\n--    \u03bb (n : \u2115), n.zero_le\n\nlemma my_lemma3: \u2200 n : \u2115, n \u2265 0 :=\nbegin\n  show_term {intro n, apply nat.zero_le},\nend\n\n-- Comentario: Al colocar el cursor sobre show_term se obtiene\n--    \u03bb n, n.zero_le\n\n------------------------------------------------------------------------\n-- \u00a7 Referencia                                                       --\n------------------------------------------------------------------------\n\n-- Basado en el v\u00eddeo \"Metaprogramming in Lean tutorial: video 1\" de Rob\n-- Lewis que se encuentra en https://youtu.be/o6oUjcE6Nz4 \n\n"}
{"text": "informal statement If $f$ is a real continuous function defined on a closed set $E \\subset \\mathbb{R}$, prove that there exist continuous real functions $g$ on $\\mathbb{R}$ such that $g(x)=f(x)$ for all $x \\in E$.formal statement theorem exercise_4_6\n  (f : \u211d \u2192 \u211d)\n  (E : set \u211d)\n  (G : set (\u211d \u00d7 \u211d))\n  (h\u2081 : is_compact E)\n  (h\u2082 : G = {(x, f x) | x \u2208 E})\n  : continuous_on f E \u2194 is_compact G :="}
{"text": "/-\nCopyright (c) 2021 Yourong Zang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yourong Zang\n\n! This file was ported from Lean 3 source module analysis.inner_product_space.conformal_linear_map\n! leanprover-community/mathlib commit 46b633fd842bef9469441c0209906f6dddd2b4f5\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Analysis.NormedSpace.ConformalLinearMap\nimport Mathbin.Analysis.InnerProductSpace.Basic\n\n/-!\n# Conformal maps between inner product spaces\n\nIn an inner product space, a map is conformal iff it preserves inner products up to a scalar factor.\n-/\n\n\nvariable {E F : Type _}\n\nvariable [NormedAddCommGroup E] [NormedAddCommGroup F]\n\nvariable [InnerProductSpace \u211d E] [InnerProductSpace \u211d F]\n\nopen LinearIsometry ContinuousLinearMap\n\nopen RealInnerProductSpace\n\n/-- A map between two inner product spaces is a conformal map if and only if it preserves inner\nproducts up to a scalar factor, i.e., there exists a positive `c : \u211d` such that `\u27eaf u, f v\u27eb = c *\n\u27eau, v\u27eb` for all `u`, `v`. -/\ntheorem isConformalMap_iff (f : E \u2192L[\u211d] F) :\n    IsConformalMap f \u2194 \u2203 c : \u211d, 0 < c \u2227 \u2200 u v : E, \u27eaf u, f v\u27eb = c * \u27eau, v\u27eb :=\n  by\n  constructor\n  \u00b7 rintro \u27e8c\u2081, hc\u2081, li, rfl\u27e9\n    refine' \u27e8c\u2081 * c\u2081, mul_self_pos.2 hc\u2081, fun u v => _\u27e9\n    simp only [real_inner_smul_left, real_inner_smul_right, mul_assoc, coe_smul',\n      coe_to_continuous_linear_map, Pi.smul_apply, inner_map_map]\n  \u00b7 rintro \u27e8c\u2081, hc\u2081, huv\u27e9\n    obtain \u27e8c, hc, rfl\u27e9 : \u2203 c : \u211d, 0 < c \u2227 c\u2081 = c * c\n    exact \u27e8Real.sqrt c\u2081, Real.sqrt_pos.2 hc\u2081, (Real.mul_self_sqrt hc\u2081.le).symm\u27e9\n    refine' \u27e8c, hc.ne', (c\u207b\u00b9 \u2022 f : E \u2192\u2097[\u211d] F).isometryOfInner fun u v => _, _\u27e9\n    \u00b7\n      simp only [real_inner_smul_left, real_inner_smul_right, huv, mul_assoc, coe_smul,\n        inv_mul_cancel_left\u2080 hc.ne', LinearMap.smul_apply, ContinuousLinearMap.coe_coe]\n    \u00b7 ext1 x\n      exact (smul_inv_smul\u2080 hc.ne' (f x)).symm\n#align is_conformal_map_iff isConformalMap_iff\n\n"}
{"text": "informal statement Prove that if $f(x)$ and $g(x)$ are polynomials with rational coefficients whose product $f(x) g(x)$ has integer coefficients, then the product of any coefficient of $g(x)$ with any coefficient of $f(x)$ is an integer.formal statement theorem exercise_9_4_2b : irreducible \n  (X^6 + 30*X^5 - 15*X^3 + 6*X - 120 : polynomial \u2124) :="}
{"text": "variable {\u03b1 : Type*}\n\ndef is_prefix (l\u2081 : list \u03b1) (l\u2082 : list \u03b1) : Prop :=\n  \u2203 t, l\u2081 ++ t = l\u2082\n\ndef list_has_le : has_le (list \u03b1) := \u27e8is_prefix\u27e9\n\nsection\n  local attribute [instance] list_has_le\n\n  theorem list.is_prefix_refl (l : list \u03b1) : l \u2264 l :=\n    \u27e8[], by simp\u27e9\nend\n\n-- error:\n-- theorem bar (l : list \u03b1) : l \u2264 l :=\n--   \u27e8[], by simp\u27e9\n"}
{"text": "namespace Hidden\n\nopen Nat\n\ntheorem zero_add (n : Nat) : 0 + n = n :=\n  Nat.recOn (motive := fun x => 0 + x = x)\n   n\n   (show 0 + 0 = 0 from rfl)\n   (fun (n : Nat) (ih : 0 + n = n) =>\n    show 0 + succ n = succ n from\n    calc\n       0 + succ n = succ (0 + n) := rfl\n                _ = succ n       := by rw [ih])\n\nend Hidden\n"}
{"text": "import Smt\n\ntheorem triv (p : Bool) : p \u2192 p := by\n  smt\n  simp_all\n"}
{"text": "lemma maze (P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\nbegin\napply l,\napply j,\napply h,\nexact p,\nend\n"}
{"text": "informal statement Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected.formal statement theorem exercise_26_11\n  {X : Type*} [topological_space X] [compact_space X] [t2_space X]\n  (A : set (set X)) (hA : \u2200 (a b : set X), a \u2208 A \u2192 b \u2208 A \u2192 a \u2286 b \u2228 b \u2286 a)\n  (hA' : \u2200 a \u2208 A, is_closed a) (hA'' : \u2200 a \u2208 A, is_connected a) :\n  is_connected (\u22c2\u2080 A) :="}
{"text": "(*\n * Copyright 2020, Data61, CSIRO (ABN 41 687 119 230)\n *\n * SPDX-License-Identifier: BSD-2-Clause\n *)\n\ntheory ptr_modifies\nimports \"Word_Lib.WordSetup\" \"CParser.CTranslation\"\nbegin\n\nexternal_file \"ptr_modifies.c\"\ninstall_C_file \"ptr_modifies.c\"\n\ncontext ptr_modifies\nbegin\n  thm foo_ptr_new_modifies\n  thm f_modifies\n  thm f_body_def\n  thm g_modifies\n  thm h_modifies\nend\n\nlemma (in f_spec) g_spec:\n  \"\\<forall> i. \\<Gamma> \\<turnstile> \\<lbrace> \\<acute>i = i \\<rbrace> \\<acute>ret__unsigned :== CALL g(\\<acute>i) \\<lbrace> \\<acute>ret__unsigned = i + 4 \\<rbrace>\"\napply vcg\napply simp\ndone\n\nend\n"}
{"text": "/-\nCopyright (c) 2017 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura\n-/\nprelude\nimport Init.Data.Option.Basic\n\nuniverse u v\n\ntheorem Option.eq_of_eq_some {\u03b1 : Type u} : \u2200 {x y : Option \u03b1}, (\u2200z, x = some z \u2194 y = some z) \u2192 x = y\n  | none,   none,   _ => rfl\n  | none,   some z, h => Option.noConfusion ((h z).2 rfl)\n  | some z, none,   h => Option.noConfusion ((h z).1 rfl)\n  | some _, some w, h => Option.noConfusion ((h w).2 rfl) (congrArg some)\n\ntheorem Option.eq_none_of_isNone {\u03b1 : Type u} : \u2200 {o : Option \u03b1}, o.isNone \u2192 o = none\n  | none, _ => rfl\n"}
{"text": "open import Relation.Binary.Core\n\nmodule Heapsort.Impl1.Correctness.Order {A : Set}\n                  (_\u2264_ : A \u2192 A \u2192 Set) \n                  (tot\u2264 : Total _\u2264_) \n                  (trans\u2264 : Transitive _\u2264_) where\n\nopen import Data.List\nopen import Function using (_\u2218_)\nopen import Heapsort.Impl1 _\u2264_ tot\u2264 trans\u2264\nopen import List.Sorted _\u2264_\nopen import OList _\u2264_\nopen import OList.Properties _\u2264_\n\ntheorem-heapsort-sorted : (xs : List A) \u2192 Sorted (forget (heapsort xs))\ntheorem-heapsort-sorted = lemma-olist-sorted \u2218 heapsort\n"}
{"text": "informal statement Suppose $a, b \\in R^k$. Find $c \\in R^k$ and $r > 0$ such that $|x-a|=2|x-b|$ if and only if $| x - c | = r$. Prove that $3c = 4b - a$ and $3r = 2 |b - a|$.formal statement theorem exercise_2_24 {X : Type*} [metric_space X]\n  (hX : \u2200 (A : set X), infinite A \u2192 \u2203 (x : X), x \u2208 closure A) :\n  separable_space X :="}
{"text": "informal statement Prove that a group of order 312 has a normal Sylow $p$-subgroup for some prime $p$ dividing its order.formal statement theorem exercise_4_5_16 {p q r : \u2115} {G : Type*} [group G] \n  [fintype G]  (hpqr : p < q \u2227 q < r) \n  (hpqr1 : p.prime \u2227 q.prime \u2227 r.prime)(hG : card G = p*q*r) : \n  nonempty (sylow p G) \u2228 nonempty(sylow q G) \u2228 nonempty(sylow r G) :="}
{"text": "import linear_algebra.finite_dimensional\n\nlemma set.eq_empty_or_eq_insert {x : Type*} (s : set x) : s = \u2205 \u2228 \u2203 t (x \u2209 t), s = insert x t :=\nbegin\n  rcases s.eq_empty_or_nonempty with (rfl|\u27e8x, hx\u27e9),\n  { exact or.inl rfl },\n  { refine or.inr \u27e8s \\ {x}, x, _, _\u27e9; simp [set.insert_eq_of_mem hx] }\nend\n\nlemma csupr_subtype {\u03b1 : Type*} [conditionally_complete_linear_order_bot \u03b1]\n  {\u03b9 : Sort*} {P : \u03b9 \u2192 Sort*} (f : \u03a0 i, P i \u2192 \u03b1) (hf : \u2203 X, \u2200 i h, f i h \u2264 X) :\n    (\u2a06 i h, f i h) = \u2a06 i : {x // P x}, f i i.prop :=\nbegin\n  obtain \u27e8X, hf\u27e9 := hf,\n  apply le_antisymm,\n  { have : bdd_above (set.range (\u03bb (i : {x // P x}), f _ i.prop)),\n    { use X, rintro _ \u27e8x, rfl\u27e9, exact hf _ _ },\n    exact csupr_le' (\u03bb i, csupr_le' $ \u03bb h, le_csupr this \u27e8i, h\u27e9) },\n  { refine csupr_le' (\u03bb i, le_trans _ (le_csupr _ i)),\n    refine le_trans _ (le_csupr _ i.prop),\n    { exact rfl.le },\n    { use X, rintro _ \u27e8x, rfl\u27e9, exact hf _ _ },\n    { use X, rintro _ \u27e8x, rfl\u27e9, exact csupr_le' (hf x) } }\nend\n\n\nlemma cardinal.le_of_add_one_le_add_one {\u03b1 \u03b2 : cardinal} (h : \u03b1 + 1 \u2264 \u03b2 + 1) : \u03b1 \u2264 \u03b2 :=\nbegin\n  rw [\u2190 \u03b1.mk_out, \u2190 \u03b2.mk_out] at h \u22a2,\n  rw [\u2190 cardinal.mk_option, \u2190 cardinal.mk_option] at h,\n  rw [cardinal.le_def] at h \u22a2,\n  obtain \u27e8f\u27e9 := h,\n  cases e : f none,\n  { have : \u2200 x : \u03b1.out, \u2203 y : \u03b2.out, f x = y,\n    { intro x, apply option.ne_none_iff_exists'.mp, intro e', apply option.some_ne_none x,\n      apply f.injective, rw [e, \u2190 e'], refl },\n    choose y hy,\n    refine \u27e8\u27e8y, \u03bb a b h, option.some_injective _ (f.injective _)\u27e9\u27e9,\n    rw [\u2190 option.coe_def, hy, hy, h] },\n  { refine \u27e8\u27e8\u03bb a, (f a).elim val id, \u03bb a b (h : (f a).elim val id = (f b).elim val id), _\u27e9\u27e9,\n    apply option.some_injective, apply f.injective,\n    show f a = f b,\n    cases ha : f a with a'; cases hb : f b with b',\n    { refl },\n    all_goals { rw [ha, hb] at h, dsimp at h, subst h },\n    { cases f.injective (hb.trans e.symm) },\n    { cases f.injective (ha.trans e.symm) } },\nend\n\nlemma cardinal.add_one_injective {\u03b1 \u03b2 : cardinal} (h : \u03b1 + 1 = \u03b2 + 1) : \u03b1 = \u03b2 :=\ncardinal.eq_of_add_eq_add_right h cardinal.one_lt_aleph_0\n\nlemma cardinal.exists_add_one_eq_iff {\u03b1 : cardinal} :\n  (\u2203 \u03b2, \u03b2 + 1 = \u03b1) \u2194 \u03b1 \u2260 0 :=\nbegin\n  split,\n  { rintros \u27e8\u03b2, rfl\u27e9 e, exact not_le_of_lt cardinal.zero_lt_one (le_add_self.trans_eq e) },\n  { intro e,\n    cases le_or_gt cardinal.aleph_0 \u03b1,\n    { exact \u27e8\u03b1, cardinal.add_one_eq h\u27e9 },\n    { refine \u27e8(\u03b1.to_nat - 1 : _), (_ : \u2191(\u03b1.to_nat - 1 + 1) = \u03b1)\u27e9,\n      rw [\u2190 bot_eq_zero, \u2190 bot_lt_iff_ne_bot, bot_eq_zero,\n        \u2190 cardinal.to_nat_lt_iff_lt_of_lt_aleph_0 _ h, cardinal.zero_to_nat, zero_lt_iff,\n        \u2190 nat.one_le_iff_ne_zero] at e,\n      rwa [tsub_add_cancel_of_le, cardinal.cast_to_nat_of_lt_aleph_0 h],\n      exact e.trans h } }\nend\n\nlemma add_one_le_dim_iff_exists_submodule_rank_eq {R : Type*} {M : Type*} [field R]\n  [add_comm_group M] [module R M] {c : cardinal} :\n  c + 1 \u2264 module.rank R M \u2194 \u2203 p : submodule R M, p \u2260 \u22a4 \u2227 module.rank R p = c :=\nbegin\n  rw le_dim_iff_exists_linear_independent,\n  split,\n  { rintros \u27e8s, e, h\u27e9,\n    obtain \u27e8x, hx\u27e9 := cardinal.mk_ne_zero_iff.mp (show cardinal.mk s \u2260 0, by simp [e]),\n    use submodule.span R (s \\ {x}),\n    split,\n    { intro e,\n      apply h.not_mem_span_image\n        (set.not_mem_compl_iff.mpr (set.mem_singleton (\u27e8x, hx\u27e9 : s))),\n      simp [set.compl_eq_univ_diff, set.image_diff subtype.coe_injective, e] },\n    { have : x \u2209 s \\ {x} := \u03bb e, e.2 rfl,\n      apply cardinal.add_one_injective,\n      rw [dim_span_set (h.mono (s.diff_subset {x})), \u2190 e, \u2190 cardinal.mk_insert this,\n        set.insert_diff_singleton, set.insert_eq_of_mem hx] } },\n  { rintros \u27e8p, hp, rfl\u27e9,\n    obtain \u27e8x, hx\u27e9 : \u2203 x, x \u2209 p := by { revert hp, contrapose!, rw eq_top_iff, exact \u03bb H x _, H x },\n    obtain \u27e8b, hb, e, h\u27e9 := exists_linear_independent R (p : set M),\n    refine \u27e8insert x b, _, h.insert ((e.trans p.span_eq).symm \u25b8 hx)\u27e9,\n    rw [cardinal.mk_insert (\u03bb e, hx (hb e)), \u2190 e.trans p.span_eq, dim_span_set h] },\nend\n\nlemma rank_supr_ne_top_add_one {R : Type*} {M : Type*} [field R] [add_comm_group M] [module R M] :\n  (\u2a06 (p : submodule R M) (h : p \u2260 \u22a4), module.rank R p + 1) = module.rank R M :=\nbegin\n  rw csupr_subtype,\n  swap, { exact \u27e8module.rank R M + 1, \u03bb _ _, add_le_add (dim_submodule_le _) rfl.le\u27e9 },\n  apply le_antisymm,\n  { exact csupr_le' (\u03bb p, add_one_le_dim_iff_exists_submodule_rank_eq.mpr \u27e8p.1, p.2, rfl\u27e9) },\n  { by_cases module.rank R M = 0, { rw h, exact zero_le _ },\n    obtain \u27e8\u03b1, h\u03b1\u27e9 := cardinal.exists_add_one_eq_iff.mpr h,\n    obtain \u27e8p, hp, rfl\u27e9 := add_one_le_dim_iff_exists_submodule_rank_eq.mp h\u03b1.le,\n    have : bdd_above (set.range (\u03bb p : {x : submodule R M // x \u2260 \u22a4}, module.rank R p + 1)),\n    { refine \u27e8module.rank R M + 1, _\u27e9, rintros _ \u27e8a, rfl\u27e9,\n      exact add_le_add (dim_submodule_le _) rfl.le },\n    exact h\u03b1.symm.le.trans (le_csupr this \u27e8p, hp\u27e9) }\nend\n\nlemma rank_supr_lt_add_one {R : Type*} {M : Type*} [field R] [add_comm_group M] [module R M]\n  (q : submodule R M) :\n  (\u2a06 p < q, module.rank R p + 1) = module.rank R q :=\nbegin\n  rw [\u2190 rank_supr_ne_top_add_one, csupr_subtype, csupr_subtype],\n  have : \u2200 p : { p : submodule R q // p \u2260 \u22a4 }, p.1.map q.subtype < q,\n  { rintros \u27e8p, hp\u27e9, convert q^.map_subtype.order_embedding^.strict_mono (lt_top_iff_ne_top.mpr hp),\n    exact q.map_subtype_top.symm },\n  let : {x // x < q} \u2243 {x : submodule R q // x \u2260 \u22a4} :=\n  { to_fun := \u03bb p, \u27e8_, submodule.comap_subtype_eq_top.not.mpr $ not_le_of_lt p.2\u27e9,\n    inv_fun := \u03bb p, \u27e8p.1.map q.subtype, this p\u27e9,\n    left_inv := \u03bb p, subtype.ext ((submodule.map_comap_eq _ _).trans $ by simpa using p.2.le),\n    right_inv := \u03bb p, by { ext, simp } },\n  apply equiv.supr_congr this,\n  { rintros \u27e8p, hp\u27e9, congr' 1,\n    exact linear_equiv.dim_eq (submodule.comap_subtype_equiv_of_le hp.le) },\n  { exact \u27e8module.rank R q + 1, \u03bb _ _, add_le_add (dim_submodule_le _) rfl.le\u27e9 },\n  { exact \u27e8module.rank R M + 1, \u03bb _ _, add_le_add (dim_submodule_le _) rfl.le\u27e9 },\nend\n"}
{"text": "informal statement Let $x$ be an element of $G$. Prove that $x^2=1$ if and only if $|x|$ is either $1$ or $2$.formal statement theorem exercise_1_1_18 {G : Type*} [group G]\n  (x y : G) : x * y = y * x \u2194 y\u207b\u00b9 * x * y = x \u2194 x\u207b\u00b9 * y\u207b\u00b9 * x * y = 1 :="}
{"text": "lemma interior_empty [simp]: \"interior {} = {}\""}
{"text": "informal statement Prove that two elements $a, b$ of a group generate the same subgroup as $b a b^2, b a b^3$.formal statement theorem exercise_6_8_1 {G : Type*} [group G]\n  (a b : G) : closure ({a, b} : set G) = closure {b*a*b^2, b*a*b^3} :="}
{"text": "/-\nPractice with predicate logic in Lean \n-/\n\nvariable {\u03b1 : Type} (P Q : \u03b1 \u2192 Prop) \n\ntheorem prob01 (a\u2080 : \u03b1) (h : \u2200 a, P a) : \u2203 a, P a := sorry \n\ntheorem prob02 (h : \u2203 a, P a \u2227 \u00ac Q a) (h : \u2200 a, P a \u2192 Q a) : False := sorry \n\ntheorem prob03 (a a' : \u03b1) (h : a = a') (h' : P a) : P a' := sorry \n\n"}
{"text": "[GOAL]\n\u22a2 1 = 1\n[PROOFSTEP]\nsleep_heartbeats 1000\n[GOAL]\n\u22a2 1 = 1\n[PROOFSTEP]\nrfl\n"}
{"text": "open tactic\n\nlemma ex1 (a b c : nat) : a + 0 = 0 + a \u2227 0 + b = b \u2227 c + b = b + c :=\nbegin\n  repeat {any_goals {constructor}},\n  show c + b = b + c, { apply add_comm }, -- third goal of three\n  show a + 0 = 0 + a, { simp }, -- first of two\n  show 0 + b = b,     { rw [zero_add] }\nend\n\n/- Same example, but the local context of each goal is different -/\nlemma ex3 : (\u2200 a : nat, a + 0 = 0 + a) \u2227 (\u2200 b : nat, 0 + b = b) \u2227 (\u2200 b c : nat, c + b = b + c) :=\nbegin\n  repeat {any_goals {constructor}}, all_goals {intros},\n  show c + b = b + c, { apply add_comm },\n  show a + 0 = 0 + a, { simp },\n  show 0 + b = b,     { rw [zero_add] }\nend\n\n/- Same example, but the local context of each goal is different -/\nlemma ex4 : (\u2200 a : nat, a + 0 = 0 + a) \u2227 (\u2200 b : nat, 0 + b = b) \u2227 (\u2200 b c : nat, c + b = b + c) :=\nbegin\n  repeat {any_goals {constructor}}, all_goals {intros},\n  show c + b = _,     { apply add_comm },\n  show a + _ = 0 + a, { simp },\n  show _ = b,         { rw [zero_add] }\nend\n"}
{"text": "/-\nCopyright (c) 2021 Scott Morrison. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Scott Morrison\n-/\nimport algebra.algebra.subalgebra\nimport topology.algebra.polynomial\nimport topology.continuous_function.bounded\nimport analysis.special_functions.bernstein\n\n/-!\n# The Weierstrass approximation theorem for continuous functions on `[a,b]`\n\nWe've already proved the Weierstrass approximation theorem\nin the sense that we've shown that the Bernstein approximations\nto a continuous function on `[0,1]` converge uniformly.\n\nHere we rephrase this more abstractly as\n`polynomial_functions_closure_eq_top' : (polynomial_functions I).topological_closure = \u22a4`\nand then, by precomposing with suitable affine functions,\n`polynomial_functions_closure_eq_top : (polynomial_functions (set.Icc a b)).topological_closure = \u22a4`\n-/\n\nopen continuous_map filter\nopen_locale unit_interval\n\n/--\nThe special case of the Weierstrass approximation theorem for the interval `[0,1]`.\nThis is just a matter of unravelling definitions and using the Bernstein approximations.\n-/\ntheorem polynomial_functions_closure_eq_top' :\n  (polynomial_functions I).topological_closure = \u22a4 :=\nbegin\n  apply eq_top_iff.mpr,\n  rintros f -,\n  refine filter.frequently.mem_closure _,\n  refine filter.tendsto.frequently (bernstein_approximation_uniform f) _,\n  apply frequently_of_forall,\n  intro n,\n  simp only [set_like.mem_coe],\n  apply subalgebra.sum_mem,\n  rintro n -,\n  apply subalgebra.smul_mem,\n  dsimp [bernstein, polynomial_functions],\n  simp,\nend\n\n/--\nThe Weierstrass approximation theorem:\npolynomials functions on `[a, b] \u2286 \u211d` are dense in `C([a,b],\u211d)`\n\n(While we could deduce this as an application of the Stone-Weierstrass theorem,\nour proof of that relies on the fact that `abs` is in the closure of polynomials on `[-M, M]`,\nso we may as well get this done first.)\n-/\ntheorem polynomial_functions_closure_eq_top (a b : \u211d) :\n  (polynomial_functions (set.Icc a b)).topological_closure = \u22a4 :=\nbegin\n  by_cases h : a < b, -- (Otherwise it's easy; we'll deal with that later.)\n  { -- We can pullback continuous functions on `[a,b]` to continuous functions on `[0,1]`,\n    -- by precomposing with an affine map.\n    let W : C(set.Icc a b, \u211d) \u2192\u2090[\u211d] C(I, \u211d) :=\n      comp_right_alg_hom \u211d (Icc_homeo_I a b h).symm.to_continuous_map,\n    -- This operation is itself a homeomorphism\n    -- (with respect to the norm topologies on continuous functions).\n    let W' : C(set.Icc a b, \u211d) \u2243\u209c C(I, \u211d) := comp_right_homeomorph \u211d (Icc_homeo_I a b h).symm,\n    have w : (W : C(set.Icc a b, \u211d) \u2192 C(I, \u211d)) = W' := rfl,\n    -- Thus we take the statement of the Weierstrass approximation theorem for `[0,1]`,\n    have p := polynomial_functions_closure_eq_top',\n    -- and pullback both sides, obtaining an equation between subalgebras of `C([a,b], \u211d)`.\n    apply_fun (\u03bb s, s.comap' W) at p,\n    simp only [algebra.comap_top] at p,\n    -- Since the pullback operation is continuous, it commutes with taking `topological_closure`,\n    rw subalgebra.topological_closure_comap'_homeomorph _ W W' w at p,\n    -- and precomposing with an affine map takes polynomial functions to polynomial functions.\n    rw polynomial_functions.comap'_comp_right_alg_hom_Icc_homeo_I at p,\n    -- \ud83c\udf89\n    exact p },\n  { -- Otherwise, `b \u2264 a`, and the interval is a subsingleton,\n    -- so all subalgebras are the same anyway.\n    haveI : subsingleton (set.Icc a b) := \u27e8\u03bb x y, le_antisymm\n      ((x.2.2.trans (not_lt.mp h)).trans y.2.1) ((y.2.2.trans (not_lt.mp h)).trans x.2.1)\u27e9,\n    haveI := (continuous_map.subsingleton_subalgebra (set.Icc a b) \u211d),\n    apply subsingleton.elim, }\nend\n\n/--\nAn alternative statement of Weierstrass' theorem.\n\nEvery real-valued continuous function on `[a,b]` is a uniform limit of polynomials.\n-/\ntheorem continuous_map_mem_polynomial_functions_closure (a b : \u211d) (f : C(set.Icc a b, \u211d)) :\n  f \u2208 (polynomial_functions (set.Icc a b)).topological_closure :=\nbegin\n  rw polynomial_functions_closure_eq_top _ _,\n  simp,\nend\n\n/--\nAn alternative statement of Weierstrass' theorem,\nfor those who like their epsilons.\n\nEvery real-valued continuous function on `[a,b]` is within any `\u03b5 > 0` of some polynomial.\n-/\ntheorem exists_polynomial_near_continuous_map (a b : \u211d) (f : C(set.Icc a b, \u211d))\n  (\u03b5 : \u211d) (pos : 0 < \u03b5) :\n  \u2203 (p : polynomial \u211d), \u2225p.to_continuous_map_on _ - f\u2225 < \u03b5 :=\nbegin\n  have w := mem_closure_iff_frequently.mp (continuous_map_mem_polynomial_functions_closure _ _ f),\n  rw metric.nhds_basis_ball.frequently_iff at w,\n  obtain \u27e8-, H, \u27e8m, \u27e8-, rfl\u27e9\u27e9\u27e9 := w \u03b5 pos,\n  rw [metric.mem_ball, dist_eq_norm] at H,\n  exact \u27e8m, H\u27e9,\nend\n\n/--\nAnother alternative statement of Weierstrass's theorem,\nfor those who like epsilons, but not bundled continuous functions.\n\nEvery real-valued function `\u211d \u2192 \u211d` which is continuous on `[a,b]`\ncan be approximated to within any `\u03b5 > 0` on `[a,b]` by some polynomial.\n-/\ntheorem exists_polynomial_near_of_continuous_on\n  (a b : \u211d) (f : \u211d \u2192 \u211d) (c : continuous_on f (set.Icc a b)) (\u03b5 : \u211d) (pos : 0 < \u03b5) :\n  \u2203 (p : polynomial \u211d), \u2200 x \u2208 set.Icc a b, abs (p.eval x - f x) < \u03b5 :=\nbegin\n  let f' : C(set.Icc a b, \u211d) := \u27e8\u03bb x, f x, continuous_on_iff_continuous_restrict.mp c\u27e9,\n  obtain \u27e8p, b\u27e9 := exists_polynomial_near_continuous_map a b f' \u03b5 pos,\n  use p,\n  rw norm_lt_iff _ pos at b,\n  intros x m,\n  exact b \u27e8x, m\u27e9,\nend\n"}
{"text": "import data.real.basic\nopen classical\nattribute [instance] prop_decidable\n\n/-\n  Rigorous definition of a limit\n  For a sequence x_n, we say that \\lim_{n \\to \\infty} x_n = l if\n    \u2200 \u03b5 > 0, \u2203 N, n \u2265 N \u2192 |x_n - l| < \u03b5\n-/\n\ndef lim_to_inf (x : \u2115 \u2192 \u211d) (l : \u211d) :=\n  \u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, abs (x n - l) < \u03b5\n\n/-\n  Bounded sequences\n  A sequence is bounded if |x_n| \\leq B for some constant B\n  and all n\n-/\n\n-- Lean's mathlib already defines bounded so we rename our\n-- predicate as bounded' to avoid name clashes\ndef bounded' (x : \u2115 \u2192 \u211d) :=\n  \u2203 B, \u2200 n, abs (x n) \u2264 B\n\ntheorem exercise_1p13 (x y : \u2115 \u2192 \u211d) (h\u2081 : lim_to_inf x 0)\n  (h\u2082 : bounded' y) : lim_to_inf (\u03bb n, x n * y n) 0 := \nbegin\n    intros \u03b5 \u03b5_pos,\n    rcases h\u2082 with \u27e8B, hB\u27e9,\n    let \u03b5' := \u03b5 / ((abs B) + 1),\n    have key : 0 < (abs B) + 1,\n        exact add_pos_of_nonneg_of_pos (abs_nonneg B) zero_lt_one,\n    have \u03b5'_pos : \u03b5' > 0,\n        exact div_pos \u03b5_pos key,\n    rcases h\u2081 \u03b5' \u03b5'_pos with \u27e8N, hN\u27e9,\n    use N,\n    intros n hn,\nend"}
{"text": "informal statement Show that there are infinitely many primes congruent to $-1$ modulo 6 .formal statement theorem exercise_3_5 : \u00ac \u2203 x y : \u2124, 7*x^3 + 2 = y^3 :="}
{"text": "/-\nCopyright (c) 2022 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller\n\n! This file was ported from Lean 3 source module data.finite.set\n! leanprover-community/mathlib commit 509de852e1de55e1efa8eacfa11df0823f26f226\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathlib.Data.Fintype.Card\n\n/-!\n# Lemmas about `Finite` and `Set`s\n\nIn this file we prove two lemmas about `Finite` and `Set`s.\n\n## Tags\n\nfiniteness, finite sets\n-/\n\n\nopen Set\n\nuniverse u v w\n\nvariable {\u03b1 : Type u} {\u03b2 : Type v} {\u03b9 : Sort w}\n\ntheorem Finite.Set.finite_of_finite_image (s : Set \u03b1) {f : \u03b1 \u2192 \u03b2} (h : s.InjOn f)\n    [Finite (f '' s)] : Finite s :=\n  Finite.of_equiv _ (Equiv.ofBijective _ h.bijOn_image.bijective).symm\n#align finite.set.finite_of_finite_image Finite.Set.finite_of_finite_image\n\ntheorem Finite.of_injective_finite_range {f : \u03b9 \u2192 \u03b1} (hf : Function.Injective f)\n    [Finite (range f)] : Finite \u03b9 :=\n  Finite.of_injective (Set.rangeFactorization f) (hf.codRestrict _)\n#align finite.of_injective_finite_range Finite.of_injective_finite_range\n"}
{"text": "import data.real.basic\n\ntheorem challenge3 :\n(2 : \u211d) + 2 \u2260 5 :=\nbegin\n  sorry\nend\n"}
{"text": "informal statement Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$.formal statement theorem exercise_2_21 {l : \u2115 \u2192 \u211d} \n  (hl : \u2200 p n : \u2115, p.prime \u2192 l (p^n) = log p )\n  (hl1 : \u2200 m : \u2115, \u00ac is_prime_pow m \u2192 l m = 0) :\n  l = \u03bb n, \u2211 d : divisors n, moebius (n/d) * log d  :="}
{"text": "informal statement Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$.formal statement theorem exercise_2_21 {l : \u2115 \u2192 \u211d} \n  (hl : \u2200 p n : \u2115, p.prime \u2192 l (p^n) = log p )\n  (hl1 : \u2200 m : \u2115, \u00ac is_prime_pow m \u2192 l m = 0) :\n  l = \u03bb n, \u2211 d : divisors n, moebius (n/d) * log d  :="}
{"text": "informal statement For all odd $n$ show that $8 \\mid n^{2}-1$.formal statement theorem exercise_1_31  : (\u27e81, 1\u27e9 : gaussian_int) ^ 2 \u2223 2 :="}
{"text": "import data.list.basic\nopen list\nuniverse u\nvariables {\u03b1 : Type} (x y z : \u03b1) (xs ys zs : list \u03b1)\n\ndef mk_symm (xs : list \u03b1) := xs ++ reverse xs\n\nattribute [simp]\ntheorem reverse_mk_symm (xs : list \u03b1) :\n  reverse (mk_symm xs) = mk_symm xs :=\n  by simp [mk_symm]\n\nexample (xs ys : list \u2115) :\n  reverse (xs ++ mk_symm ys) = mk_symm ys ++ reverse xs :=\n  by simp\n\nexample (xs ys : list \u2115) (p : list \u2115 \u2192 Prop) (h : p (reverse (xs ++ (mk_symm ys)))) :\n  p (mk_symm ys ++ reverse xs) :=\n  by simp at h; assumption\n"}
{"text": "import Meta.Boolean\nimport Meta.Resolution\n\ntheorem mpCvc5 (P Q : Prop) : \u00ac (P \u2192 (P \u2192 Q) \u2192 Q) \u2192 False :=\n  \u03bb lean_a0 =>\n    have lean_s0     := notImplies2 lean_a0\n    have lean_s1     := notImplies1 lean_s0\n    have lean_s2     := impliesElim lean_s1\n    have lean_s4     := notImplies1 lean_a0\n    have lean_s6     := by R1 lean_s4, lean_s2, P\n    have lean_s9     := notImplies2 lean_s0\n    contradiction lean_s6 lean_s9\n\ntheorem mp : \u2200 (P Q : Prop), P \u2192 (P \u2192 Q) \u2192 Q := \u03bb P Q => doubleNeg (mpCvc5 P Q)\n"}
{"text": "example (x y : \u2115) (h : x = y) : y = x :=\nbegin\n  revert x y,\n  intros,\n  symmetry,\n  assumption\nend\n"}
{"text": "informal statement Define $f_{n}:[0,1] \\rightarrow \\mathbb{R}$ by the equation $f_{n}(x)=x^{n}$. Show that the sequence $\\left(f_{n}(x)\\right)$ converges for each $x \\in[0,1]$.formal statement theorem exercise_21_8\n  {X : Type*} [topological_space X] {Y : Type*} [metric_space Y]\n  {f : \u2115 \u2192 X \u2192 Y} {x : \u2115 \u2192 X}\n  (hf : \u2200 n, continuous (f n))\n  (x\u2080 : X)\n  (hx : tendsto x at_top (\ud835\udcdd x\u2080))\n  (f\u2080 : X \u2192 Y)\n  (hh : tendsto_uniformly f f\u2080 at_top) :\n  tendsto (\u03bb n, f n (x n)) at_top (\ud835\udcdd (f\u2080 x\u2080)) :="}
{"text": "lemma example2 (x y : mynat) (h : y = x + 7) : 2 * y = 2 * (x + 7) :=\nbegin\nrw \u2190 h,\nrefl,\nend"}
{"text": "[GOAL]\n\u22a2 DecidableRel fun x x_1 => x < x_1\n[PROOFSTEP]\nsimp only [LT']\n[GOAL]\n\u22a2 DecidableRel fun s\u2081 s\u2082 => ltb (iter s\u2081) (iter s\u2082) = true\n[PROOFSTEP]\ninfer_instance\n  -- short-circuit type class inference\n[GOAL]\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c } { s := { data := c :: cs\u2082 }, i := i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 } { s := { data := cs\u2082 }, i := i\u2082 }\n[PROOFSTEP]\napply\n  ltb.inductionOn \u27e8\u27e8cs\u2081\u27e9, i\u2081\u27e9 \u27e8\u27e8cs\u2082\u27e9, i\u2082\u27e9 (motive := fun \u27e8\u27e8cs\u2081\u27e9, i\u2081\u27e9 \u27e8\u27e8cs\u2082\u27e9, i\u2082\u27e9 \u21a6\n    ltb \u27e8\u27e8c :: cs\u2081\u27e9, i\u2081 + c\u27e9 \u27e8\u27e8c :: cs\u2082\u27e9, i\u2082 + c\u27e9 = ltb \u27e8\u27e8cs\u2081\u27e9, i\u2081\u27e9 \u27e8\u27e8cs\u2082\u27e9, i\u2082\u27e9)\n[GOAL]\ncase ind\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    Iterator.hasNext { s := s\u2082, i := i\u2082 } = true \u2192\n      Iterator.hasNext { s := s\u2081, i := i\u2081 } = true \u2192\n        get s\u2081 i\u2081 = get s\u2082 i\u2082 \u2192\n          (match Iterator.next { s := s\u2081, i := i\u2081 } with\n            | { s := { data := cs\u2081 }, i := i\u2081 } =>\n              match Iterator.next { s := s\u2082, i := i\u2082 } with\n              | { s := { data := cs\u2082 }, i := i\u2082 } =>\n                ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c } { s := { data := c :: cs\u2082 }, i := i\u2082 + c } =\n                  ltb { s := { data := cs\u2081 }, i := i\u2081 } { s := { data := cs\u2082 }, i := i\u2082 }) \u2192\n            match { s := s\u2081, i := i\u2081 } with\n            | { s := { data := cs\u2081 }, i := i\u2081 } =>\n              match { s := s\u2082, i := i\u2082 } with\n              | { s := { data := cs\u2082 }, i := i\u2082 } =>\n                ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c } { s := { data := c :: cs\u2082 }, i := i\u2082 + c } =\n                  ltb { s := { data := cs\u2081 }, i := i\u2081 } { s := { data := cs\u2082 }, i := i\u2082 }\n[PROOFSTEP]\nsimp\n[GOAL]\ncase eq\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    Iterator.hasNext { s := s\u2082, i := i\u2082 } = true \u2192\n      Iterator.hasNext { s := s\u2081, i := i\u2081 } = true \u2192\n        \u00acget s\u2081 i\u2081 = get s\u2082 i\u2082 \u2192\n          match { s := s\u2081, i := i\u2081 } with\n          | { s := { data := cs\u2081 }, i := i\u2081 } =>\n            match { s := s\u2082, i := i\u2082 } with\n            | { s := { data := cs\u2082 }, i := i\u2082 } =>\n              ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c } { s := { data := c :: cs\u2082 }, i := i\u2082 + c } =\n                ltb { s := { data := cs\u2081 }, i := i\u2081 } { s := { data := cs\u2082 }, i := i\u2082 }\n[PROOFSTEP]\nsimp\n[GOAL]\ncase base\u2081\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    Iterator.hasNext { s := s\u2082, i := i\u2082 } = true \u2192\n      \u00acIterator.hasNext { s := s\u2081, i := i\u2081 } = true \u2192\n        match { s := s\u2081, i := i\u2081 } with\n        | { s := { data := cs\u2081 }, i := i\u2081 } =>\n          match { s := s\u2082, i := i\u2082 } with\n          | { s := { data := cs\u2082 }, i := i\u2082 } =>\n            ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c } { s := { data := c :: cs\u2082 }, i := i\u2082 + c } =\n              ltb { s := { data := cs\u2081 }, i := i\u2081 } { s := { data := cs\u2082 }, i := i\u2082 }\n[PROOFSTEP]\nsimp\n[GOAL]\ncase base\u2082\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    \u00acIterator.hasNext { s := s\u2082, i := i\u2082 } = true \u2192\n      match { s := s\u2081, i := i\u2081 } with\n      | { s := { data := cs\u2081 }, i := i\u2081 } =>\n        match { s := s\u2082, i := i\u2082 } with\n        | { s := { data := cs\u2082 }, i := i\u2082 } =>\n          ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c } { s := { data := c :: cs\u2082 }, i := i\u2082 + c } =\n            ltb { s := { data := cs\u2081 }, i := i\u2081 } { s := { data := cs\u2082 }, i := i\u2082 }\n[PROOFSTEP]\nsimp\n[GOAL]\ncase ind\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    Iterator.hasNext { s := s\u2082, i := i\u2082 } = true \u2192\n      Iterator.hasNext { s := s\u2081, i := i\u2081 } = true \u2192\n        get s\u2081 i\u2081 = get s\u2082 i\u2082 \u2192\n          ltb\n                { s := { data := c :: (Iterator.next { s := s\u2081, i := i\u2081 }).1.data },\n                  i := (Iterator.next { s := s\u2081, i := i\u2081 }).i + c }\n                { s := { data := c :: (Iterator.next { s := s\u2082, i := i\u2082 }).1.data },\n                  i := (Iterator.next { s := s\u2082, i := i\u2082 }).i + c } =\n              ltb\n                { s := { data := (Iterator.next { s := s\u2081, i := i\u2081 }).1.data },\n                  i := (Iterator.next { s := s\u2081, i := i\u2081 }).i }\n                { s := { data := (Iterator.next { s := s\u2082, i := i\u2082 }).1.data },\n                  i := (Iterator.next { s := s\u2082, i := i\u2082 }).i } \u2192\n            ltb { s := { data := c :: s\u2081.data }, i := i\u2081 + c } { s := { data := c :: s\u2082.data }, i := i\u2082 + c } =\n              ltb { s := { data := s\u2081.data }, i := i\u2081 } { s := { data := s\u2082.data }, i := i\u2082 }\n[PROOFSTEP]\nintro \u27e8cs\u2081\u27e9 \u27e8cs\u2082\u27e9 i\u2081 i\u2082\n[GOAL]\ncase eq\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    Iterator.hasNext { s := s\u2082, i := i\u2082 } = true \u2192\n      Iterator.hasNext { s := s\u2081, i := i\u2081 } = true \u2192\n        \u00acget s\u2081 i\u2081 = get s\u2082 i\u2082 \u2192\n          ltb { s := { data := c :: s\u2081.data }, i := i\u2081 + c } { s := { data := c :: s\u2082.data }, i := i\u2082 + c } =\n            ltb { s := { data := s\u2081.data }, i := i\u2081 } { s := { data := s\u2082.data }, i := i\u2082 }\n[PROOFSTEP]\nintro \u27e8cs\u2081\u27e9 \u27e8cs\u2082\u27e9 i\u2081 i\u2082\n[GOAL]\ncase base\u2081\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    Iterator.hasNext { s := s\u2082, i := i\u2082 } = true \u2192\n      Iterator.hasNext { s := s\u2081, i := i\u2081 } = false \u2192\n        ltb { s := { data := c :: s\u2081.data }, i := i\u2081 + c } { s := { data := c :: s\u2082.data }, i := i\u2082 + c } =\n          ltb { s := { data := s\u2081.data }, i := i\u2081 } { s := { data := s\u2082.data }, i := i\u2082 }\n[PROOFSTEP]\nintro \u27e8cs\u2081\u27e9 \u27e8cs\u2082\u27e9 i\u2081 i\u2082\n[GOAL]\ncase base\u2082\nc : Char\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 \u2200 (s\u2081 s\u2082 : String) (i\u2081 i\u2082 : Pos),\n    Iterator.hasNext { s := s\u2082, i := i\u2082 } = false \u2192\n      ltb { s := { data := c :: s\u2081.data }, i := i\u2081 + c } { s := { data := c :: s\u2082.data }, i := i\u2082 + c } =\n        ltb { s := { data := s\u2081.data }, i := i\u2081 } { s := { data := s\u2082.data }, i := i\u2082 }\n[PROOFSTEP]\nintro \u27e8cs\u2081\u27e9 \u27e8cs\u2082\u27e9 i\u2081 i\u2082\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true \u2192\n    Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true \u2192\n      get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082 \u2192\n        ltb\n              { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n                i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n              { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n                i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n            ltb\n              { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n                i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n              { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n                i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i } \u2192\n          ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n              { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n            ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nintros\n[GOAL]\ncase eq\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true \u2192\n    Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true \u2192\n      \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082 \u2192\n        ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n            { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n          ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nintros\n[GOAL]\ncase base\u2081\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true \u2192\n    Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false \u2192\n      ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n          { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n        ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nintros\n[GOAL]\ncase base\u2082\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\n\u22a2 Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false \u2192\n    ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n        { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n      ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nintros\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n\u22a2 ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => lhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n    { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase eq\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n\u22a2 ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => lhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n    { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase base\u2081\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n\u22a2 ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => lhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n    { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase base\u2082\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n\u22a2 ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => lhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n      { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nlhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| ltb { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c }\n    { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => rhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n| ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase eq\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => rhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n| ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase base\u2081\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => rhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n| ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase base\u2082\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nconv => rhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs; rw [ltb]\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrhs\n[GOAL]\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n| ltb { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } { s := { data := { data := cs\u2082 }.data }, i := i\u2082 }\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    if Iterator.hasNext { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } = true then\n      if Iterator.hasNext { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } = true then\n        if\n            Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } =\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } then\n          ltb (Iterator.next { s := { data := { data := cs\u2081 }.data }, i := i\u2081 })\n            (Iterator.next { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n        else\n          decide\n            (Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } <\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n      else true\n    else false\n[PROOFSTEP]\nsimp [Iterator.hasNext_cons_addChar, *]\n[GOAL]\ncase eq\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    if Iterator.hasNext { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } = true then\n      if Iterator.hasNext { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } = true then\n        if\n            Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } =\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } then\n          ltb (Iterator.next { s := { data := { data := cs\u2081 }.data }, i := i\u2081 })\n            (Iterator.next { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n        else\n          decide\n            (Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } <\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n      else true\n    else false\n[PROOFSTEP]\nsimp [Iterator.hasNext_cons_addChar, *]\n[GOAL]\ncase base\u2081\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = false\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    if Iterator.hasNext { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } = true then\n      if Iterator.hasNext { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } = true then\n        if\n            Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } =\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } then\n          ltb (Iterator.next { s := { data := { data := cs\u2081 }.data }, i := i\u2081 })\n            (Iterator.next { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n        else\n          decide\n            (Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } <\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n      else true\n    else false\n[PROOFSTEP]\nsimp [Iterator.hasNext_cons_addChar, *]\n[GOAL]\ncase base\u2082\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = false\n\u22a2 (if Iterator.hasNext { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } = true then\n      if Iterator.hasNext { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } = true then\n        if\n            Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } =\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c } then\n          ltb (Iterator.next { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c })\n            (Iterator.next { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n        else\n          decide\n            (Iterator.curr { s := { data := c :: { data := cs\u2081 }.data }, i := i\u2081 + c } <\n              Iterator.curr { s := { data := c :: { data := cs\u2082 }.data }, i := i\u2082 + c })\n      else true\n    else false) =\n    if Iterator.hasNext { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } = true then\n      if Iterator.hasNext { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } = true then\n        if\n            Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } =\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 } then\n          ltb (Iterator.next { s := { data := { data := cs\u2081 }.data }, i := i\u2081 })\n            (Iterator.next { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n        else\n          decide\n            (Iterator.curr { s := { data := { data := cs\u2081 }.data }, i := i\u2081 } <\n              Iterator.curr { s := { data := { data := cs\u2082 }.data }, i := i\u2082 })\n      else true\n    else false\n[PROOFSTEP]\nsimp [Iterator.hasNext_cons_addChar, *]\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b3 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d\u00b9 : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\na\u271d :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n\u22a2 (if\n        Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } =\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c } then\n      ltb (Iterator.next { s := { data := c :: cs\u2081 }, i := i\u2081 + c })\n        (Iterator.next { s := { data := c :: cs\u2082 }, i := i\u2082 + c })\n    else\n      decide\n        (Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } <\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c })) =\n    if Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } = Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 } then\n      ltb (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }) (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 })\n    else decide (Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } < Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 })\n[PROOFSTEP]\nrename_i h\u2082 h\u2081 heq ih\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\nh\u2082 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\nh\u2081 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\nheq : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\nih :\n  ltb\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i + c }\n      { s := { data := c :: (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i + c } =\n    ltb\n      { s := { data := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }).i }\n      { s := { data := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).1.data },\n        i := (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 }).i }\n\u22a2 (if\n        Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } =\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c } then\n      ltb (Iterator.next { s := { data := c :: cs\u2081 }, i := i\u2081 + c })\n        (Iterator.next { s := { data := c :: cs\u2082 }, i := i\u2082 + c })\n    else\n      decide\n        (Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } <\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c })) =\n    if Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } = Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 } then\n      ltb (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }) (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 })\n    else decide (Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } < Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 })\n[PROOFSTEP]\nsimp [Iterator.curr, get_cons_addChar, Iterator.next, next, *] at *\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\nh\u2082 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\nh\u2081 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\nheq : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\nih :\n  ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n\u22a2 ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c + get { data := cs\u2082 } i\u2082 }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + c + get { data := cs\u2082 } i\u2082 } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n[PROOFSTEP]\nrepeat rw [Pos.addChar_right_comm _ c]\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\nh\u2082 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\nh\u2081 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\nheq : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\nih :\n  ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n\u22a2 ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + c + get { data := cs\u2082 } i\u2082 }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + c + get { data := cs\u2082 } i\u2082 } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n[PROOFSTEP]\nrw [Pos.addChar_right_comm _ c]\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\nh\u2082 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\nh\u2081 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\nheq : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\nih :\n  ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n\u22a2 ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + c + get { data := cs\u2082 } i\u2082 } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n[PROOFSTEP]\nrw [Pos.addChar_right_comm _ c]\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\nh\u2082 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\nh\u2081 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\nheq : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\nih :\n  ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n\u22a2 ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n[PROOFSTEP]\nrw [Pos.addChar_right_comm _ c]\n[GOAL]\ncase ind\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\nh\u2082 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\nh\u2081 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\nheq : get { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\nih :\n  ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n\u22a2 ltb { s := { data := c :: cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 + c }\n      { s := { data := c :: cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 + c } =\n    ltb { s := { data := cs\u2081 }, i := i\u2081 + get { data := cs\u2082 } i\u2082 }\n      { s := { data := cs\u2082 }, i := i\u2082 + get { data := cs\u2082 } i\u2082 }\n[PROOFSTEP]\nexact ih\n[GOAL]\ncase eq\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\na\u271d\u00b2 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\na\u271d\u00b9 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\na\u271d : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n\u22a2 (if\n        Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } =\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c } then\n      ltb (Iterator.next { s := { data := c :: cs\u2081 }, i := i\u2081 + c })\n        (Iterator.next { s := { data := c :: cs\u2082 }, i := i\u2082 + c })\n    else\n      decide\n        (Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } <\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c })) =\n    if Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } = Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 } then\n      ltb (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }) (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 })\n    else decide (Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } < Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 })\n[PROOFSTEP]\nrename_i h\u2082 h\u2081 hne\n[GOAL]\ncase eq\nc : Char\ncs\u2081\u271d cs\u2082\u271d : List Char\ni\u2081\u271d i\u2082\u271d : Pos\ncs\u2081 cs\u2082 : List Char\ni\u2081 i\u2082 : Pos\nh\u2082 : Iterator.hasNext { s := { data := cs\u2082 }, i := i\u2082 } = true\nh\u2081 : Iterator.hasNext { s := { data := cs\u2081 }, i := i\u2081 } = true\nhne : \u00acget { data := cs\u2081 } i\u2081 = get { data := cs\u2082 } i\u2082\n\u22a2 (if\n        Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } =\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c } then\n      ltb (Iterator.next { s := { data := c :: cs\u2081 }, i := i\u2081 + c })\n        (Iterator.next { s := { data := c :: cs\u2082 }, i := i\u2082 + c })\n    else\n      decide\n        (Iterator.curr { s := { data := c :: cs\u2081 }, i := i\u2081 + c } <\n          Iterator.curr { s := { data := c :: cs\u2082 }, i := i\u2082 + c })) =\n    if Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } = Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 } then\n      ltb (Iterator.next { s := { data := cs\u2081 }, i := i\u2081 }) (Iterator.next { s := { data := cs\u2082 }, i := i\u2082 })\n    else decide (Iterator.curr { s := { data := cs\u2081 }, i := i\u2081 } < Iterator.curr { s := { data := cs\u2082 }, i := i\u2082 })\n[PROOFSTEP]\nsimp [Iterator.curr, get_cons_addChar, *]\n[GOAL]\ns\u2081 s\u2082 : List Char\n\u22a2 ltb { s := { data := s\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 s\u2081 < s\u2082\n[PROOFSTEP]\ninduction s\u2081 generalizing s\u2082\n[GOAL]\ncase nil\ns\u2082 : List Char\n\u22a2 ltb { s := { data := [] }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 [] < s\u2082\n[PROOFSTEP]\ncases s\u2082\n[GOAL]\ncase cons\nhead\u271d : Char\ntail\u271d : List Char\ntail_ih\u271d :\n  \u2200 (s\u2082 : List Char), ltb { s := { data := tail\u271d }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 tail\u271d < s\u2082\ns\u2082 : List Char\n\u22a2 ltb { s := { data := head\u271d :: tail\u271d }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 head\u271d :: tail\u271d < s\u2082\n[PROOFSTEP]\ncases s\u2082\n[GOAL]\ncase nil.nil\n\u22a2 ltb { s := { data := [] }, i := 0 } { s := { data := [] }, i := 0 } = true \u2194 [] < []\n[PROOFSTEP]\nsimp\n[GOAL]\ncase nil.cons\nhead\u271d : Char\ntail\u271d : List Char\n\u22a2 ltb { s := { data := [] }, i := 0 } { s := { data := head\u271d :: tail\u271d }, i := 0 } = true \u2194 [] < head\u271d :: tail\u271d\n[PROOFSTEP]\nrename_i c\u2082 cs\u2082\n[GOAL]\ncase nil.cons\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 ltb { s := { data := [] }, i := 0 } { s := { data := c\u2082 :: cs\u2082 }, i := 0 } = true \u2194 [] < c\u2082 :: cs\u2082\n[PROOFSTEP]\napply iff_of_true\n[GOAL]\ncase nil.cons.ha\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 ltb { s := { data := [] }, i := 0 } { s := { data := c\u2082 :: cs\u2082 }, i := 0 } = true\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase nil.cons.ha\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 (if Iterator.hasNext { s := { data := c\u2082 :: cs\u2082 }, i := 0 } = true then\n      if Iterator.hasNext { s := { data := [] }, i := 0 } = true then\n        if Iterator.curr { s := { data := [] }, i := 0 } = Iterator.curr { s := { data := c\u2082 :: cs\u2082 }, i := 0 } then\n          ltb (Iterator.next { s := { data := [] }, i := 0 }) (Iterator.next { s := { data := c\u2082 :: cs\u2082 }, i := 0 })\n        else\n          decide (Iterator.curr { s := { data := [] }, i := 0 } < Iterator.curr { s := { data := c\u2082 :: cs\u2082 }, i := 0 })\n      else true\n    else false) =\n    true\n[PROOFSTEP]\nsimp\n[GOAL]\ncase nil.cons.ha\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 Iterator.hasNext { s := { data := c\u2082 :: cs\u2082 }, i := 0 } = false \u2192 False\n[PROOFSTEP]\napply ne_false_of_eq_true\n[GOAL]\ncase nil.cons.ha.a\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 Iterator.hasNext { s := { data := c\u2082 :: cs\u2082 }, i := 0 } = true\n[PROOFSTEP]\napply decide_eq_true\n[GOAL]\ncase nil.cons.ha.a.a\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 0.byteIdx < (endPos { data := c\u2082 :: cs\u2082 }).byteIdx\n[PROOFSTEP]\nsimp [endPos, utf8ByteSize, utf8ByteSize.go, csize_pos]\n[GOAL]\ncase nil.cons.hb\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 [] < c\u2082 :: cs\u2082\n[PROOFSTEP]\napply List.nil_lt_cons\n[GOAL]\ncase cons.nil\nhead\u271d : Char\ntail\u271d : List Char\ntail_ih\u271d :\n  \u2200 (s\u2082 : List Char), ltb { s := { data := tail\u271d }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 tail\u271d < s\u2082\n\u22a2 ltb { s := { data := head\u271d :: tail\u271d }, i := 0 } { s := { data := [] }, i := 0 } = true \u2194 head\u271d :: tail\u271d < []\n[PROOFSTEP]\nrename_i c\u2081 cs\u2081 ih\n[GOAL]\ncase cons.nil\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\n\u22a2 ltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 } { s := { data := [] }, i := 0 } = true \u2194 c\u2081 :: cs\u2081 < []\n[PROOFSTEP]\napply iff_of_false\n[GOAL]\ncase cons.nil.ha\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\n\u22a2 \u00acltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 } { s := { data := [] }, i := 0 } = true\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase cons.nil.ha\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\n\u22a2 \u00ac(if Iterator.hasNext { s := { data := [] }, i := 0 } = true then\n        if Iterator.hasNext { s := { data := c\u2081 :: cs\u2081 }, i := 0 } = true then\n          if Iterator.curr { s := { data := c\u2081 :: cs\u2081 }, i := 0 } = Iterator.curr { s := { data := [] }, i := 0 } then\n            ltb (Iterator.next { s := { data := c\u2081 :: cs\u2081 }, i := 0 }) (Iterator.next { s := { data := [] }, i := 0 })\n          else\n            decide\n              (Iterator.curr { s := { data := c\u2081 :: cs\u2081 }, i := 0 } < Iterator.curr { s := { data := [] }, i := 0 })\n        else true\n      else false) =\n      true\n[PROOFSTEP]\nsimp\n[GOAL]\ncase cons.nil.hb\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\n\u22a2 \u00acc\u2081 :: cs\u2081 < []\n[PROOFSTEP]\napply not_lt_of_lt\n[GOAL]\ncase cons.nil.hb.a\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\n\u22a2 [] < c\u2081 :: cs\u2081\n[PROOFSTEP]\napply List.nil_lt_cons\n[GOAL]\ncase cons.cons\nhead\u271d\u00b9 : Char\ntail\u271d\u00b9 : List Char\ntail_ih\u271d :\n  \u2200 (s\u2082 : List Char), ltb { s := { data := tail\u271d\u00b9 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 tail\u271d\u00b9 < s\u2082\nhead\u271d : Char\ntail\u271d : List Char\n\u22a2 ltb { s := { data := head\u271d\u00b9 :: tail\u271d\u00b9 }, i := 0 } { s := { data := head\u271d :: tail\u271d }, i := 0 } = true \u2194\n    head\u271d\u00b9 :: tail\u271d\u00b9 < head\u271d :: tail\u271d\n[PROOFSTEP]\nrename_i c\u2081 cs\u2081 ih c\u2082 cs\u2082\n[GOAL]\ncase cons.cons\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 ltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 } { s := { data := c\u2082 :: cs\u2082 }, i := 0 } = true \u2194 c\u2081 :: cs\u2081 < c\u2082 :: cs\u2082\n[PROOFSTEP]\nrw [ltb]\n[GOAL]\ncase cons.cons\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 (if Iterator.hasNext { s := { data := c\u2082 :: cs\u2082 }, i := 0 } = true then\n        if Iterator.hasNext { s := { data := c\u2081 :: cs\u2081 }, i := 0 } = true then\n          if\n              Iterator.curr { s := { data := c\u2081 :: cs\u2081 }, i := 0 } =\n                Iterator.curr { s := { data := c\u2082 :: cs\u2082 }, i := 0 } then\n            ltb (Iterator.next { s := { data := c\u2081 :: cs\u2081 }, i := 0 })\n              (Iterator.next { s := { data := c\u2082 :: cs\u2082 }, i := 0 })\n          else\n            decide\n              (Iterator.curr { s := { data := c\u2081 :: cs\u2081 }, i := 0 } <\n                Iterator.curr { s := { data := c\u2082 :: cs\u2082 }, i := 0 })\n        else true\n      else false) =\n      true \u2194\n    c\u2081 :: cs\u2081 < c\u2082 :: cs\u2082\n[PROOFSTEP]\nsimp [Iterator.hasNext, endPos, utf8ByteSize, utf8ByteSize.go, csize_pos, Iterator.curr, get, utf8GetAux, Iterator.next,\n  next]\n[GOAL]\ncase cons.cons\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\n\u22a2 (if c\u2081 = c\u2082 then ltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 + c\u2081 } { s := { data := c\u2082 :: cs\u2082 }, i := 0 + c\u2082 } = true\n    else c\u2081 < c\u2082) \u2194\n    c\u2081 :: cs\u2081 < c\u2082 :: cs\u2082\n[PROOFSTEP]\nsplit_ifs with h\n[GOAL]\ncase pos\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\nh : c\u2081 = c\u2082\n\u22a2 ltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 + c\u2081 } { s := { data := c\u2082 :: cs\u2082 }, i := 0 + c\u2082 } = true \u2194\n    c\u2081 :: cs\u2081 < c\u2082 :: cs\u2082\n[PROOFSTEP]\nsubst c\u2082\n[GOAL]\ncase pos\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\ncs\u2082 : List Char\n\u22a2 ltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 + c\u2081 } { s := { data := c\u2081 :: cs\u2082 }, i := 0 + c\u2081 } = true \u2194\n    c\u2081 :: cs\u2081 < c\u2081 :: cs\u2082\n[PROOFSTEP]\nsuffices ltb \u27e8\u27e8c\u2081 :: cs\u2081\u27e9, \u27e8csize c\u2081\u27e9\u27e9 \u27e8\u27e8c\u2081 :: cs\u2082\u27e9, \u27e8csize c\u2081\u27e9\u27e9 = ltb \u27e8\u27e8cs\u2081\u27e9, 0\u27e9 \u27e8\u27e8cs\u2082\u27e9, 0\u27e9 by\n  rw [Pos.zero_addChar_eq, this]; exact (ih cs\u2082).trans List.Lex.cons_iff.symm\n[GOAL]\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\ncs\u2082 : List Char\nthis :\n  ltb { s := { data := c\u2081 :: cs\u2081 }, i := { byteIdx := csize c\u2081 } }\n      { s := { data := c\u2081 :: cs\u2082 }, i := { byteIdx := csize c\u2081 } } =\n    ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := cs\u2082 }, i := 0 }\n\u22a2 ltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 + c\u2081 } { s := { data := c\u2081 :: cs\u2082 }, i := 0 + c\u2081 } = true \u2194\n    c\u2081 :: cs\u2081 < c\u2081 :: cs\u2082\n[PROOFSTEP]\nrw [Pos.zero_addChar_eq, this]\n[GOAL]\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\ncs\u2082 : List Char\nthis :\n  ltb { s := { data := c\u2081 :: cs\u2081 }, i := { byteIdx := csize c\u2081 } }\n      { s := { data := c\u2081 :: cs\u2082 }, i := { byteIdx := csize c\u2081 } } =\n    ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := cs\u2082 }, i := 0 }\n\u22a2 ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := cs\u2082 }, i := 0 } = true \u2194 c\u2081 :: cs\u2081 < c\u2081 :: cs\u2082\n[PROOFSTEP]\nexact (ih cs\u2082).trans List.Lex.cons_iff.symm\n[GOAL]\ncase pos\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\ncs\u2082 : List Char\n\u22a2 ltb { s := { data := c\u2081 :: cs\u2081 }, i := { byteIdx := csize c\u2081 } }\n      { s := { data := c\u2081 :: cs\u2082 }, i := { byteIdx := csize c\u2081 } } =\n    ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := cs\u2082 }, i := 0 }\n[PROOFSTEP]\nrw [\u2190 Pos.zero_addChar_eq]\n[GOAL]\ncase pos\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\ncs\u2082 : List Char\n\u22a2 ltb { s := { data := c\u2081 :: cs\u2081 }, i := 0 + c\u2081 } { s := { data := c\u2081 :: cs\u2082 }, i := 0 + c\u2081 } =\n    ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := cs\u2082 }, i := 0 }\n[PROOFSTEP]\napply ltb_cons_addChar\n[GOAL]\ncase neg\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\nh : \u00acc\u2081 = c\u2082\n\u22a2 c\u2081 < c\u2082 \u2194 c\u2081 :: cs\u2081 < c\u2082 :: cs\u2082\n[PROOFSTEP]\nrefine \u27e8List.Lex.rel, fun e \u21a6 ?_\u27e9\n[GOAL]\ncase neg\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\nh : \u00acc\u2081 = c\u2082\ne : c\u2081 :: cs\u2081 < c\u2082 :: cs\u2082\n\u22a2 c\u2081 < c\u2082\n[PROOFSTEP]\ncases e\n[GOAL]\ncase neg.cons\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\ncs\u2082 : List Char\nh : \u00acc\u2081 = c\u2081\nh\u271d : List.Lex (fun x x_1 => x < x_1) cs\u2081 cs\u2082\n\u22a2 c\u2081 < c\u2081\n[PROOFSTEP]\nrename_i h'\n[GOAL]\ncase neg.rel\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\nh : \u00acc\u2081 = c\u2082\nh\u271d : c\u2081 < c\u2082\n\u22a2 c\u2081 < c\u2082\n[PROOFSTEP]\nrename_i h'\n[GOAL]\ncase neg.cons\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\ncs\u2082 : List Char\nh : \u00acc\u2081 = c\u2081\nh' : List.Lex (fun x x_1 => x < x_1) cs\u2081 cs\u2082\n\u22a2 c\u2081 < c\u2081\n[PROOFSTEP]\ncontradiction\n[GOAL]\ncase neg.rel\nc\u2081 : Char\ncs\u2081 : List Char\nih : \u2200 (s\u2082 : List Char), ltb { s := { data := cs\u2081 }, i := 0 } { s := { data := s\u2082 }, i := 0 } = true \u2194 cs\u2081 < s\u2082\nc\u2082 : Char\ncs\u2082 : List Char\nh : \u00acc\u2081 = c\u2082\nh' : c\u2081 < c\u2082\n\u22a2 c\u2081 < c\u2082\n[PROOFSTEP]\nassumption\n[GOAL]\n\u22a2 DecidableRel fun x x_1 => x \u2264 x_1\n[PROOFSTEP]\nsimp only [LE]\n[GOAL]\n\u22a2 DecidableRel fun s\u2081 s\u2082 => \u00acs\u2082 < s\u2081\n[PROOFSTEP]\ninfer_instance\n  -- short-circuit type class inference\n[GOAL]\ns : List Char\nh : { data := s } \u2260 \"\"\n\u22a2 toList { data := s } = head { data := s } :: toList (drop { data := s } 1)\n[PROOFSTEP]\ncases s\n[GOAL]\ncase nil\nh : { data := [] } \u2260 \"\"\n\u22a2 toList { data := [] } = head { data := [] } :: toList (drop { data := [] } 1)\n[PROOFSTEP]\nsimp only at h \n[GOAL]\ncase cons\nhead\u271d : Char\ntail\u271d : List Char\nh : { data := head\u271d :: tail\u271d } \u2260 \"\"\n\u22a2 toList { data := head\u271d :: tail\u271d } = head { data := head\u271d :: tail\u271d } :: toList (drop { data := head\u271d :: tail\u271d } 1)\n[PROOFSTEP]\nrename_i c cs\n[GOAL]\ncase cons\nc : Char\ncs : List Char\nh : { data := c :: cs } \u2260 \"\"\n\u22a2 toList { data := c :: cs } = head { data := c :: cs } :: toList (drop { data := c :: cs } 1)\n[PROOFSTEP]\nsimp only [toList, List.cons.injEq]\n[GOAL]\ncase cons\nc : Char\ncs : List Char\nh : { data := c :: cs } \u2260 \"\"\n\u22a2 c = head { data := c :: cs } \u2227 cs = (drop { data := c :: cs } 1).data\n[PROOFSTEP]\nconstructor <;> [rfl; simp [drop_eq]]\n[GOAL]\ncase cons\nc : Char\ncs : List Char\nh : { data := c :: cs } \u2260 \"\"\n\u22a2 c = head { data := c :: cs } \u2227 cs = (drop { data := c :: cs } 1).data\n[PROOFSTEP]\nconstructor\n[GOAL]\ncase cons.left\nc : Char\ncs : List Char\nh : { data := c :: cs } \u2260 \"\"\n\u22a2 c = head { data := c :: cs }\n[PROOFSTEP]\nrfl\n[GOAL]\ncase cons.right\nc : Char\ncs : List Char\nh : { data := c :: cs } \u2260 \"\"\n\u22a2 cs = (drop { data := c :: cs } 1).data\n[PROOFSTEP]\nsimp [drop_eq]\n[GOAL]\na b c : String\n\u22a2 a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\n[PROOFSTEP]\nsimp only [le_iff_toList_le]\n[GOAL]\na b c : String\n\u22a2 toList a \u2264 toList b \u2192 toList b \u2264 toList c \u2192 toList a \u2264 toList c\n[PROOFSTEP]\napply le_trans\n[GOAL]\na b : String\n\u22a2 a < b \u2194 a \u2264 b \u2227 \u00acb \u2264 a\n[PROOFSTEP]\nsimp only [lt_iff_toList_lt, le_iff_toList_le, lt_iff_le_not_le]\n[GOAL]\na b : String\n\u22a2 a \u2264 b \u2192 b \u2264 a \u2192 a = b\n[PROOFSTEP]\nsimp only [le_iff_toList_le, \u2190 toList_inj]\n[GOAL]\na b : String\n\u22a2 toList a \u2264 toList b \u2192 toList b \u2264 toList a \u2192 toList a = toList b\n[PROOFSTEP]\napply le_antisymm\n[GOAL]\na b : String\n\u22a2 a \u2264 b \u2228 b \u2264 a\n[PROOFSTEP]\nsimp only [le_iff_toList_le]\n[GOAL]\na b : String\n\u22a2 toList a \u2264 toList b \u2228 toList b \u2264 toList a\n[PROOFSTEP]\napply le_total\n[GOAL]\na b : String\n\u22a2 compare a b = compareOfLessAndEq a b\n[PROOFSTEP]\nsimp [compare, compareOfLessAndEq, toList, instLTString, List.instLTList, List.LT']\n[GOAL]\na b : String\n\u22a2 (if List.lt a.data b.data then Ordering.lt else if a = b then Ordering.eq else Ordering.gt) =\n    if List.Lex (fun x x_1 => x < x_1) a.data b.data then Ordering.lt else if a = b then Ordering.eq else Ordering.gt\n[PROOFSTEP]\nsplit_ifs\n[GOAL]\ncase pos\na b : String\nh\u271d\u00b9 : List.lt a.data b.data\nh\u271d : List.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 Ordering.lt = Ordering.lt\n[PROOFSTEP]\nsimp [List.lt_iff_lex_lt] at *\n[GOAL]\ncase pos\na b : String\nh\u271d\u00b2 : List.lt a.data b.data\nh\u271d\u00b9 : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\nh\u271d : a = b\n\u22a2 False\n[PROOFSTEP]\nsimp [List.lt_iff_lex_lt] at *\n[GOAL]\ncase neg\na b : String\nh\u271d\u00b2 : List.lt a.data b.data\nh\u271d\u00b9 : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\nh\u271d : \u00aca = b\n\u22a2 False\n[PROOFSTEP]\nsimp [List.lt_iff_lex_lt] at *\n[GOAL]\ncase pos\na b : String\nh\u271d\u00b2 : \u00acList.lt a.data b.data\nh\u271d\u00b9 : a = b\nh\u271d : List.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 False\n[PROOFSTEP]\nsimp [List.lt_iff_lex_lt] at *\n[GOAL]\ncase neg\na b : String\nh\u271d\u00b2 : \u00acList.lt a.data b.data\nh\u271d\u00b9 : a = b\nh\u271d : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 Ordering.eq = Ordering.eq\n[PROOFSTEP]\nsimp [List.lt_iff_lex_lt] at *\n[GOAL]\ncase pos\na b : String\nh\u271d\u00b2 : \u00acList.lt a.data b.data\nh\u271d\u00b9 : \u00aca = b\nh\u271d : List.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 False\n[PROOFSTEP]\nsimp [List.lt_iff_lex_lt] at *\n[GOAL]\ncase neg\na b : String\nh\u271d\u00b2 : \u00acList.lt a.data b.data\nh\u271d\u00b9 : \u00aca = b\nh\u271d : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 Ordering.gt = Ordering.gt\n[PROOFSTEP]\nsimp [List.lt_iff_lex_lt] at *\n[GOAL]\ncase pos\na b : String\nh\u271d\u00b2 : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\nh\u271d\u00b9 : a = b\nh\u271d : List.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 False\n[PROOFSTEP]\ncontradiction\n[GOAL]\ncase neg\na b : String\nh\u271d\u00b2 : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\nh\u271d\u00b9 : \u00aca = b\nh\u271d : List.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 False\n[PROOFSTEP]\ncontradiction\n[GOAL]\ncase pos\na b : String\nh\u271d\u00b2 : a = b\nh\u271d\u00b9 : List.Lex (fun x x_1 => x < x_1) a.data b.data\nh\u271d : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 False\n[PROOFSTEP]\ncontradiction\n[GOAL]\ncase pos\na b : String\nh\u271d\u00b2 : \u00aca = b\nh\u271d\u00b9 : List.Lex (fun x x_1 => x < x_1) a.data b.data\nh\u271d : \u00acList.Lex (fun x x_1 => x < x_1) a.data b.data\n\u22a2 False\n[PROOFSTEP]\ncontradiction\n[GOAL]\nl l' : List Char\nh : asString l = asString l'\n\u22a2 l = l'\n[PROOFSTEP]\nrw [\u2190 toList_inv_asString l, \u2190 toList_inv_asString l', toList_inj, h]\n[GOAL]\nl : List Char\ns : String\n\u22a2 asString l = s \u2194 l = toList s\n[PROOFSTEP]\nrw [\u2190 asString_inv_toList s, asString_inj, asString_inv_toList s]\n"}
{"text": "informal statement If $G$ is a group and $a, x \\in G$, prove that $C\\left(x^{-1} a x\\right)=x^{-1} C(a) x$formal statement theorem exercise_2_4_36 {a n : \u2115} (h : a > 1) :\n  n \u2223 (a ^ n - 1).totient :="}
{"text": "[GOAL]\na b : \u2115\n\u22a2 a \u2260 b \u2194 \u2191a \u2260 \u2191b\n[PROOFSTEP]\nsimp only [ne_eq, Int.cast_eq_cast_iff_Nat]\n"}
{"text": "universes v\n/-\nmatcher for the following patterns\n```\n| \"hello\" => _\n| \"world\" => _\n| a       => _\n``` -/\ndef matchString (C : String \u2192 Sort v) (s : String)\n    (h\u2081 : Unit \u2192 C \"hello\")\n    (h\u2082 : Unit \u2192 C \"world\")\n    (h\u2083 : \u2200 s,   C s)\n    : C s :=\ndite (s = \"hello\")\n  (fun h => @Eq.ndrec _ _ (fun x => C x) (h\u2081 ()) _ h.symm)\n  (fun _ => dite (s = \"world\")\n    (fun h => @Eq.ndrec _ _ (fun x => C x) (h\u2082 ()) _ h.symm)\n    (fun _ => h\u2083 s))\n\ntheorem matchString.Eq1 (C : String \u2192 Sort v)\n    (h\u2081 : Unit \u2192 C \"hello\")\n    (h\u2082 : Unit \u2192 C \"world\")\n    (h\u2083 : \u2200 s,   C s)\n    : matchString C \"hello\" h\u2081 h\u2082 h\u2083 = h\u2081 () :=\ndifPos rfl\n\naxiom neg1 : \"world\" \u2260 \"hello\"\n\ntheorem matchString.Eq2 (C : String \u2192 Sort v)\n    (h\u2081 : Unit \u2192 C \"hello\")\n    (h\u2082 : Unit \u2192 C \"world\")\n    (h\u2083 : \u2200 s,   C s)\n    : matchString C \"world\" h\u2081 h\u2082 h\u2083 = h\u2082 () :=\nhave aux\u2081 : matchString C \"world\" h\u2081 h\u2082 h\u2083 = if h : \"world\" = \"world\" then @Eq.rec _ _ (fun x _ => C x) (h\u2082 ()) _ h.symm else h\u2083 \"world\" from difNeg neg1;\nhave aux\u2082 : (if h : \"world\" = \"world\" then @Eq.rec _ _ (fun x _ => C x) (h\u2082 ()) _ h.symm else h\u2083 \"world\" : C \"world\") = h\u2082 () from difPos rfl;\nEq.trans aux\u2081 aux\u2082\n\ntheorem matchString.Eq3 (C : String \u2192 Sort v)\n    (h\u2081 : Unit \u2192 C \"hello\")\n    (h\u2082 : Unit \u2192 C \"world\")\n    (h\u2083 : \u2200 s,   C s)\n    (s : String) (n\u2081 : s \u2260 \"hello\") (n\u2082 : s \u2260 \"world\")\n    : matchString C s h\u2081 h\u2082 h\u2083 = h\u2083 s :=\nhave aux\u2081 : matchString C s h\u2081 h\u2082 h\u2083 = if h : s = \"world\" then @Eq.rec _ _ (fun x _ => C x) (h\u2082 ()) _ h.symm else h\u2083 s from difNeg n\u2081;\nhave aux\u2082 : (if h : s = \"world\" then @Eq.rec _ _ (fun x _ => C x) (h\u2082 ()) _ h.symm else h\u2083 s : C s) = h\u2083 s from difNeg n\u2082;\nEq.trans aux\u2081 aux\u2082\n"}
{"text": "import data.real.basic\n\ntheorem challenge3 :\n(2 : \u211d) + 2 \u2260 5 :=\nbegin\n  norm_num\nend\n"}
{"text": "informal statement Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$.formal statement theorem exercise_22_2b {X : Type*} [topological_space X]\n  {A : set X} (r : X \u2192 A) (hr : continuous r) (h : \u2200 x : A, r x = x) :\n  quotient_map r :="}
{"text": "import analysis.real tactic.norm_num algebra.group_power\n\ntheorem Q5a1 (S : set \u211d) : (\u2203 x : \u211d, x \u2208 lower_bounds S) \n    \u2194 (\u2203 y : \u211d, y \u2208 upper_bounds {t : \u211d | \u2203 s \u2208 S, t = -s }) := sorry\n\ntheorem Q5a2 (S : set \u211d) (x : \u211d) : is_glb S x \u2194 \n    is_lub {t : \u211d | \u2203 s \u2208 S, t = -s} (-x) := sorry\n\nlemma Q5bhelper (S : set \u211d) (x\u2081 x\u2082 : \u211d) : is_glb S x\u2081 \u2227 is_glb S x\u2082 \u2192 x\u2081 \u2264 x\u2082 :=\nbegin\nintro H,\nhave Hglb1 := H.left,\nhave Hlb1 := Hglb1.left,\nhave Hglb2 := H.right,\nhave H1 := Hglb2.right,\nexact H1 _ Hlb1,\nend\n\ntheorem Q5b (S : set \u211d) (x\u2081 x\u2082 : \u211d) : is_glb S x\u2081 \u2227 is_glb S x\u2082 \u2192 x\u2081 = x\u2082 := sorry\n\ntheorem Q5c :  (\u2200 S : set \u211d, (\u2203 w : \u211d, w \u2208 S) \u2192 (\u2203 x : \u211d, x \u2208 upper_bounds S) \u2192 \u2203 y : \u211d, is_lub S y) \n   \u2192   (\u2200 T : set \u211d, (\u2203 w\u2081 : \u211d, w\u2081 \u2208 T) \u2192 (\u2203 x\u2081 : \u211d, x\u2081 \u2208 lower_bounds T) \u2192 \u2203 y\u2081 : \u211d, is_glb T y\u2081) := sorry\n\n"}
{"text": "import data.real.basic\n\n\nlemma mp (p q : Prop) :\n  p \u2192 (p \u2192 q) \u2192 q := \n\u03bb hp hpq, hpq hp\n\n\n\n\n\n\n"}
{"text": "informal statement Show that the subgroup of all rotations in a dihedral group is a maximal subgroup.formal statement theorem exercise_3_1_3a {A : Type*} [comm_group A] (B : subgroup A) :\n  \u2200 a b : A \u29f8 B, a*b = b*a :="}
{"text": "informal statement Prove that characteristic subgroups are normal.formal statement theorem exercise_4_4_6a {G : Type*} [group G] (H : subgroup G)\n  [subgroup.characteristic H] : subgroup.normal H  :="}
{"text": "import group_theory.subgroup\n\ntheorem cpge_groupe_9_a {G1 : Type*} [group G1] {G2 : Type*} [group G2]\n(f : G1 \u2192* G2) : \u2200 (a : G1), ( (f a = 1) \u2192 (\u2200 (x : G1), f (x * a * x\u207b\u00b9) = 1))  := sorry\n"}
{"text": "informal statement Prove that if an integer is the sum of two rational squares, then it is the sum of two integer squares.formal statement theorem exercise_8_3_6a {R : Type*} [ring R]\n  (hR : R = (gaussian_int \u29f8 ideal.span ({\u27e80, 1\u27e9} : set gaussian_int))) :\n  is_field R \u2227 \u2203 finR : fintype R, @card R finR = 2 :="}
{"text": "import data.real.basic tactic.ring tactic.tidy\n\n/- Definitions -/\n\ndefinition double (n : \u2115) : \u2115 := n + n\n\n#check double\n\n#check double \u2218 double\n\ndefinition quadruple : \u2115 \u2192 \u2115 := double \u2218 double\n\ndefinition FLT : Prop :=\n\u2200 n > 2, \u2200 x y z, x^n + y^n = z^n \u2192 (x = 0 \u2228 y = 0)\n\ntheorem Wiles : FLT :=\nbegin\n  unfold FLT,\n  intros,\n  sorry\nend\n\n--- --- --- --- --- --- --- --- --- --- --- --- --- ---\n\nlemma transitive_imply (P Q R : Prop)\n(P_imp_Q : P \u2192 Q)\n(Q_imp_R : Q \u2192 R) :\n  P \u2192 R :=\nbegin\n  intro P_is_true,\n  apply Q_imp_R,\n  apply P_imp_Q,\n  assumption,\nend\n\nlemma transitive_imply' (P Q R : Prop)\n(P_imp_Q : P \u2192 Q)\n(Q_imp_R : Q \u2192 R) :\n  P \u2192 R := Q_imp_R \u2218 P_imp_Q"}
{"text": "import linear_algebra.basic\n\nuniverses u v w x\n\nvariables {R : Type u} [ring R]\nvariables {M\u2081 : Type v} [add_comm_group M\u2081] [module R M\u2081]\nvariables {M\u2082 : Type w} [add_comm_group M\u2082] [module R M\u2082]\nvariables {M\u2083 : Type x} [add_comm_group M\u2083] [module R M\u2083]\n\nopen linear_map\nopen submodule\n\nlemma linear_map.ker_le_range_iff {f : M\u2081 \u2192\u2097[R] M\u2082} {g : M\u2082 \u2192\u2097[R] M\u2083} :\n  g.ker \u2264 f.range \u2194 f.range.mkq.comp g.ker.subtype = 0 :=\nby rw [\u2190range_le_ker_iff, ker_mkq, range_subtype]\n\n/-\u27e8\u03bb h, ker_eq_top.1 $ eq_top_iff'.2 $ \u03bb x, mem_ker.2 $ by simpa using mem_range.1 (h x.2),\n \u03bb h,\n begin\n  rw \u2190range_le_ker_iff at h,\n  rw ker_mkq at h,\n  rw range_subtype at h,\n  exact h,\n end-\n  /-x hx,\n begin\n  rw \u2190submodule.ker_mkq f.range,\n  apply mem_ker.2,\n  rw \u2190zero_apply x,\n  rw \u2190h,\n  --rw \u2190submodule.subtype_apply _ \u27e8x, hx\u27e9,\n  exact mem_ker.2 (@linear_map.congr _ _ _ _ _ _ _ _\n    (comp (mkq (range f)) (submodule.subtype (ker g))) 0 \u27e8x, hx\u27e9 h),-/\n end\u27e9-/\n"}
{"text": "-- Andreas, 2017-01-14, issue #2405 reported by m0davis\n-- Instance not found due to regression introduced by\n-- parameter-refinement.\n\n-- {-# OPTIONS --show-implicit #-}\n-- {-# OPTIONS -v tc.instance:70 #-}\n-- {-# OPTIONS -v tc.meta.assign:40 #-}\n-- {-# OPTIONS -v tc.conv:40 #-}\n-- {-# OPTIONS -v tc.sig.param:100 #-}\n\npostulate\n  R : Set \u2192 Set\n  S : (F : Set \u2192 Set) \u2983 _ : {A : Set} \u2192 R (F A) \u2984 \u2192 Set\n\nmodule M1 (X : Set) where\n  postulate\n    F : Set \u2192 Set\n    instance Ri : {A : Set} \u2192 R (F A)\n    Si-works : S F \u2983 Ri \u2984\n    Si-test  : S F\n\n-- WAS:\n-- No instance of type R (F A) was found in scope. -}\n--\n-- candidate:\n--   Ri X    : (A : Set) \u2192 R (F X A)\n--   Ri 0    : \u03a0 Set \u03bb A \u2192 R (F 1 0)\n--   Ri 0 _A : R (F 0 (_A 1 0))\n-- goal:\n--   getMetaType\n--   ? : (X A : Set) \u2192 R (F X A)\n--   ? : \u03a0 Set \u03bb X \u2192 Pi Set \u03bb A \u2192 R (F 1 0)\n--   ? : R (F A)\n--   ? : R (F 1 0)\n\n-- Should succeed.\n"}
{"text": "/-\nCopyright (c) 2021 Yourong Zang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yourong Zang\n-/\nimport analysis.calculus.conformal.normed_space\nimport analysis.inner_product_space.conformal_linear_map\n\n/-!\n# Conformal maps between inner product spaces\n\nA function between inner product spaces is which has a derivative at `x`\nis conformal at `x` iff the derivative preserves inner products up to a scalar multiple.\n-/\n\nnoncomputable theory\n\nvariables {E F : Type*}\nvariables [normed_add_comm_group E] [normed_add_comm_group F]\nvariables [inner_product_space \u211d E] [inner_product_space \u211d F]\n\nopen_locale real_inner_product_space\n\n/-- A real differentiable map `f` is conformal at point `x` if and only if its\n    differential `fderiv \u211d f x` at that point scales every inner product by a positive scalar. -/\nlemma conformal_at_iff' {f : E \u2192 F} {x : E} :\n  conformal_at f x \u2194\n  \u2203 (c : \u211d), 0 < c \u2227 \u2200 (u v : E), \u27eafderiv \u211d f x u, fderiv \u211d f x v\u27eb = c * \u27eau, v\u27eb :=\nby rw [conformal_at_iff_is_conformal_map_fderiv, is_conformal_map_iff]\n\n/-- A real differentiable map `f` is conformal at point `x` if and only if its\n    differential `f'` at that point scales every inner product by a positive scalar. -/\nlemma conformal_at_iff {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F} (h : has_fderiv_at f f' x) :\n  conformal_at f x \u2194 \u2203 (c : \u211d), 0 < c \u2227 \u2200 (u v : E), \u27eaf' u, f' v\u27eb = c * \u27eau, v\u27eb :=\nby simp only [conformal_at_iff', h.fderiv]\n\n/-- The conformal factor of a conformal map at some point `x`. Some authors refer to this function\n    as the characteristic function of the conformal map. -/\ndef conformal_factor_at {f : E \u2192 F} {x : E} (h : conformal_at f x) : \u211d :=\nclassical.some (conformal_at_iff'.mp h)\n\nlemma conformal_factor_at_pos {f : E \u2192 F} {x : E} (h : conformal_at f x) :\n  0 < conformal_factor_at h :=\n(classical.some_spec $ conformal_at_iff'.mp h).1\n\nlemma conformal_factor_at_inner_eq_mul_inner' {f : E \u2192 F} {x : E}\n  (h : conformal_at f x) (u v : E) :\n  \u27ea(fderiv \u211d f x) u, (fderiv \u211d f x) v\u27eb = (conformal_factor_at h : \u211d) * \u27eau, v\u27eb :=\n(classical.some_spec $ conformal_at_iff'.mp h).2 u v\n\nlemma conformal_factor_at_inner_eq_mul_inner {f : E \u2192 F} {x : E} {f' : E \u2192L[\u211d] F}\n  (h : has_fderiv_at f f' x) (H : conformal_at f x) (u v : E) :\n  \u27eaf' u, f' v\u27eb = (conformal_factor_at H : \u211d) * \u27eau, v\u27eb :=\n(H.differentiable_at.has_fderiv_at.unique h) \u25b8 conformal_factor_at_inner_eq_mul_inner' H u v\n"}
{"text": "opaque f : Nat \u2192 Nat\nopaque g : Nat \u2192 Nat\n\nnamespace Foo\n\n@[scoped simp] axiom ax1 (x : Nat) : f (g x) = x\n@[scoped simp] axiom ax2 (x : Nat) : g (g x) = g x\n\nend Foo\n\ntheorem ex1 : f (g (g (g x))) = x := by\n  simp -- does not use ax1 and ax2\n  simp [Foo.ax1, Foo.ax2]\n\ntheorem ex2 : f (g (g (g x))) = x :=\n  have h\u2081 : f (g (g (g x))) = f (g x) := by simp; /- try again with `Foo` scoped lemmas -/ open Foo in simp\n  have h\u2082 : f (g x) = x               := by simp; open Foo in simp\n  Eq.trans h\u2081 h\u2082\n  -- open Foo in simp -- works\n\ntheorem ex3 : f (g (g (g x))) = x := by\n  simp\n  simp [Foo.ax1, Foo.ax2]\n\nopen Foo in\ntheorem ex4 : f (g (g (g x))) = x := by\n  simp\n\ntheorem ex5 : f (g (g (g x))) = x \u2227 f (g x) = x := by\n  apply And.intro\n  { simp; open Foo in simp }\n  { simp; open Foo in simp }\n"}
{"text": "theorem ex1 (p q r : Prop) (h1 : p \u2228 q) (h2 : p \u2192 q) : q := by\n\ntheorem ex2 (p q r : Prop) (h1 : p \u2228 q) (h2 : p \u2192 q) : q := by\n  cases h1\n  case inl =>\n"}
{"text": "[STATEMENT]\nlemma ensures_simple:\n  \"\\<lbrakk> \\<turnstile> $P \\<and> N \\<longrightarrow> P` \\<or> Q`;\n      \\<turnstile> ($P \\<and> N) \\<and> A \\<longrightarrow> Q`\n   \\<rbrakk> \\<Longrightarrow> \\<turnstile> \\<box>N \\<and> \\<box>\\<diamond>A \\<longrightarrow> (P \\<leadsto> Q)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>\\<turnstile> $P \\<and> N \\<longrightarrow> P$ \\<or> Q$; \\<turnstile> ($P \\<and> N) \\<and> A \\<longrightarrow> Q$\\<rbrakk> \\<Longrightarrow> \\<turnstile> \\<box>N \\<and> \\<box>\\<diamond>A \\<longrightarrow> (P \\<leadsto> Q)\n[PROOF STEP]\napply clarsimp\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<And>sigma. \\<lbrakk>\\<turnstile> $P \\<and> N \\<longrightarrow> P$ \\<or> Q$; \\<turnstile> ($P \\<and> N) \\<and> A \\<longrightarrow> Q$; sigma \\<Turnstile> \\<box>N; sigma \\<Turnstile> \\<box>\\<diamond>A\\<rbrakk> \\<Longrightarrow> sigma \\<Turnstile> P \\<leadsto> Q\n[PROOF STEP]\napply (erule (2) ensures [temp_use])\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<And>sigma. \\<lbrakk>\\<turnstile> ($P \\<and> N) \\<and> A \\<longrightarrow> Q$; sigma \\<Turnstile> \\<box>N; sigma \\<Turnstile> \\<box>\\<diamond>A\\<rbrakk> \\<Longrightarrow> sigma \\<Turnstile> \\<box>(\\<box>P \\<longrightarrow> \\<diamond>A)\n[PROOF STEP]\napply (force elim!: STL4E [temp_use])\n[PROOF STATE]\nproof (prove)\ngoal:\nNo subgoals!\n[PROOF STEP]\ndone"}
{"text": "import data.real.basic\nimport data.polynomial.basic\nimport data.polynomial.ring_division\nimport data.complex.basic\n\ntheorem USAMO_Problem_3_1977 (a b : \u2102): \n(a \u2208 polynomial.roots ((polynomial.monomial 4 (1:\u2102 ) ) + (polynomial.monomial 3 (1:\u2102) ) - 1) \u2227 \nb \u2208 polynomial.roots ((polynomial.monomial 4 (1:\u2102) ) + (polynomial.monomial 3 (1:\u2102) ) - 1)) \u2192 \n\n(a*b) \u2208 polynomial.roots (polynomial.monomial 6 (1:\u2102 ) + \npolynomial.monomial 4 (1:\u2102 ) + \npolynomial.monomial 3 (1:\u2102 ) -\npolynomial.monomial 2 (1:\u2102 ) -1)\n\n := sorry\n\n\n\n\n"}
{"text": "example : \u2203 a : \u2115, 5 = a :=\nbegin\n  apply exists.intro,\n  reflexivity\nend\n"}
{"text": "/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n\n! This file was ported from Lean 3 source module data.fin.tuple.bubble_sort_induction\n! leanprover-community/mathlib commit 50832daea47b195a48b5b33b1c8b2162c48c3afc\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Data.Fin.Tuple.Sort\nimport Mathbin.Data.Fintype.Perm\nimport Mathbin.Order.WellFounded\n\n/-!\n# \"Bubble sort\" induction\n\n> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.\n> Any changes to this file require a corresponding PR to mathlib4.\n\nWe implement the following induction principle `tuple.bubble_sort_induction`\non tuples with values in a linear order `\u03b1`.\n\nLet `f : fin n \u2192 \u03b1` and let `P` be a predicate on `fin n \u2192 \u03b1`. Then we can show that\n`f \u2218 sort f` satisfies `P` if `f` satisfies `P`, and whenever some `g : fin n \u2192 \u03b1`\nsatisfies `P` and `g i > g j` for some `i < j`, then `g \u2218 swap i j` also satisfies `P`.\n\nWe deduce it from a stronger variant `tuple.bubble_sort_induction'`, which\nrequires the assumption only for `g` that are permutations of `f`.\n\nThe latter is proved by well-founded induction via `well_founded.induction_bot'`\nwith respect to the lexicographic ordering on the finite set of all permutations of `f`.\n-/\n\n\nnamespace Tuple\n\n#print Tuple.bubble_sort_induction' /-\n/-- *Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satsifies `P` and `P` is preserved on permutations of `f` when swapping two\nantitone values. -/\ntheorem bubble_sort_induction' {n : \u2115} {\u03b1 : Type _} [LinearOrder \u03b1] {f : Fin n \u2192 \u03b1}\n    {P : (Fin n \u2192 \u03b1) \u2192 Prop} (hf : P f)\n    (h :\n      \u2200 (\u03c3 : Equiv.Perm (Fin n)) (i j : Fin n),\n        i < j \u2192 (f \u2218 \u03c3) j < (f \u2218 \u03c3) i \u2192 P (f \u2218 \u03c3) \u2192 P (f \u2218 \u03c3 \u2218 Equiv.swap i j)) :\n    P (f \u2218 sort f) :=\n  by\n  letI := @Preorder.lift _ (Lex (Fin n \u2192 \u03b1)) _ fun \u03c3 : Equiv.Perm (Fin n) => toLex (f \u2218 \u03c3)\n  refine'\n    @WellFounded.induction_bot' _ _ _ (@Finite.Preorder.wellFounded_lt (Equiv.Perm (Fin n)) _ _)\n      (Equiv.refl _) (sort f) P (fun \u03c3 => f \u2218 \u03c3) (fun \u03c3 h\u03c3 hf\u03c3 => _) hf\n  obtain \u27e8i, j, hij\u2081, hij\u2082\u27e9 := antitone_pair_of_not_sorted' h\u03c3\n  exact \u27e8\u03c3 * Equiv.swap i j, Pi.lex_desc hij\u2081 hij\u2082, h \u03c3 i j hij\u2081 hij\u2082 hf\u03c3\u27e9\n#align tuple.bubble_sort_induction' Tuple.bubble_sort_induction'\n-/\n\n#print Tuple.bubble_sort_induction /-\n/-- *Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satsifies `P` and `P` is preserved when swapping two antitone values. -/\ntheorem bubble_sort_induction {n : \u2115} {\u03b1 : Type _} [LinearOrder \u03b1] {f : Fin n \u2192 \u03b1}\n    {P : (Fin n \u2192 \u03b1) \u2192 Prop} (hf : P f)\n    (h : \u2200 (g : Fin n \u2192 \u03b1) (i j : Fin n), i < j \u2192 g j < g i \u2192 P g \u2192 P (g \u2218 Equiv.swap i j)) :\n    P (f \u2218 sort f) :=\n  bubble_sort_induction' hf fun \u03c3 => h _\n#align tuple.bubble_sort_induction Tuple.bubble_sort_induction\n-/\n\nend Tuple\n\n"}
{"text": "informal statement Let $H \\leq K \\leq G$. Prove that $|G: H|=|G: K| \\cdot|K: H|$ (do not assume $G$ is finite).formal statement theorem exercise_3_2_11 {G : Type*} [group G] {H K : subgroup G}\n  (hHK : H \u2264 K) : \n  H.index = K.index * H.relindex K :="}
{"text": "\nuniverse u\nvariable {\u03b1 : Type u}\n\ndef split : List \u03b1 \u2192 List \u03b1 \u00d7 List \u03b1\n| []       => ([], [])\n| [a]      => ([a], [])\n| a::b::as => (a :: (split as).1, b :: (split as).2)\n\ntheorem ex1 : split [1, 2, 3, 4, 5] = ([1, 3, 5], [2, 4]) :=\nrfl\n"}
{"text": "{-# OPTIONS --erased-cubical #-}\n\nmodule Erased-cubical-Open-public.Erased (_ : Set\u2081) where\n\npostulate\n  A : Set\n"}
{"text": "theory Scratch\n  imports Main\nbegin\n  lemma \"1=1\" by simp\nend"}
{"text": "universes u v\n\ninductive Vec2 (\u03b1 : Type u) (\u03b2 : Type v) : Nat \u2192 Type (max u v)\n| nil  : Vec2 \u03b1 \u03b2 0\n| cons : \u03b1 \u2192 \u03b2 \u2192 forall {n}, Vec2 \u03b1 \u03b2 n \u2192 Vec2 \u03b1 \u03b2 (n+1)\n\ninductive Fin2 : Nat \u2192 Type\n| zero (n : Nat)              : Fin2 (n+1)\n| succ {n : Nat} (s : Fin2 n) : Fin2 (n+1)\n\ntheorem test1 {\u03b1 \u03b2} {n} (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) (v w : Vec2 \u03b1 \u03b2 n) (h : Vec2.cons a\u2081 b\u2081 v = Vec2.cons a\u2082 b\u2082 w) : a\u2081 = a\u2082 :=\nby {\n  injection h;\n  assumption\n}\n\ntheorem test2 {\u03b1 \u03b2} {n} (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) (v w : Vec2 \u03b1 \u03b2 n) (h : Vec2.cons a\u2081 b\u2081 v = Vec2.cons a\u2082 b\u2082 w) : v = w :=\nby {\n  injection h with h1 h2 h3 h4;\n  assumption\n}\n\ntheorem test3 {\u03b1 \u03b2} {n} (a\u2081 a\u2082 : \u03b1) (b\u2081 b\u2082 : \u03b2) (v w : Vec2 \u03b1 \u03b2 n) (h : Vec2.cons a\u2081 b\u2081 v = Vec2.cons a\u2082 b\u2082 w) : v = w :=\nby {\n  injection h with _ _ _ h4;\n  exact h4\n}\n\ntheorem test4 {\u03b1} (v : Fin2 0) : \u03b1 :=\nby cases v\n\ndef test5 {\u03b1 \u03b2} {n} (v : Vec2 \u03b1 \u03b2 (n+1)) : \u03b1 := by\n  cases v with\n  | cons h1 h2 n tail => exact h1\n\ndef test6 {\u03b1 \u03b2} {n} (v : Vec2 \u03b1 \u03b2 (n+2)) : \u03b1 := by\n  cases v with\n  | cons h1 h2 n tail => exact h1\n"}
{"text": "def f (a : Array Nat) (i : Nat) (v : Nat) (h : i < a.size) : Array Nat :=\n  a.set \u27e8i, h\u27e9 (a.get \u27e8i, h\u27e9 + v)\n\nset_option pp.proofs true\n\ntheorem ex1 (h\u2083 : i = j) : f a i (0 + v) h\u2081 = f a j v h\u2082 := by\n  simp\n  trace_state\n  simp [h\u2083]\n\ntheorem ex2 (h\u2083 : i = j) : f a (0 + i) (0 + v) h\u2081 = f a j v h\u2082 := by\n  simp\n  trace_state\n  simp [h\u2083]\n\ntheorem ex3 (h\u2083 : i = j) : f a (0 + i) (0 + v) h\u2081 = f a j v h\u2082 := by\n  simp [h\u2083]\n"}
{"text": "@[simp] theorem liftOn_mk (a : \u03b1) (f : \u03b1 \u2192 \u03b3) (h : \u2200 a\u2081 a\u2082, r a\u2081 a\u2082 \u2192 f a\u2081 = f a\u2082) :\n    Quot.liftOn (Quot.mk r a) f h = f a := rfl\n\ntheorem eq_iff_true_of_subsingleton [Subsingleton \u03b1] (x y : \u03b1) : x = y \u2194 True :=\n  iff_true _ \u25b8 Subsingleton.elim ..\n\nsection attribute [simp] eq_iff_true_of_subsingleton end\n\n@[simp] theorem PUnit.default_eq_unit : (default : PUnit) = PUnit.unit := rfl\n\nset_option trace.Meta.Tactic.simp.discharge true\nset_option trace.Meta.Tactic.simp.unify true\nset_option trace.Meta.Tactic.simp.rewrite true\nexample : (default : PUnit) = x := by simp\n"}
{"text": "section {* \\isaheader{Generic Compare Algorithms} *}\ntheory Gen_Comp\nimports \n  \"../Intf/Intf_Comp\" \n  \"../../../Automatic_Refinement/Automatic_Refinement\"\nbegin\n\nsubsection {* Order for Product *}\n(* TODO: Optimization? Or only go via prod_cmp? *)\nlemma autoref_prod_cmp_dflt_id[autoref_rules_raw]: \n  \"(dflt_cmp op \\<le> op <, dflt_cmp op \\<le> op <) \\<in>\n    \\<langle>Id,Id\\<rangle>prod_rel \\<rightarrow> \\<langle>Id,Id\\<rangle>prod_rel \\<rightarrow> Id\"\n  by auto\n\nlemma gen_prod_cmp_dflt[autoref_rules_raw]:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes \"GEN_OP cmp1 (dflt_cmp op \\<le> op <) (R1 \\<rightarrow> R1 \\<rightarrow> Id)\"\n  assumes \"GEN_OP cmp2 (dflt_cmp op \\<le> op <) (R2 \\<rightarrow> R2 \\<rightarrow> Id)\"\n  shows \"(cmp_prod cmp1 cmp2, dflt_cmp op \\<le> op <) \\<in>\n    \\<langle>R1,R2\\<rangle>prod_rel \\<rightarrow> \\<langle>R1,R2\\<rangle>prod_rel \\<rightarrow> Id\"\nproof -\n  have E: \"dflt_cmp op \\<le> op < \n    = cmp_prod (dflt_cmp op \\<le> op <) (dflt_cmp op \\<le> op <)\"\n    by (auto simp: dflt_cmp_def prod_less_def prod_le_def intro!: ext)\n\n  show ?thesis\n    using assms\n    unfolding autoref_tag_defs E\n    by parametricity\nqed\n\n\nend\n"}
{"text": "--\n\n/-\nThis example demonstratea that when we are using `nativeDecide`,\nwe are also trusting the correctness of `implementedBy` annotations,\nforeign functions (i.e., `[extern]` annotations), etc.\n-/\ndef g (b : Bool) := false\n\n/-\nThe following `implementedBy` is telling the compiler\n\"trust me, `g` does implement `f`\"\nwhich is clearly false in this example.\n-/\n@[implementedBy g]\ndef f (b : Bool) := b\n\ntheorem fConst (b : Bool) : f b = false :=\nmatch b with\n| true  =>\n  /- The following `nativeDecide` is going to use `g` to evaluate `f`\n     because of the `implementedBy` directive. -/\n  have : (f true) = false := by nativeDecide\n  this\n| false => rfl\n\ntheorem trueEqFalse : true = false :=\nhave h\u2081 : f true = true  := rfl;\nhave h\u2082 : f true = false := fConst true;\nEq.trans h\u2081.symm h\u2082\n\n/-\nWe managed to prove `False` using the unsound annotation `implementedBy` above.\n-/\ntheorem unsound : False :=\nBool.noConfusion trueEqFalse\n\n#print axioms unsound -- axiom 'Lean.ofReduceBool' is listed\n"}
{"text": "[GOAL]\n\u22a2 DivisionRing \u211a\n[PROOFSTEP]\ninfer_instance\n"}
{"text": "informal statement Show that there are infinitely many primes congruent to $-1$ modulo 6 .formal statement theorem exercise_3_1 : infinite {p : primes // p \u2261 -1 [ZMOD 6]} :="}
{"text": "/-| \nHello World!\n-/\n#print \"Hello World!\"\n\n/-|\nA literate comment!\n-/\n\ntheorem exampleTheorem (p q : Prop) (hp : p) (hq : q) : p \u2227 q \u2227 p := by\n  apply And.intro\n  . exact hp\n  . sorry"}
{"text": "class Preorder (\u03b1 : Type u) extends LE \u03b1 where\n  le_refl  (a : \u03b1) : a \u2264 a\n  le_trans {a b c : \u03b1} : a \u2264 b \u2192 b \u2264 c \u2192 a \u2264 c\n\ninstance {\u03b1 : Type u} {\u03b2 : \u03b1 \u2192 Type v} [(a : \u03b1) \u2192 Preorder (\u03b2 a)] : Preorder ((a : \u03b1) \u2192 \u03b2 a) where\n  le f g := \u2200 a, f a \u2264 g a\n  le_refl f  := fun a => Preorder.le_refl (f a)\n  le_trans   := fun h\u2081 h\u2082 a => Preorder.le_trans (h\u2081 a) (h\u2082 a)\n\n-- In Lean 3, we defined `monotone` using the strict implicit notation `{{ ... }}`.\n-- Implicit lambdas in Lean 4 allow us to use the regular `{...}`\ndef Monotone [Preorder \u03b1] [Preorder \u03b2] (f : \u03b1 \u2192 \u03b2) :=\n  \u2200 {a b}, a \u2264 b \u2192 f a \u2264 f b\n\ntheorem monotone_id [Preorder \u03b1] : Monotone (\u03b1 := \u03b1) id :=\n  fun h => h\n\ntheorem monotone_id' [Preorder \u03b1] : Monotone (\u03b1 := \u03b1) id :=\n  @fun a b h => h -- `@` disables implicit lambdas\n\ntheorem monotone_id'' [Preorder \u03b1] : Monotone (\u03b1 := \u03b1) id :=\n  fun {a b} (h : a \u2264 b) => h -- `{a b}` disables implicit lambdas\n\ntheorem monotone_const [Preorder \u03b1] [Preorder \u03b2] (b : \u03b2) : Monotone (fun a : \u03b1 => b) :=\n  fun _ => Preorder.le_refl b\n\ntheorem monotone_comp [Preorder \u03b1] [Preorder \u03b2] [Preorder \u03b3] {g : \u03b2 \u2192 \u03b3} {f : \u03b1 \u2192 \u03b2} (m_g : Monotone g) (m_f : Monotone f) : Monotone (g \u2218 f) :=\n  fun h => m_g (m_f h)\n\ntheorem monotone_fun [Preorder \u03b1] [Preorder \u03b3] {f : \u03b1 \u2192 \u03b2 \u2192 \u03b3} (m : (b : \u03b2) \u2192 Monotone (fun a => f a b)) : Monotone f :=\n  fun h b => m b h\n\ntheorem ex [Preorder \u03b1] {f g h : \u03b1 \u2192 \u03b1} (m_h : Monotone h) (m_g : Monotone g) (m_f : Monotone f) : Monotone (h \u2218 g \u2218 f) :=\n  monotone_comp m_h (monotone_comp m_g m_f) -- implicit lambdas in action here\n"}
{"text": "From stdpp Require Import base tactics.\n\n(** Test parsing of variants of [(\u2261)] notation. *)\nLemma test_equiv_annot_sections `{!Equiv A, !Equivalence (\u2261@{A})} (x : A) :\n  x \u2261@{A} x \u2227 (\u2261@{A}) x x \u2227 (x \u2261.) x \u2227 (.\u2261 x) x \u2227\n  ((x \u2261@{A} x)) \u2227 ((\u2261@{A})) x x \u2227 ((x \u2261.)) x \u2227 ((.\u2261 x)) x \u2227\n  ( x \u2261@{A} x) \u2227 ( x \u2261.) x \u2227\n  (x \u2261@{A} x ) \u2227 (\u2261@{A} ) x x \u2227 (.\u2261 x ) x.\nProof. naive_solver. Qed.\n"}
{"text": "import LeanCodePrompts.FirstTacticFinder\nimport Mathlib.Tactic.Basic\nimport Mathlib.Tactic.Use\nimport Mathlib\n\n-- example : \u2200 n : \u2115, \u2203 m : \u2115, n < 2 * m + 1 := by\n--   repeat (aide_lookahead)\n--   repeat (sorry)\n\nset_option trace.Translate.info true\nexample : \u2200 n : \u2115, \u2203 m : \u2115, n < 2 * m + 1 := by\n  show_tactic_prompt\n  aide\n  aide\n  aide  \n  repeat (sorry)\n\n\n"}
{"text": "informal statement Show that if $X$ is normal, every pair of disjoint closed sets have neighborhoods whose closures are disjoint.formal statement theorem exercise_32_1 {X : Type*} [topological_space X]\n  (hX : normal_space X) (A : set X) (hA : is_closed A) :\n  normal_space {x // x \u2208 A} :="}
{"text": "theorem P_implies_P (P : Prop) : P \u2192 P :=\nbegin\n  intro HP,\n  exact HP\nend\n"}
{"text": "import Mathlib.Data.Nat.Basic\n\ntheorem rangeDecompose (start mid stop : \u2115) (hs : start \u2264 mid \u2227 mid \u2264 stop)\n  {f : \u2115 \u2192 \u03b2 \u2192 Id (ForInStep \u03b2)} :\n  STD.forIn (mkRange' start stop) init f =\n    STD.forIn (mkRange' mid stop) (Id.run (STD.forIn (mkRange' start mid) init f)) f := by\n  sorry"}
{"text": "import help data.nat.prime\n\nopen nat\n\ntheorem Euclid (n : \u2115) : \u2203 p \u2265 n, prime p :=\nbegin\n  let N := n.fact + 1,\n  let p := min_fac N,\n  use_this p,\n  have p_is_prime : prime p := min_fac_prime _,\n  split,\n    show p \u2265 n,\n    by_contradiction,\n    have key_fact : p \u2223 n.fact := dvd_fact _ _,\n    have oops : p \u2223 1,\n  all_goals { auto },\nend"}
{"text": "lemma lt_aux_one (a b : mynat) : a \u2264 b \u2227 \u00ac (b \u2264 a) \u2192 succ a \u2264 b :=\nbegin\nintro h,\ncases h with h1 h2,\ncases h1 with c h1,\ncases c,\nrw add_zero at h1,\nrw h1 at h2,\nexfalso,\nexact h2 (le_refl a),\nrwa [h1, add_succ],\napply succ_le_succ,\nuse c,\nrefl,\nend\n"}
{"text": "(*  Title:      HOL/ex/PresburgerEx.thy\n    Author:     Amine Chaieb, TU Muenchen\n*)\n\nsection {* Some examples for Presburger Arithmetic *}\n\ntheory PresburgerEx\nimports Presburger\nbegin\n\nlemma \"\\<And>m n ja ia. \\<lbrakk>\\<not> m \\<le> j; \\<not> (n::nat) \\<le> i; (e::nat) \\<noteq> 0; Suc j \\<le> ja\\<rbrakk> \\<Longrightarrow> \\<exists>m. \\<forall>ja ia. m \\<le> ja \\<longrightarrow> (if j = ja \\<and> i = ia then e else 0) = 0\" by presburger\nlemma \"(0::nat) < emBits mod 8 \\<Longrightarrow> 8 + emBits div 8 * 8 - emBits = 8 - emBits mod 8\" \nby presburger\nlemma \"(0::nat) < emBits mod 8 \\<Longrightarrow> 8 + emBits div 8 * 8 - emBits = 8 - emBits mod 8\" \nby presburger\n\ntheorem \"(\\<forall>(y::int). 3 dvd y) ==> \\<forall>(x::int). b < x --> a \\<le> x\"\n  by presburger\n\ntheorem \"!! (y::int) (z::int) (n::int). 3 dvd z ==> 2 dvd (y::int) ==>\n  (\\<exists>(x::int).  2*x =  y) & (\\<exists>(k::int). 3*k = z)\"\n  by presburger\n\ntheorem \"!! (y::int) (z::int) n. Suc(n::nat) < 6 ==>  3 dvd z ==>\n  2 dvd (y::int) ==> (\\<exists>(x::int).  2*x =  y) & (\\<exists>(k::int). 3*k = z)\"\n  by presburger\n\ntheorem \"\\<forall>(x::nat). \\<exists>(y::nat). (0::nat) \\<le> 5 --> y = 5 + x \"\n  by presburger\n\ntext{*Slow: about 7 seconds on a 1.6GHz machine.*}\ntheorem \"\\<forall>(x::nat). \\<exists>(y::nat). y = 5 + x | x div 6 + 1= 2\"\n  by presburger\n\ntheorem \"\\<exists>(x::int). 0 < x\"\n  by presburger\n\ntheorem \"\\<forall>(x::int) y. x < y --> 2 * x + 1 < 2 * y\"\n  by presburger\n \ntheorem \"\\<forall>(x::int) y. 2 * x + 1 \\<noteq> 2 * y\"\n  by presburger\n \ntheorem \"\\<exists>(x::int) y. 0 < x  & 0 \\<le> y  & 3 * x - 5 * y = 1\"\n  by presburger\n\ntheorem \"~ (\\<exists>(x::int) (y::int) (z::int). 4*x + (-6::int)*y = 1)\"\n  by presburger\n\ntheorem \"\\<forall>(x::int). b < x --> a \\<le> x\"\n  apply (presburger elim)\n  oops\n\ntheorem \"~ (\\<exists>(x::int). False)\"\n  by presburger\n\ntheorem \"\\<forall>(x::int). (a::int) < 3 * x --> b < 3 * x\"\n  apply (presburger elim)\n  oops\n\ntheorem \"\\<forall>(x::int). (2 dvd x) --> (\\<exists>(y::int). x = 2*y)\"\n  by presburger \n\ntheorem \"\\<forall>(x::int). (2 dvd x) --> (\\<exists>(y::int). x = 2*y)\"\n  by presburger \n\ntheorem \"\\<forall>(x::int). (2 dvd x) = (\\<exists>(y::int). x = 2*y)\"\n  by presburger \n\ntheorem \"\\<forall>(x::int). ((2 dvd x) = (\\<forall>(y::int). x \\<noteq> 2*y + 1))\"\n  by presburger \n\ntheorem \"~ (\\<forall>(x::int). \n            ((2 dvd x) = (\\<forall>(y::int). x \\<noteq> 2*y+1) | \n             (\\<exists>(q::int) (u::int) i. 3*i + 2*q - u < 17)\n             --> 0 < x | ((~ 3 dvd x) &(x + 8 = 0))))\"\n  by presburger\n \ntheorem \"~ (\\<forall>(i::int). 4 \\<le> i --> (\\<exists>x y. 0 \\<le> x & 0 \\<le> y & 3 * x + 5 * y = i))\"\n  by presburger\n\ntheorem \"\\<forall>(i::int). 8 \\<le> i --> (\\<exists>x y. 0 \\<le> x & 0 \\<le> y & 3 * x + 5 * y = i)\"\n  by presburger\n\ntheorem \"\\<exists>(j::int). \\<forall>i. j \\<le> i --> (\\<exists>x y. 0 \\<le> x & 0 \\<le> y & 3 * x + 5 * y = i)\"\n  by presburger\n\ntheorem \"~ (\\<forall>j (i::int). j \\<le> i --> (\\<exists>x y. 0 \\<le> x & 0 \\<le> y & 3 * x + 5 * y = i))\"\n  by presburger\n\ntext{*Slow: about 5 seconds on a 1.6GHz machine.*}\ntheorem \"(\\<exists>m::nat. n = 2 * m) --> (n + 1) div 2 = n div 2\"\n  by presburger\n\ntext{* This following theorem proves that all solutions to the\nrecurrence relation $x_{i+2} = |x_{i+1}| - x_i$ are periodic with\nperiod 9.  The example was brought to our attention by John\nHarrison. It does does not require Presburger arithmetic but merely\nquantifier-free linear arithmetic and holds for the rationals as well.\n\nWarning: it takes (in 2006) over 4.2 minutes! *}\n\nlemma \"\\<lbrakk> x3 = abs x2 - x1; x4 = abs x3 - x2; x5 = abs x4 - x3;\n         x6 = abs x5 - x4; x7 = abs x6 - x5; x8 = abs x7 - x6;\n         x9 = abs x8 - x7; x10 = abs x9 - x8; x11 = abs x10 - x9 \\<rbrakk>\n \\<Longrightarrow> x1 = x10 & x2 = (x11::int)\"\nby arith\n\nend\n"}
{"text": "informal statement Show that any subgroup of order $p^{n-1}$ in a group $G$ of order $p^n$ is normal in $G$.formal statement theorem exercise_4_1_19 : infinite {x : quaternion \u211d | x^2 = -1} :="}
{"text": "import tactic\n\nvariable X : Type\n\ntheorem reflexive_of_symmetric_transitive_and_connected\n  (r : X \u2192 X \u2192 Prop)\n  (h_symm : \u2200 x y : X, r x y \u2192 r y x)\n  (h_trans : \u2200 x y z : X, r x y \u2192 r y z \u2192 r x z)\n  (h_connected : \u2200 x, \u2203 y, r x y)\n: (\u2200 x : X, r x x) :=\nbegin\n  sorry,\nend"}
{"text": "module Main\n\n\nmutual\n  %inline\n  is_even : Int -> Int\n  is_even n =\n      if n == 0 then 1 else is_odd $ n-1\n\n  is_odd : Int -> Int\n  is_odd n =\n      if n == 0 then 0 else is_even $ n-1\n\nmain : JS_IO ()\nmain = do\n  putStr' $ show $ is_even 100001\n"}
{"text": "informal statement Define $\\wedge(n)=\\log p$ if $n$ is a power of $p$ and zero otherwise. Prove that $\\sum_{A \\mid n} \\mu(n / d) \\log d$ $=\\wedge(n)$.formal statement theorem exercise_3_1 : infinite {p : primes // p \u2261 -1 [ZMOD 6]} :="}
{"text": "lemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\nbegin\nby_cases p : P; by_cases q : Q,\nintros h p2,\nexact q,\nrepeat { tauto! },\nend"}
{"text": "informal statement If $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, C_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ has at least one real root between 0 and 1.formal statement theorem exercise_5_6\n  {f : \u211d \u2192 \u211d}\n  (hf1 : continuous f)\n  (hf2 : \u2200 x, differentiable_at \u211d f x)\n  (hf3 : f 0 = 0)\n  (hf4 : monotone (deriv f)) :\n  monotone_on (\u03bb x, f x / x) (set.Ioi 0) :="}
{"text": "\n\ntheorem tst0 (x : Nat) : x + 0 = x + 0 :=\nby {\n  generalize x + 0 = y;\n  exact (Eq.refl y)\n}\n\ntheorem tst1 (x : Nat) : x + 0 = x + 0 :=\nby {\n  generalize h : x + 0 = y;\n  exact (Eq.refl y)\n}\n\ntheorem tst2 (x y w : Nat) (h : y = w) : (x + x) + w  = (x + x) + y :=\nby {\n  generalize h' : x + x = z;\n  subst y;\n  exact Eq.refl $ z + w\n}\n\ntheorem tst3 (x y w : Nat) (h : x + x = y) : (x + x) + (x+x)  = (x + x) + y :=\nby {\n  generalize h' : x + x = z;\n  subst z;\n  subst y;\n  exact rfl\n}\n\ntheorem tst4 (x y w : Nat) (h : y = w) : (x + x) + w  = (x + x) + y :=\nby {\n  generalize h' : x + y = z; -- just add equality\n  subst h;\n  exact rfl\n}\n"}
{"text": "open import Relation.Binary.Core\n\nmodule TreeSort.Impl2.Correctness.Order  {A : Set}\n                  (_\u2264_ : A \u2192 A \u2192 Set)\n                  (tot\u2264 : Total _\u2264_) \n                  (trans\u2264 : Transitive _\u2264_)  where\n\nopen import BBSTree _\u2264_ \nopen import BBSTree.Properties _\u2264_ trans\u2264\nopen import Data.List\nopen import Function using (_\u2218_)\nopen import List.Sorted _\u2264_\nopen import TreeSort.Impl2 _\u2264_ tot\u2264\n\ntheorem-treeSort-sorted : (xs : List A) \u2192 Sorted (flatten (treeSort xs))\ntheorem-treeSort-sorted = lemma-bbst-sorted \u2218 treeSort\n\n\n\n\n"}
{"text": "abbrev M := ExceptT String <| StateT Nat Id\n\ndef f (xs : List Nat) : M Unit := do\nfor x in xs do\n  if x == 0 then\n    throw \"contains zero\"\n\n#eval f [1, 2, 3] |>.run' 0\n#eval f [1, 0, 3] |>.run' 0\n\ntheorem ex1 : (f [1, 2, 3] |>.run' 0) = Except.ok () :=\nrfl\n\ntheorem ex2 : (f [1, 0, 3] |>.run' 0) = Except.error \"contains zero\" :=\nrfl\n\nuniverse u\n\nabbrev N := ExceptT (ULift.{u} String) Id\n\ndef idM {\u03b1 : Type u} (a : \u03b1) : N \u03b1 :=\npure a\n\ndef checkEq {\u03b1 : Type u} [BEq \u03b1] [ToString \u03b1] (a b : \u03b1) : N PUnit := do\nunless a == b do\n  throw (ULift.up s!\"{a} is not equal to {b}\")\n\ndef g {\u03b1 : Type u} [BEq \u03b1] [ToString \u03b1] (xs : List \u03b1) (a : \u03b1) : N PUnit := do\nfor x in xs do\n  let a \u2190 idM a\n  checkEq x a\n\n#eval g [1, (2:Nat), 3] 1 |>.run\n"}
{"text": "lemma zero_le (a : mynat) : 0 \u2264 a :=\nbegin\nrw le_iff_exists_add,\nuse a,\nrwa zero_add,\nend\n"}
{"text": "/- \n\n# Advanced proposition world. \n\n## Level 3: and_trans.\n-/\n\n/- Lemma\nIf $P$, $Q$ and $R$ are true/false statements, then $P\\land Q$ and\n$Q\\land R$ together imply $P\\land R$.\n-/\nlemma and_trans (P Q R : Prop) : P \u2227 Q \u2192 Q \u2227 R \u2192 P \u2227 R :=\nbegin\n  intro hpq,\n  intro hqr,\n  cases hpq with p q,\n  cases hqr with q' r,\n  split,\n  assumption,\n  assumption,\n\n\nend\n"}
{"text": "informal statement Show that $\\int_0^1 \\log(\\sin \\pi x) dx = - \\log 2$.formal statement theorem exercise_3_9 : \u222b x in 0..1, real.log (real.sin (real.pi * x)) = - real.log 2 :="}
{"text": "module ModusPonens where\n\nmodusPonens : \u2200 {P Q : Set} \u2192 (P \u2192 Q) \u2192 P \u2192 Q\nmodusPonens x = x\n"}
{"text": "[STATEMENT]\nlemma HIm_nth [simp]:\n  \"HIm x $ 1 = Im1 x\" \"HIm x $ 2 = Im2 x\" \"HIm x $ 3 = Im3 x\"  \"HIm x $ 4 = Im4 x\"\n  \"HIm x $ 5 = Im5 x\" \"HIm x $ 6 = Im6 x\" \"HIm x $ 7 = Im7 x\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. (HIm x $ 1 = Im1 x &&& HIm x $ 2 = Im2 x &&& HIm x $ 3 = Im3 x) &&& (HIm x $ 4 = Im4 x &&& HIm x $ 5 = Im5 x) &&& HIm x $ 6 = Im6 x &&& HIm x $ 7 = Im7 x\n[PROOF STEP]\nby (simp_all add: HIm_def)"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\n/--\nSuppose that $f(x+3)=3x^2 + 7x + 4$ and $f(x)=ax^2 + bx + c$. What is $a+b+c$?\nAnswer: $2$\n--/\ntheorem amc12a_2009_p9\n  (a b c : \u211d)\n  (f : \u211d \u2192 \u211d)\n  (h\u2080 : \u2200 x, f (x + 3) = 3 * x^2 + 7 * x + 4)\n  (h\u2081 : \u2200 x, f x = a * x^2 + b * x + c) :\n  a + b + c = 2 :=\nbegin\n  simp [*, pow_succ'] at *,\n  linarith [h\u2080 0, h\u2080 1, h\u2080 2],\nend"}
{"text": "\n\ntheorem tst1 (x y z : Nat) : y = z \u2192 x = x \u2192 x = y \u2192 x = z :=\nby {\n  intros h1 h2 h3;\n  revert h2;\n  intro h2;\n  exact Eq.trans h3 h1\n}\n\ntheorem tst2 (x y z : Nat) : y = z \u2192 x = x \u2192 x = y \u2192 x = z :=\nby {\n  intros h1 h2 h3;\n  revert y;\n  intros y hb ha;\n  exact Eq.trans ha hb\n}\n\ntheorem tst3 (x y z : Nat) : y = z \u2192 x = x \u2192 x = y \u2192 x = z := by\n  intros\n  revert \u2039x = y\u203a\n  intro ha\n  exact Eq.trans ha \u2039y = z\u203a\n"}
{"text": "universe u\n\ntheorem instForAll {A : Type u} {f : A \u2192 Prop} {a : A} :\n  (forall a' : A, f a') \u2192 f a := by\n  intro h\n  exact h a\n\ntheorem instEqual\u2081 {A : Type u} {P : A \u2192 Prop} {t : A} :\n  (forall x : A, x = t \u2192 P x) \u2192 P t := by\n  intro h\n  exact h t rfl\n\ntheorem instEqual\u2082 {A : Type u} {P : A \u2192 Prop} {t : A} :\n  P t \u2192 (forall x : A, x = t \u2192 P x) := by\n  intros h x r\n  rewrite [r]\n  exact h\n\ntheorem instEqual {A : Type u} {P : A \u2192 Prop} {t : A} :\n  (forall x : A, x = t \u2192 P x) \u2194 P t := \u27e8instEqual\u2081, instEqual\u2082\u27e9\n\n"}
{"text": "lemma ne_succ_self (n : \u2115) : n \u2260 nat.succ n :=\nbegin\n    \nend"}
{"text": "import data.real.basic\nimport data.set.intervals.unordered_interval\n\ntheorem USAMO_Problem_3_1993 (f : \u211d -> \u211d) [f \u2265 0] [f(1) = 1]:  \n(\u2200 x y : \u211d, (x \u2208 (set.interval (0 : \u211d) (1: \u211d)) \u2227 y \u2208 (set.interval (0 : \u211d) (1: \u211d))) \u2192\n x+y \u2208 (set.interval (0 : \u211d) (1: \u211d)) \u2192 f(x) + f(y) \u2264 f(x+y)) \u2192 \n(\u2200 x : \u211d, x \u2208 (set.interval (0 : \u211d) (1: \u211d)) \u2192 f(x) >= 2*x) \n\u2227 (\u00ac (\u2203 c : \u211d, c < 2 \u2227 (\u2200 x : \u211d, x \u2208 (set.interval (0 : \u211d) (1: \u211d)) \u2192  f(x) >= c*x)))\n:= sorry\n"}
{"text": "informal statement Prove that $\\cos 1^{\\circ}$  is algebraic over $\\mathbb{Q}$.formal statement theorem exercise_5_3_10 : is_algebraic \u211a (cos (real.pi / 180)) :="}
{"text": "lemma convex_prod: assumes \"\\<And>i. i \\<in> Basis \\<Longrightarrow> convex {x. P i x}\" shows \"convex {x. \\<forall>i\\<in>Basis. P i (x\\<bullet>i)}\""}
{"text": "section\nvariables (P Q : Prop)\n\ntheorem my_theorem : P \u2227 Q \u2192 Q \u2227 P :=\nassume h : P \u2227 Q,\nhave P, from and.left h,\nhave Q, from and.right h,\nshow Q \u2227 P, from and.intro \u2039Q\u203a \u2039P\u203a\n\nend\n"}
{"text": "informal statement Let $F = \\mathbb{Z}_p$ be the field of integers $\\mod p$, where $p$ is a prime, and let $q(x) \\in F[x]$ be irreducible of degree $n$. Show that $F[x]/(q(x))$ is a field having at exactly $p^n$ elements.formal statement theorem exercise_4_5_25 {p : \u2115} (hp : nat.prime p) :\n  irreducible (\u2211 i : finset.range p, X ^ p : polynomial \u211a) :="}
{"text": "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Kenny Lau\n-/\n\nimport data.finset.basic\n\n/-!\n# Finsets of ordered types\n-/\n\nuniverses u v w\nvariables {\u03b1 : Type u}\n\ntheorem directed.finset_le {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [is_trans \u03b1 r]\n  {\u03b9} [h\u03b9 : nonempty \u03b9] {f : \u03b9 \u2192 \u03b1} (D : directed r f) (s : finset \u03b9) :\n  \u2203 z, \u2200 i \u2208 s, r (f i) (f z) :=\nshow \u2203 z, \u2200 i \u2208 s.1, r (f i) (f z), from\nmultiset.induction_on s.1 (let \u27e8z\u27e9 := h\u03b9 in \u27e8z, \u03bb _, false.elim\u27e9) $\n\u03bb i s \u27e8j, H\u27e9, let \u27e8k, h\u2081, h\u2082\u27e9 := D i j in\n\u27e8k, \u03bb a h, or.cases_on (multiset.mem_cons.1 h)\n  (\u03bb h, h.symm \u25b8 h\u2081)\n  (\u03bb h, trans (H _ h) h\u2082)\u27e9\n\ntheorem finset.exists_le {\u03b1 : Type u} [nonempty \u03b1] [directed_order \u03b1] (s : finset \u03b1) :\n  \u2203 M, \u2200 i \u2208 s, i \u2264 M :=\ndirected.finset_le directed_order.directed s\n"}
{"text": "lemma of_real_0 [simp]: \"of_real 0 = 0\""}
{"text": "import PnP2023.Lec_01_25.Answer\n\nnamespace Waffle\n\ntheorem Answer.eq_of_le_le (a b  : Answer) : \n  a \u2264 b \u2192 b \u2264 a \u2192 a = b := by  sorry"}
{"text": "example : \u2200 a b c : \u2115, a = b \u2192 a = c \u2192 c = b :=\nbegin\n  intros,\n  transitivity,\n  symmetry,\n  assumption,\n  assumption\nend\n"}
{"text": "lemma reflect_poly_0 [simp]: \"reflect_poly 0 = 0\""}
{"text": "lemma frontier_empty [simp]: \"frontier {} = {}\""}
{"text": "/-\nCopyright (c) 2015 Robert Y. Lewis. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Robert Y. Lewis, Jeremy Avigad\n\nThe square root function.\n-/\nimport .ivt\nopen analysis real classical topology\nnoncomputable theory\n\nprivate definition sqr_lb (x : \u211d) : \u211d := 0\n\nprivate theorem sqr_lb_is_lb (x : \u211d) (H : x \u2265 0) : (sqr_lb x) * (sqr_lb x) \u2264 x :=\n  by rewrite [\u2191sqr_lb, zero_mul]; assumption\n\nprivate definition sqr_ub (x : \u211d) : \u211d := x + 1\n\nprivate theorem sqr_ub_is_ub (x : \u211d) (H : x \u2265 0) : (sqr_ub x) * (sqr_ub x) \u2265 x :=\n  begin\n    rewrite [\u2191sqr_ub, left_distrib, mul_one, right_distrib, one_mul, {x + 1}add.comm, -*add.assoc],\n    apply le_add_of_nonneg_left,\n    repeat apply add_nonneg,\n    apply mul_nonneg,\n    repeat assumption,\n    apply zero_le_one\n  end\n\nprivate theorem lb_le_ub (x : \u211d) (H : x \u2265 0) : sqr_lb x \u2264 sqr_ub x :=\n  begin\n    rewrite [\u2191sqr_lb, \u2191sqr_ub],\n    apply add_nonneg,\n    assumption,\n    apply zero_le_one\n  end\n\nprivate lemma sqr_cts : continuous (\u03bb x : \u211d, x * x) := continuous_mul_of_continuous continuous_id continuous_id\n\ndefinition sqrt (x : \u211d) : \u211d :=\n  if H : x \u2265 0 then\n    some (intermediate_value_incr_weak sqr_cts (lb_le_ub x H) (sqr_lb_is_lb x H) (sqr_ub_is_ub x H))\n  else 0\n\nprivate theorem sqrt_spec {x : \u211d} (H : x \u2265 0) : sqrt x * sqrt x = x \u2227 sqrt x \u2265 0 :=\n  begin\n    rewrite [\u2191sqrt, dif_pos H],\n    note Hs := some_spec (intermediate_value_incr_weak sqr_cts (lb_le_ub x H)\n                           (sqr_lb_is_lb x H) (sqr_ub_is_ub x H)),\n    cases Hs with Hs1 Hs2,\n    cases Hs2 with Hs2a Hs2b,\n    exact and.intro Hs2b Hs1\n  end\n\ntheorem sqrt_mul_self {x : \u211d} (H : x \u2265 0) : sqrt x * sqrt x = x := and.left (sqrt_spec H)\n\ntheorem sqrt_nonneg (x : \u211d) : sqrt x \u2265 0 :=\nif H : x \u2265 0 then and.right (sqrt_spec H) else by rewrite [\u2191sqrt, dif_neg H]; exact le.refl 0\n\ntheorem sqrt_squared {x : \u211d} (H : x \u2265 0) : (sqrt x)^2 = x :=\nby krewrite [pow_two, sqrt_mul_self H]\n\ntheorem sqrt_zero : sqrt (0 : \u211d) = 0 :=\nhave sqrt 0 * sqrt 0 = 0, from sqrt_mul_self !le.refl,\nor.elim (eq_zero_or_eq_zero_of_mul_eq_zero this) (\u03bb H, H) (\u03bb H, H)\n\ntheorem sqrt_squared_of_nonneg {x : \u211d} (H : x \u2265 0) : sqrt (x^2) = x :=\nhave sqrt (x^2)^2 = x^2, from sqrt_squared (squared_nonneg x),\neq_of_squared_eq_squared_of_nonneg (sqrt_nonneg (x^2)) H this\n\ntheorem sqrt_squared' (x : \u211d) : sqrt (x^2) = abs x :=\nhave x^2 = (abs x)^2, by krewrite [+pow_two, -abs_mul, abs_mul_self],\nusing this, by rewrite [this, sqrt_squared_of_nonneg (abs_nonneg x)]\n\ntheorem sqrt_mul {x y : \u211d} (Hx : x \u2265 0) (Hy : y \u2265 0) : sqrt (x * y) = sqrt x * sqrt y :=\nhave (sqrt (x * y))^2 = (sqrt x * sqrt y)^2, from calc\n  (sqrt (x * y))^2 = x * y                   : by rewrite [sqrt_squared (mul_nonneg Hx Hy)]\n               ... = (sqrt x)^2 * (sqrt y)^2 : by rewrite [sqrt_squared Hx, sqrt_squared Hy]\n               ... = (sqrt x * sqrt y)^2     : by krewrite [*pow_two]; rewrite [*mul.assoc,\n                                                           mul.left_comm (sqrt y)],\neq_of_squared_eq_squared_of_nonneg !sqrt_nonneg (mul_nonneg !sqrt_nonneg !sqrt_nonneg) this\n"}
{"text": "def g (x : Nat) (b : Bool) :=\n  if b then\n    x - 1\n  else\n    x + 1\n\ntheorem g_eq (x : Nat) (h : \u00ac x = 0) : g x (x > 0) = x - 1 \u2227 g x false = x + 1 := by\n  have : x > 0 := by match x with\n    | 0 => contradiction\n    | x+1 => apply Nat.zero_lt_succ\n  simp [g, this]\n\nmacro_rules\n| `(tactic| decreasing_tactic) =>\n `(tactic|\n   (simp [invImage, InvImage, Prod.lex, sizeOfWFRel, measure, Nat.lt_wfRel, WellFoundedRelation.rel, g_eq, *]\n    apply Nat.pred_lt; assumption))\n\ndef f (x : Nat) : Nat :=\n  if h : x = 0 then\n    1\n  else\n    f (g x (x > 0)) + 2\ntermination_by f x => x\n"}
{"text": "\n/-\n\nlemma divides_p_times (r : \u2115) (n : \u2115) : p^r \u2223 n \u2194 p^(r+1) \u2223 (p * n) :=\ncalc p^r \u2223 n \u2194 (p * p^r) \u2223 (p * n)  : (nat.mul_dvd_mul_iff_left (gt_zero hp)).symm\n     ...     = (p^r * p \u2223 p * n)     : by rw mul_comm\n\nlemma exactly_divides_p_times (r : \u2115) (n : \u2115) : p^r \u2223\u2223 n \u2194 p^(r+1) \u2223\u2223 (p * n) :=\nhave eq : (p * n) / p^(r+1) = n / p^r, from\ncalc (p * n) / p^(r+1) = (p * n) / (p^r * p)  : rfl\n     ...               = (p * n) / (p * p^r)  : by rw mul_comm (p^r) p\n     ...               = (p * n) / p / p^r    : by rw nat.div_div_eq_div_mul\n     ...               = n / p^r    : by rw (nat.mul_div_cancel_left n (gt_zero hp)),\n--      : congr_arg (\u03bb m, m / p^r) (nat.mul_div_cancel_left n gt_zero),\nand_congr (divides_p_times hp r n) (by rw eq)\n\nlemma exactly_divides' {r : \u2115} {n : \u2115} : p^r \u2223\u2223 n \u2192 (\u2200 i, p^i \u2223 n \u2194 i \u2264 r) :=\nbegin\n  intros prn i, apply iff.intro,\n  { intro pin,\n    apply (le_or_gt _ _).resolve_right, intro i_gt_r,\n    have :=\n    calc p^r * p = p^(r+1)  : rfl\n         ...     \u2223 p^i      : pow_dvd_pow p i_gt_r\n         ...     \u2223 n        : pin,\n    exact absurd (dvd_div_of_mul_dvd (pos_pow_of_pos r (gt_zero hp)) this) prn.right,\n  },\n  { intro i_le_r,\n    exact dvd.trans (pow_dvd_pow p i_le_r) (and.left prn) }\nend\n\n-/\n\n\n/-\n\nlemma exactly_divides_mul (r s a b : \u2115) : p^r \u2223\u2223 a \u2192 p^s \u2223\u2223 b \u2192 p^(r+s) \u2223\u2223 a*b :=\nbegin\n  intros pra psb, split,\n  { rw nat.pow_add, exact mul_dvd_mul pra.left psb.left },\n  let a' := a / p^r,\n  have ha : p^r * a' = a := nat.mul_div_cancel' pra.left,\n  let b' := b / p^s,\n  have hb : p^s * b' = b := nat.mul_div_cancel' psb.left,\n  have : (a * b) / (p^(r+s)) = (a / p^r) * (b / p^s) :=\n  calc (a * b) / (p^(r+s)) = ((p^r * a') * (p^s * b')) / (p^r * p^s)\n    : by rw [ha, hb, pow_add]\n       ...                 = ((p^r * p^s) * (a' * b')) / (p^r * p^s)\n    : by ac_refl\n       ...                 = a' * b'\n    : by rw nat.mul_div_cancel_left _\n            (mul_pos (pos_pow_of_pos r (gt_zero hp)) (pos_pow_of_pos s (gt_zero hp)))\n       ...                 = (a / p^r) * (b / p^s)  : rfl,\n  rw this,\n  exact prime.not_dvd_mul hp pra.right psb.right\nend\n\n-/\n\n\n"}
{"text": "section\n  variables (x y z : \u2115)\n  variables (h\u2081 : x = y) (h\u2082 : y = z)\n\n  include h\u2081 h\u2082\n  theorem foo : x = z :=\n  begin\n    rw [h\u2081, h\u2082]\n  end\n  omit h\u2081 h\u2082\n\n  theorem bar : x = z :=\n    eq.trans h\u2081 h\u2082\n\n  theorem baz : x = x := rfl\n\n  #check @foo\n  #check @bar\n  #check baz\nend\n"}
{"text": "/-\nCopyright (c) S\u00e9bastien Gou\u00ebzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S\u00e9bastien Gou\u00ebzel, Yourong Zang\n\n! This file was ported from Lean 3 source module analysis.complex.real_deriv\n! leanprover-community/mathlib commit e9be2fa75faa22892937c275e27a91cd558cf8c0\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Analysis.Calculus.ContDiff\nimport Mathbin.Analysis.Complex.Conformal\nimport Mathbin.Analysis.Calculus.Conformal.NormedSpace\n\n/-! # Real differentiability of complex-differentiable functions\n\n`has_deriv_at.real_of_complex` expresses that, if a function on `\u2102` is differentiable (over `\u2102`),\nthen its restriction to `\u211d` is differentiable over `\u211d`, with derivative the real part of the\ncomplex derivative.\n\n`differentiable_at.conformal_at` states that a real-differentiable function with a nonvanishing\ndifferential from the complex plane into an arbitrary complex-normed space is conformal at a point\nif it's holomorphic at that point. This is a version of Cauchy-Riemann equations.\n\n`conformal_at_iff_differentiable_at_or_differentiable_at_comp_conj` proves that a real-differential\nfunction with a nonvanishing differential between the complex plane is conformal at a point if and\nonly if it's holomorphic or antiholomorphic at that point.\n\n## TODO\n\n* The classical form of Cauchy-Riemann equations\n* On a connected open set `u`, a function which is `conformal_at` each point is either holomorphic\nthroughout or antiholomorphic throughout.\n\n## Warning\n\nWe do NOT require conformal functions to be orientation-preserving in this file.\n-/\n\n\nsection RealDerivOfComplex\n\n/-! ### Differentiability of the restriction to `\u211d` of complex functions -/\n\n\nopen Complex\n\nvariable {e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}\n\n/-- If a complex function is differentiable at a real point, then the induced real function is also\ndifferentiable at this point, with a derivative equal to the real part of the complex derivative. -/\ntheorem HasStrictDerivAt.real_of_complex (h : HasStrictDerivAt e e' z) :\n    HasStrictDerivAt (fun x : \u211d => (e x).re) e'.re z :=\n  by\n  have A : HasStrictFderivAt (coe : \u211d \u2192 \u2102) of_real_clm z := of_real_clm.has_strict_fderiv_at\n  have B :\n    HasStrictFderivAt e ((ContinuousLinearMap.smulRight 1 e' : \u2102 \u2192L[\u2102] \u2102).restrictScalars \u211d)\n      (of_real_clm z) :=\n    h.has_strict_fderiv_at.restrict_scalars \u211d\n  have C : HasStrictFderivAt re re_clm (e (of_real_clm z)) := re_clm.has_strict_fderiv_at\n  simpa using (C.comp z (B.comp z A)).HasStrictDerivAt\n#align has_strict_deriv_at.real_of_complex HasStrictDerivAt.real_of_complex\n\n/-- If a complex function `e` is differentiable at a real point, then the function `\u211d \u2192 \u211d` given by\nthe real part of `e` is also differentiable at this point, with a derivative equal to the real part\nof the complex derivative. -/\ntheorem HasDerivAt.real_of_complex (h : HasDerivAt e e' z) :\n    HasDerivAt (fun x : \u211d => (e x).re) e'.re z :=\n  by\n  have A : HasFderivAt (coe : \u211d \u2192 \u2102) of_real_clm z := of_real_clm.has_fderiv_at\n  have B :\n    HasFderivAt e ((ContinuousLinearMap.smulRight 1 e' : \u2102 \u2192L[\u2102] \u2102).restrictScalars \u211d)\n      (of_real_clm z) :=\n    h.has_fderiv_at.restrict_scalars \u211d\n  have C : HasFderivAt re re_clm (e (of_real_clm z)) := re_clm.has_fderiv_at\n  simpa using (C.comp z (B.comp z A)).HasDerivAt\n#align has_deriv_at.real_of_complex HasDerivAt.real_of_complex\n\ntheorem ContDiffAt.real_of_complex {n : \u2115\u221e} (h : ContDiffAt \u2102 n e z) :\n    ContDiffAt \u211d n (fun x : \u211d => (e x).re) z :=\n  by\n  have A : ContDiffAt \u211d n (coe : \u211d \u2192 \u2102) z := of_real_clm.cont_diff.cont_diff_at\n  have B : ContDiffAt \u211d n e z := h.restrict_scalars \u211d\n  have C : ContDiffAt \u211d n re (e z) := re_clm.cont_diff.cont_diff_at\n  exact C.comp z (B.comp z A)\n#align cont_diff_at.real_of_complex ContDiffAt.real_of_complex\n\ntheorem ContDiff.real_of_complex {n : \u2115\u221e} (h : ContDiff \u2102 n e) :\n    ContDiff \u211d n fun x : \u211d => (e x).re :=\n  contDiff_iff_contDiffAt.2 fun x => h.ContDiffAt.real_of_complex\n#align cont_diff.real_of_complex ContDiff.real_of_complex\n\nvariable {E : Type _} [NormedAddCommGroup E] [NormedSpace \u2102 E]\n\ntheorem HasStrictDerivAt.complexToReal_fderiv' {f : \u2102 \u2192 E} {x : \u2102} {f' : E}\n    (h : HasStrictDerivAt f f' x) :\n    HasStrictFderivAt f (reClm.smul_right f' + I \u2022 imClm.smul_right f') x := by\n  simpa only [Complex.restrictScalars_one_smul_right'] using\n    h.has_strict_fderiv_at.restrict_scalars \u211d\n#align has_strict_deriv_at.complex_to_real_fderiv' HasStrictDerivAt.complexToReal_fderiv'\n\ntheorem HasDerivAt.complexToReal_fderiv' {f : \u2102 \u2192 E} {x : \u2102} {f' : E} (h : HasDerivAt f f' x) :\n    HasFderivAt f (reClm.smul_right f' + I \u2022 imClm.smul_right f') x := by\n  simpa only [Complex.restrictScalars_one_smul_right'] using h.has_fderiv_at.restrict_scalars \u211d\n#align has_deriv_at.complex_to_real_fderiv' HasDerivAt.complexToReal_fderiv'\n\ntheorem HasDerivWithinAt.complexToReal_fderiv' {f : \u2102 \u2192 E} {s : Set \u2102} {x : \u2102} {f' : E}\n    (h : HasDerivWithinAt f f' s x) :\n    HasFderivWithinAt f (reClm.smul_right f' + I \u2022 imClm.smul_right f') s x := by\n  simpa only [Complex.restrictScalars_one_smul_right'] using\n    h.has_fderiv_within_at.restrict_scalars \u211d\n#align has_deriv_within_at.complex_to_real_fderiv' HasDerivWithinAt.complexToReal_fderiv'\n\ntheorem HasStrictDerivAt.complexToReal_fderiv {f : \u2102 \u2192 \u2102} {f' x : \u2102} (h : HasStrictDerivAt f f' x) :\n    HasStrictFderivAt f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.has_strict_fderiv_at.restrict_scalars \u211d\n#align has_strict_deriv_at.complex_to_real_fderiv HasStrictDerivAt.complexToReal_fderiv\n\ntheorem HasDerivAt.complexToReal_fderiv {f : \u2102 \u2192 \u2102} {f' x : \u2102} (h : HasDerivAt f f' x) :\n    HasFderivAt f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.has_fderiv_at.restrict_scalars \u211d\n#align has_deriv_at.complex_to_real_fderiv HasDerivAt.complexToReal_fderiv\n\ntheorem HasDerivWithinAt.complexToReal_fderiv {f : \u2102 \u2192 \u2102} {s : Set \u2102} {f' x : \u2102}\n    (h : HasDerivWithinAt f f' s x) : HasFderivWithinAt f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) s x := by\n  simpa only [Complex.restrictScalars_one_smulRight] using h.has_fderiv_within_at.restrict_scalars \u211d\n#align has_deriv_within_at.complex_to_real_fderiv HasDerivWithinAt.complexToReal_fderiv\n\n/-- If a complex function `e` is differentiable at a real point, then its restriction to `\u211d` is\ndifferentiable there as a function `\u211d \u2192 \u2102`, with the same derivative. -/\ntheorem HasDerivAt.comp_of_real (hf : HasDerivAt e e' \u2191z) : HasDerivAt (fun y : \u211d => e \u2191y) e' z :=\n  by simpa only [of_real_clm_apply, of_real_one, mul_one] using hf.comp z of_real_clm.has_deriv_at\n#align has_deriv_at.comp_of_real HasDerivAt.comp_of_real\n\n/-- If a function `f : \u211d \u2192 \u211d` is differentiable at a (real) point `x`, then it is also\ndifferentiable as a function `\u211d \u2192 \u2102`. -/\ntheorem HasDerivAt.of_real_comp {f : \u211d \u2192 \u211d} {u : \u211d} (hf : HasDerivAt f u z) :\n    HasDerivAt (fun y : \u211d => \u2191(f y) : \u211d \u2192 \u2102) u z := by\n  simpa only [of_real_clm_apply, of_real_one, real_smul, mul_one] using\n    of_real_clm.has_deriv_at.scomp z hf\n#align has_deriv_at.of_real_comp HasDerivAt.of_real_comp\n\nend RealDerivOfComplex\n\nsection Conformality\n\n/-! ### Conformality of real-differentiable complex maps -/\n\n\nopen Complex ContinuousLinearMap\n\nopen ComplexConjugate\n\nvariable {E : Type _} [NormedAddCommGroup E] [NormedSpace \u2102 E] {z : \u2102} {f : \u2102 \u2192 E}\n\n/-- A real differentiable function of the complex plane into some complex normed space `E` is\n    conformal at a point `z` if it is holomorphic at that point with a nonvanishing differential.\n    This is a version of the Cauchy-Riemann equations. -/\ntheorem DifferentiableAt.conformalAt (h : DifferentiableAt \u2102 f z) (hf' : deriv f z \u2260 0) :\n    ConformalAt f z :=\n  by\n  rw [conformalAt_iff_isConformalMap_fderiv, (h.has_fderiv_at.restrict_scalars \u211d).fderiv]\n  apply isConformalMap_complex_linear\n  simpa only [Ne.def, ext_ring_iff]\n#align differentiable_at.conformal_at DifferentiableAt.conformalAt\n\n/-- A complex function is conformal if and only if the function is holomorphic or antiholomorphic\n    with a nonvanishing differential. -/\ntheorem conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj {f : \u2102 \u2192 \u2102} {z : \u2102} :\n    ConformalAt f z \u2194\n      (DifferentiableAt \u2102 f z \u2228 DifferentiableAt \u2102 (f \u2218 conj) (conj z)) \u2227 fderiv \u211d f z \u2260 0 :=\n  by\n  rw [conformalAt_iff_isConformalMap_fderiv]\n  rw [isConformalMap_iff_is_complex_or_conj_linear]\n  apply and_congr_left\n  intro h\n  have h_diff := h.imp_symm fderiv_zero_of_not_differentiableAt\n  apply or_congr\n  \u00b7 rw [differentiableAt_iff_restrictScalars \u211d h_diff]\n  rw [\u2190 conj_conj z] at h_diff\n  rw [differentiableAt_iff_restrictScalars \u211d (h_diff.comp _ conj_cle.differentiable_at)]\n  refine' exists_congr fun g => rfl.congr _\n  have : fderiv \u211d conj (conj z) = _ := conj_cle.fderiv\n  simp [fderiv.comp _ h_diff conj_cle.differentiable_at, this, conj_conj]\n#align conformal_at_iff_differentiable_at_or_differentiable_at_comp_conj conformalAt_iff_differentiableAt_or_differentiableAt_comp_conj\n\nend Conformality\n\n"}
{"text": "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Eric Wieser\n-/\n\nimport algebra.char_p.basic\nimport algebra.ring_quot\n\n/-!\n# Characteristic of quotients rings\n-/\n\nuniverses u v\n\nnamespace char_p\n\ntheorem quotient (R : Type u) [comm_ring R] (p : \u2115) [hp1 : fact p.prime] (hp2 : \u2191p \u2208 nonunits R) :\n  char_p (ideal.span {p} : ideal R).quotient p :=\nhave hp0 : (p : (ideal.span {p} : ideal R).quotient) = 0,\n  from (ideal.quotient.mk (ideal.span {p} : ideal R)).map_nat_cast p \u25b8\n    ideal.quotient.eq_zero_iff_mem.2 (ideal.subset_span $ set.mem_singleton _),\nring_char.of_eq $ or.resolve_left ((nat.dvd_prime hp1.1).1 $ ring_char.dvd hp0) $ \u03bb h1,\nhp2 $ is_unit_iff_dvd_one.2 $ ideal.mem_span_singleton.1 $ ideal.quotient.eq_zero_iff_mem.1 $\n@@subsingleton.elim (@@char_p.subsingleton _ $ ring_char.of_eq h1) _ _\n\n/-- If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. -/\nlemma quotient' {R : Type*} [comm_ring R] (p : \u2115) [char_p R p] (I : ideal R)\n  (h : \u2200 x : \u2115, (x : R) \u2208 I \u2192 (x : R) = 0) :\n  char_p I.quotient p :=\n\u27e8\u03bb x, begin\n  rw [\u2190cast_eq_zero_iff R p x, \u2190(ideal.quotient.mk I).map_nat_cast],\n  refine quotient.eq'.trans (_ : \u2191x - 0 \u2208 I \u2194 _),\n  rw sub_zero,\n  exact \u27e8h x, \u03bb h', h'.symm \u25b8 I.zero_mem\u27e9,\nend\u27e9\n\nend char_p\n"}
{"text": "State Before: \u03b1 : Type u\nm : OuterMeasure \u03b1\ns\u271d s\u2081 s\u2082 : Set \u03b1\ns : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), IsCaratheodory m (s i)\nhd : Pairwise (Disjoint on s)\nt : Set \u03b1\n\u22a2 \u2211 i in Finset.range 0, \u2191m (t \u2229 s i) = \u2191m (t \u2229 \u22c3 (i : \u2115) (_ : i < 0), s i) State After: no goals Tactic: simp [Nat.not_lt_zero, m.empty] State Before: \u03b1 : Type u\nm : OuterMeasure \u03b1\ns\u271d s\u2081 s\u2082 : Set \u03b1\ns : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), IsCaratheodory m (s i)\nhd : Pairwise (Disjoint on s)\nt : Set \u03b1\nn : \u2115\n\u22a2 \u2211 i in Finset.range (Nat.succ n), \u2191m (t \u2229 s i) = \u2191m (t \u2229 \u22c3 (i : \u2115) (_ : i < Nat.succ n), s i) State After: \u03b1 : Type u\nm : OuterMeasure \u03b1\ns\u271d s\u2081 s\u2082 : Set \u03b1\ns : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), IsCaratheodory m (s i)\nhd : Pairwise (Disjoint on s)\nt : Set \u03b1\nn : \u2115\n\u22a2 (s n \u2229 \u22c3 (k : \u2115) (_ : k < n), s k) \u2286 \u2205 Tactic: rw [biUnion_lt_succ, Finset.sum_range_succ, Set.union_comm, isCaratheodory_sum h hd,\n  m.measure_inter_union _ (h n), add_comm] State Before: \u03b1 : Type u\nm : OuterMeasure \u03b1\ns\u271d s\u2081 s\u2082 : Set \u03b1\ns : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), IsCaratheodory m (s i)\nhd : Pairwise (Disjoint on s)\nt : Set \u03b1\nn : \u2115\n\u22a2 (s n \u2229 \u22c3 (k : \u2115) (_ : k < n), s k) \u2286 \u2205 State After: \u03b1 : Type u\nm : OuterMeasure \u03b1\ns\u271d s\u2081 s\u2082 : Set \u03b1\ns : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), IsCaratheodory m (s i)\nhd : Pairwise (Disjoint on s)\nt : Set \u03b1\nn : \u2115\na : \u03b1\n\u22a2 (a \u2208 s n \u2229 \u22c3 (k : \u2115) (_ : k < n), s k) \u2192 a \u2208 \u2205 Tactic: intro a State Before: \u03b1 : Type u\nm : OuterMeasure \u03b1\ns\u271d s\u2081 s\u2082 : Set \u03b1\ns : \u2115 \u2192 Set \u03b1\nh : \u2200 (i : \u2115), IsCaratheodory m (s i)\nhd : Pairwise (Disjoint on s)\nt : Set \u03b1\nn : \u2115\na : \u03b1\n\u22a2 (a \u2208 s n \u2229 \u22c3 (k : \u2115) (_ : k < n), s k) \u2192 a \u2208 \u2205 State After: no goals Tactic: simpa using fun (h\u2081 : a \u2208 s n) i (hi : i < n) h\u2082 => (hd (ne_of_gt hi)).le_bot \u27e8h\u2081, h\u2082\u27e9"}
{"text": "From iris.proofmode Require Import tactics.\nFrom aneris.aneris_lang Require Import network adequacy.\nFrom aneris.aneris_lang.program_logic Require Export aneris_weakestpre.\n\n\nDefinition aneris_adequate (e :expr) (ip : ip_address) (\u03c3 : state)\n           (\u03c6 : val \u2192 Prop) :=\n  adequate NotStuck (mkExpr ip e) \u03c3 (\u03bb v _, \u2203 w, v = mkVal ip w \u2227 \u03c6 w).\n\nTheorem adequacy `{anerisPreG \u03a3 Mdl} IPs A B\n        lbls obs_send_sas obs_rec_sas e ip \u03c3 \u03c6 :\n  aneris_model_rel_finitary Mdl \u2192\n  (\u2200 `{anerisG Mdl \u03a3}, \u22a2 |={\u22a4}=> \u2203 (f : socket_address \u2192 socket_interp \u03a3),\n     fixed A -\u2217\n     ([\u2217 set] a \u2208 A, a \u2907 (f a)) -\u2217\n     ([\u2217 set] b \u2208 B, b \u2933[bool_decide (b \u2208 obs_send_sas), bool_decide (b \u2208 obs_rec_sas)] (\u2205, \u2205)) -\u2217\n     frag_st Mdl.(model_state_initial) -\u2217\n     ([\u2217 set] i \u2208 IPs, free_ip i) -\u2217\n     ([\u2217 set] lbl \u2208 lbls, alloc_evs lbl []) -\u2217\n     ([\u2217 set] sa \u2208 obs_send_sas, sendon_evs sa []) -\u2217\n     ([\u2217 set] sa \u2208 obs_rec_sas, receiveon_evs sa []) -\u2217\n     observed_send obs_send_sas -\u2217\n     observed_receive obs_rec_sas -\u2217\n     WP e @[ip] \u22a4 {{ v, \u231c\u03c6 v\u231d }}) \u2192\n  ip \u2209 IPs \u2192\n  dom (gset ip_address) (state_ports_in_use \u03c3) = IPs \u2192\n  (\u2200 ip, ip \u2208 IPs \u2192 state_ports_in_use \u03c3 !! ip = Some \u2205) \u2192\n  (\u2200 a, a \u2208 A \u2192 ip_of_address a \u2208 IPs) \u2192\n  state_heaps \u03c3 = {[ip:=\u2205]} \u2192\n  state_sockets \u03c3 = {[ip:=\u2205]} \u2192\n  state_ms \u03c3 = \u2205 \u2192\n  aneris_adequate e ip \u03c3 \u03c6.\nProof.\n  intros HMdlfin Hwp Hipdom Hpiiu Hip Hfixdom Hste Hsce Hmse.\n  eapply adequacy; [done| |done|done|done|done|done|done|done].\n  intros dg.\n  iMod (Hwp dg) as (f) \"Hwp\".\n  iModIntro. iExists _. iIntros \"??????????? /=\".\n  rewrite !aneris_wp_unfold /aneris_wp_def.\n  iSpecialize (\"Hwp\" with \"[$] [$] [$] [$] [$] [$] [$] [$] [$] [$] [$]\").\n  iApply (wp_wand with \"Hwp\").\n  eauto.\nQed.\n\nTheorem adequacy_hoare `{anerisPreG \u03a3 Mdl} IPs A B\n        lbls obs_send_sas obs_rec_sas e \u03c3 \u03c6 ip :\n  aneris_model_rel_finitary Mdl \u2192\n  (\u2200 `{anerisG Mdl \u03a3}, \u22a2 \u2203 (f : socket_address \u2192 socket_interp \u03a3),\n          {{{ fixed A \u2217\n              ([\u2217 set] a \u2208 A, a \u2907 (f a)) \u2217\n              ([\u2217 set] b \u2208 B, b \u2933[bool_decide (b \u2208 obs_send_sas), bool_decide (b \u2208 obs_rec_sas)] (\u2205, \u2205)) \u2217\n              frag_st Mdl.(model_state_initial) \u2217\n              ([\u2217 set] ip \u2208 IPs, free_ip ip) \u2217\n              ([\u2217 set] lbl \u2208 lbls, alloc_evs lbl []) \u2217\n              ([\u2217 set] sa \u2208 obs_send_sas, sendon_evs sa []) \u2217\n              ([\u2217 set] sa \u2208 obs_rec_sas, receiveon_evs sa []) \u2217\n              observed_send obs_send_sas \u2217\n              observed_receive obs_rec_sas }}}\n          e @[ip]\n      {{{ v, RET v; \u231c\u03c6 v\u231d }}}) \u2192\n  ip \u2209 IPs \u2192\n  dom (gset ip_address) (state_ports_in_use \u03c3) = IPs \u2192\n  (\u2200 i, i \u2208 IPs \u2192 state_ports_in_use \u03c3 !! i = Some \u2205) \u2192\n  (\u2200 a, a \u2208 A \u2192 ip_of_address a \u2208 IPs) \u2192\n  state_heaps \u03c3 = {[ip:=\u2205]} \u2192\n  state_sockets \u03c3 = {[ip:=\u2205]} \u2192\n  state_ms \u03c3 = \u2205 \u2192\n  aneris_adequate e ip \u03c3 \u03c6.\nProof.\n  intros ? Hwp ???????.\n  eapply adequacy; eauto.\n  intros ?. iModIntro.\n  iDestruct Hwp as (f) \"#Hwp\".\n  iExists f. iIntros \"??????????\".\n  iApply (\"Hwp\" with \"[$]\"); auto.\nQed.\n"}
{"text": "Class inhabited(A: Type): Type := mk_inhabited { default: A }.\nGlobal Arguments mk_inhabited {_} _.\nGlobal Hint Mode inhabited + : typeclass_instances.\n\nGlobal Hint Extern 1 (inhabited _) =>\n  simple refine (mk_inhabited _); constructor\n  : typeclass_instances.\n\nModule InhabitedTests.\n  Goal inhabited nat. typeclasses eauto. Abort.\n  Goal inhabited (list nat). typeclasses eauto. Abort.\n  Goal forall A, inhabited (option A). typeclasses eauto. Abort.\n\n  Inductive test_foo: Type :=\n  | C1(x: False)\n  | C2\n  | C3(x: False).\n\n  Goal inhabited test_foo. typeclasses eauto. Abort.\nEnd InhabitedTests.\n\n(* TODO move code below to specific files *)\n\nRequire Import coqutil.Word.Interface.\nGlobal Instance word_inhabited{width: BinInt.Z}{word: word.word width}: inhabited word :=\n  mk_inhabited (word.of_Z BinInt.Z0).\n\nRequire Import coqutil.Map.Interface.\nGlobal Instance map_inhabited{key value: Type}{map: map.map key value}: inhabited map :=\n  mk_inhabited map.empty.\n\nModule Option.\n  Definition force{A: Type}{i: inhabited A}(o: option A): A :=\n    match o with\n    | Some a => a\n    | None => default\n    end.\nEnd Option.\n"}
{"text": "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, Yury Kudryashov\n-/\nimport data.real.sqrt\nimport tactic.interval_cases\nimport ring_theory.algebraic\nimport data.rat.sqrt\nimport ring_theory.int.basic\n/-!\n# Irrational real numbers\n\nIn this file we define a predicate `irrational` on `\u211d`, prove that the `n`-th root of an integer\nnumber is irrational if it is not integer, and that `sqrt q` is irrational if and only if\n`rat.sqrt q * rat.sqrt q \u2260 q \u2227 0 \u2264 q`.\n\nWe also provide dot-style constructors like `irrational.add_rat`, `irrational.rat_sub` etc.\n-/\n\nopen rat real multiplicity\n\n/-- A real number is irrational if it is not equal to any rational number. -/\ndef irrational (x : \u211d) := x \u2209 set.range (coe : \u211a \u2192 \u211d)\n\nlemma irrational_iff_ne_rational (x : \u211d) : irrational x \u2194 \u2200 a b : \u2124, x \u2260 a / b :=\nby simp only [irrational, rat.forall, cast_mk, not_exists, set.mem_range, cast_coe_int, cast_div,\n  eq_comm]\n\n/-- A transcendental real number is irrational. -/\nlemma transcendental.irrational {r : \u211d} (tr : transcendental \u211a r) :\n  irrational r :=\nby { rintro \u27e8a, rfl\u27e9, exact tr (is_algebraic_algebra_map a) }\n\n/-!\n### Irrationality of roots of integer and rational numbers\n-/\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem irrational_nrt_of_notint_nrt {x : \u211d} (n : \u2115) (m : \u2124)\n  (hxr : x ^ n = m) (hv : \u00ac \u2203 y : \u2124, x = y) (hnpos : 0 < n) :\n  irrational x :=\nbegin\n  rintros \u27e8\u27e8N, D, P, C\u27e9, rfl\u27e9,\n  rw [\u2190 cast_pow] at hxr,\n  have c1 : ((D : \u2124) : \u211d) \u2260 0,\n  { rw [int.cast_ne_zero, int.coe_nat_ne_zero], exact ne_of_gt P },\n  have c2 : ((D : \u2124) : \u211d) ^ n \u2260 0 := pow_ne_zero _ c1,\n  rw [num_denom', cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2,\n      \u2190 int.cast_pow, \u2190 int.cast_pow, \u2190 int.cast_mul, int.cast_inj] at hxr,\n  have hdivn : \u2191D ^ n \u2223 N ^ n := dvd.intro_left m hxr,\n  rw [\u2190 int.dvd_nat_abs, \u2190 int.coe_nat_pow, int.coe_nat_dvd, int.nat_abs_pow,\n    nat.pow_dvd_pow_iff hnpos] at hdivn,\n  obtain rfl : D = 1 := by rw [\u2190 nat.gcd_eq_right hdivn, C.gcd_eq_one],\n  refine hv \u27e8N, _\u27e9,\n  rw [num_denom', int.coe_nat_one, mk_eq_div, int.cast_one, div_one, cast_coe_int]\nend\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem irrational_nrt_of_n_not_dvd_multiplicity {x : \u211d} (n : \u2115) {m : \u2124} (hm : m \u2260 0) (p : \u2115)\n  [hp : fact p.prime] (hxr : x ^ n = m)\n  (hv : (multiplicity (p : \u2124) m).get (finite_int_iff.2 \u27e8hp.1.ne_one, hm\u27e9) % n \u2260 0) :\n  irrational x :=\nbegin\n  rcases nat.eq_zero_or_pos n with rfl | hnpos,\n  { rw [eq_comm, pow_zero, \u2190 int.cast_one, int.cast_inj] at hxr,\n    simpa [hxr, multiplicity.one_right (mt is_unit_iff_dvd_one.1\n      (mt int.coe_nat_dvd.1 hp.1.not_dvd_one)), nat.zero_mod] using hv },\n  refine irrational_nrt_of_notint_nrt _ _ hxr _ hnpos,\n  rintro \u27e8y, rfl\u27e9,\n  rw [\u2190 int.cast_pow, int.cast_inj] at hxr, subst m,\n  have : y \u2260 0, { rintro rfl, rw zero_pow hnpos at hm, exact hm rfl },\n  erw [multiplicity.pow' (nat.prime_iff_prime_int.1 hp.1)\n    (finite_int_iff.2 \u27e8hp.1.ne_one, this\u27e9), nat.mul_mod_right] at hv,\n  exact hv rfl\nend\n\ntheorem irrational_sqrt_of_multiplicity_odd (m : \u2124) (hm : 0 < m)\n  (p : \u2115) [hp : fact p.prime]\n  (Hpv : (multiplicity (p : \u2124) m).get\n    (finite_int_iff.2 \u27e8hp.1.ne_one, (ne_of_lt hm).symm\u27e9) % 2 = 1) :\n  irrational (sqrt m) :=\n@irrational_nrt_of_n_not_dvd_multiplicity _ 2 _ (ne.symm (ne_of_lt hm)) p hp\n  (sq_sqrt (int.cast_nonneg.2 $ le_of_lt hm))\n  (by rw Hpv; exact one_ne_zero)\n\ntheorem nat.prime.irrational_sqrt {p : \u2115} (hp : nat.prime p) : irrational (sqrt p) :=\n@irrational_sqrt_of_multiplicity_odd p (int.coe_nat_pos.2 hp.pos) p \u27e8hp\u27e9 $\nby simp [multiplicity_self (mt is_unit_iff_dvd_one.1 (mt int.coe_nat_dvd.1 hp.not_dvd_one) : _)];\n  refl\n\n/-- **Irrationality of the Square Root of 2** -/\ntheorem irrational_sqrt_two : irrational (sqrt 2) :=\nby simpa using nat.prime_two.irrational_sqrt\n\ntheorem irrational_sqrt_rat_iff (q : \u211a) : irrational (sqrt q) \u2194\n  rat.sqrt q * rat.sqrt q \u2260 q \u2227 0 \u2264 q :=\nif H1 : rat.sqrt q * rat.sqrt q = q\nthen iff_of_false (not_not_intro \u27e8rat.sqrt q,\n  by rw [\u2190 H1, cast_mul, sqrt_mul_self (cast_nonneg.2 $ rat.sqrt_nonneg q),\n         sqrt_eq, abs_of_nonneg (rat.sqrt_nonneg q)]\u27e9) (\u03bb h, h.1 H1)\nelse if H2 : 0 \u2264 q\nthen iff_of_true (\u03bb \u27e8r, hr\u27e9, H1 $ (exists_mul_self _).1 \u27e8r,\n  by rwa [eq_comm, sqrt_eq_iff_mul_self_eq (cast_nonneg.2 H2), \u2190 cast_mul, rat.cast_inj] at hr;\n  rw [\u2190 hr]; exact real.sqrt_nonneg _\u27e9) \u27e8H1, H2\u27e9\nelse iff_of_false (not_not_intro \u27e80,\n  by rw cast_zero; exact (sqrt_eq_zero_of_nonpos (rat.cast_nonpos.2 $ le_of_not_le H2)).symm\u27e9)\n  (\u03bb h, H2 h.2)\n\ninstance (q : \u211a) : decidable (irrational (sqrt q)) :=\ndecidable_of_iff' _ (irrational_sqrt_rat_iff q)\n\n/-!\n### Dot-style operations on `irrational`\n\n#### Coercion of a rational/integer/natural number is not irrational\n-/\n\nnamespace irrational\n\nvariable {x : \u211d}\n\n/-!\n#### Irrational number is not equal to a rational/integer/natural number\n-/\n\ntheorem ne_rat (h : irrational x) (q : \u211a) : x \u2260 q := \u03bb hq, h \u27e8q, hq.symm\u27e9\n\ntheorem ne_int (h : irrational x) (m : \u2124) : x \u2260 m :=\nby { rw \u2190 rat.cast_coe_int, exact h.ne_rat _ }\n\ntheorem ne_nat (h : irrational x) (m : \u2115) : x \u2260 m := h.ne_int m\n\ntheorem ne_zero (h : irrational x) : x \u2260 0 := by exact_mod_cast h.ne_nat 0\n\ntheorem ne_one (h : irrational x) : x \u2260 1 := by simpa only [nat.cast_one] using h.ne_nat 1\n\nend irrational\n\n@[simp] lemma rat.not_irrational (q : \u211a) : \u00acirrational q := \u03bb h, h \u27e8q, rfl\u27e9\n\n@[simp] lemma int.not_irrational (m : \u2124) : \u00acirrational m := \u03bb h, h.ne_int m rfl\n\n@[simp] lemma nat.not_irrational (m : \u2115) : \u00acirrational m := \u03bb h, h.ne_nat m rfl\n\nnamespace irrational\n\nvariables (q : \u211a) {x y : \u211d}\n\n\n/-!\n#### Addition of rational/integer/natural numbers\n-/\n\n/-- If `x + y` is irrational, then at least one of `x` and `y` is irrational. -/\ntheorem add_cases : irrational (x + y) \u2192 irrational x \u2228 irrational y :=\nbegin\n  delta irrational,\n  contrapose!,\n  rintros \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9,\n  exact \u27e8rx + ry, cast_add rx ry\u27e9\nend\n\ntheorem of_rat_add (h : irrational (q + x)) : irrational x :=\nh.add_cases.resolve_left q.not_irrational\n\ntheorem rat_add (h : irrational x) : irrational (q + x) :=\nof_rat_add (-q) $ by rwa [cast_neg, neg_add_cancel_left]\n\ntheorem of_add_rat : irrational (x + q) \u2192 irrational x :=\nadd_comm \u2191q x \u25b8 of_rat_add q\n\ntheorem add_rat (h : irrational x) : irrational (x + q) :=\nadd_comm \u2191q x \u25b8 h.rat_add q\n\ntheorem of_int_add (m : \u2124) (h : irrational (m + x)) : irrational x :=\nby { rw \u2190 cast_coe_int at h, exact h.of_rat_add m }\n\ntheorem of_add_int (m : \u2124) (h : irrational (x + m)) : irrational x :=\nof_int_add m $ add_comm x m \u25b8 h\n\ntheorem int_add (h : irrational x) (m : \u2124) : irrational (m + x) :=\nby { rw \u2190 cast_coe_int, exact h.rat_add m }\n\ntheorem add_int (h : irrational x) (m : \u2124) : irrational (x + m) :=\nadd_comm \u2191m x \u25b8 h.int_add m\n\ntheorem of_nat_add (m : \u2115) (h : irrational (m + x)) : irrational x := h.of_int_add m\n\ntheorem of_add_nat (m : \u2115) (h : irrational (x + m)) : irrational x := h.of_add_int m\n\ntheorem nat_add (h : irrational x) (m : \u2115) : irrational (m + x) := h.int_add m\n\ntheorem add_nat (h : irrational x) (m : \u2115) : irrational (x + m) := h.add_int m\n\n/-!\n#### Negation\n-/\n\ntheorem of_neg (h : irrational (-x)) : irrational x :=\n\u03bb \u27e8q, hx\u27e9, h \u27e8-q, by rw [cast_neg, hx]\u27e9\n\nprotected theorem neg (h : irrational x) : irrational (-x) :=\nof_neg $ by rwa neg_neg\n\n/-!\n#### Subtraction of rational/integer/natural numbers\n-/\n\ntheorem sub_rat (h : irrational x) : irrational (x - q) :=\nby simpa only [sub_eq_add_neg, cast_neg] using h.add_rat (-q)\n\ntheorem rat_sub (h : irrational x) : irrational (q - x) :=\nby simpa only [sub_eq_add_neg] using h.neg.rat_add q\n\ntheorem of_sub_rat (h : irrational (x - q)) : irrational x :=\n(of_add_rat (-q) $ by simpa only [cast_neg, sub_eq_add_neg] using h)\n\ntheorem of_rat_sub (h : irrational (q - x)) : irrational x :=\nof_neg (of_rat_add q (by simpa only [sub_eq_add_neg] using h))\n\ntheorem sub_int (h : irrational x) (m : \u2124) : irrational (x - m) :=\nby simpa only [rat.cast_coe_int] using h.sub_rat m\n\ntheorem int_sub (h : irrational x) (m : \u2124) : irrational (m - x) :=\nby simpa only [rat.cast_coe_int] using h.rat_sub m\n\ntheorem of_sub_int (m : \u2124) (h : irrational (x - m)) : irrational x :=\nof_sub_rat m $ by rwa rat.cast_coe_int\n\ntheorem of_int_sub (m : \u2124) (h : irrational (m - x)) : irrational x :=\nof_rat_sub m $ by rwa rat.cast_coe_int\n\ntheorem sub_nat (h : irrational x) (m : \u2115) : irrational (x - m) := h.sub_int m\n\ntheorem nat_sub (h : irrational x) (m : \u2115) : irrational (m - x) := h.int_sub m\n\ntheorem of_sub_nat (m : \u2115) (h : irrational (x - m)) : irrational x := h.of_sub_int m\n\ntheorem of_nat_sub (m : \u2115) (h : irrational (m - x)) : irrational x := h.of_int_sub m\n\n/-!\n#### Multiplication by rational numbers\n-/\n\ntheorem mul_cases : irrational (x * y) \u2192 irrational x \u2228 irrational y :=\nbegin\n  delta irrational,\n  contrapose!,\n  rintros \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9,\n  exact \u27e8rx * ry, cast_mul rx ry\u27e9\nend\n\ntheorem of_mul_rat (h : irrational (x * q)) : irrational x :=\nh.mul_cases.resolve_right q.not_irrational\n\ntheorem mul_rat (h : irrational x) {q : \u211a} (hq : q \u2260 0) : irrational (x * q) :=\nof_mul_rat q\u207b\u00b9 $ by rwa [mul_assoc, \u2190 cast_mul, mul_inv_cancel hq, cast_one, mul_one]\n\ntheorem of_rat_mul : irrational (q * x) \u2192 irrational x :=\nmul_comm x q \u25b8 of_mul_rat q\n\ntheorem rat_mul (h : irrational x) {q : \u211a} (hq : q \u2260 0) : irrational (q * x) :=\nmul_comm x q \u25b8 h.mul_rat hq\n\ntheorem of_mul_int (m : \u2124) (h : irrational (x * m)) : irrational x :=\nof_mul_rat m $ by rwa cast_coe_int\n\ntheorem of_int_mul (m : \u2124) (h : irrational (m * x)) : irrational x :=\nof_rat_mul m $ by rwa cast_coe_int\n\ntheorem mul_int (h : irrational x) {m : \u2124} (hm : m \u2260 0) : irrational (x * m) :=\nby { rw \u2190 cast_coe_int, refine h.mul_rat _, rwa int.cast_ne_zero }\n\ntheorem int_mul (h : irrational x) {m : \u2124} (hm : m \u2260 0) : irrational (m * x) :=\nmul_comm x m \u25b8 h.mul_int hm\n\ntheorem of_mul_nat (m : \u2115) (h : irrational (x * m)) : irrational x := h.of_mul_int m\n\ntheorem of_nat_mul (m : \u2115) (h : irrational (m * x)) : irrational x := h.of_int_mul m\n\ntheorem mul_nat (h : irrational x) {m : \u2115} (hm : m \u2260 0) : irrational (x * m) :=\nh.mul_int $ int.coe_nat_ne_zero.2 hm\n\ntheorem nat_mul (h : irrational x) {m : \u2115} (hm : m \u2260 0) : irrational (m * x) :=\nh.int_mul $ int.coe_nat_ne_zero.2 hm\n\n/-!\n#### Inverse\n-/\n\ntheorem of_inv (h : irrational x\u207b\u00b9) : irrational x :=\n\u03bb \u27e8q, hq\u27e9, h $ hq \u25b8 \u27e8q\u207b\u00b9, q.cast_inv\u27e9\n\nprotected theorem inv (h : irrational x) : irrational x\u207b\u00b9 :=\nof_inv $ by rwa inv_inv\n\n/-!\n#### Division\n-/\n\ntheorem div_cases (h : irrational (x / y)) : irrational x \u2228 irrational y :=\nh.mul_cases.imp id of_inv\n\ntheorem of_rat_div (h : irrational (q / x)) : irrational x :=\n(h.of_rat_mul q).of_inv\n\ntheorem of_div_rat (h : irrational (x / q)) : irrational x :=\nh.div_cases.resolve_right q.not_irrational\n\ntheorem rat_div (h : irrational x) {q : \u211a} (hq : q \u2260 0) : irrational (q / x) := h.inv.rat_mul hq\n\ntheorem div_rat (h : irrational x) {q : \u211a} (hq : q \u2260 0) : irrational (x / q) :=\nby { rw [div_eq_mul_inv, \u2190 cast_inv], exact h.mul_rat (inv_ne_zero hq) }\n\ntheorem of_int_div (m : \u2124) (h : irrational (m / x)) : irrational x :=\nh.div_cases.resolve_left m.not_irrational\n\ntheorem of_div_int (m : \u2124) (h : irrational (x / m)) : irrational x :=\nh.div_cases.resolve_right m.not_irrational\n\ntheorem int_div (h : irrational x) {m : \u2124} (hm : m \u2260 0) : irrational (m / x) :=\nh.inv.int_mul hm\n\ntheorem div_int (h : irrational x) {m : \u2124} (hm : m \u2260 0) : irrational (x / m) :=\nby { rw \u2190 cast_coe_int, refine h.div_rat _, rwa int.cast_ne_zero }\n\ntheorem of_nat_div (m : \u2115) (h : irrational (m / x)) : irrational x := h.of_int_div m\n\ntheorem of_div_nat (m : \u2115) (h : irrational (x / m)) : irrational x := h.of_div_int m\n\ntheorem nat_div (h : irrational x) {m : \u2115} (hm : m \u2260 0) : irrational (m / x) := h.inv.nat_mul hm\n\ntheorem div_nat (h : irrational x) {m : \u2115} (hm : m \u2260 0) : irrational (x / m) :=\nh.div_int $ by rwa int.coe_nat_ne_zero\n\ntheorem of_one_div (h : irrational (1 / x)) : irrational x :=\nof_rat_div 1 $ by rwa [cast_one]\n\n/-!\n#### Natural and integerl power\n-/\n\ntheorem of_mul_self (h : irrational (x * x)) : irrational x :=\nh.mul_cases.elim id id\n\ntheorem of_pow : \u2200 n : \u2115, irrational (x^n) \u2192 irrational x\n| 0 := \u03bb h, by { rw pow_zero at h, exact (h \u27e81, cast_one\u27e9).elim }\n| (n+1) := \u03bb h, by { rw pow_succ at h, exact h.mul_cases.elim id (of_pow n) }\n\ntheorem of_zpow : \u2200 m : \u2124, irrational (x^m) \u2192 irrational x\n| (n:\u2115) := \u03bb h, by { rw zpow_coe_nat at h, exact h.of_pow _ }\n| -[1+n] := \u03bb h, by { rw zpow_neg_succ_of_nat at h, exact h.of_inv.of_pow _ }\n\nend irrational\n\nsection polynomial\n\nopen polynomial\nopen_locale polynomial\n\nvariables (x : \u211d) (p : \u2124[X])\n\nlemma one_lt_nat_degree_of_irrational_root (hx : irrational x) (p_nonzero : p \u2260 0)\n  (x_is_root : aeval x p = 0) : 1 < p.nat_degree :=\nbegin\n  by_contra rid,\n  rcases exists_eq_X_add_C_of_nat_degree_le_one (not_lt.1 rid) with \u27e8a, b, rfl\u27e9, clear rid,\n  have : (a : \u211d) * x = -b, by simpa [eq_neg_iff_add_eq_zero] using x_is_root,\n  rcases em (a = 0) with (rfl|ha),\n  { obtain rfl : b = 0, by simpa,\n    simpa using p_nonzero },\n  { rw [mul_comm, \u2190 eq_div_iff_mul_eq, eq_comm] at this,\n    refine hx \u27e8-b / a, _\u27e9,\n    assumption_mod_cast, assumption_mod_cast }\nend\n\nend polynomial\n\nsection\nvariables {q : \u211a} {m : \u2124} {n : \u2115} {x : \u211d}\n\nopen irrational\n\n/-!\n### Simplification lemmas about operations\n-/\n\n@[simp] theorem irrational_rat_add_iff : irrational (q + x) \u2194 irrational x :=\n\u27e8of_rat_add q, rat_add q\u27e9\n\n@[simp] theorem irrational_int_add_iff : irrational (m + x) \u2194 irrational x :=\n\u27e8of_int_add m, \u03bb h, h.int_add m\u27e9\n\n@[simp] theorem irrational_nat_add_iff : irrational (n + x) \u2194 irrational x :=\n\u27e8of_nat_add n, \u03bb h, h.nat_add n\u27e9\n\n@[simp] theorem irrational_add_rat_iff : irrational (x + q) \u2194 irrational x :=\n\u27e8of_add_rat q, add_rat q\u27e9\n\n@[simp] theorem irrational_add_int_iff : irrational (x + m) \u2194 irrational x :=\n\u27e8of_add_int m, \u03bb h, h.add_int m\u27e9\n\n@[simp] theorem irrational_add_nat_iff : irrational (x + n) \u2194 irrational x :=\n\u27e8of_add_nat n, \u03bb h, h.add_nat n\u27e9\n\n@[simp] theorem irrational_rat_sub_iff : irrational (q - x) \u2194 irrational x :=\n\u27e8of_rat_sub q, rat_sub q\u27e9\n\n@[simp] theorem irrational_int_sub_iff : irrational (m - x) \u2194 irrational x :=\n\u27e8of_int_sub m, \u03bb h, h.int_sub m\u27e9\n\n@[simp] theorem irrational_nat_sub_iff : irrational (n - x) \u2194 irrational x :=\n\u27e8of_nat_sub n, \u03bb h, h.nat_sub n\u27e9\n\n@[simp] theorem irrational_sub_rat_iff : irrational (x - q) \u2194 irrational x :=\n\u27e8of_sub_rat q, sub_rat q\u27e9\n\n@[simp] theorem irrational_sub_int_iff : irrational (x - m) \u2194 irrational x :=\n\u27e8of_sub_int m, \u03bb h, h.sub_int m\u27e9\n\n@[simp] theorem irrational_sub_nat_iff : irrational (x - n) \u2194 irrational x :=\n\u27e8of_sub_nat n, \u03bb h, h.sub_nat n\u27e9\n\n@[simp] theorem irrational_neg_iff : irrational (-x) \u2194 irrational x :=\n\u27e8of_neg, irrational.neg\u27e9\n\n@[simp] theorem irrational_inv_iff : irrational x\u207b\u00b9 \u2194 irrational x :=\n\u27e8of_inv, irrational.inv\u27e9\n\n@[simp] theorem irrational_rat_mul_iff : irrational (q * x) \u2194 q \u2260 0 \u2227 irrational x :=\n\u27e8\u03bb h, \u27e8rat.cast_ne_zero.1 $ left_ne_zero_of_mul h.ne_zero, h.of_rat_mul q\u27e9, \u03bb h, h.2.rat_mul h.1\u27e9\n\n@[simp] theorem irrational_mul_rat_iff : irrational (x * q) \u2194 q \u2260 0 \u2227 irrational x :=\nby rw [mul_comm, irrational_rat_mul_iff]\n\n@[simp] theorem irrational_int_mul_iff : irrational (m * x) \u2194 m \u2260 0 \u2227 irrational x :=\nby rw [\u2190 cast_coe_int, irrational_rat_mul_iff, int.cast_ne_zero]\n\n@[simp] theorem irrational_mul_int_iff : irrational (x * m) \u2194 m \u2260 0 \u2227 irrational x :=\nby rw [\u2190 cast_coe_int, irrational_mul_rat_iff, int.cast_ne_zero]\n\n@[simp] theorem irrational_nat_mul_iff : irrational (n * x) \u2194 n \u2260 0 \u2227 irrational x :=\nby rw [\u2190 cast_coe_nat, irrational_rat_mul_iff, nat.cast_ne_zero]\n\n@[simp] theorem irrational_mul_nat_iff : irrational (x * n) \u2194 n \u2260 0 \u2227 irrational x :=\nby rw [\u2190 cast_coe_nat, irrational_mul_rat_iff, nat.cast_ne_zero]\n\n@[simp] theorem irrational_rat_div_iff : irrational (q / x) \u2194 q \u2260 0 \u2227 irrational x :=\nby simp [div_eq_mul_inv]\n\n@[simp] theorem irrational_div_rat_iff : irrational (x / q) \u2194 q \u2260 0 \u2227 irrational x :=\nby rw [div_eq_mul_inv, \u2190 cast_inv, irrational_mul_rat_iff, ne.def, inv_eq_zero]\n\n@[simp] theorem irrational_int_div_iff : irrational (m / x) \u2194 m \u2260 0 \u2227 irrational x :=\nby simp [div_eq_mul_inv]\n\n@[simp] theorem irrational_div_int_iff : irrational (x / m) \u2194 m \u2260 0 \u2227 irrational x :=\nby rw [\u2190 cast_coe_int, irrational_div_rat_iff, int.cast_ne_zero]\n\n@[simp] theorem irrational_nat_div_iff : irrational (n / x) \u2194 n \u2260 0 \u2227 irrational x :=\nby simp [div_eq_mul_inv]\n\n@[simp] theorem irrational_div_nat_iff : irrational (x / n) \u2194 n \u2260 0 \u2227 irrational x :=\nby rw [\u2190 cast_coe_nat, irrational_div_rat_iff, nat.cast_ne_zero]\n\n/-- There is an irrational number `r` between any two reals `x < r < y`. -/\ntheorem exists_irrational_btwn {x y : \u211d} (h : x < y) :\n  \u2203 r, irrational r \u2227 x < r \u2227 r < y :=\nlet \u27e8q, \u27e8hq1, hq2\u27e9\u27e9 := (exists_rat_btwn ((sub_lt_sub_iff_right (real.sqrt 2)).mpr h)) in\n  \u27e8q + real.sqrt 2, irrational_sqrt_two.rat_add _,\n    sub_lt_iff_lt_add.mp hq1, lt_sub_iff_add_lt.mp hq2\u27e9\n\nend\n"}
{"text": "lemma coeffs_map_poly [code abstract]: \"coeffs (map_poly f p) = strip_while ((=) 0) (map f (coeffs p))\""}
{"text": "informal statement Let $V$ be a vector space which is spanned by a countably infinite set. Prove that every linearly independent subset of $V$ is finite or countably infinite.formal statement theorem exercise_6_1_14 (G : Type*) [group G]\n  (hG : is_cyclic $ G \u29f8 (center G)) :\n  center G = \u22a4  :="}
{"text": "theorem very_easy : true :=\nbegin\n  sorry\nend\n"}
{"text": "/-\nCopyright (c) 2021 Ashvni Narayanan. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ashvni Narayanan\n-/\nimport tendsto_zero_of_sum_even_char\n--import p_adic_L_function_def\n-- import general_bernoulli_number.basic\n-- import topology.algebra.nonarchimedean.bases\n-- import chinese_remainder_units\n/-!\n# A convergence property regarding (\u2124/dp^n \u2124)\u02e3\nThis file proves the third sum in the proof of Theorem 12.2 in Introduction to Cyclotomic Fields, Washington. \nIt gives a convergence property relating to generalized Bernoulli numbers.\n\n# Main Theorems\n * `W`\n\n## Tags\np-adic, L-function, Bernoulli measure, Dirichlet character\n-/\nopen_locale big_operators\nlocal attribute [instance] zmod.topological_space\n\nopen filter dirichlet_character\nopen_locale topological_space\n\nopen_locale big_operators\n\nvariables {p : \u2115} [fact (nat.prime p)] {d : \u2115} [fact (0 < d)] {R : Type*} [normed_comm_ring R] (m : \u2115)\n(hd : d.gcd p = 1) (\u03c7 : dirichlet_character R (d*(p^m))) {c : \u2115} (hc : c.gcd p = 1)\n(hc' : c.gcd d = 1) (na : \u2200 (n : \u2115) (f : \u2115 \u2192 R), \u2225 \u2211 (i : \u2115) in finset.range n, f i\u2225 \u2264 \u2a06 (i : zmod n), \u2225f i.val\u2225)\nvariables (p d R) [complete_space R] [char_zero R]\nopen continuous_map\n\nvariables [normed_algebra \u211a_[p] R] [fact (0 < m)]\nvariable [fact (0 < d)]\nopen dirichlet_character\nvariable (hd)\nopen zmod\nvariable (c)\nvariables (hc) (hc')\n\nlemma W [no_zero_divisors R] [algebra \u211a R] [norm_one_class R] (hd : d.coprime p) (hp : 2 < p)\n  (na' : \u2200 (n : \u2115) (f : (zmod n)\u02e3 \u2192 R), \u2225\u2211 i : (zmod n)\u02e3, f i\u2225 \u2264 \u2a06 (i : (zmod n)\u02e3), \u2225f i\u2225)\n  (na : \u2200 (n : \u2115) (f : \u2115 \u2192 R), \u2225\u2211 i in finset.range n, f i\u2225 \u2264 \u2a06 (i : zmod n), \u2225f i.val\u2225)\n  (n : \u2115) (hn : 1 < n) (h\u03c7 : \u03c7.is_even) :\n  filter.tendsto (\u03bb j : \u2115, \u2211 (x : (zmod (d * p ^ j))\u02e3),\n  ((asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R^n)) x : R) *\n  ((((x : zmod (d * p^j))).val)^(n - 1) : R)) \u2022 (algebra_map \u211a R) ((\u2191c - 1) / 2)) filter.at_top (nhds 0) :=\nbegin\n  simp_rw [smul_eq_mul, \u2190 finset.sum_mul],\n  conv { congr, skip, skip, congr, rw \u2190 zero_mul ((algebra_map \u211a R) ((\u2191c - 1) / 2)), },\n  apply tendsto.mul_const,\n  simp_rw zmod.nat_cast_val, simp_rw \u2190 coe_coe,\n  convert (tendsto_congr' _).1 (sum_even_character_tendsto_zero_of_units na' hn h\u03c7 hp),\n  rw eventually_eq, rw eventually_at_top,\n  refine \u27e8m, \u03bb y hy, _\u27e9,\n  apply finset.sum_congr rfl,\n  intros z hz,\n  conv_lhs { congr, rw coe_coe, rw \u2190 zmod.nat_cast_val, },\n  rw zmod.nat_cast_val, rw \u2190 coe_coe,\nend\n"}
{"text": "import .affine_space_type\nimport .affine_frame\nimport data.real.basic\n\ndef reals_as_affine_space := affine_space_type\n    \u211d \n    \u211d \n    \u211d\n\n#check reals_as_affine_space\n\ndef reals_as_affine_space_1 : reals_as_affine_space  := \u27e8\u27e9\ndef reals_as_affine_space_2 : reals_as_affine_space  := \u27e8\u27e9\n\nexample : reals_as_affine_space_1 = reals_as_affine_space_2 := rfl\n\ndef a_frame : affine_frame \u211d \u211d \u211d (fin 1) :=\n\u27e8(0 : \u211d),\n(\u03bb (n : fin 1), 1),\nsorry \u27e9 \n\n\n\n\n\n/-\nA few things to note:\n\n(1) We can specialize our generic affine_space_type definition\n(2) We can't instantiate disjoint affine space of the same type \n(3) Can we express news points and vectors in terms of this frame?\n-/"}
{"text": "[STATEMENT]\nlemma min_enat_simps [simp]:\n  \"min (enat m) (enat n) = enat (min m n)\"\n  \"min q 0 = 0\"\n  \"min 0 q = 0\"\n  \"min q (\\<infinity>::enat) = q\"\n  \"min (\\<infinity>::enat) q = q\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. (min (enat m) (enat n) = enat (min m n) &&& min q 0 = 0) &&& min 0 q = 0 &&& min q \\<infinity> = q &&& min \\<infinity> q = q\n[PROOF STEP]\nby (auto simp add: min_def)"}
{"text": "/-\nCopyright (c) 2021 Alain Verberkmoes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alain Verberkmoes\n-/\n\nimport data.int.basic\n\n/-!\n# IMO 2011 Q5\n\nLet `f` be a function from the set of integers to the set\nof positive integers.  Suppose that, for any two integers\n`m` and `n`, the difference `f(m) \u2212 f(n)` is divisible by\n`f(m \u2212 n)`.  Prove that, for all integers `m` and `n` with\n`f(m) \u2264 f(n)`, the number `f(n)` is divisible by `f(m)`.\n-/\n\nopen int\n\ntheorem imo2011_q5 (f : \u2124 \u2192 \u2124) (hpos : \u2200 n : \u2124, 0 < f n)\n  (hdvd : \u2200 m n : \u2124, f (m - n) \u2223 f m - f n) :\n\u2200 m n : \u2124, f m \u2264 f n \u2192 f m \u2223 f n :=\nbegin\n  intros m n h_fm_le_fn,\n  cases lt_or_eq_of_le h_fm_le_fn with h_fm_lt_fn h_fm_eq_fn,\n  { -- m < n\n    let d := f m - f (m - n),\n    have h_fn_dvd_d : f n \u2223 d,\n    { rw \u2190sub_sub_self m n,\n      exact hdvd m (m - n) },\n    have h_d_lt_fn : d < f n,\n    { calc d < f m : sub_lt_self _ (hpos (m - n))\n        ... < f n : h_fm_lt_fn },\n    have h_neg_d_lt_fn : -d < f n,\n    { calc -d = f (m - n) - f m : neg_sub _ _\n        ... < f (m - n) : sub_lt_self _ (hpos m)\n        ... \u2264 f n - f m : le_of_dvd (sub_pos.mpr h_fm_lt_fn) _\n        ... < f n : sub_lt_self _ (hpos m),\n      -- \u22a2 f (m - n) \u2223 f n - f m\n      rw [\u2190dvd_neg, neg_sub], exact hdvd m n },\n    have h_d_eq_zero : d = 0,\n    { obtain (hd | hd | hd) : d > 0 \u2228 d = 0 \u2228 d < 0 := trichotomous d 0,\n      { -- d > 0\n        have h\u2081 : f n \u2264 d, from le_of_dvd hd h_fn_dvd_d,\n        have h\u2082 : \u00ac f n \u2264 d, from not_le.mpr h_d_lt_fn,\n        contradiction },\n      { -- d = 0\n        exact hd },\n      { -- d < 0\n        have h\u2081 : f n \u2264 -d, from le_of_dvd (neg_pos.mpr hd) ((dvd_neg _ _).mpr h_fn_dvd_d),\n        have h\u2082 : \u00ac f n \u2264 -d, from not_le.mpr h_neg_d_lt_fn,\n        contradiction } },\n    have h\u2081 : f m = f (m - n), from sub_eq_zero.mp h_d_eq_zero,\n    have h\u2082 : f (m - n) \u2223 f m - f n, from hdvd m n,\n    rw \u2190h\u2081 at h\u2082,\n    exact (dvd_iff_dvd_of_dvd_sub h\u2082).mp dvd_rfl },\n  { -- m = n\n    rw h_fm_eq_fn }\nend\n"}
{"text": "import Mathlib.Data.Rat.Order\nimport Mathlib.Tactic.Ring\n\n/- 4 points -/\ntheorem problem1 {x : \u211a} (hx : x = 2/3) : 3 * x \u2260 1 := by\n  apply ne_of_gt\n  calc 3 * x = 3 * (2 / 3) := by rw [hx]\n  _ > 1 := by rfl\n\n/- 5 points -/\ntheorem problem2 {x y : \u211a} (h : x = 1 \u2228 y = -1) :\n    x * y + x = y + 1 := by\n  cases' h with hx hy\n  . calc x * y + x = 1 * y + 1 := by rw [hx]\n    _ = y + 1 := by ring\n  . calc x * y + x = x * -1 + x := by rw [hy]\n    _ = -1 + 1 := by ring\n    _ = y + 1 := by rw [hy]\n\n/- 1 point -/\ntheorem problem3 {x : \u211a} (hx : 2 * x + 1 = 5) :\n    2 * x = 2 \u2228 2 * x = 4 := by\n  right\n  calc 2 * x = (2 * x + 1) - 1 := by ring\n  _ = 5 - 1 := by rw [hx]\n  _ = 4 := by norm_num"}
{"text": "{-# OPTIONS --rewriting #-}\n\npostulate\n  _\u21a6_ : {A : Set} \u2192 A \u2192 A \u2192 Set\n  idr : {A : Set} {a : A} \u2192 a \u21a6 a\n{-# BUILTIN REWRITE _\u21a6_ #-}\n\nrecord _\u00d7_ (A B : Set) : Set where\n  constructor _,_\n  field\n    fst : A\n    snd : B\n\n\npostulate\n  A B C : Set\n  g : A \u2192 B \u2192 C\n\nf : A \u00d7 B \u2192 C\nf (x , y) = g x y\n\n\npostulate\n  D : Set\n  P : (A \u2192 B \u2192 C) \u2192 D\n  res : D\n  rew : P (\u03bb x y \u2192 g x y) \u21a6 res\n  {-# REWRITE rew #-}\n\ntest : P (\u03bb x y \u2192 f (x , y)) \u21a6 res\ntest = idr\n"}
{"text": "/-\n Description : Formalization of islanders problem for two people.\n Copyright   : (c) Daniel Selsam, 2018\n License     : GPL-3\n-/\n\nimport .util .knows .problem\n\ntheorem islanders_n2 : islanders 2 :=\n\nassume everyone_sees :\n  \u2200 (d\u2081 d\u2082 : day) (p\u2081 p\u2082 : person), p\u2082 \u2260 p\u2081 \u2192 common_knowledge (is_marked p\u2082 \u2192 knows d\u2082 p\u2081 (is_marked p\u2082)) d\u2081\n                                            \u2227 common_knowledge (\u00ac is_marked p\u2082 \u2192 knows d\u2082 p\u2081 (\u00ac is_marked p\u2082)) d\u2081,\n\nassume oracle :\n  \u2200 (d : day) (p : person) (k : \u2115), common_knowledge (knows (d+1) p (reduce_or (list.map is_marked (list.range 2)))) (d+1+k),\n\nassume nobody_leaves :\n  \u2200 (d : day) (p : person), d+1 < 2 \u2192 common_knowledge (\u00ac knows (d+1) p (is_marked p)) (d+2),\n\nhave H1 : knows 1 1 (\u00ac is_marked 1 \u2192 knows 1 0 (is_marked 0 \u2228 is_marked 1)), from\n  knows_lam 1 1 1 [] (\u03bb _, oracle 0 0 0 [1]),\n\nhave H2 : knows 1 1 (\u00ac is_marked 1 \u2192 knows 1 0 (\u00ac is_marked 1)), from\n  and.right (everyone_sees 1 1 0 1 (ne.symm nat.zero_ne_one)) [1],\n\nhave H3 : knows 1 1 (\u00ac is_marked 1) \u2192 knows 1 1 (knows 1 0 (is_marked 0)), from\n  assume h1 : knows 1 1 (\u00ac is_marked 1),\n  show knows 1 1 (knows 1 0 (is_marked 0)), from\n  have h2 : knows 1 1 (knows 1 0 (is_marked 0 \u2228 is_marked 1)), from knows_mp 0 1 1 1 [] [] H1 h1,\n  have h3 : knows 1 1 (knows 1 0 (\u00ac is_marked 1)), from knows_mp 0 1 1 1 [] [] H2 h1,\n  knows_cancel_or 0 _ _ _ [1] [] h2 h3,\n\nhave H4 : knows 2 1 (\u00ac is_marked 1 \u2192 knows 1 0 (is_marked 0)), from\n  knows_persists 0 1 1 [] (knows_lam 0 1 1 [] H3),\n\nhave H5 : knows 2 1 (\u00ac knows 1 0 (is_marked 0)), from\n  nobody_leaves 0 0 (nat.lt_succ_self 1) [1],\n\nshow knows 2 1 (is_marked 1), from\n  knows_dneg 0 _ _ [] (knows_cancel_imp 0 0 _ _ [] [] H4 H5)\n"}
{"text": "lemma of_real_1 [simp]: \"of_real 1 = 1\""}
{"text": "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Eric Wieser\n-/\n\nimport algebra.char_p.basic\nimport ring_theory.ideal.quotient\n\n/-!\n# Characteristic of quotients rings\n-/\n\nuniverses u v\n\nnamespace char_p\n\ntheorem quotient (R : Type u) [comm_ring R] (p : \u2115) [hp1 : fact p.prime] (hp2 : \u2191p \u2208 nonunits R) :\n  char_p (R \u29f8 (ideal.span {p} : ideal R)) p :=\nhave hp0 : (p : R \u29f8 (ideal.span {p} : ideal R)) = 0,\n  from (ideal.quotient.mk (ideal.span {p} : ideal R)).map_nat_cast p \u25b8\n    ideal.quotient.eq_zero_iff_mem.2 (ideal.subset_span $ set.mem_singleton _),\nring_char.of_eq $ or.resolve_left ((nat.dvd_prime hp1.1).1 $ ring_char.dvd hp0) $ \u03bb h1,\nhp2 $ is_unit_iff_dvd_one.2 $ ideal.mem_span_singleton.1 $ ideal.quotient.eq_zero_iff_mem.1 $\n@@subsingleton.elim (@@char_p.subsingleton _ $ ring_char.of_eq h1) _ _\n\n/-- If an ideal does not contain any coercions of natural numbers other than zero, then its quotient\ninherits the characteristic of the underlying ring. -/\nlemma quotient' {R : Type*} [comm_ring R] (p : \u2115) [char_p R p] (I : ideal R)\n  (h : \u2200 x : \u2115, (x : R) \u2208 I \u2192 (x : R) = 0) :\n  char_p (R \u29f8 I) p :=\n\u27e8\u03bb x, begin\n  rw [\u2190cast_eq_zero_iff R p x, \u2190(ideal.quotient.mk I).map_nat_cast],\n  refine quotient.eq'.trans (_ : \u2191x - 0 \u2208 I \u2194 _),\n  rw sub_zero,\n  exact \u27e8h x, \u03bb h', h'.symm \u25b8 I.zero_mem\u27e9,\nend\u27e9\n\nend char_p\n"}
{"text": "/-\nCopyright (c) 2018 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro, Abhimanyu Pallavi Sudhir, Jean Lo, Calle S\u00f6nne, Yury Kudryashov\n-/\nimport data.real.sqrt\nimport data.rat.sqrt\nimport ring_theory.int.basic\nimport data.polynomial.eval\nimport data.polynomial.degree\nimport tactic.interval_cases\nimport ring_theory.algebraic\n/-!\n# Irrational real numbers\n\nIn this file we define a predicate `irrational` on `\u211d`, prove that the `n`-th root of an integer\nnumber is irrational if it is not integer, and that `sqrt q` is irrational if and only if\n`rat.sqrt q * rat.sqrt q \u2260 q \u2227 0 \u2264 q`.\n\nWe also provide dot-style constructors like `irrational.add_rat`, `irrational.rat_sub` etc.\n-/\n\nopen rat real multiplicity\n\n/-- A real number is irrational if it is not equal to any rational number. -/\ndef irrational (x : \u211d) := x \u2209 set.range (coe : \u211a \u2192 \u211d)\n\nlemma irrational_iff_ne_rational (x : \u211d) : irrational x \u2194 \u2200 a b : \u2124, x \u2260 a / b :=\nby simp only [irrational, rat.forall, cast_mk, not_exists, set.mem_range, cast_coe_int, cast_div,\n  eq_comm]\n\n/-- A transcendental real number is irrational. -/\nlemma transcendental.irrational {r : \u211d} (tr : transcendental \u211a r) :\n  irrational r :=\nby { rintro \u27e8a, rfl\u27e9, exact tr (is_algebraic_algebra_map a) }\n\n/-!\n### Irrationality of roots of integer and rational numbers\n-/\n\n/-- If `x^n`, `n > 0`, is integer and is not the `n`-th power of an integer, then\n`x` is irrational. -/\ntheorem irrational_nrt_of_notint_nrt {x : \u211d} (n : \u2115) (m : \u2124)\n  (hxr : x ^ n = m) (hv : \u00ac \u2203 y : \u2124, x = y) (hnpos : 0 < n) :\n  irrational x :=\nbegin\n  rintros \u27e8\u27e8N, D, P, C\u27e9, rfl\u27e9,\n  rw [\u2190 cast_pow] at hxr,\n  have c1 : ((D : \u2124) : \u211d) \u2260 0,\n  { rw [int.cast_ne_zero, int.coe_nat_ne_zero], exact ne_of_gt P },\n  have c2 : ((D : \u2124) : \u211d) ^ n \u2260 0 := pow_ne_zero _ c1,\n  rw [num_denom', cast_pow, cast_mk, div_pow, div_eq_iff_mul_eq c2,\n      \u2190 int.cast_pow, \u2190 int.cast_pow, \u2190 int.cast_mul, int.cast_inj] at hxr,\n  have hdivn : \u2191D ^ n \u2223 N ^ n := dvd.intro_left m hxr,\n  rw [\u2190 int.dvd_nat_abs, \u2190 int.coe_nat_pow, int.coe_nat_dvd, int.nat_abs_pow,\n    nat.pow_dvd_pow_iff hnpos] at hdivn,\n  have hD : D = 1 := by rw [\u2190 nat.gcd_eq_right hdivn, C.gcd_eq_one],\n  subst D,\n  refine hv \u27e8N, _\u27e9,\n  rw [num_denom', int.coe_nat_one, mk_eq_div, int.cast_one, div_one, cast_coe_int]\nend\n\n/-- If `x^n = m` is an integer and `n` does not divide the `multiplicity p m`, then `x`\nis irrational. -/\ntheorem irrational_nrt_of_n_not_dvd_multiplicity {x : \u211d} (n : \u2115) {m : \u2124} (hm : m \u2260 0) (p : \u2115)\n  [hp : fact p.prime] (hxr : x ^ n = m)\n  (hv : (multiplicity (p : \u2124) m).get (finite_int_iff.2 \u27e8hp.1.ne_one, hm\u27e9) % n \u2260 0) :\n  irrational x :=\nbegin\n  rcases nat.eq_zero_or_pos n with rfl | hnpos,\n  { rw [eq_comm, pow_zero, \u2190 int.cast_one, int.cast_inj] at hxr,\n    simpa [hxr, multiplicity.one_right (mt is_unit_iff_dvd_one.1\n      (mt int.coe_nat_dvd.1 hp.1.not_dvd_one)), nat.zero_mod] using hv },\n  refine irrational_nrt_of_notint_nrt _ _ hxr _ hnpos,\n  rintro \u27e8y, rfl\u27e9,\n  rw [\u2190 int.cast_pow, int.cast_inj] at hxr, subst m,\n  have : y \u2260 0, { rintro rfl, rw zero_pow hnpos at hm, exact hm rfl },\n  erw [multiplicity.pow' (nat.prime_iff_prime_int.1 hp.1)\n    (finite_int_iff.2 \u27e8hp.1.ne_one, this\u27e9), nat.mul_mod_right] at hv,\n  exact hv rfl\nend\n\ntheorem irrational_sqrt_of_multiplicity_odd (m : \u2124) (hm : 0 < m)\n  (p : \u2115) [hp : fact p.prime]\n  (Hpv : (multiplicity (p : \u2124) m).get\n    (finite_int_iff.2 \u27e8hp.1.ne_one, (ne_of_lt hm).symm\u27e9) % 2 = 1) :\n  irrational (sqrt m) :=\n@irrational_nrt_of_n_not_dvd_multiplicity _ 2 _ (ne.symm (ne_of_lt hm)) p hp\n  (sq_sqrt (int.cast_nonneg.2 $ le_of_lt hm))\n  (by rw Hpv; exact one_ne_zero)\n\ntheorem nat.prime.irrational_sqrt {p : \u2115} (hp : nat.prime p) : irrational (sqrt p) :=\n@irrational_sqrt_of_multiplicity_odd p (int.coe_nat_pos.2 hp.pos) p \u27e8hp\u27e9 $\nby simp [multiplicity_self (mt is_unit_iff_dvd_one.1 (mt int.coe_nat_dvd.1 hp.not_dvd_one) : _)];\n  refl\n\ntheorem irrational_sqrt_two : irrational (sqrt 2) :=\nby simpa using nat.prime_two.irrational_sqrt\n\ntheorem irrational_sqrt_rat_iff (q : \u211a) : irrational (sqrt q) \u2194\n  rat.sqrt q * rat.sqrt q \u2260 q \u2227 0 \u2264 q :=\nif H1 : rat.sqrt q * rat.sqrt q = q\nthen iff_of_false (not_not_intro \u27e8rat.sqrt q,\n  by rw [\u2190 H1, cast_mul, sqrt_mul_self (cast_nonneg.2 $ rat.sqrt_nonneg q),\n         sqrt_eq, abs_of_nonneg (rat.sqrt_nonneg q)]\u27e9) (\u03bb h, h.1 H1)\nelse if H2 : 0 \u2264 q\nthen iff_of_true (\u03bb \u27e8r, hr\u27e9, H1 $ (exists_mul_self _).1 \u27e8r,\n  by rwa [eq_comm, sqrt_eq_iff_mul_self_eq (cast_nonneg.2 H2), \u2190 cast_mul, rat.cast_inj] at hr;\n  rw [\u2190 hr]; exact real.sqrt_nonneg _\u27e9) \u27e8H1, H2\u27e9\nelse iff_of_false (not_not_intro \u27e80,\n  by rw cast_zero; exact (sqrt_eq_zero_of_nonpos (rat.cast_nonpos.2 $ le_of_not_le H2)).symm\u27e9)\n  (\u03bb h, H2 h.2)\n\ninstance (q : \u211a) : decidable (irrational (sqrt q)) :=\ndecidable_of_iff' _ (irrational_sqrt_rat_iff q)\n\n/-!\n### Adding/subtracting/multiplying by rational numbers\n-/\n\nlemma rat.not_irrational (q : \u211a) : \u00acirrational q := \u03bb h, h \u27e8q, rfl\u27e9\n\nnamespace irrational\n\nvariables (q : \u211a) {x y : \u211d}\n\nopen_locale classical\n\ntheorem add_cases : irrational (x + y) \u2192 irrational x \u2228 irrational y :=\nbegin\n  delta irrational,\n  contrapose!,\n  rintros \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9,\n  exact \u27e8rx + ry, cast_add rx ry\u27e9\nend\n\ntheorem of_rat_add (h : irrational (q + x)) : irrational x :=\nh.add_cases.elim (\u03bb h, absurd h q.not_irrational) id\n\ntheorem rat_add (h : irrational x) : irrational (q + x) :=\nof_rat_add (-q) $ by rwa [cast_neg, neg_add_cancel_left]\n\ntheorem of_add_rat : irrational (x + q) \u2192 irrational x :=\nadd_comm \u2191q x \u25b8 of_rat_add q\n\ntheorem add_rat (h : irrational x) : irrational (x + q) :=\nadd_comm \u2191q x \u25b8 h.rat_add q\n\ntheorem of_neg (h : irrational (-x)) : irrational x :=\n\u03bb \u27e8q, hx\u27e9, h \u27e8-q, by rw [cast_neg, hx]\u27e9\n\nprotected theorem neg (h : irrational x) : irrational (-x) :=\nof_neg $ by rwa neg_neg\n\ntheorem sub_rat (h : irrational x) : irrational (x - q) :=\nby simpa only [sub_eq_add_neg, cast_neg] using h.add_rat (-q)\n\ntheorem rat_sub (h : irrational x) : irrational (q - x) :=\nby simpa only [sub_eq_add_neg] using h.neg.rat_add q\n\ntheorem of_sub_rat (h : irrational (x - q)) : irrational x :=\n(of_add_rat (-q) $ by simpa only [cast_neg, sub_eq_add_neg] using h)\n\ntheorem of_rat_sub (h : irrational (q - x)) : irrational x :=\nof_neg (of_rat_add q (by simpa only [sub_eq_add_neg] using h))\n\ntheorem mul_cases : irrational (x * y) \u2192 irrational x \u2228 irrational y :=\nbegin\n  delta irrational,\n  contrapose!,\n  rintros \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9,\n  exact \u27e8rx * ry, cast_mul rx ry\u27e9\nend\n\ntheorem of_mul_rat (h : irrational (x * q)) : irrational x :=\nh.mul_cases.elim id (\u03bb h, absurd h q.not_irrational)\n\ntheorem mul_rat (h : irrational x) {q : \u211a} (hq : q \u2260 0) : irrational (x * q) :=\nof_mul_rat q\u207b\u00b9 $ by rwa [mul_assoc, \u2190 cast_mul, mul_inv_cancel hq, cast_one, mul_one]\n\ntheorem of_rat_mul : irrational (q * x) \u2192 irrational x :=\nmul_comm x q \u25b8 of_mul_rat q\n\ntheorem rat_mul (h : irrational x) {q : \u211a} (hq : q \u2260 0) : irrational (q * x) :=\nmul_comm x q \u25b8 h.mul_rat hq\n\ntheorem of_mul_self (h : irrational (x * x)) : irrational x :=\nh.mul_cases.elim id id\n\ntheorem of_inv (h : irrational x\u207b\u00b9) : irrational x :=\n\u03bb \u27e8q, hq\u27e9, h $ hq \u25b8 \u27e8q\u207b\u00b9, q.cast_inv\u27e9\n\nprotected theorem inv (h : irrational x) : irrational x\u207b\u00b9 :=\nof_inv $ by rwa inv_inv'\n\ntheorem div_cases (h : irrational (x / y)) : irrational x \u2228 irrational y :=\nh.mul_cases.imp id of_inv\n\ntheorem of_rat_div (h : irrational (q / x)) : irrational x :=\n(h.of_rat_mul q).of_inv\n\ntheorem of_one_div (h : irrational (1 / x)) : irrational x :=\nof_rat_div 1 $ by rwa [cast_one]\n\ntheorem of_pow : \u2200 n : \u2115, irrational (x^n) \u2192 irrational x\n| 0 := \u03bb h, by { rw pow_zero at h, exact (h \u27e81, cast_one\u27e9).elim }\n| (n+1) := \u03bb h, by { rw pow_succ at h, exact h.mul_cases.elim id (of_pow n) }\n\ntheorem of_fpow : \u2200 m : \u2124, irrational (x^m) \u2192 irrational x\n| (n:\u2115) := of_pow n\n| -[1+n] := \u03bb h, by { rw gpow_neg_succ_of_nat at h, exact h.of_inv.of_pow _ }\n\nend irrational\n\nsection polynomial\n\nopen polynomial\nvariables (x : \u211d) (p : polynomial \u2124)\n\nlemma one_lt_nat_degree_of_irrational_root (hx : irrational x) (p_nonzero : p \u2260 0)\n  (x_is_root : aeval x p = 0) : 1 < p.nat_degree :=\nbegin\n  by_contra rid,\n  rcases exists_eq_X_add_C_of_nat_degree_le_one (not_lt.1 rid) with \u27e8a, b, rfl\u27e9, clear rid,\n  have : (a : \u211d) * x = -b, by simpa [eq_neg_iff_add_eq_zero] using x_is_root,\n  rcases em (a = 0) with (rfl|ha),\n  { obtain rfl : b = 0, by simpa,\n    simpa using p_nonzero },\n  { rw [mul_comm, \u2190 eq_div_iff_mul_eq, eq_comm] at this,\n    refine hx \u27e8-b / a, _\u27e9,\n    assumption_mod_cast, assumption_mod_cast }\nend\n\nend polynomial\n\nsection\nvariables {q : \u211a} {x : \u211d}\n\nopen irrational\n\n@[simp] theorem irrational_rat_add_iff : irrational (q + x) \u2194 irrational x :=\n\u27e8of_rat_add q, rat_add q\u27e9\n\n@[simp] theorem irrational_add_rat_iff : irrational (x + q) \u2194 irrational x :=\n\u27e8of_add_rat q, add_rat q\u27e9\n\n@[simp] theorem irrational_rat_sub_iff : irrational (q - x) \u2194 irrational x :=\n\u27e8of_rat_sub q, rat_sub q\u27e9\n\n@[simp] theorem irrational_sub_rat_iff : irrational (x - q) \u2194 irrational x :=\n\u27e8of_sub_rat q, sub_rat q\u27e9\n\n@[simp] theorem irrational_neg_iff : irrational (-x) \u2194 irrational x :=\n\u27e8of_neg, irrational.neg\u27e9\n\n@[simp] theorem irrational_inv_iff : irrational x\u207b\u00b9 \u2194 irrational x :=\n\u27e8of_inv, irrational.inv\u27e9\n\nend\n"}
{"text": "informal statement If $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ prove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$.formal statement theorem exercise_3_6a\n: tendsto (\u03bb (n : \u2115), (\u2211 i in finset.range n, g i)) at_top at_top :="}
{"text": "lemmas has_derivative_Im [derivative_intros] = bounded_linear.has_derivative[OF bounded_linear_Im]"}
{"text": "informal statement Let $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, and let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.formal statement theorem exercise_4_4a\n  {\u03b1 : Type} [metric_space \u03b1]\n  {\u03b2 : Type} [metric_space \u03b2]\n  (f : \u03b1 \u2192 \u03b2)\n  (s : set \u03b1)\n  (h\u2081 : continuous f)\n  (h\u2082 : dense s)\n  : f '' set.univ \u2286 closure (f '' s) :="}
{"text": "import tactic\n-- the next two lines let us use the law of the excluded middle without trouble\nnoncomputable theory\nopen_locale classical\n\n--BEGIN--\n\n/--------------------------------------------------------------------------\n\nDelete the ``sorry,`` below and replace them with a legitimate proof.\n\n--------------------------------------------------------------------------/\n\n-- camper is a type.\n-- If x : camper then x is a camper in the main lounge.\n-- singing(x) is inhabited if x is singing\n\ntheorem math_campers_singing_paradox\n  (camper : Type)\n  (singing : camper \u2192 Prop)\n  (alice : camper) -- making sure that there is at least one camper in the lounge\n  : \u2203 x : camper, (singing x \u2192 (\u2200 y : camper, singing y)) :=\nbegin\n  sorry,\nend\n--END--"}
{"text": "[GOAL]\n\u22a2 1 = \u2016\u2191reClm 1\u2016\n[PROOFSTEP]\nsimp\n[GOAL]\n\u22a2 \u20161\u2016 \u2264 1\n[PROOFSTEP]\nsimp\n[GOAL]\n\u22a2 1 = \u2016\u2191imClm I\u2016\n[PROOFSTEP]\nsimp\n[GOAL]\n\u22a2 \u2016I\u2016 \u2264 1\n[PROOFSTEP]\nsimp\n"}
{"text": "postulate\n  \u221e  : \u2200 {a} (A : Set a) \u2192 Set a\n  \u266f_ : \u2200 {a} {A : Set a} \u2192 A \u2192 \u221e A\n  \u266d  : \u2200 {a} {A : Set a} \u2192 \u221e A \u2192 A\n\n{-# BUILTIN INFINITY \u221e  #-}\n{-# BUILTIN SHARP    \u266f_ #-}\n{-# BUILTIN FLAT     \u266d  #-}\n\n{-# COMPILE GHC \u266d as flat #-}\n"}
{"text": "import MyNat.Definition\nimport AdditionWorld.Level4 -- add_comm\nimport AdvancedAdditionWorld.Level5 -- add_right_cancel\nnamespace MyNat\nopen MyNat\n\n/-!\n\n# Advanced Addition World\n\n## Level 7: `add_right_cancel_iff`\n\nIt's sometimes convenient to have the \"if and only if\" version\nof theorems like `add_right_cancel`. Remember that you can use `constructor`\nto split an `\u2194` goal into the `\u2192` goal and the `\u2190` goal.\n\n## Pro tip:\n\nNotice `exact add_right_cancel _ _ _` means \"let Lean figure out the missing inputs\"\nso we don't have to spell it out like we did in Level 6.\n\n## Theorem\nFor all naturals `a`, `b` and `t`, `a + t = b + t \u2194 a = b.`\n-/\ntheorem add_right_cancel_iff (t a b : MyNat) :  a + t = b + t \u2194 a = b := by\n  constructor\n  exact add_right_cancel _ _ _\n  intro h\n  rw [h]\n\n/-!\nNext up [Level 8](./Level8.lean.md)\n-/\n"}
{"text": "informal statement Prove that for each positive integer $n$, the number $10^{10^{10^n}}+10^{10^n}+10^n-1$ is not prime.formal statement theorem exercise_2000_a2 : \n  \u2200 N : \u2115, \u2203 n : \u2115, n > N \u2227 \u2203 i : fin 6 \u2192 \u2115, n = (i 0)^2 + (i 1)^2 \u2227 \n  n + 1 = (i 2)^2 + (i 3)^2 \u2227 n + 2 = (i 4)^2 + (i 5)^2 :="}
{"text": "informal statement An ideal $N$ is called nilpotent if $N^{n}$ is the zero ideal for some $n \\geq 1$. Prove that the ideal $p \\mathbb{Z} / p^{m} \\mathbb{Z}$ is a nilpotent ideal in the ring $\\mathbb{Z} / p^{m} \\mathbb{Z}$.formal statement theorem exercise_7_3_37 {R : Type*} {p m : \u2115} (hp : p.prime) \n  (N : ideal $ zmod $ p^m) : \n  is_nilpotent N \u2194  is_nilpotent (ideal.span ({p} : set $ zmod $ p^m)) :="}
{"text": "! Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n! See https://llvm.org/LICENSE.txt for license information.\n! SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n\n\nsubroutine weird(dummy)\n  class(*), target :: dummy(:)\nend subroutine weird\n\nprogram main\n  integer(kind=4), pointer :: myptr(:)\n  integer :: j\n  logical rslt(8), expect(8)\n  interface\n     subroutine weird(dummy)\n       class(*), target :: dummy(:)\n     end subroutine weird\n  end interface\n  allocate(myptr(4))\n  myptr = [(111*j, j=1,4)]\n  expect = .true.\n  do j=1,4\n     rslt(j) = (myptr(j) .eq. (111*j))\n  enddo\n  call weird(myptr)\n  do j=1,4\n     rslt(j+4) = (myptr(j) .eq. (111*j))\n  enddo\n  call check(rslt,expect,8)\nend program main\n"}
{"text": "(*  Title:      HOL/Bali/Trans.thy\n    Author:     David von Oheimb and Norbert Schirmer\n\nOperational transition (small-step) semantics of the \nexecution of Java expressions and statements\n\nPRELIMINARY!!!!!!!!\n*)\n\ntheory Trans imports Evaln begin\n\ndefinition\n  groundVar :: \"var \\<Rightarrow> bool\" where\n  \"groundVar v \\<longleftrightarrow> (case v of\n                     LVar ln \\<Rightarrow> True\n                   | {accC,statDeclC,stat}e..fn \\<Rightarrow> \\<exists> a. e=Lit a\n                   | e1.[e2] \\<Rightarrow> \\<exists> a i. e1= Lit a \\<and> e2 = Lit i\n                   | InsInitV c v \\<Rightarrow> False)\"\n\nlemma groundVar_cases:\n  assumes ground: \"groundVar v\"\n  obtains (LVar) ln where \"v=LVar ln\"\n    | (FVar) accC statDeclC stat a fn where \"v={accC,statDeclC,stat}(Lit a)..fn\"\n    | (AVar) a i where \"v=(Lit a).[Lit i]\"\n  using ground LVar FVar AVar\n  by (cases v) (auto simp add: groundVar_def)\n\ndefinition\n  groundExprs :: \"expr list \\<Rightarrow> bool\"\n  where \"groundExprs es \\<longleftrightarrow> (\\<forall>e \\<in> set es. \\<exists>v. e = Lit v)\"\n  \nprimrec the_val:: \"expr \\<Rightarrow> val\"\n  where \"the_val (Lit v) = v\"\n\nprimrec the_var:: \"prog \\<Rightarrow> state \\<Rightarrow> var \\<Rightarrow> (vvar \\<times> state)\" where\n  \"the_var G s (LVar ln) = (lvar ln (store s),s)\"\n| the_var_FVar_def: \"the_var G s ({accC,statDeclC,stat}a..fn) =fvar statDeclC stat fn (the_val a) s\"\n| the_var_AVar_def: \"the_var G s(a.[i])                       =avar G (the_val i) (the_val a) s\"\n\nlemma the_var_FVar_simp[simp]:\n\"the_var G s ({accC,statDeclC,stat}(Lit a)..fn) = fvar statDeclC stat fn a s\"\nby (simp)\ndeclare the_var_FVar_def [simp del]\n\nlemma the_var_AVar_simp:\n\"the_var G s ((Lit a).[Lit i]) = avar G i a s\"\nby (simp)\ndeclare the_var_AVar_def [simp del]\n\nabbreviation\n  Ref :: \"loc \\<Rightarrow> expr\"\n  where \"Ref a == Lit (Addr a)\"\n\nabbreviation\n  SKIP :: \"expr\"\n  where \"SKIP == Lit Unit\"\n\ninductive\n  step :: \"[prog,term \\<times> state,term \\<times> state] \\<Rightarrow> bool\" (\"_\\<turnstile>_ \\<mapsto>1 _\"[61,82,82] 81)\n  for G :: prog\nwhere\n\n(* evaluation of expression *)\n  (* cf. 15.5 *)\n  Abrupt:       \"\\<lbrakk>\\<forall>v. t \\<noteq> \\<langle>Lit v\\<rangle>;\n                  \\<forall> t. t \\<noteq> \\<langle>l\\<bullet> Skip\\<rangle>;\n                  \\<forall> C vn c.  t \\<noteq> \\<langle>Try Skip Catch(C vn) c\\<rangle>;\n                  \\<forall> x c. t \\<noteq> \\<langle>Skip Finally c\\<rangle> \\<and> xc \\<noteq> Xcpt x;\n                  \\<forall> a c. t \\<noteq> \\<langle>FinA a c\\<rangle>\\<rbrakk> \n                \\<Longrightarrow> \n                  G\\<turnstile>(t,Some xc,s) \\<mapsto>1 (\\<langle>Lit undefined\\<rangle>,Some xc,s)\"\n\n| InsInitE: \"\\<lbrakk>G\\<turnstile>(\\<langle>c\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c'\\<rangle>, s')\\<rbrakk>\n             \\<Longrightarrow> \n             G\\<turnstile>(\\<langle>InsInitE c e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>InsInitE c' e\\<rangle>, s')\"\n\n(* SeqE: \"G\\<turnstile>(\\<langle>Seq Skip e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e\\<rangle>, Norm s)\" *)\n(* Specialised rules to evaluate: \n   InsInitE Skip (NewC C), InisInitE Skip (NewA T[e]) *)\n \n  (* cf. 15.8.1 *)\n| NewC: \"G\\<turnstile>(\\<langle>NewC C\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>InsInitE (Init C) (NewC C)\\<rangle>, Norm s)\"\n| NewCInited: \"\\<lbrakk>G\\<turnstile> Norm s \\<midarrow>halloc (CInst C)\\<succ>a\\<rightarrow> s'\\<rbrakk> \n               \\<Longrightarrow> \n               G\\<turnstile>(\\<langle>InsInitE Skip (NewC C)\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Ref a\\<rangle>, s')\"\n\n\n\n(* Alternative when rule SeqE is present \nNewCInited: \"\\<lbrakk>inited C (globs s); \n              G\\<turnstile> Norm s \\<midarrow>halloc (CInst C)\\<succ>a\\<rightarrow> s'\\<rbrakk> \n             \\<Longrightarrow> \n              G\\<turnstile>(\\<langle>NewC C\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Ref a\\<rangle>, s')\"\n\nNewC:\n     \"\\<lbrakk>\\<not> inited C (globs s)\\<rbrakk> \n     \\<Longrightarrow> \n      G\\<turnstile>(\\<langle>NewC C\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Seq (Init C) (NewC C)\\<rangle>, Norm s)\"\n\n*)\n  (* cf. 15.9.1 *)\n| NewA: \n   \"G\\<turnstile>(\\<langle>New T[e]\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>InsInitE (init_comp_ty T) (New T[e])\\<rangle>,Norm s)\"\n| InsInitNewAIdx: \n   \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>, s')\\<rbrakk>\n    \\<Longrightarrow>  \n    G\\<turnstile>(\\<langle>InsInitE Skip (New T[e])\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>InsInitE Skip (New T[e'])\\<rangle>,s')\"\n| InsInitNewA: \n   \"\\<lbrakk>G\\<turnstile>abupd (check_neg i) (Norm s) \\<midarrow>halloc (Arr T (the_Intg i))\\<succ>a\\<rightarrow> s' \\<rbrakk>\n    \\<Longrightarrow>\n    G\\<turnstile>(\\<langle>InsInitE Skip (New T[Lit i])\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Ref a\\<rangle>,s')\"\n \n  (* cf. 15.15 *)\n| CastE:\n   \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\\<rbrakk> \n    \\<Longrightarrow>\n    G\\<turnstile>(\\<langle>Cast T e\\<rangle>,None,s) \\<mapsto>1 (\\<langle>Cast T e'\\<rangle>,s')\" \n| Cast:\n   \"\\<lbrakk>s' = abupd (raise_if (\\<not>G,s\\<turnstile>v fits T)  ClassCast) (Norm s)\\<rbrakk> \n    \\<Longrightarrow> \n    G\\<turnstile>(\\<langle>Cast T (Lit v)\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit v\\<rangle>,s')\"\n  (* can be written without abupd, since we know Norm s *)\n\n\n| InstE: \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'::expr\\<rangle>,s')\\<rbrakk> \n        \\<Longrightarrow> \n        G\\<turnstile>(\\<langle>e InstOf T\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\" \n| Inst:  \"\\<lbrakk>b = (v\\<noteq>Null \\<and> G,s\\<turnstile>v fits RefT T)\\<rbrakk> \n          \\<Longrightarrow> \n          G\\<turnstile>(\\<langle>(Lit v) InstOf T\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit (Bool b)\\<rangle>,s')\"\n\n  (* cf. 15.7.1 *)\n(*Lit                           \"G\\<turnstile>(Lit v,None,s) \\<mapsto>1 (Lit v,None,s)\"*)\n\n| UnOpE:  \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s') \\<rbrakk>\n           \\<Longrightarrow> \n           G\\<turnstile>(\\<langle>UnOp unop e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>UnOp unop e'\\<rangle>,s')\"\n| UnOp:   \"G\\<turnstile>(\\<langle>UnOp unop (Lit v)\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit (eval_unop unop v)\\<rangle>,Norm s)\"\n\n| BinOpE1:  \"\\<lbrakk>G\\<turnstile>(\\<langle>e1\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e1'\\<rangle>,s') \\<rbrakk>\n             \\<Longrightarrow> \n             G\\<turnstile>(\\<langle>BinOp binop e1 e2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>BinOp binop e1' e2\\<rangle>,s')\"\n| BinOpE2:  \"\\<lbrakk>need_second_arg binop v1; G\\<turnstile>(\\<langle>e2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e2'\\<rangle>,s') \\<rbrakk>\n             \\<Longrightarrow> \n             G\\<turnstile>(\\<langle>BinOp binop (Lit v1) e2\\<rangle>,Norm s) \n              \\<mapsto>1 (\\<langle>BinOp binop (Lit v1) e2'\\<rangle>,s')\"\n| BinOpTerm:  \"\\<lbrakk>\\<not> need_second_arg binop v1\\<rbrakk>\n               \\<Longrightarrow> \n               G\\<turnstile>(\\<langle>BinOp binop (Lit v1) e2\\<rangle>,Norm s) \n                \\<mapsto>1 (\\<langle>Lit v1\\<rangle>,Norm s)\"\n| BinOp:    \"G\\<turnstile>(\\<langle>BinOp binop (Lit v1) (Lit v2)\\<rangle>,Norm s) \n              \\<mapsto>1 (\\<langle>Lit (eval_binop binop v1 v2)\\<rangle>,Norm s)\"\n(* Maybe its more convenient to add: need_second_arg as precondition to BinOp \n   to make the choice between BinOpTerm and BinOp deterministic *)\n   \n| Super: \"G\\<turnstile>(\\<langle>Super\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit (val_this s)\\<rangle>,Norm s)\"\n\n| AccVA: \"\\<lbrakk>G\\<turnstile>(\\<langle>va\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>va'\\<rangle>,s') \\<rbrakk>\n          \\<Longrightarrow> \n          G\\<turnstile>(\\<langle>Acc va\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Acc va'\\<rangle>,s')\"\n| Acc:  \"\\<lbrakk>groundVar va; ((v,vf),s') = the_var G (Norm s) va\\<rbrakk>\n         \\<Longrightarrow>  \n         G\\<turnstile>(\\<langle>Acc va\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit v\\<rangle>,s')\"\n\n(*\nAccLVar: \"G\\<turnstile>(\\<langle>Acc (LVar vn)\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit (fst (lvar vn s))\\<rangle>,Norm s)\"\nAccFVar: \"\\<lbrakk>((v,vf),s') = fvar statDeclC stat fn a (Norm s)\\<rbrakk>\n          \\<Longrightarrow>  \n          G\\<turnstile>(\\<langle>Acc ({accC,statDeclC,stat}(Lit a)..fn)\\<rangle>,Norm s) \n           \\<mapsto>1 (\\<langle>Lit v\\<rangle>,s')\"\nAccAVar: \"\\<lbrakk>((v,vf),s') = avar G i a (Norm s)\\<rbrakk>\n          \\<Longrightarrow>  \n          G\\<turnstile>(\\<langle>Acc ((Lit a).[Lit i])\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit v\\<rangle>,s')\"\n*) \n| AssVA:  \"\\<lbrakk>G\\<turnstile>(\\<langle>va\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>va'\\<rangle>,s')\\<rbrakk> \n           \\<Longrightarrow> \n           G\\<turnstile>(\\<langle>va:=e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>va':=e\\<rangle>,s')\"\n| AssE:   \"\\<lbrakk>groundVar va; G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\\<rbrakk> \n           \\<Longrightarrow> \n           G\\<turnstile>(\\<langle>va:=e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>va:=e'\\<rangle>,s')\"\n| Ass:    \"\\<lbrakk>groundVar va; ((w,f),s') = the_var G (Norm s) va\\<rbrakk> \n           \\<Longrightarrow> \n           G\\<turnstile>(\\<langle>va:=(Lit v)\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit v\\<rangle>,assign f v s')\"\n\n| CondC: \"\\<lbrakk>G\\<turnstile>(\\<langle>e0\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e0'\\<rangle>,s')\\<rbrakk> \n          \\<Longrightarrow> \n          G\\<turnstile>(\\<langle>e0? e1:e2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e0'? e1:e2\\<rangle>,s')\"\n| Cond:  \"G\\<turnstile>(\\<langle>Lit b? e1:e2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>if the_Bool b then e1 else e2\\<rangle>,Norm s)\"\n\n\n| CallTarget: \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\\<rbrakk> \n               \\<Longrightarrow>\n               G\\<turnstile>(\\<langle>{accC,statT,mode}e\\<cdot>mn({pTs}args)\\<rangle>,Norm s) \n                \\<mapsto>1 (\\<langle>{accC,statT,mode}e'\\<cdot>mn({pTs}args)\\<rangle>,s')\"\n| CallArgs:   \"\\<lbrakk>G\\<turnstile>(\\<langle>args\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>args'\\<rangle>,s')\\<rbrakk> \n               \\<Longrightarrow>\n               G\\<turnstile>(\\<langle>{accC,statT,mode}Lit a\\<cdot>mn({pTs}args)\\<rangle>,Norm s) \n                \\<mapsto>1 (\\<langle>{accC,statT,mode}Lit a\\<cdot>mn({pTs}args')\\<rangle>,s')\"\n| Call:       \"\\<lbrakk>groundExprs args; vs = map the_val args;\n                D = invocation_declclass G mode s a statT \\<lparr>name=mn,parTs=pTs\\<rparr>;\n                s'=init_lvars G D \\<lparr>name=mn,parTs=pTs\\<rparr> mode a' vs (Norm s)\\<rbrakk> \n               \\<Longrightarrow> \n               G\\<turnstile>(\\<langle>{accC,statT,mode}Lit a\\<cdot>mn({pTs}args)\\<rangle>,Norm s) \n                \\<mapsto>1 (\\<langle>Callee (locals s) (Methd D \\<lparr>name=mn,parTs=pTs\\<rparr>)\\<rangle>,s')\"\n           \n| Callee:     \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'::expr\\<rangle>,s')\\<rbrakk>\n               \\<Longrightarrow> \n               G\\<turnstile>(\\<langle>Callee lcls_caller e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\"\n\n| CalleeRet:   \"G\\<turnstile>(\\<langle>Callee lcls_caller (Lit v)\\<rangle>,Norm s) \n                 \\<mapsto>1 (\\<langle>Lit v\\<rangle>,(set_lvars lcls_caller (Norm s)))\"\n\n| Methd: \"G\\<turnstile>(\\<langle>Methd D sig\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>body G D sig\\<rangle>,Norm s)\"\n\n| Body: \"G\\<turnstile>(\\<langle>Body D c\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>InsInitE (Init D) (Body D c)\\<rangle>,Norm s)\"\n\n| InsInitBody: \n    \"\\<lbrakk>G\\<turnstile>(\\<langle>c\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c'\\<rangle>,s')\\<rbrakk>\n     \\<Longrightarrow> \n     G\\<turnstile>(\\<langle>InsInitE Skip (Body D c)\\<rangle>,Norm s) \\<mapsto>1(\\<langle>InsInitE Skip (Body D c')\\<rangle>,s')\"\n| InsInitBodyRet: \n     \"G\\<turnstile>(\\<langle>InsInitE Skip (Body D Skip)\\<rangle>,Norm s)\n       \\<mapsto>1 (\\<langle>Lit (the ((locals s) Result))\\<rangle>,abupd (absorb Ret) (Norm s))\"\n\n(*   LVar: \"G\\<turnstile>(LVar vn,Norm s)\" is already evaluated *)\n  \n| FVar: \"\\<lbrakk>\\<not> inited statDeclC (globs s)\\<rbrakk>\n         \\<Longrightarrow> \n         G\\<turnstile>(\\<langle>{accC,statDeclC,stat}e..fn\\<rangle>,Norm s) \n          \\<mapsto>1 (\\<langle>InsInitV (Init statDeclC) ({accC,statDeclC,stat}e..fn)\\<rangle>,Norm s)\"\n| InsInitFVarE:\n      \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\\<rbrakk>\n       \\<Longrightarrow>\n       G\\<turnstile>(\\<langle>InsInitV Skip ({accC,statDeclC,stat}e..fn)\\<rangle>,Norm s) \n        \\<mapsto>1 (\\<langle>InsInitV Skip ({accC,statDeclC,stat}e'..fn)\\<rangle>,s')\"\n| InsInitFVar:\n      \"G\\<turnstile>(\\<langle>InsInitV Skip ({accC,statDeclC,stat}Lit a..fn)\\<rangle>,Norm s) \n        \\<mapsto>1 (\\<langle>{accC,statDeclC,stat}Lit a..fn\\<rangle>,Norm s)\"\n\\<comment> \\<open>Notice, that we do not have literal values for \\<open>vars\\<close>. \nThe rules for accessing variables (\\<open>Acc\\<close>) and assigning to variables \n(\\<open>Ass\\<close>), test this with the predicate \\<open>groundVar\\<close>.  After \ninitialisation is done and the \\<open>FVar\\<close> is evaluated, we can't just \nthrow away the \\<open>InsInitFVar\\<close> term and return a literal value, as in the \ncases of \\<open>New\\<close>  or \\<open>NewC\\<close>. Instead we just return the evaluated \n\\<open>FVar\\<close> and test for initialisation in the rule \\<open>FVar\\<close>.\\<close>\n\n\n| AVarE1: \"\\<lbrakk>G\\<turnstile>(\\<langle>e1\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e1'\\<rangle>,s')\\<rbrakk> \n           \\<Longrightarrow> \n           G\\<turnstile>(\\<langle>e1.[e2]\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e1'.[e2]\\<rangle>,s')\"\n\n| AVarE2: \"G\\<turnstile>(\\<langle>e2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e2'\\<rangle>,s') \n           \\<Longrightarrow> \n           G\\<turnstile>(\\<langle>Lit a.[e2]\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Lit a.[e2']\\<rangle>,s')\"\n\n(* AVar: \\<langle>(Lit a).[Lit i]\\<rangle> is fully evaluated *)\n\n(* evaluation of expression lists *)\n\n  \\<comment> \\<open>\\<open>Nil\\<close>  is fully evaluated\\<close>\n\n| ConsHd: \"\\<lbrakk>G\\<turnstile>(\\<langle>e::expr\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'::expr\\<rangle>,s')\\<rbrakk> \n           \\<Longrightarrow>\n           G\\<turnstile>(\\<langle>e#es\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'#es\\<rangle>,s')\"\n  \n| ConsTl: \"\\<lbrakk>G\\<turnstile>(\\<langle>es\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>es'\\<rangle>,s')\\<rbrakk> \n           \\<Longrightarrow>\n           G\\<turnstile>(\\<langle>(Lit v)#es\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>(Lit v)#es'\\<rangle>,s')\"\n\n(* execution of statements *)\n\n  (* cf. 14.5 *)\n| Skip: \"G\\<turnstile>(\\<langle>Skip\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>SKIP\\<rangle>,Norm s)\"\n\n| ExprE: \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\\<rbrakk> \n          \\<Longrightarrow> \n          G\\<turnstile>(\\<langle>Expr e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Expr e'\\<rangle>,s')\"\n| Expr:  \"G\\<turnstile>(\\<langle>Expr (Lit v)\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Skip\\<rangle>,Norm s)\"\n\n\n| LabC: \"\\<lbrakk>G\\<turnstile>(\\<langle>c\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c'\\<rangle>,s')\\<rbrakk> \n         \\<Longrightarrow>  \n         G\\<turnstile>(\\<langle>l\\<bullet> c\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>l\\<bullet> c'\\<rangle>,s')\"\n| Lab:  \"G\\<turnstile>(\\<langle>l\\<bullet> Skip\\<rangle>,s) \\<mapsto>1 (\\<langle>Skip\\<rangle>, abupd (absorb l) s)\"\n\n  (* cf. 14.2 *)\n| CompC1: \"\\<lbrakk>G\\<turnstile>(\\<langle>c1\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c1'\\<rangle>,s')\\<rbrakk> \n           \\<Longrightarrow> \n           G\\<turnstile>(\\<langle>c1;; c2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c1';; c2\\<rangle>,s')\"\n\n| Comp:   \"G\\<turnstile>(\\<langle>Skip;; c2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c2\\<rangle>,Norm s)\"\n\n  (* cf. 14.8.2 *)\n| IfE: \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle> ,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\\<rbrakk> \n        \\<Longrightarrow>\n        G\\<turnstile>(\\<langle>If(e) s1 Else s2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>If(e') s1 Else s2\\<rangle>,s')\"\n| If:  \"G\\<turnstile>(\\<langle>If(Lit v) s1 Else s2\\<rangle>,Norm s) \n         \\<mapsto>1 (\\<langle>if the_Bool v then s1 else s2\\<rangle>,Norm s)\"\n\n  (* cf. 14.10, 14.10.1 *)\n| Loop: \"G\\<turnstile>(\\<langle>l\\<bullet> While(e) c\\<rangle>,Norm s) \n          \\<mapsto>1 (\\<langle>If(e) (Cont l\\<bullet>c;; l\\<bullet> While(e) c) Else Skip\\<rangle>,Norm s)\"\n\n| Jmp: \"G\\<turnstile>(\\<langle>Jmp j\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Skip\\<rangle>,(Some (Jump j), s))\"\n\n| ThrowE: \"\\<lbrakk>G\\<turnstile>(\\<langle>e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>e'\\<rangle>,s')\\<rbrakk> \n           \\<Longrightarrow>\n           G\\<turnstile>(\\<langle>Throw e\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Throw e'\\<rangle>,s')\"\n| Throw:  \"G\\<turnstile>(\\<langle>Throw (Lit a)\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Skip\\<rangle>,abupd (throw a) (Norm s))\"\n\n| TryC1: \"\\<lbrakk>G\\<turnstile>(\\<langle>c1\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c1'\\<rangle>,s')\\<rbrakk> \n          \\<Longrightarrow>\n          G\\<turnstile>(\\<langle>Try c1 Catch(C vn) c2\\<rangle>, Norm s) \\<mapsto>1 (\\<langle>Try c1' Catch(C vn) c2\\<rangle>,s')\"\n| Try:   \"\\<lbrakk>G\\<turnstile>s \\<midarrow>sxalloc\\<rightarrow> s'\\<rbrakk>\n          \\<Longrightarrow>\n          G\\<turnstile>(\\<langle>Try Skip Catch(C vn) c2\\<rangle>, s) \n           \\<mapsto>1 (if G,s'\\<turnstile>catch C then (\\<langle>c2\\<rangle>,new_xcpt_var vn s')\n                                else (\\<langle>Skip\\<rangle>,s'))\"\n\n| FinC1: \"\\<lbrakk>G\\<turnstile>(\\<langle>c1\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c1'\\<rangle>,s')\\<rbrakk> \n          \\<Longrightarrow>\n          G\\<turnstile>(\\<langle>c1 Finally c2\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>c1' Finally c2\\<rangle>,s')\"\n\n| Fin:    \"G\\<turnstile>(\\<langle>Skip Finally c2\\<rangle>,(a,s)) \\<mapsto>1 (\\<langle>FinA a c2\\<rangle>,Norm s)\"\n\n| FinAC: \"\\<lbrakk>G\\<turnstile>(\\<langle>c\\<rangle>,s) \\<mapsto>1 (\\<langle>c'\\<rangle>,s')\\<rbrakk>\n          \\<Longrightarrow>\n          G\\<turnstile>(\\<langle>FinA a c\\<rangle>,s) \\<mapsto>1 (\\<langle>FinA a c'\\<rangle>,s')\"\n| FinA: \"G\\<turnstile>(\\<langle>FinA a Skip\\<rangle>,s) \\<mapsto>1 (\\<langle>Skip\\<rangle>,abupd (abrupt_if (a\\<noteq>None) a) s)\"\n\n\n| Init1: \"\\<lbrakk>inited C (globs s)\\<rbrakk> \n          \\<Longrightarrow> \n          G\\<turnstile>(\\<langle>Init C\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>Skip\\<rangle>,Norm s)\"\n| Init: \"\\<lbrakk>the (class G C)=c; \\<not> inited C (globs s)\\<rbrakk>  \n         \\<Longrightarrow> \n         G\\<turnstile>(\\<langle>Init C\\<rangle>,Norm s) \n          \\<mapsto>1 (\\<langle>(if C = Object then Skip else (Init (super c)));;\n                Expr (Callee (locals s) (InsInitE (init c) SKIP))\\<rangle>\n               ,Norm (init_class_obj G C s))\"\n\\<comment> \\<open>\\<open>InsInitE\\<close> is just used as trick to embed the statement \n\\<open>init c\\<close> into an expression\\<close> \n| InsInitESKIP:\n    \"G\\<turnstile>(\\<langle>InsInitE Skip SKIP\\<rangle>,Norm s) \\<mapsto>1 (\\<langle>SKIP\\<rangle>,Norm s)\"\n\nabbreviation\n  stepn:: \"[prog, term \\<times> state,nat,term \\<times> state] \\<Rightarrow> bool\" (\"_\\<turnstile>_ \\<mapsto>_ _\"[61,82,82] 81)\n  where \"G\\<turnstile>p \\<mapsto>n p' \\<equiv> (p,p') \\<in> {(x, y). step G x y}^^n\"\n\nabbreviation\n  steptr:: \"[prog,term \\<times> state,term \\<times> state] \\<Rightarrow> bool\" (\"_\\<turnstile>_ \\<mapsto>* _\"[61,82,82] 81)\n  where \"G\\<turnstile>p \\<mapsto>* p' \\<equiv> (p,p') \\<in> {(x, y). step G x y}\\<^sup>*\"\n         \n(* Equivalenzen:\n  Bigstep zu Smallstep komplett.\n  Smallstep zu Bigstep, nur wenn nicht die Ausdr\u00fccke Callee, FinA ,\\<dots>\n*)\n\n(*\nlemma imp_eval_trans:\n  assumes eval: \"G\\<turnstile>s0 \\<midarrow>t\\<succ>\\<rightarrow> (v,s1)\" \n    shows trans: \"G\\<turnstile>(t,s0) \\<mapsto>* (\\<langle>Lit v\\<rangle>,s1)\"\n*)\n(* Jetzt muss man bei trans nat\u00fcrlich wieder unterscheiden: Stmt, Expr, Var!\n   Sowas bl\u00f6des:\n   Am besten den Terminus ground auf Var,Stmt,Expr hochziehen und dann\n   the_vals definieren\\<dots>\n  G\\<turnstile>(t,s0) \\<mapsto>* (t',s1) \\<and> the_vals t' = v\n*)\n\n\nend\n"}
{"text": "informal statement Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.formal statement theorem exercise_1998_a3 (f : \u211d \u2192 \u211d) (hf : cont_diff \u211d 3 f) : \n  \u2203 a : \u211d, (f a) * (deriv f a) * (iterated_deriv 2 f a) * (iterated_deriv 3 f a) \u2265 0 :="}
{"text": "import Smt\nimport Smt.Data.BitVec\n\ntheorem append_eq_shl_or_2 (x y : BitVec 2)\n    : x ++ y = (x.zeroExtend 2 <<< 2) ||| y.zeroExtend 2 := by\n  smt\n  sorry\n\ntheorem append_eq_shl_or_3 (x y : BitVec 3)\n    : x ++ y = (x.zeroExtend 3 <<< 3) ||| y.zeroExtend 3 := by\n  smt\n  sorry\n"}
{"text": "From demo Require Import simplified_iris.\n\nSection proof.\nContext `{!heapGS \u03a3}.\n\nTheorem coq_swap (P Q: Prop):\n  P \u2227 Q \u2192 Q \u2227 P.\nProof.\n  intros H.\n  destruct H as [HP HQ].\n  split.\n  - apply HQ.\n  - apply HP.\nQed.\n\nTheorem prove_swap_the_hard_way x y :\n  x \u21a6 #0 \u2217 y \u21a6 #3 \u22a2 y \u21a6 #3 \u2217 x \u21a6 #0.\nProof.\n  iIntros \"H\".\n  iDestruct \"H\" as \"[Hx Hy]\".\n  iSplitL \"Hy\".\n  - iApply \"Hy\".\n  - iApply \"Hx\".\nQed.\n\nTheorem prove_swap_the_easy_way x y :\n  x \u21a6 #0 \u2217 y \u21a6 #3 \u22a2 y \u21a6 #3 \u2217 x \u21a6 #0.\nProof.\n  iIntros \"[Hx Hy]\".\n  iFrame.\nQed.\n\nTheorem ex01 (x y: loc) :\n  x \u21a6 #0 \u2217 y \u21a6 #0 \u22a2 WP #x <- #y;; #y <- #x {{ \u03bb _, x \u21a6 #y \u2217 y \u21a6 #x }}.\nProof.\n  iIntros \"[Hx Hy]\".\n  wp_bind (Store _ _).\n  iApply wp_frame.\n  iSplitL \"Hx\".\n  { iApply (wp_store_axiom with \"Hx\"). }\n  simpl. iIntros (?) \"Hx\"; wp_pures.\n  iApply wp_frame.\n  iSplitL \"Hy\".\n  { iApply (wp_store_axiom with \"Hy\"). }\n  simpl. iIntros (?) \"Hy\".\n  iFrame.\nQed.\n\nEnd proof.\n"}
{"text": "import data.real.basic\n\n-- BEGIN\ntheorem not_monotone_iff {f : \u211d \u2192 \u211d}:\n  \u00ac monotone f \u2194 \u2203 x y, x \u2264 y \u2227 f x > f y :=\nby { rw monotone, push_neg }\n\nexample : \u00ac monotone (\u03bb x : \u211d, -x) :=\nbegin\n  rw monotone, \n  push_neg,\n  use -2,\n  use -1,\n  norm_num,\nend\n-- END"}
{"text": "[GOAL]\n\u22a2 IsPrincipalIdealRing { x // x \u2208 \ud835\udcde \u211a }\n[PROOFSTEP]\nconvert\n  IsPrincipalIdealRing.of_surjective (Rat.ringOfIntegersEquiv.symm : \u2124 \u2192+* ringOfIntegers \u211a)\n    Rat.ringOfIntegersEquiv.symm.surjective\n"}
{"text": "-- UNDER CONSTRUCTION. IGNORE.\n\n\n/-\nNow that we've defined our base and step\n\"machines\" (lemmas), we assemble them into\nan overall proof by applying the induction\naxiom to them.\n-/\ntheorem left_zero : \u2200 n, 0 + n = n := _\n\n/-\nEXERCISE: Reformulate the formal proof in\nthe class notes, \u2200 n, 0 + n = n := _ to\nuse Lean's induction tactic.\n-/\n\n\n/-\nEXERCISE: Give a fluent English-language proof\n(based on the formal proof).\n\nEXERCISE: Give a fluent English-language proof\nthat 2 * sum_to n = n * (n+1). Show all of the\nalgebraic steps needed to complete this proof.\nIf you need to transform expressions using the\nassociativity or commutativity of addition or\nmultiplication, say so. Each step must have a\njustification.\n\nEXERCISE: Give an English language proof by\ninduction of the proposition that, for any\nnatural number, n, a set with n elements has\n2^n subsets. \n\nEXERCISE: Prove by induction that \u2200 n, P n, \nwhere P n is the proposition that the sum of \nall the squares of the natural numbers from \n0 to n = (n(n+1)(2n+1))/6.\n\nA. Using the induction axiom for the natural\nnumbers, applied to base and step functions\nthat you define separately, to implement a\nfunction that computes this sum of squares \nfor any natural number, n.  Write a few test\ncases to check that your function appears to\nbe working, at least for n = 0, 1, 3, and 5.\n\nB. Formally express the property of a natural\nnumber, P n, that asserts that the sum of the\nsquares of the numbers from 0 to any given n\nequals (n(n+1)(2n+1))/6.\n\nC. Define the proposition that every natural\nnumber, n, has this property. This is what is\nto be proved by induction.\n\nD. Define a proof of the base case, n = 0.\n\nE. Define a proof for the inductive or step\ncase, amounting to a function that, when given \nany n' and a proof of P n' returns a proof of\nP (n' + 1).\n\nF. Construct a proof of the proposition that\nevery natural number has this property by\napplying the induction axiom for the natural\nnumbers to n and the base and step proofs.\n\nG. Give a fluent English-language proof of\nthe universal generalization based on the\nwork done above. Show *all* of your algebra\nwork.\n-/\n\n"}
{"text": "-- Derek Johnson\n\ndef s1 := \"Hello, \"\ndef s2 := \"Nifty!\"\ndef s3 := s1 ++ s2\n\ntheorem t1 : (s1 ++ s2) = s3 := eq.refl s3\n\ntheorem t2 : 4^2 = 16 := eq.refl 16\n\ntheorem t3 : (s1 ++ s2) = s3 \u2227 (5^2 = 25) := and.intro \n    (eq.refl s3)\n    (eq.refl 25)\n\ntheorem t4 :\n    \u2200 (P Q R : Prop), (P \u2227 Q) \u2227 (Q \u2227 R) \u2192 (P \u2227 R) :=\n    \u03bb (P Q R : Prop),\n        \u03bb h,\n            and.intro (h.left.left)(h.right.right)"}
{"text": "/-\n  Copyright (c) 2022 Arthur Paulino. All rights reserved.\n  Released under Apache 2.0 license as described in the file LICENSE.\n  Authors: Arthur Paulino\n-/\n\nimport FxyLang.Reasoning.Defs\n\ntheorem State.stepNComp : (s^[n\u2081])^[n\u2082] = s^[n\u2081 + n\u2082] := by\n  induction n\u2081 generalizing s with\n  | zero => simp [stepN]\n  | succ n hi =>\n    rw [stepN, @hi s.step]\n    have : n.succ + n\u2082 = (n + n\u2082).succ := by\n      simp only [Nat.add_comm, Nat.add_assoc, Nat.add_left_comm]; rfl\n    rw [this, stepN]\n\ntheorem State.extendsForward {s : State} (hs : s.extends s\u2080) :\n    s.step.extends s\u2080 := by\n  sorry\n\ntheorem State.reachDeterministic' (h : ret c\u2081 k v\u2081 \u21a0 ret c\u2082 k v\u2082) :\n    v\u2081 = v\u2082 \u2227 c\u2081 = c\u2082 := by\n  sorry\n\ntheorem State.reachDeterministic (h\u2081 : s \u21a0 ret c\u2081 k v\u2081) (h\u2082 : s \u21a0 ret c\u2082 k v\u2082) :\n    v\u2081 = v\u2082 \u2227 c\u2081 = c\u2082 := by\n  sorry\n\ntheorem Determinism (h\u2081 : \u27e6c, p\u27e7 \u00bb \u27e6c\u2081, v\u2081\u27e7) (h\u2082 : \u27e6c, p\u27e7 \u00bb \u27e6c\u2082, v\u2082\u27e7) :\n  v\u2081 = v\u2082 \u2227 c\u2081 = c\u2082 := State.reachDeterministic (h\u2081 default) (h\u2082 default)\n"}
{"text": "-- Math 52: Quiz 5\n-- Open this file in a folder that contains 'utils'.\n\nimport utils\nopen classical\n\ndefinition divides (a b : \u2124) : Prop := \u2203 (k : \u2124), b = a * k\nlocal infix \u2223 := divides\n\naxiom not_3_divides : \u2200 (m : \u2124), \u00ac (3 \u2223 m) \u2194 3 \u2223 m - 1 \u2228 3 \u2223 m + 1\n\nlemma not_3_divides_of_3_divides_minus_1 : \n\u2200 (m : \u2124), 3 \u2223 m - 1 \u2192 \u00ac (3 \u2223 m) :=\nbegin\nintros m H,\nrw not_3_divides,\nleft,\nassumption, \nend\n\nlemma not_3_divides_of_3_divides_plus_1 : \n\u2200 (m : \u2124), 3 \u2223 m + 1 \u2192 \u00ac (3 \u2223 m) :=\nbegin\nintros m H,\nrw not_3_divides,\nright,\nassumption, \nend\n\ntheorem main : \u2200 (n : \u2124), 3 \u2223 n * n - 1 \u2192 \u00ac (3 \u2223 n) :=\nbegin\nintro n,\nby_contrapositive,\n\n\n\n\n\nend\n"}
{"text": "lemmas landau_symbols_if_at_top_eq [simp] = landau_symbols[THEN landau_symbol_if_at_top_eq]"}
{"text": "lemma coeff_0_reflect_poly_0_iff [simp]: \"coeff (reflect_poly p) 0 = 0 \\<longleftrightarrow> p = 0\""}
{"text": "informal statement Suppose $k \\geq 3, x, y \\in \\mathbb{R}^k, |x - y| = d > 0$, and $r > 0$. Prove that if $2r > d$, there are infinitely many $z \\in \\mathbb{R}^k$ such that $|z-x|=|z-y|=r$.formal statement theorem exercise_1_18a\n  (n : \u2115)\n  (h : n > 1)\n  (x : euclidean_space \u211d (fin n)) -- R^n\n  : \u2203 (y : euclidean_space \u211d (fin n)), y \u2260 0 \u2227 (inner x y) = (0 : \u211d) :="}
{"text": "informal statement Prove that $\\mathbb{Q}$ has no proper subgroups of finite index.formal statement theorem exercise_3_2_21a (H : add_subgroup \u211a) (hH : H \u2260 \u22a4) : H.index = 0 :="}
{"text": "[STATEMENT]\nlemma subst_simps [simp]:\n  \"subst x t x = t\"\n  \"subst x (Var x) = Var\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. subst x t x = t &&& subst x (Var x) = Var\n[PROOF STEP]\nby (auto simp: subst_def)"}
{"text": "\n-- Given p : A \u27f7 B do action on X\n\nact : (A \u27f7 B) \u27f7 (X \u27f7 X)\nact = ? \n"}
{"text": "theory Axler\n  imports Complex_Main\n\"HOL-Analysis.Inner_Product\"\n\"HOL-Analysis.Abstract_Euclidean_Space\"\n\"HOL.Vector_Spaces\"\n\"Rank_Nullity_Theorem.Fundamental_Subspaces\"\n(*\"HOL-Analysis.Weierstrass_Theorems\"*)\n\"HOL-Computational_Algebra.Polynomial\"\n\n(* Note by Angeliki:\nsome types chosen are too general, some others too specific e.g. *real* vector etc. \nNote to perhaps readjust with appropriate use of locales *)\n\nbegin\n\n(*\nproblem_number:1_2\nnatural language statement:\nShow that $\\frac{-1 + \\sqrt{3}i}{2}$ is a cube root of 1 (meaning that its cube equals 1).\nlean statement:\ntheorem exercise_1_2 :\n  (\\<langle>-1/2, real.sqrt 3 / 2\\<rangle> : \\<complex>) ^ 3 = -1 :=\n\ncodex statement:\ntheorem cube_root_of_1:\n  shows \"(-1 + sqrt 3 * \\<i>)^3 = 1\"\n\nOur comment on the codex statement: wrong function, missed the denominator.\n *)\ntheorem exercise_1_2: shows \"((-1 + sqrt 3 * \\<i>)/2)^3 = 1 \" oops\n\n\n(*\nproblem_number:1_3\nnatural language statement:\nProve that $-(-v) = v$ for every $v \\in V$.\nlean statement:\ntheorem exercise_1_3 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {v : V} : -(-v) = v :=\n\ncodex statement:\ntheorem neg_neg_eq_self:\n  fixes v::\"'a::ab_group_add\"\n  shows \"-(-v) = v\"\n\nOur comment on the codex statement: < the statement is in principle correct, though the type is not\nspecified in the natural language statement. By the choice of notation I assume it's a vector instead.   >\n *)\ntheorem exercise_1_3:\n  \n   fixes v::\"'a::ab_group_add\"and V::\"'a::ab_group_add set\"\n  shows \"\\<forall> v \\<in> V. -(-v) = v\"\n  oops\n\ntheorem exercise_1_3_alternative:  fixes v :: \"'a :: real_vector\"\n  shows \"-(-v) = v\" oops\n\n\n(*\nproblem_number:1_4\nnatural language statement:\nProve that if $a \\in \\mathbf{F}$, $v \\in V$, and $av = 0$, then $a = 0$ or $v = 0$.\nlean statement:\ntheorem exercise_1_4 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (v : V) (a : F): a \\<bullet> v = 0 \\<longleftrightarrow> a = 0 \\<or> v = 0 :=\n\ncodex statement:\ntheorem zero_of_scalar_times_vector_eq_zero:\n  fixes a::\"'a::field\" and v::\"'b::real_vector\"\n  assumes \"a *\\<^sub>R v = 0\"\n  shows \"a = 0 \u2228 v = 0\"\n\nOur comment on the codex statement: <wrong symbol for multiplication.\nCan work if  the field is the reals here in particular. Can\nwe generalise? >\n *)\n(*TODO *)\ntheorem exercise_1_4: \n   fixes a::real and v::\"'b::real_vector\"\n  assumes \"scaleR a v = 0\"\n  shows \"a = 0 \u2228 v = 0\"\n  oops\n\n\n(*\nproblem_number:1_6\nnatural language statement:\nGive an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under addition \nand under taking additive inverses (meaning $-u \\in U$ whenever $u \\in U$), \nbut $U$ is not a subspace of $\\mathbf{R}^2$.\nlean statement:\ntheorem exercise_1_6 : \\<exists> U : set (\\<real> \\<times> \\<real>),\n  (U \\<noteq> \\<emptyset>) \\<and>\n  (\\<forall> (u v : \\<real> \\<times> \\<real>), u \\<in> U \\<and> v \\<in> U \\<rightarrow> u + v \\<in> U) \\<and>\n  (\\<forall> (u : \\<real> \\<times> \\<real>), u \\<in> U \\<rightarrow> -u \\<in> U) \\<and>\n  (\\<forall> U' : submodule \\<real> (\\<real> \\<times> \\<real>), U \\<noteq> \u2191U') :=\n\ncodex statement:\ntheorem exists_nonempty_subset_of_R2_closed_under_add_and_inv_not_subspace:\n  shows \"\u2203U. U \u2260 {} \u2227 (\u2200x\u2208U. -x\u2208U) \u2227 (\u2200x y\u2208U. x+y\u2208U) \u2227 \u00ac(subspace U (UNIV::(real, real) vec set))\"\n\nOur comment on the codex statement: <quite close but syntactic and type problems>\n *)\ntheorem exercise_1_6:\n  fixes V::\"'a::euclidean_space set\" assumes\" DIM('a::euclidean_space) = 2\"\n  obtains  U::\"'a::euclidean_space set\" where\n\"U \\<subseteq> V \\<and> U \u2260 {} \u2227 (\\<forall> x \\<in> U. -x \\<in> U) \u2227 (\\<forall>x\\<in>U\n. \\<forall> y \\<in>U. x+y\\<in> U) \u2227 \u00ac(subspace U )\"\n\n  oops\n\n\n(*\nproblem_number:1_7\nnatural language statement:\nGive an example of a nonempty subset $U$ of $\\mathbf{R}^2$ such that $U$ is closed under scalar multiplication,\n but $U$ is not a subspace of $\\mathbf{R}^2$.\nlean statement:\ntheorem exercise_1_7 : \\<exists> U : set (\\<real> \\<times> \\<real>),\n  (U \\<noteq> \\<emptyset>) \\<and>\n  (\\<forall> (c : \\<real>) (u : \\<real> \\<times> \\<real>), u \\<in> U \\<rightarrow> c \\<bullet> u \\<in> U) \\<and>\n  (\\<forall> U' : submodule \\<real> (\\<real> \\<times> \\<real>), U \\<noteq> \u2191U') :=\n\ncodex statement:\ntheorem exists_nonempty_subset_closed_under_scalar_multiplication_not_subspace:\n  fixes U::\"('a::real_vector) set\"\n  assumes \"\u2203U. U \u2260 {} \u2227 (\u2200x\u2208U. \u2200c. c\u2208UNIV \u27f6 c \u2022 x \u2208 U)\"\n  shows \"\u2203U. U \u2260 {} \u2227 (\u2200x\u2208U. \u2200c. c\u2208UNIV \u27f6 c \u2022 x \u2208 U) \u2227 \u00ac(subspace U)\"\n\nOur comment on the codex statement: <logically wrong: fixes U and then assumes \\exists U, also \nwrong notation for scalar multiplication>\n *)\n\ntheorem exercise_1_7:\n   fixes V::\"'a::euclidean_space set\" assumes\" DIM('a::euclidean_space) = 2\"\n  obtains  U::\"'a::euclidean_space set\" where\n\"U \\<subseteq> V  \\<and> U \u2260 {} \u2227 (\\<forall> x \\<in> U. \\<forall> a::real. scaleR a x\n\\<in> U) \u2227 \u00ac(subspace U )\"\n \n  oops\n\n\n(*\nproblem_number:1_8\nnatural language statement:\nProve that the intersection of any collection of subspaces of $V$ is a subspace of $V$.\nlean statement:\ntheorem exercise_1_8 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {\\<iota> : Type*} (u : \\<iota> \\<rightarrow> submodule F V) :\n  \\<exists> U : submodule F V, (\\<Inter> (i : \\<iota>), (u i).carrier) = \u2191U :=\n\ncodex statement:\ntheorem subspace_of_intersection_of_subspaces:\n  fixes V::\"'a::real_vector set\"\n  assumes \"\u2200S\u2208S. subspace S\"\n  shows \"subspace (\u22c2S\u2208S. S)\"\n\nOur comment on the codex statement: <The natural language statement does not give the type of V,\nbut from the notation chosen we may infer that it is a vector space. \nThe codex formalisation is wrong:  introduces V and then only uses S.>\n *)\ntheorem exercise_1_8: \n  fixes V::\"'a::real_vector set\"\n  and C:: \"'a::real_vector set set\"\n  assumes \"C= {S. subspace S \\<and> S\\<subset> V}\"\n  shows \"subspace (\u22c2S\u2208C. S)\"\n  oops\n\n\n(*\nproblem_number:1_9\nnatural language statement:\nProve that the union of two subspaces of $V$ is a subspace of $V$ if and only \nif one of the subspaces is contained in the other.\nlean statement:\ntheorem exercise_1_9 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (U W : submodule F V):\n  \\<exists> U' : submodule F V, U'.carrier = \u2191U \u2229 \u2191W \\<longleftrightarrow> U \\<le> W \\<or> W \\<le> U :=\n\ncodex statement:\ntheorem union_of_subspaces_is_subspace_iff_one_subset_of_other:\n  fixes V::\"'a::real_vector set\"\n  assumes \"subspace V\" \"subspace U\" \"subspace W\"\n  shows \"subspace (U \u222a W) \u27f7 U \u2286 W \u2228 W \u2286 U\"\n\nOur comment on the codex statement: < introduces V without using it.>\n *)\ntheorem exercise_1_9: \n  \n  fixes U::\"'a::real_vector set\"\n  fixes W::\"'a::real_vector set\"\n  assumes \"subspace U\" \"subspace W\"\n  shows \"subspace (U \u222a W) \u27f7 U \u2286 W \u2228 W \u2286 U\"\n  oops\n\n\n(*\nproblem_number:2_1\nnatural language statement:\nProve that if $\\left(v_{1}, \\ldots, v_{n}\\right)$ spans $V$, then so does \nthe list $\\left(v_{1}-v_{2}, v_{2}-v_{3}, \\ldots, v_{n-1}-v_{n}, v_{n}\\right)$ \nobtained by subtracting from each vector (except the last one) the following vector.\nlean statement:\n\ncodex statement:\ntheorem span_of_subtract_succ_of_span:\n  fixes v::\"'a::euclidean_space set\"\n  assumes \"span v = UNIV\"\n  shows \"span (\u03bbn. v (Suc n) - v n) = UNIV\"\n\nOur comment on the codex statement: <wrong, mainly problem with types/indices>\n *)\n\ntheorem exercise_2_1: \n\nundefined oops\n \n\n\n(*\nproblem_number:2_2\nnatural language statement:\nProve that if $\\left(v_{1}, \\ldots, v_{n}\\right)$ is linearly independent in $V$, \nthen so is the list $\\left(v_{1}-v_{2}, v_{2}-v_{3}, \\ldots, v_{n-1}-v_{n}, v_{n}\\right)$ \nobtained by subtracting from each vector (except the last one) the following vector.\nlean statement:\n\ncodex statement:\ntheorem linear_independent_of_linear_independent_sub:\n  fixes v::\"'a::euclidean_space set\"\n  assumes \"independent v\"\n\n  shows \"independent (\u03bbi. (v (Suc i)) - (v i))\"\nOur comment on the codex statement: <wrong, again mainly problem with types/indices >\n *)\ntheorem exercise_2_2: \nundefined\n  oops\n\n\n(*\nproblem_number:2_6\nnatural language statement:\nProve that the real vector space consisting of all continuous real valued functions \non the interval $[0,1]$ is infinite dimensional.\nlean statement:\n\ncodex statement:\ntheorem infinite_dim_of_continuous_real_valued_functions:\n  fixes f::\"real \u21d2 real\"\n  assumes \"continuous_on {0..1} f\"\n  shows \"\u2203g. continuous_on {0..1} g \u2227 g \u2260 f\"\n\nOur comment on the codex statement: <completely wrong statement. syntax ok, but it talks about\na completely different statement>\n *)\n\ntheorem exercise_2_6:\n\n  assumes \" V= {f::real \\<Rightarrow> real. continuous_on {0..1} f}\"  \n  shows \"infinite V\"\n  oops\n\n(*\nproblem_number:3_1\nnatural language statement:\nShow that every linear map from a one-dimensional vector space to itself is multiplication \nby some scalar. More precisely, prove that if $\\operatorname{dim} V=1$ \nand $T \\in \\mathcal{L}(V, V)$, then there \nexists $a \\in \\mathbf{F}$ such that $T v=a v$ for all $v \\in V$.\nlean statement:\ntheorem exercise_3_1 {F V : Type*}\n  [add_comm_group V] [field F] [module F V] [finite_dimensional F V]\n  (T : V \\<rightarrow>\u2097[F] V) (hT : finrank F V = 1) :\n  \\<exists> c : F, \\<forall> v : V, T v = c \\<bullet> v:=\n\ncodex statement:\ntheorem linear_map_of_dim_one_is_scalar_mult:\n  fixes V::\"'a::real_vector space\" and T::\"'a \u21d2 'a\"\n  assumes \"linear T\" \"DIM('a) = 1\"\n  shows \"\u2203a. \u2200x. T x = a * x\"\n\nOur comment on the codex statement: <various type issues and multiplication symbol>\n *)\n\ntheorem exercise_3_1:\n \nfixes  T::\" 'a:: real_vector \u21d2 'a:: real_vector \"\n (* assumes \"linear T\" *) (* TODO: how to incorporate assumptions without type issue?   *)\n  shows \"\u2203a \\<in> \\<real>. \u2200x. T x = scaleR a x\"\n\n oops (* TODO again I restrict it to real ..*)\n\n\n(*\nproblem_number:3_8\nnatural language statement:\nSuppose that $V$ is finite dimensional and that $T \\in \\mathcal{L}(V, W)$. \nProve that there exists a subspace $U$ of $V$ such that $U \\cap \\operatorname{null} T=\\{0\\}$ \nand range $T=\\{T u: u \\in U\\}$.\nlean statement:\ntheorem exercise_3_8 {F V W : Type*}  [add_comm_group V]\n  [add_comm_group W] [field F] [module F V] [module F W]\n  (L : V \\<rightarrow>\u2097[F] W) :\n  \\<exists> U : submodule F V, U \\<sqinter> L.ker = \\<bot> \\<and>\n  linear_map.range L = range (dom_restrict L U):=\n\ncodex statement:\ntheorem exists_subspace_of_range_eq_image_of_subspace:\n  fixes V::\"'a::euclidean_space set\" and W::\"'b::euclidean_space set\"\n  assumes \"finite_dimensional V\" \"finite_dimensional W\" \"linear T\"\n  shows \"\u2203U. subspace U \u2227 U \u2229 null_space T = {0} \u2227 range T = T ` U\"\n\nOur comment on the codex statement: < the codex formalisation is incorrect wrt assumptions,\nconclusions, also it makes up nonexistent Isabelle definitions such as finite_dimensional   >\n *)\ntheorem exercise_3_8: \nundefined \n\n(* TODO*)\n\n(* note that null_space refers to matrices *)\n\n (*\n  obtains U where \" subspace U \\<and> U \\<subseteq> V \u2227 U \u2229 null_space T = {0} \u2227 range T = T ` U\"\n*)\n\n  oops\n\n\n\n(*\nproblem_number:3_9\nnatural language statement:\nProve that if $T$ is a linear map from $\\mathbf{F}^{4}$ to $\\mathbf{F}^{2}$ \nsuch that $\\operatorname{null} T=\\left\\{\\left(x_{1}, x_{2}, x_{3}, x_{4}\\right) \\in \\mathbf{F}^{4}: \nx_{1}=5 x_{2}\\right.$ and $\\left.x_{3}=7 x_{4}\\right\\}$, then $T$ is surjective.\nlean statement:\n\ncodex statement:\ntheorem surjective_of_null_space:\n  fixes T::\"'a::{field}^4 \u21d2 'a^2\"\n  assumes \"null_space T = {x. x$1 = 5 * x$2 \u2227 x$3 = 7 * x$4}\"\n  shows \"surj T\"\n\nOur comment on the codex statement: <various type issues >*)\n\ntheorem exercise_3_9:\nundefined (* TODO *)\n  oops\n\n\n(*\nproblem_number:3_10\nnatural language statement:\nProve that there does not exist a linear map from $\\mathbf{F}^{5}$ to $\\mathbf{F}^{2}$ \nwhose null space equals $\\left\\{\\left(x_{1}, x_{2}, x_{3}, x_{4}, x_{5}\\right) \n\\in \\mathbf{F}^{5}: x_{1}=3 x_{2} \\text { and } x_{3}=x_{4}=x_{5}\\right\\} .$\nlean statement:\n\ncodex statement:\ntheorem not_exists_linear_map_of_null_space_eq_set:\n  fixes f::\"real^5 \u21d2 real^2\"\n  assumes \"linear f\" \"null_space f = {x | x. x$1 = 3 * x$2 \u2227 x$3 = x$4 \u2227 x$4 = x$5}\"\n  shows False\n\nOur comment on the codex statement: <wrong, various type issues>\n *)\ntheorem exercise_3_10:\nundefined (*TODO *)\n  \n  oops\n\n\n(*\nproblem_number:3_11\nnatural language statement:\nProve that if there exists a linear map on $V$ whose null space and range are both finite dimensional, \nthen $V$ is finite dimensional.\nlean statement:\n\ncodex statement:\ntheorem finite_dim_of_linear_map_finite_dim_null_space_range:\n  fixes V::\"'a::euclidean_space set\" and f::\"'a \u21d2 'b::euclidean_space\"\n  assumes \"linear f\" \"finite_dimensional (null_space f)\" \"finite_dimensional (range f)\"\n  shows \"finite_dimensional V\"\n\nOur comment on the codex statement: <various type problems but gets close>\n *)\n\ntheorem exercise_3_11:\n   fixes V::\"'a::real_vector set\" and f::\"'a \u21d2 'a\"\n  assumes (*\"linear f\"*) (*\"finite (null_space f)\"*) \"finite (range f)\"\n  shows \"finite V\"\n\n  (* TODO *)\n  oops\n\n\n(*\nproblem_number:4_4\nnatural language statement:\nSuppose $p \\in \\mathcal{P}(\\mathbf{C})$ has degree $m$. \nProve that $p$ has $m$ distinct roots if and only if $p$ and its derivative $p^{\\prime}$ \nhave no roots in common.\nlean statement:\ntheorem exercise_4_4 (p : polynomial \\<complex>) :\n  p.degree = @card (root_set p \\<complex>) (polynomial.root_set_fintype p \\<complex>) \\<longleftrightarrow>\n  disjoint\n  (@card (root_set p.derivative \\<complex>) (polynomial.root_set_fintype p.derivative \\<complex>))\n  (@card (root_set p \\<complex>) (polynomial.root_set_fintype p \\<complex>)) :=\n\ncodex statement:\ntheorem distinct_roots_of_poly_iff_no_common_roots_with_derivative:\n  fixes p::\"complex poly\"\n  assumes \"degree p = m\"\n  shows \"distinct_roots p \u2194 (\u2200x. poly p x = 0 \u27f6 poly (deriv p) x \u2260 0)\"\n\nOur comment on the codex statement: <makes up definitions that do not exist in Isabelle e.g. distinct_roots,\nuses wrong defs that are inappropriate here like deriv, wrong double implication symbol >\n *)\ntheorem exercise_4_4: \n  fixes p::\"complex poly\" \n  assumes \"degree p = m\" \n  shows \"( {x. poly p x = 0}\\<inter> {x. pderiv p = 0} = {}) \\<longleftrightarrow> card {x. poly p x = 0}=m \"\n  oops\n\n(*\nproblem_number:5_1\nnatural language statement:\nSuppose $T \\in \\mathcal{L}(V)$. Prove that if $U_{1}, \\ldots, U_{m}$ are subspaces\n of $V$ invariant under $T$, then $U_{1}+\\cdots+U_{m}$ is invariant under $T$.\nlean statement:\ntheorem exercise_5_1 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {L : V \\<rightarrow>\u2097[F] V} {n : \\<nat>} (U : fin n \\<rightarrow> submodule F V)\n  (hU : \\<forall> i : fin n, map L (U i) = U i) :\n  map L (\\<Sum> i : fin n, U i : submodule F V) =\n  (\\<Sum> i : fin n, U i : submodule F V) :=\n\ncodex statement:\ntheorem sum_of_invariant_subspace_is_invariant:\n  fixes T::\"'a::real_vector \u21d2 'a\"\n  assumes \"\u2200i. i \u2264 m \u27f6 subspace (U i)\" \"\u2200i. i \u2264 m \u27f6 T (U i) \u2286 U i\"\n  shows \"T (\u2a01i\u2264m. U i) \u2286 (\u2a01i\u2264m. U i)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_1: undefined oops\n\n\n(*\nproblem_number:5_4\nnatural language statement:\nSuppose that $S, T \\in \\mathcal{L}(V)$ are such that $S T=T S$. \nProve that $\\operatorname{null} (T-\\lambda I)$ is invariant under $S$ for every $\\lambda \\in \\mathbf{F}$.\nlean statement:\ntheorem exercise_5_4 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (S T : V \\<rightarrow>\u2097[F] V) (hST : S \u2218 T = T \u2218 S) (c : F):\n  map S (T - c \\<bullet> id).ker = (T - c \\<bullet> id).ker :=\n\ncodex statement:\ntheorem null_of_commutative_is_invariant:\n  fixes S T::\"'a::{real_normed_algebra_1, finite_dimensional} \u21d2 'a\"\n  assumes \"commutative S T\"\n  shows \"\u2200\u03bb. subspace (null_space (T - \u03bb *\\<^sub>R \ud835\udfed)) (range S)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_4: undefined oops\n\n\n(*\nproblem_number:5_11\nnatural language statement:\nSuppose $S, T \\in \\mathcal{L}(V)$. Prove that $S T$ and $T S$ have the same eigenvalues.\nlean statement:\ntheorem exercise_5_11 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] (S T : End F V) :\n  (S * T).eigenvalues = (T * S).eigenvalues  :=\n\ncodex statement:\ntheorem eigenvalues_of_commutative_linear_operators:\n  fixes S T::\"'a::{comm_ring_1,euclidean_space} \u21d2 'a\"\n  assumes \"linear S\" \"linear T\"\n  shows \"eigenvalues (S \u2218 T) = eigenvalues (T \u2218 S)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_11: undefined oops\n\n\n(*\nproblem_number:5_12\nnatural language statement:\nSuppose $T \\in \\mathcal{L}(V)$ is such that every vector in $V$ is an eigenvector of $T$. Prove that $T$ is a scalar multiple of the identity operator.\nlean statement:\ntheorem exercise_5_12 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] {S : End F V}\n  (hS : \\<forall> v : V, \\<exists> c : F, v \\<in> eigenspace S c) :\n  \\<exists> c : F, S = c \\<bullet> id :=\n\ncodex statement:\ntheorem scalar_multiple_of_identity_of_eigenvector_of_all_vectors:\n  fixes T::\"'a::{real_normed_algebra_1, real_inner} \u21d2 'a\"\n  assumes \"linear T\" \"\u2200x. \u2203c. T x = c * x\"\n  shows \"\u2203c. T = (\u03bbx. c * x)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_12: undefined oops\n\n\n(*\nproblem_number:5_13\nnatural language statement:\nSuppose $T \\in \\mathcal{L}(V)$ is such that every subspace of $V$ with dimension $\\operatorname{dim} V-1$ is invariant under $T$. Prove that $T$ is a scalar multiple of the identity operator.\nlean statement:\ntheorem exercise_5_13 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] [finite_dimensional F V] {T : End F V}\n  (hS : \\<forall> U : submodule F V, finrank F U = finrank F V - 1 \\<rightarrow>\n  map T U = U) : \\<exists> c : F, T = c \\<bullet> id :=\n\ncodex statement:\ntheorem scalar_multiple_of_identity_of_invariant_subspace_of_dim_pred:\n  fixes T::\"'a::euclidean_space \u21d2 'a\"\n  assumes \"linear T\" \"\u2200S. subspace S \u27f6 dim S = dim V - 1 \u27f6 subspace (T ` S)\"\n  shows \"T = (\u03bbx. c * x) \u2218 T \u2218 (\u03bbx. c * x)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_13: undefined oops\n\n\n(*\nproblem_number:5_20\nnatural language statement:\nSuppose that $T \\in \\mathcal{L}(V)$ has $\\operatorname{dim} V$ distinct eigenvalues and that $S \\in \\mathcal{L}(V)$ has the same eigenvectors as $T$ (not necessarily with the same eigenvalues). Prove that $S T=T S$.\nlean statement:\ntheorem exercise_5_20 {F V : Type*} [add_comm_group V] [field F]\n  [module F V] [finite_dimensional F V] {S T : End F V}\n  (h1 : @card T.eigenvalues (eigenvalues.fintype T) = finrank F V)\n  (h2 : \\<forall> v : V, \\<exists> c : F, v \\<in> eigenspace S c \\<longleftrightarrow> \\<exists> c : F, v \\<in> eigenspace T c) :\n  S * T = T * S :=\n\ncodex statement:\ntheorem commutative_of_same_eigenvectors:\n  fixes T::\"'a::{finite_dimensional, real_inner} \u21d2 'a\" and S::\"'a::{finite_dimensional, real_inner} \u21d2 'a\"\n  assumes \"linear T\" \"linear S\" \"\u2200x. x\u2208carrier_vec n \u27f6 (\u2203\u03bb. T x = \u03bb *\\<^sub>R x)\" \"\u2200x. x\u2208carrier_vec n \u27f6 (\u2203\u03bb. S x = \u03bb *\\<^sub>R x)\" \"\u2200x. x\u2208carrier_vec n \u27f6 (\u2203\u03bb. T x = \u03bb *\\<^sub>R x) \u27f6 (\u2203\u03bb. S x = \u03bb *\\<^sub>R x)\"\n  shows \"T \u2218 S = S \u2218 T\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_20: undefined oops\n\n\n(*\nproblem_number:5_24\nnatural language statement:\nSuppose $V$ is a real vector space and $T \\in \\mathcal{L}(V)$ has no eigenvalues. Prove that every subspace of $V$ invariant under $T$ has even dimension.\nlean statement:\ntheorem exercise_5_24 {V : Type*} [add_comm_group V]\n  [module \\<real> V] [finite_dimensional \\<real> V] {T : End \\<real> V}\n  (hT : \\<forall> c : \\<real>, eigenspace T c = \\<bot>) {U : submodule \\<real> V}\n  (hU : map T U = U) : even (finrank U) :=\n\ncodex statement:\ntheorem even_dim_of_invariant_subspace_of_no_eigenvalue:\n  fixes V::\"'a::euclidean_space set\" and T::\"'a \u21d2 'a\"\n  assumes \"linear T\" \"\u2200x. T x \u2260 x\"\n  shows \"\u2200S. subspace S \u27f6 subspace.invariant S T \u27f6 even (dim S)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_24: undefined oops\n\n\n(*\nproblem_number:6_2\nnatural language statement:\nSuppose $u, v \\in V$. Prove that $\\langle u, v\\rangle=0$ if and only if $\\|u\\| \\leq\\|u+a v\\|$ for all $a \\in \\mathbf{F}$.\nlean statement:\ntheorem exercise_6_2 {V : Type*} [add_comm_group V] [module \\<complex> V]\n  [inner_product_space \\<complex> V] (u v : V) :\n  \u27eau, v\u27eb_\\<complex> = 0 \\<longleftrightarrow> \\<forall> (a : \\<complex>), \u2225u\u2225 \\<le> \u2225u + a \\<bullet> v\u2225 :=\n\ncodex statement:\ntheorem norm_leq_norm_add_scalar_mul_iff_inner_eq_zero:\n  fixes u v::\"'a::euclidean_space\"\n  shows \"inner u v = 0 \u27f7 \u2200a. norm u \u2264 norm (u + a *\\<^sub>R v)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_2: undefined oops\n\n\n(*\nproblem_number:6_3\nnatural language statement:\nProve that $\\left(\\sum_{j=1}^{n} a_{j} b_{j}\\right)^{2} \\leq\\left(\\sum_{j=1}^{n} \nj a_{j}{ }^{2}\\right)\\left(\\sum_{j=1}^{n} \\frac{b_{j}{ }^{2}}{j}\\right)$ \nfor all real numbers $a_{1}, \\ldots, a_{n}$ and $b_{1}, \\ldots, b_{n}$.\nlean statement:\ntheorem exercise_6_3 {n : \\<nat>} (a b : fin n \\<rightarrow> \\<real>) :\n  (\\<Sum> i, a i * b i) ^ 2 \\<le> (\\<Sum> i : fin n, i * a i ^ 2) * (\\<Sum> i, b i ^ 2 / i) :=\n\ncodex statement:\ntheorem sum_square_leq_sum_square_of_sum_square:\n  fixes a b::\"nat \u21d2 real\"\n  assumes \"\u2200i. i \u2264 n \u27f6 a i \u2265 0\" \"\u2200i. i \u2264 n \u27f6 b i \u2265 0\"\n  shows \"(\u2211i=1..n. a i * b i)^2 \u2264 (\u2211i=1..n. i * (a i)^2) * (\u2211i=1..n. (b i)^2 / i)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_3: undefined oops\n\n\n(*\nproblem_number:6_7\nnatural language statement:\nProve that if $V$ is a complex inner-product space, \nthen $\\langle u, v\\rangle=\\frac{\\|u+v\\|^{2}-\\|u-v\\|^{2}+\\|u+i v\\|^{2} i-\\|u-i v\\|^{2} i}{4}$ \nfor all $u, v \\in V$.\nlean statement:\ntheorem exercise_6_7 {V : Type*} [inner_product_space \\<complex> V] (u v : V) :\n  \u27eau, v\u27eb_\\<complex> = (\u2225u + v\u2225^2 - \u2225u - v\u2225^2 + I*\u2225u + I\\<bullet>v\u2225^2 - I*\u2225u-I\\<bullet>v\u2225^2) / 4 :=\n\ncodex statement:\ntheorem inner_product_eq_sum_square_sub_square_sum_square_sub_square:\n  fixes u v::\"'a::euclidean_space\"\n  shows \"inner_product u v = (norm (u+v)^2 - norm (u-v)^2 + norm (u+ii*v)^2 - norm (u-ii*v)^2)/4\"\n\nOur comment on the codex statement: <wrong: missed\nfactors  \ud835\uddc2 in the expression, uses wrong type, nonexistent definition inner_product>\n *)\ntheorem exercise_6_7:\n fixes u v::\"complex\"\n  shows \"inner u v = (norm (u+v)^2 - norm (u-v)^2 + (norm (u+ \ud835\uddc2 * v)^2) * \ud835\uddc2 - (norm (u- \ud835\uddc2  * v)^2)* \ud835\uddc2)/4\"\n\n oops\n\n\n(*\nproblem_number:6_13\nnatural language statement:\nSuppose $\\left(e_{1}, \\ldots, e_{m}\\right)$ is an orthonormal list of vectors in $V$. \nLet $v \\in V$. \nProve that \n$\\|v\\|^{2}=\\left|\\left\\langle v, e_{1}\\right\\rangle\\right|^{2}+\\cdots+\\left|\\left\\langle v, \ne_{m}\\right\\rangle\\right|^{2}$ \nif and only if $v \\in \\operatorname{span}\\left(e_{1}, \\ldots, e_{m}\\right)$.\nlean statement:\ntheorem exercise_6_13 {V : Type*} [inner_product_space \\<complex> V] {n : \\<nat>}\n  {e : fin n \\<rightarrow> V} (he : orthonormal \\<complex> e) (v : V) :\n  \u2225v\u2225^2 = \\<Sum> i : fin n, \u2225\u27eav, e i\u27eb_\\<complex>\u2225^2 \\<longleftrightarrow> v \\<in> span \\<complex> (e '' univ) :=\n\ncodex statement:\ntheorem norm_square_eq_sum_abs_square_of_orthonormal_list_iff_in_span:\n  fixes v::\"'a::euclidean_space\" and e::\"'a set\"\n  assumes \"finite e\" \"e \u2286 orthonormal_basis\" \"v \u2208 span e\"\n  shows \"norm v ^ 2 = (\u2211x\u2208e. (cinner v x)^2)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_13: undefined oops\n\n\n(*\nproblem_number:6_16\nnatural language statement:\nSuppose $U$ is a subspace of $V$. Prove that $U^{\\perp}=\\{0\\}$ if and only if $U=V$\nlean statement:\ntheorem exercise_6_16 {K V : Type*} [is_R_or_C K] [inner_product_space K V]\n  {U : submodule K V} :\n  U.orthogonal = \\<bot>  \\<longleftrightarrow> U = \\<top> :=\n\ncodex statement:\ntheorem orthogonal_of_subspace_eq_zero_iff_eq_space:\n  fixes U::\"'a::euclidean_space set\"\n  assumes \"subspace U\"\n  shows \"orthogonal_complement U = {0} \u27f7 U = UNIV\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_16: undefined oops\n\n\n(*\nproblem_number:6_17\nnatural language statement:\nProve that if $P \\in \\mathcal{L}(V)$ is such that $P^{2}=P$ and every vector\n in $\\operatorname{null} P$ is orthogonal to every vector in $\\operatorname{range} P$, \nthen $P$ is an orthogonal projection.\nlean statement:\n\ncodex statement:\ntheorem orthogonal_projection_of_null_orthogonal_range:\n  fixes P::\"'a::euclidean_space \u21d2 'a\"\n  assumes \"linear P\" \"P^2 = P\" \"\u2200x\u2208null_space P. \u2200y\u2208range P. x\u22c5y = 0\"\n  shows \"orthogonal_projection P\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_17: undefined oops\n\n\n(*\nproblem_number:6_18\nnatural language statement:\nProve that if $P \\in \\mathcal{L}(V)$ is \nsuch that $P^{2}=P$ and $\\|P v\\| \\leq\\|v\\|$ for every $v \\in V$, then $P$ is an orthogonal projection.\nlean statement:\n\ncodex statement:\ntheorem orthogonal_projection_of_square_eq_self_and_norm_leq_norm:\n  fixes P::\"'a::euclidean_space \u21d2 'a\"\n  assumes \"linear P\" \"P^2 = P\" \"\u2200x. norm (P x) \u2264 norm x\"\n  shows \"\u2200x y. P x = P y \u27f6 x = y\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_18: undefined oops\n\n\n(*\nproblem_number:6_19\nnatural language statement:\nSuppose $T \\in \\mathcal{L}(V)$ and $U$ is a subspace of $V$. Prove that $U$ is invariant under $T$ \nif and only if $P_{U} T P_{U}=T P_{U}$.\nlean statement:\n\ncodex statement:\ntheorem invariant_of_projection_eq_projection_comp:\n  fixes T::\"'a::euclidean_space \u21d2 'a\" and U::\"'a set\"\n  assumes \"subspace U\"\n  shows \"invariant_under T U \u27f7 (T \u2218 (projection U) = projection U \u2218 T)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_19: undefined oops\n\n\n(*\nproblem_number:6_20\nnatural language statement:\nSuppose $T \\in \\mathcal{L}(V)$ and $U$ is a subspace of $V$. \nProve that $U$ and $U^{\\perp}$ are both invariant under $T$ if and only if $P_{U} T=T P_{U}$.\nlean statement:\n\ncodex statement:\ntheorem orthogonal_projection_eq_projection_orthogonal_iff_invariant:\n  fixes T::\"'a::euclidean_space \u21d2 'a\" and U::\"'a set\"\n  assumes \"subspace U\"\n  shows \"T ` U \u2286 U \u2227 T ` U\u22a5 \u2286 U\u22a5 \u27f7 (T \u2218 (projection U) = (projection U) \u2218 T)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_20: undefined oops\n\n\n(*\nproblem_number:6_29\nnatural language statement:\nSuppose $T \\in \\mathcal{L}(V)$ and $U$ is a subspace of $V$. Prove that $U$ \nis invariant under $T$ if and only if $U^{\\perp}$ is invariant under $T^{*}$.\nlean statement:\n\ncodex statement:\ntheorem invariant_of_adjoint_invariant:\n  fixes T::\"'a::euclidean_space \u21d2 'a\" and U::\"'a set\"\n  assumes \"linear T\" \"subspace U\"\n  shows \"U \u2286 carrier T \u27fa (orthogonal_complement U) \u2286 carrier (adjoint T)\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_29: undefined oops\n\n\n(*\nproblem_number:7_4\nnatural language statement:\nSuppose $P \\in \\mathcal{L}(V)$ is such that $P^{2}=P$. \nProve that $P$ is an orthogonal projection if and only if $P$ is self-adjoint.\nlean statement:\n\ncodex statement:\ntheorem orthogonal_projection_iff_self_adjoint:\n  fixes P::\"'a::euclidean_space \u21d2 'a\"\n  assumes \"linear P\" \"P^2 = P\"\n  shows \"orthogonal_projection P \u27f7 selfadjoint P\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_4: undefined oops\n\n\n(*\nproblem_number:7_5\nnatural language statement:\nShow that if $\\operatorname{dim} V \\geq 2$, then the set of normal \noperators on $V$ is not a subspace of $\\mathcal{L}(V)$.\nlean statement:\ntheorem exercise_7_5 {V : Type*} [inner_product_space \\<complex> V]\n  [finite_dimensional \\<complex> V] (hV : finrank V \\<ge> 2) :\n  \\<forall> U : submodule \\<complex> (End \\<complex> V), U.carrier \\<noteq>\n  {T | T * T.adjoint = T.adjoint * T} :=\n\ncodex statement:\ntheorem normal_operators_not_subspace_of_linear_operators:\n  fixes V::\"'a::euclidean_space set\"\n  assumes \"DIM('a) \u2265 2\"\n  shows \"\u2200N. linear N \u27f6 normal N \u27f6 False\"\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_5: undefined oops\n\n\n(*\nproblem_number:7_6\nnatural language statement:\nProve that if $T \\in \\mathcal{L}(V)$ is normal, then $\\operatorname{range} T=\\operatorname{range} T^{*}.$\nlean statement:\ntheorem exercise_7_6 {V : Type*} [inner_product_space \\<complex> V]\n  [finite_dimensional \\<complex> V] (T : End \\<complex> V)\n  (hT : T * T.adjoint = T.adjoint * T) :\n  T.range = T.adjoint.range :=\n\ncodex statement:\ntheorem range_of_normal_eq_range_of_adjoint:\n  fixes T::\"'a::euclidean_space \\<Rightarrow> 'a\"\n  assumes \"linear T\" \"T adjoint = T\"\n  shows \"range T = range (T adjoint)\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_6: undefined oops\n\n\n(*\nproblem_number:7_8\nnatural language statement:\nProve that there does not exist a self-adjoint operator \n$T \\in \\mathcal{L}\\left(\\mathbf{R}^{3}\\right)$ such that $T(1,2,3)=(0,0,0)$ and $T(2,5,7)=(2,5,7)$.\nlean statement:\n\ncodex statement:\ntheorem not_exists_self_adjoint_operator_of_two_eigenvectors:\n  fixes T::\"real^3 \\<Rightarrow> real^3\"\n  assumes \"linear T\" \"self_adjoint T\" \"T (vector [1,2,3]) = 0\" \"T (vector [2,5,7]) = vector [2,5,7]\"\n  shows False\nOur comment on the codex statement: <linear assumption issue. makes use of nonexistent def. self_adjoint>\n *)\n\ntheorem exercise_7_8: \n  fixes T::\"real^3 \\<Rightarrow> real^3\" assumes  (* \"linear T\"*) \n(* TODO T linear *)\n  \"T (vector [1,2,3]) = 0\" \"T (vector [2,5,7]) = vector [2,5,7]\"\n\"adjoint T = T\"\n  shows False\n  oops\n\n(*\nproblem_number:7_9\nnatural language statement:\nProve that a normal operator on a complex inner-product space is self-adjoint if and \nonly if all its eigenvalues are real.\nlean statement:\ntheorem exercise_7_9 {V : Type*} [inner_product_space \\<complex> V]\n  [finite_dimensional \\<complex> V] (T : End \\<complex> V)\n  (hT : T * T.adjoint = T.adjoint * T) :\n  is_self_adjoint T \\<longleftrightarrow> \\<forall> e : T.eigenvalues, (e : \\<complex>).im = 0 :=\n\ncodex statement:\ntheorem normal_operator_is_self_adjoint_iff_eigenvalues_are_real:\n  fixes A::\"'a::euclidean_space \\<Rightarrow> 'a\"\n  assumes \"normal_operator A\"\n  shows \"self_adjoint A \\<longleftrightarrow> (\\<forall>x. eigenvalue A x \\<longrightarrow> x\\<in>\\<real>)\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_9: undefined oops\n\n\n(*\nproblem_number:7_10\nnatural language statement:\nSuppose $V$ is a complex inner-product space and $T \\in \\mathcal{L}(V)$ is a normal \noperator such that $T^{9}=T^{8}$. Prove that $T$ is self-adjoint and $T^{2}=T$.\nlean statement:\ntheorem exercise_7_10 {V : Type*} [inner_product_space \\<complex> V]\n  [finite_dimensional \\<complex> V] (T : End \\<complex> V)\n  (hT : T * T.adjoint = T.adjoint * T) (hT1 : T^9 = T^8) :\n  is_self_adjoint T \\<and> T^2 = T :=\n\ncodex statement:\ntheorem normal_operator_of_power_eq_power_succ:\n  fixes T::\"'a::complex_inner_product_space \\<Rightarrow> 'a\"\n  assumes \"normal T\" \"T^9 = T^8\"\n  shows \"T = adjoint T \\<and> T^2 = T\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_10: undefined oops\n\n\n(*\nproblem_number:7_11\nnatural language statement:\nSuppose $V$ is a complex inner-product space. Prove that every normal \noperator on $V$ has a square root. (\nAn operator $S \\in \\mathcal{L}(V)$ is called a square root of $T \\in \\mathcal{L}(V)$ if $S^{2}=T$.)\nlean statement:\ntheorem exercise_7_11 {V : Type*} [inner_product_space \\<complex> V]\n  [finite_dimensional \\<complex> V] {T : End \\<complex> V} (hT : T*T.adjoint = T.adjoint*T) :\n  \\<exists> (S : End \\<complex> V), S ^ 2 = T :=\n\ncodex statement:\ntheorem exists_sqrt_of_normal_operator:\n  fixes V::\"'a::complex_inner_product_space\"\n  assumes \"normal_operator V\"\n  shows \"\\<exists>S. bounded_linear S \\<and> S^2 = T\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_11: undefined oops\n(*\nproblem_number:7_14\nnatural language statement:\nSuppose $T \\in \\mathcal{L}(V)$ is self-adjoint, $\\lambda \\in \\mathbf{F}$, and $\\epsilon>0$. Prove that if there exists $v \\in V$ such that $\\|v\\|=1$ and $\\|T v-\\lambda v\\|<\\epsilon,$ then $T$ has an eigenvalue $\\lambda^{\\prime}$ such that $\\left|\\lambda-\\lambda^{\\prime}\\right|<\\epsilon$.\nlean statement:\ntheorem exercise_7_14 {\ud835\udd5c V : Type*} [is_R_or_C \ud835\udd5c]\n  [inner_product_space \ud835\udd5c V] [finite_dimensional \ud835\udd5c V]\n  {T : End \ud835\udd5c V} (hT : is_self_adjoint T)\n  {l : \ud835\udd5c} {\\<epsilon> : \\<real>} (he : \\<epsilon> > 0) : \\<exists> v : V, \u2225v\u2225 = 1 \\<and> \u2225T v - l \\<bullet> v\u2225 < \\<epsilon> \\<rightarrow>\n  \\<exists> l' : T.eigenvalues, \u2225l - l'\u2225 < \\<epsilon> :=\n\ncodex statement:\ntheorem exists_eigenvalue_of_self_adjoint_operator:\n  fixes T::\"'a::euclidean_space \\<Rightarrow> 'a\"\n  assumes \"self_adjoint T\" \"\\<exists>v. norm v = 1 \\<and> norm (T v - \\<lambda> v) < \\<epsilon>\"\n  shows \"\\<exists>\\<lambda>'. eigenvalue T \\<lambda>' \\<and> abs (\\<lambda> - \\<lambda>') < \\<epsilon>\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_14: undefined oops\n\n\n(*\nproblem_number:7_15\nnatural language statement:\nSuppose $U$ is a finite-dimensional real vector space and $T \\in$ $\\mathcal{L}(U)$. \nProve that $U$ has a basis consisting of eigenvectors of $T$ if and only if there is an \ninner product on $U$ that makes $T$ into a self-adjoint operator.\nlean statement:\n\ncodex statement:\ntheorem exists_inner_product_of_eigenvectors_basis:\n  fixes T::\"'a::euclidean_space \\<Rightarrow> 'a\"\n  assumes \"linear T\" \"\\<exists>b. independent b \\<and> b \\<subseteq> carrier_vec n \\<and> span b = carrier_vec n\"\n  shows \"\\<exists>B. inner_product_space B \\<and> (\\<forall>x\\<in>b. eigenvector B T x)\"\nOur comment on the codex statement: <various type errors, wrong statement, and makes up defs that\ndon't exist in Isabelle.>\n *)\ntheorem exercise_7_15:\n  undefined\n  oops\n\n\n(*\nproblem_number:7_17\nnatural language statement:\nProve that the sum of any two positive operators on $V$ is positive.\nlean statement:\n\ncodex statement:\ntheorem sum_of_positive_operators_is_positive:\n  fixes V::\"'a::euclidean_space set\" and f g::\"'a \\<Rightarrow> 'a\"\n  assumes \"linear f\" \"linear g\" \"\\<forall>x\\<in>V. 0 \\<le> f x \u22c5 x\" \"\\<forall>x\\<in>V. 0 \\<le> g x \u22c5 x\"\n  shows \"\\<forall>x\\<in>V. 0 \\<le> (f + g) x \u22c5 x\"\nOur comment on the codex statement: <wrong assumptions and type issues>\n *)\ntheorem exercise_7_17: \nundefined\n\n  oops\n\n\n(*\nproblem_number:7_18\nnatural language statement:\nProve that if $T \\in \\mathcal{L}(V)$ is positive, then so is $T^{k}$ for every positive integer $k$.\nlean statement:\n\ncodex statement:\ntheorem positive_of_positive_power:\n  fixes T::\"'a::euclidean_space \\<Rightarrow> 'a\"\n  assumes \"linear T\" \"positive T\"\n  shows \"positive (T^k)\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_7_18:\nundefined\n  oops\n\n\n\n\nend\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_140\n  (a b c : \u211d)\n  (h\u2080 : 0 < a \u2227 0 < b \u2227 0 < c)\n  (h\u2081 : \u2200 x, 24 * x^2 - 19 * x - 35 = (((a * x) - 5) * ((2 * (b * x)) + c))) :\n  a * b - 3 * c = -9 :=\nbegin\n  have h\u2082 := h\u2081 0,\n  have h\u2082 := h\u2081 1,\n  have h\u2083 := h\u2081 (-1),\n  linarith,\nend"}
{"text": "import data.list.basic\nopen list\nuniverse u\nvariables {\u03b1 : Type} (x y z : \u03b1) (xs ys zs : list \u03b1)\n\ndef mk_symm (xs : list \u03b1) := xs ++ reverse xs\n\ntheorem reverse_mk_symm (xs : list \u03b1) :\n  reverse (mk_symm xs) = mk_symm xs :=\n  by simp [mk_symm]\n\nattribute [simp] reverse_mk_symm\n\nexample (xs ys : list \u2115) :\n  reverse (xs ++ mk_symm ys) = mk_symm ys ++ reverse xs :=\n  by simp\n\nexample (xs ys : list \u2115) (p : list \u2115 \u2192 Prop) (h : p (reverse (xs ++ (mk_symm ys)))) :\n  p (mk_symm ys ++ reverse xs) :=\n  by simp at h; assumption\n"}
{"text": "import smt2\n\nlemma negation_of_conj :\n    forall (P Q : Prop),\n        not (P \u2227 Q) \u2194 not P \u2228 not Q :=\nby intros; z3 \"d1.log\"\n\nlemma negation_of_disj :\n    forall (P Q : Prop),\n        \u00ac (P \u2228 Q) \u2194 \u00ac P \u2227 \u00ac Q :=\nbegin\n    intros, z3\nend\n\n#print negation_of_conj\n#print negation_of_disj\n"}
{"text": "informal statement Show that if $\\prod X_\\alpha$ is regular, then so is $X_\\alpha$. Assume that each $X_\\alpha$ is nonempty.formal statement theorem exercise_32_3 {X : Type*} [topological_space X]\n  (hX : locally_compact_space X) (hX' : t2_space X) :\n  regular_space X :="}
{"text": "import M4R.Algebra.Ring.IdealZorn\nimport M4R.Algebra.Ring.Localisation\nimport M4R.Algebra.Ring.Radical\n\nnamespace M4R\n  open Monoid NCSemiring Semiring NCRing\n\n  variable {A : Type _} [Ring A] {I : Ideal A}\n\n  -- Theorem 1.1\n  private theorem t1_1 (hI : I.proper_ideal) : \u2203 J : Ideal A, I \u2286 J \u2227 J.is_maximal :=\n    let \u27e8m, hm\u2081, hm\u2082\u27e9 := Ideal.ideal_zorn {J | I \u2286 J \u2227 J.proper_ideal} (by\n      intro c cs hc\n      cases Classical.em (Nonempty c) with\n      | inl h =>\n        have hub\u2081 := fun (a : Ideal A) (ha : a \u2208 c) => Ideal.ideal_chain_subset c ha hc\n        have hub\u2082 := Ideal.ideal_chain_proper c h hc (fun J Jc => (cs Jc).right)\n        exact \u27e8Ideal.ideal_chain c h hc, \u27e8let \u27e8J, Jc\u27e9 := Classical.choice h\n          Subset.trans (cs Jc).left (hub\u2081 J Jc), hub\u2082\u27e9, hub\u2081\u27e9\n      | inr h => exact \u27e8I, \u27e8Subset.refl _, hI\u27e9, fun a ac => absurd \u27e8a, ac\u27e9 h\u27e9)\n    \u27e8m, hm\u2081.left, \u27e8hm\u2081.right, by intro J mJ; exact (Classical.em J.proper_ideal).imp (fun h =>\n      hm\u2082 J \u27e8Subset.trans hm\u2081.left mJ, h\u27e9 mJ) of_not_not\u27e9\u27e9\n\n  theorem Ideal.exists_maximal_containing (hI : I.proper_ideal) : \u2203 J : Ideal A, I \u2286 J \u2227 J.is_maximal := t1_1 hI\n  theorem Ideal.exists_prime_containing (hI : I.proper_ideal) : \u2203 J : Ideal A, I \u2286 J \u2227 J.is_prime :=\n    let \u27e8J, hIJ, hJ\u27e9 := t1_1 hI; \u27e8J, hIJ, maximal_is_prime hJ\u27e9\n\n  theorem Ideal.exists_maximal_containing_nonunit {x : A} (hx : \u00acisUnit x) : \u2203 I : Ideal A, I.is_maximal \u2227 x \u2208 I :=\n    let \u27e8I, hxI, hI\u27e9 := t1_1 (unit_not_principal hx); \u27e8I, hI, hxI (generator_in_principal x)\u27e9\n  theorem Ideal.exists_maximal_ideal_of_nontrivial [Ring A] (h : Ring.is_NonTrivial A) : \u2203 I : Ideal A, I.is_maximal :=\n    let \u27e8I, _, hI\u27e9 := t1_1 (zero_ideal_proper_of_nontrivial h)\n    \u27e8I, hI\u27e9\n  theorem Ideal.exists_prime_ideal_of_nontrivial [Ring A] (h : Ring.is_NonTrivial A) : \u2203 I : Ideal A, I.is_prime :=\n    let \u27e8I, hI\u27e9 := exists_maximal_ideal_of_nontrivial h; \u27e8I, maximal_is_prime hI\u27e9\n  theorem Ideal.exists_maximal_ideal (A) [NonTrivialRing A] : \u2203 I : Ideal A, I.is_maximal :=\n    let \u27e8I, _, hI\u27e9 := t1_1 (zero_ideal_proper A); \u27e8I, hI\u27e9\n  theorem Ideal.exists_prime_ideal (A) [NonTrivialRing A] : \u2203 I : Ideal A, I.is_prime :=\n    let \u27e8I, hI\u27e9 := exists_maximal_ideal A; \u27e8I, maximal_is_prime hI\u27e9\n\n  theorem Ring.jacobson_radical.units {x : A} : x \u2208 jacobson_radical A \u2194 \u2191{y : A | \u2203 r, 1 + r * x = y} \u2286 unit_set A :=\n    \u27e8fun hx => fun y \u27e8r, hrxy\u27e9 => Classical.byContradiction fun hy => by\n      let \u27e8M, hM, hyM\u27e9 := Ideal.exists_maximal_containing_nonunit hy\n      rw [\u2190hrxy] at hyM\n      have := M.add_closed hyM ((M.mul_closed (-r) (maximal_subset_jacobson hM hx)))\n      rw [add_assoc, neg_mul, add_neg, add_zero] at this\n      exact absurd (Ideal.is_unit_ideal.mpr this) hM.left,\n    fun hx => Ideal.sIntersection.mem.mpr fun M hM => Classical.byContradiction fun h =>\n      let \u27e8m, hm, x', \u27e8s, hs\u27e9, h'\u27e9 := Ideal.is_unit_ideal.mp ((hM.right (Ideal.add.subset M (Ideal.principal x))).resolve_left\n        fun h' => h (h' \u25b8 Ideal.add.subset' _ _ (Ideal.generator_in_principal x)))\n      absurd (Ideal.is_unit_ideal'.mpr \u27e81 + -s * x, hx \u27e8-s, rfl\u27e9, by\n        rw [\u2190h', \u2190hs, mul_comm, neg_mul, add_assoc, add_neg, add_zero]; exact hm\u27e9) hM.left\u27e9\n\n  theorem Ring.nakayama {M : Ideal A} (hM : M.finitely_generated) {I : Ideal A} (hI : I \u2286 Ring.jacobson_radical A)\n    (hIM : M = I * M) : M = 0 := by\n      let \u27e8f, hfM, hfmax\u27e9 := hM.has_minimal_generating_set\n      byCases hf : f = \u2205\n      { rw [hf, Finset.empty_toSet, Ideal.from_set.empty] at hfM; exact hfM }\n      { let \u27e8g, hg\u27e9 : \u2203 g, g \u2208 f := Classical.byContradiction fun h => hf (Finset.ext fun x => by\n          rw [Finset.mem_empty, iff_false]; exact not_exists.mp h x)\n        have : g \u2208 I * M := hIM \u25b8 hfM \u25b8 Ideal.from_set.contains_mem hg\n        let \u27e8c, hcI, hfc\u27e9 : \u2203 c : A \u2192 A, (\u2200 x, c x \u2208 I) \u2227 g = \u2211 x in f, c x * x :=\n          let \u27e8fs, c, hf, hc\u27e9 := Ideal.from_set.mem_as_sum.mp this\n          @Finset.cons_induction _ (fun fs : Finset A => fs.toSet \u2286 Ideal.product_gen I M \u2192 \u2200 g, g = (\u2211 x in fs, c x * x) \u2192\n            \u2203 c : A \u2192 A, (\u2200 x, c x \u2208 I) \u2227 g = \u2211 x in f, c x * x) (fun _ g hg => \u27e8fun _ => 0, fun _ => I.has_zero, by\n            rw [hg, Finset.map_sum.empty, Finset.map_sum.eq_zero (fun _ _ => by rw [zero_mul])]\u27e9)\n            (fun x fs hx ih hfs g hg =>\n              let \u27e8c', hc', hgc'\u27e9 := ih (Subset.trans (fun _ => Finset.mem_cons_self' hx) hfs) (g - c x * x)\n                (by rw [Finset.map_sum.cons] at hg; exact Group.sub_eq.mpr hg)\n              let \u27e8i, hi, m, hm, him\u27e9 := hfs (Finset.mem_cons_self fs hx)\n              let \u27e8mc, hmc\u27e9 := Ideal.from_set.mem_as_sum_finset.mp (hfM \u25b8 hm : m \u2208 Ideal.from_set f.toSet)\n              \u27e8fun y => c' y + c x * i * mc y, fun y => I.add_closed (hc' y) (mul_right_comm _ _ _ \u25b8 I.mul_closed _ hi),\n              by simp only [mul_distrib_right, Finset.map_sum.distrib, mul_assoc,\n                \u2190Finset.map_sum.mul_sum]; rw [\u2190hgc', \u2190hmc, \u2190him, Group.sub_add]\u27e9) fs hf g hc\n        let \u27e8u, hu\u27e9 : isUnit (1 - c g) := by exact jacobson_radical.units.mp (hI (hcI g)) \u27e8-1, by rw [neg_one_mul, Group.sub_def]\u27e9\n        have : (1 - c g) * g = \u2211 x in f.erase g, c x * x := by\n          rw [sub_mul_distrib_right, one_mul, Group.sub_eq, \u2190Finset.map_sum.sum_term _ _ hg, hfc]\n        have := hfmax (f.erase g) (hfM \u25b8 Ideal.antisymm (Ideal.from_set.ideal_contained fun x hx => by\n          byCases hxg : x = g\n          { exact Ideal.from_set.mem_as_sum_finset.mpr \u27e8fun y => u * c y, by\n              simp only [mul_assoc]; rw [\u2190Finset.map_sum.mul_sum, \u2190this, \u2190mul_assoc, mul_comm u, hu, one_mul, hxg]\u27e9 }\n          { exact Ideal.from_set.contains_mem (Finset.mem_erase.mpr \u27e8hxg, hx\u27e9) })\n              (Ideal.from_set.subset fun x hx => (Finset.mem_erase.mp hx).right));\n        exact absurd this (have : (f.erase g).length.succ = f.length := by\n            rw [congrArg Finset.length (Finset.erase_cons f hg), Finset.length_cons]\n          Nat.not_le.mpr (this \u25b8 Nat.lt.base _)) }\n\n  -- Theorem 1.2\n  private theorem t1_2 (I) (S : MultiplicativeSet A) (hIS : Set.disjoint I.subset S.subset) :\n    \u2203 J : Ideal A, I \u2286 J \u2227 Set.disjoint J.subset S.subset \u2227 J.is_prime :=\n      let \u27e8m, hm\u2081, hm\u2082\u27e9 := Ideal.ideal_zorn {J | I \u2286 J \u2227 Set.disjoint J.subset S.subset} (by\n        intro c cs hc; byCases h : Nonempty c\n        { have hub\u2081 := fun (a : Ideal A) (ha : a \u2208 c) => Ideal.ideal_chain_subset c ha hc\n          have hub\u2082 := Ideal.ideal_chain_disjoint c h hc S.subset fun J Jc => (cs Jc).right;\n          exact \u27e8Ideal.ideal_chain c h hc, \u27e8let \u27e8J, Jc\u27e9 := Classical.choice h\n            Subset.trans (cs Jc).left (hub\u2081 J Jc), hub\u2082\u27e9, hub\u2081\u27e9 }\n        { exact \u27e8I, \u27e8Subset.refl _, hIS\u27e9, fun a ac => absurd \u27e8a, ac\u27e9 h\u27e9 })\n      \u27e8m, hm\u2081.left, hm\u2081.right, S.disjoint_ideal_proper hm\u2081.right, by\n        intro r s hrs; apply Classical.byContradiction; rw [not_or_iff_and_not]; intro \u27e8nrm, nsm\u27e9\n        have : \u2200 {x}, x \u2209 m \u2192 \u00acSet.disjoint (m + Ideal.principal x).subset S.subset := by\n          intro x xnm h; apply xnm\n          have := hm\u2082 (m + Ideal.principal x) \u27e8Subset.trans hm\u2081.left (Ideal.add.subset m (Ideal.principal x)), h\u27e9\n            (Ideal.add.subset m (Ideal.principal x))\n          rw [\u2190this]; exact \u27e80, m.has_zero, x, Ideal.generator_in_principal x, zero_add x\u27e9\n        have \u27e8r', \u27e8r'i, r'im, r'j, \u27e8r'', hr''\u27e9, hr'ij\u27e9, r'S\u27e9 := Classical.choice (Set.nonempty.mp (this nrm))\n        have \u27e8s', \u27e8s'i, s'im, s'j, \u27e8s'', hs''\u27e9, hs'ij\u27e9, s'S\u27e9 := Classical.choice (Set.nonempty.mp (this nsm))\n        have h\u2081 := S.mul_closed r'S s'S\n        rw [\u2190hr'ij, \u2190hs'ij, \u2190hr'', \u2190hs'', mul_distrib_left, mul_distrib_right, mul_distrib_right, \u2190add_assoc] at h\u2081\n        have h\u2082 : r'i * s'i + r * r'' * s'i + r'i * (s * s'') + r * r'' * (s * s'') \u2208 m + Ideal.principal (r * s) :=\n          \u27e8r'i * s'i + r * r'' * s'i + r'i * (s * s''), m.add_closed (m.add_closed (m.mul_closed _ s'im)\n            (m.mul_closed _ s'im)) (m.mul_closed' r'im _), r * r'' * (s * s''), \u27e8r'' * s'', by\n              rw [mul_assoc, \u2190mul_assoc s, mul_comm s, mul_assoc, \u2190mul_assoc r]\u27e9, rfl\u27e9\n        have h\u2083 : m + Ideal.principal (r * s) = m := Ideal.add.of_subset (Ideal.principal_in hrs)\n        rw [h\u2083] at h\u2082\n        exact Set.nonempty.mpr (\u27e8_, h\u2082, h\u2081\u27e9 : Nonempty \u2191(m.subset \u2229 S.subset)) hm\u2081.right\u27e9\n\n  theorem Ideal.radical_prime_intersection (I : Ideal A) : I.radical = \u22c2\u2080 {J | I \u2286 J \u2227 J.is_prime} :=\n    Ideal.antisymm (fun x hx => propext sIntersection.mem \u25b8 fun J \u27e8hIJ, hJ\u27e9 =>\n      (prime_radical hJ).eq_rad \u25b8 radical.subset hIJ hx)\n      fun x hx => Classical.byContradiction fun hxI =>\n        let S : MultiplicativeSet A := {\n          subset := {a | \u2203 n : Nat, a = x ^ n}\n          has_one := \u27e80, rfl\u27e9\n          mul_closed := fun \u27e8m, hm\u27e9 \u27e8n, hn\u27e9 => \u27e8m + n,\n            hm \u25b8 hn \u25b8 (pow_nat_add_distrib x m n).symm\u27e9\n        }\n        let \u27e8J, hIJ, hJS, hJ\u27e9 := t1_2 I.radical S (by\n          apply Set.disjoint.elementwise.mpr; intro a haI \u27e8n, hn\u27e9\n          byCases hn0 : n = 0\n          { apply ((is_unit_ideal.mpr (pow_nat_0 x \u25b8 hn0 \u25b8 hn \u25b8 haI)) \u25b8 hxI : x \u2209 (1 : Ideal A)); trivial }\n          { exact absurd (radical.is_radical I x n hn0 (hn \u25b8 haI)) hxI })\n        absurd \u27e81, rfl\u27e9 (Set.disjoint.elementwise.mp hJS x\n          (sIntersection.mem.mp hx J \u27e8Subset.trans (radical.sub_self I) hIJ, hJ\u27e9))\n\n  theorem Ring.nil_radical.eq_prime_intersection (A : Type _) [Ring A] : Ring.nil_radical A = \u22c2\u2080 Ring.Spec A :=\n    (Ideal.radical_prime_intersection 0).trans (Ideal.ext'.mpr fun x => by\n      rw [Ideal.sIntersection.mem, Ideal.sIntersection.mem]; exact forall_congr' fun P => (by\n        simp only [P.zero_ideal_in, true_and]; exact Iff.rfl : _ \u2227 _ \u2192 _ \u2194 _))\n\n  -- Theorem 1.3\n  private theorem t1_3 (fI : Finset (Ideal A)) (hfI : \u2200 I \u2208 fI, \u2200 J \u2208 fI, I \u2260 J \u2192 Ideal.coprime I J) :\n    \u22c2\u2080 fI.toSet = \u220f fI := @Finset.cons_induction _ (fun f => f \u2286 fI \u2192 \u22c2\u2080 f.toSet = \u220f f)\n      (fun _ => by rw [Finset.empty_toSet, Ideal.sIntersection.empty]; rfl)\n      (fun J s hJs ih hsfI => by\n        rw [Finset.prod.cons, Ideal.product.coprime_eq_inter ((Ideal.coprime.comm _ _).mp (Ideal.product.prod_coprime\n          (fun K hK => hfI J (hsfI (s.mem_cons_self hJs)) K (hsfI (Finset.mem_cons_self' hJs hK))\n          fun h => absurd (h \u25b8 hK) hJs))), \u2190ih fun x hx => hsfI (Finset.mem_cons_self' hJs hx),\n          \u2190Ideal.sIntersection.insert, Finset.cons_toSet])\n      fI (Subset.refl fI)\n\n  open QuotientRing\n\n  -- Theorem 1.4\n  private noncomputable def t1_4 (fI : Finset (Ideal A)) (hfI : \u2200 I \u2208 fI, \u2200 J \u2208 fI, I \u2260 J \u2192 Ideal.coprime I J) :\n    QClass (\u22c2\u2080 fI.toSet) \u2245\u1d63 MultiProd (fun i : fI => QClass i.val) :=\n      Classical.choice (@Finset.cons_induction _ (fun f : Finset (Ideal A) => f \u2286 fI \u2192\n        Nonempty (QClass (\u22c2\u2080 f.toSet) \u2245\u1d63 MultiProd (fun i : f => QClass i.val)))\n        (fun _ => by\n          rw [Finset.empty_toSet, Ideal.sIntersection.empty]\n          exact \u27e8{\n            hom           := fun _ _ => 0\n            preserve_zero := rfl\n            preserve_add  := fun _ _ => (add_zero _).symm\n            preserve_neg  := fun _ => Group.neg_zero.symm\n            preserve_mul  := fun _ _ => (mul_zero _).symm\n            inv           := fun _ => 0\n            left_inv      := fun x => (QuotientRing.trivial_zero x).symm\n            right_inv     := fun x => funext fun \u27e8_, _\u27e9 => by contradiction\n          }\u27e9)\n        (fun I s hI ih hs => by\n          have f\u2081 := chinese_remainder_theorem (\u22c2\u2080 s.toSet) I ((Ideal.coprime.comm _ _).mp (Ideal.sIntersection.sinter_coprime\n            fun J hJ => hfI I (hs (s.mem_cons_self hI)) J (hs (Finset.mem_cons_self' hI hJ)) fun h => absurd (h \u25b8 hJ) hI))\n          have f\u2082 : QClass (\u22c2\u2080Finset.toSet s) \u00d7 QClass I \u2245\u1d63 MultiProd (fun i : s => QClass i.val) \u00d7 QClass I :=\n            (Classical.choice (ih (fun x hx => hs (Finset.mem_cons_self' hI hx)))).Product RIsomorphism.Identity\n          rw [Finset.cons_toSet, Ideal.sIntersection.insert]\n          exact \u27e8(f\u2081.comp f\u2082).comp (RIsomorphism.MultiProd_cons QClass hI)\u27e9) fI (Subset.refl _))\n\nend M4R\n"}
{"text": "lemma holomorphic_on_If_Un [holomorphic_intros]: assumes \"f holomorphic_on A\" \"g holomorphic_on B\" \"open A\" \"open B\" assumes \"\\<And>z. z \\<in> A \\<Longrightarrow> z \\<in> B \\<Longrightarrow> f z = g z\" shows \"(\\<lambda>z. if z \\<in> A then f z else g z) holomorphic_on (A \\<union> B)\" (is \"?h holomorphic_on _\")"}
{"text": "--\n\nstructure S  :=\n(g {\u03b1} : \u03b1 \u2192 \u03b1)\n\ndef f (h : Nat \u2192 ({\u03b1 : Type} \u2192 \u03b1 \u2192 \u03b1) \u00d7 Bool) : Nat :=\n(h 0).1 1\n\ndef tst : Nat :=\nf fun n => (fun x => x, true)\n\ntheorem ex : id (Nat \u2192 Nat) :=\nby {\n  intro;\n  assumption\n}\n\ndef g (i j k : Nat) (a : Array Nat) (h\u2081 : i < k) (h\u2082 : k < j) (h\u2083 : j < a.size) : Nat :=\n  let vj := a.get \u27e8j, h\u2083\u27e9;\n  let vi := a.get \u27e8i, Nat.ltTrans h\u2081 (Nat.ltTrans h\u2082 h\u2083)\u27e9;\n  vi + vj\n\nset_option pp.all true in\n#print g\n\n#check g.proof_1\n\ntheorem ex1 {p q r s : Prop} : p \u2227 q \u2227 r \u2227 s \u2192 r \u2227 s \u2227 q \u2227 p :=\n  fun \u27e8hp, hq, hr, hs\u27e9 => \u27e8hr, hs, hq, hp\u27e9\n\ntheorem ex2 {p q r s : Prop} : p \u2227 q \u2227 r \u2227 s \u2192 r \u2227 s \u2227 q \u2227 p := by\n  intro \u27e8hp, hq, hr, hs\u27e9\n  exact \u27e8hr, hs, hq, hp\u27e9\n"}
{"text": "lemma connected_empty [simp]: \"connected {}\""}
{"text": "def g (x : Nat) : List (Nat \u00d7 List Nat) :=\n[(x, [x, x]), (x, [])]\n\ndef h (x : Nat) : List (Nat \u00d7 List Nat) :=\ng x |>.filter fun \u27e8_, xs\u27e9 => xs.isEmpty\n\ntheorem ex1 : g 10 = [(10, [10, 10]), (10, [])] :=\nrfl\n\ntheorem ex2 : h 10 = [(10, [])] :=\nrfl\n"}
{"text": "opaque A : Nat \u2192 Type\nopaque f (x : Nat) (a : A x) : Nat\n\nexample (x : Nat) (a : A (x + 0)) : f (x + 0) a = x := by\n  simp\n  trace_state -- \u22a2 f x a = x\n  sorry\n\nexample (x : Nat) (a : A (x + 0)) : f (x + 0) a = x := by\n  simp (config := { dsimp := false })\n  trace_state -- \u22a2 f (x + 0) a = x\n  sorry\n"}
{"text": "-----------------------------------------------------------------------------\n-- |\n-- Module      : Berp.Base.Truth\n-- Copyright   : (c) 2010 Bernie Pope\n-- License     : BSD-style\n-- Maintainer  : florbitous@gmail.com\n-- Stability   : experimental\n-- Portability : ghc\n--\n-- Implementation of the truth predicate on Python objects.\n--\n-----------------------------------------------------------------------------\n\nmodule Berp.Base.Truth (truth) where\n\nimport {-# SOURCE #-} Berp.Base.HashTable as HashTable (sizeIO)\nimport {-# SOURCE #-} Berp.Base.HashSet as HashSet (sizeIO)\nimport Berp.Base.SemanticTypes (Object (..))\nimport Data.Complex (Complex (..))\nimport System.IO.Unsafe (unsafePerformIO)\nimport Data.IORef (readIORef)\n\n-- XXX incomplete\ntruth :: Object -> Bool\ntruth (Bool { object_bool = b }) = b\ntruth (Integer { object_integer = i }) = i /= 0\ntruth (Float { object_float = f }) = f /= 0\ntruth (Complex { object_complex = c }) = c /= (0 :+ 0)\ntruth None = False\ntruth obj@(Tuple {}) = object_length obj /= 0\ntruth obj@(String {}) = object_string obj /= []\ntruth obj@(List {}) = unsafePerformIO $ do\n   numElems <- readIORef $ object_list_num_elements obj\n   return (numElems /= 0)\ntruth obj@(Dictionary {}) = unsafePerformIO $ do\n   numElems <- HashTable.sizeIO $ object_hashTable obj\n   return (numElems /= 0)\ntruth obj@(Set {}) = unsafePerformIO $ do\n   numElems <- HashSet.sizeIO $ object_hashSet obj\n   return (numElems /= 0)\ntruth _other = True\n\n{-\n   Python Language Reference, section 5.10 \"Boolean operations\":\n\n   In the context of Boolean operations, and also when expressions \n   are used by control flow statements, the following values are \n   interpreted as false: False, None, numeric zero of all types, \n   and empty strings and containers (including strings, tuples, \n   lists, dictionaries, sets and frozensets). All other values \n   are interpreted as true. User-defined objects can customize their \n   truth value by providing a __bool__() method.\n-}\n"}
{"text": "theory deMorgan1\n  imports Main\nbegin\n  text\\<open> Apply style \\<close>\n   lemma lem_k_1 : \"\\<not>(p \\<or> q) \\<longrightarrow> (\\<not>p \\<and> \\<not>q)\"\n    apply (rule impI)\n    apply (rule conjI)\n    apply (rule notI)\n    apply (erule notE)\n     apply(rule disjI1)\n       apply assumption\n      apply (rule notI)\n      apply (erule notE)\n      apply (rule disjI2)\n     apply assumption\n    done\n\nend"}
{"text": "import smt2\n\nlemma p_implies_p (P : Prop) : P \u2192 P :=\nbegin\n    intros,\n    z3\nend\n"}
{"text": "theory Check\n  imports Submission\nbegin\n\ntheorem double_len: \"length (double xs) = 2 * length xs\"\n  by (rule Submission.double_len)\n\ntheorem reverse_double: \"reverse (double xs) = double (reverse xs)\"\n  by (rule Submission.reverse_double)\n\ntheorem rev_double: \"rev (double xs) = double (rev xs)\"\n  by (rule Submission.rev_double)\n\nend"}
{"text": "lemmas continuous_Re [simp] = bounded_linear.continuous [OF bounded_linear_Re]"}
{"text": "\n\ndef head {\u03b1} : (as : List \u03b1) \u2192 as \u2260 [] \u2192 \u03b1\n| [],    h => absurd rfl h\n| a::as, _ => a\n\ntheorem head_cons {\u03b1} (a : \u03b1) (as : List \u03b1) : head (a::as) (fun h => List.noConfusion h) = a :=\nrfl\n\ntheorem head_cons' {\u03b1} (a : \u03b1) (as : List \u03b1) (h : a::as \u2260 []) : head (a::as) h = a :=\nrfl\n"}
{"text": "import data.nat.digits\n\nopen nat\nopen int\n\n/-\n(a) Prove the \"rule of 9\": an integer is divisible by 9 if and only if the sum of its digits is divisible by 9.\n(b) Prove the \"rule of 11\" stated in Example 13.6. Use this rule to decide in your head whether the number 82918073579 is divisible by 11.\n-/\n\nlemma part_a (n : \u2124) : 9 \u2223 n \u2194 9 \u2223 (digits 10 n.nat_abs).sum :=\nbegin\n  sorry\nend\n\nlemma part_b (n : \u2124) : 11 \u2223 n \u2194 (11 : \u2124) \u2223 ((digits 10 n.nat_abs).map (\u03bb (n : \u2115), \u2191n)).alternating_sum :=\nbegin\n  sorry\nend"}
{"text": "(*  Title:      Code_Int_Integer_Conversion.thy\n    Author:     Andreas Lochbihler, ETH Zurich\n*)\n\nchapter \\<open>A special case of a conversion.\\<close>\n\ntheory Code_Int_Integer_Conversion\nimports\n  Main\nbegin\n\ntext \\<open>\n  Use this function to convert numeral @{typ integer}s quickly into @{typ int}s.\n  By default, it works only for symbolic evaluation; normally generated code raises\n  an exception at run-time. If theory \\<^text>\\<open>Code_Target_Int_Bit\\<close> is imported,\n  it works again, because then @{typ int} is implemented in terms of @{typ integer}\n  even for symbolic evaluation.\n\\<close>\n\ndefinition int_of_integer_symbolic :: \"integer \\<Rightarrow> int\"\n  where \"int_of_integer_symbolic = int_of_integer\"\n\nlemma int_of_integer_symbolic_aux_code [code nbe]:\n  \"int_of_integer_symbolic 0 = 0\"\n  \"int_of_integer_symbolic (Code_Numeral.Pos n) = Int.Pos n\"\n  \"int_of_integer_symbolic (Code_Numeral.Neg n) = Int.Neg n\"\n  by (simp_all add: int_of_integer_symbolic_def)\n\nend\n"}
{"text": "/-\nCopyright (c) 2019 Neil Strickland. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Neil Strickland\n\n-/\n\nimport data.nat.choose\nimport algebra.prod_equiv\nimport tactic.squeeze\n\n/-\n Consider the identity\n (choose n k) =  (choose k-1 k-1) + (choose k k-1) + ... + (choose n-1 k-1)\n\n or \n (choose n+1 k+1) = (choose k k) + (choose k+1 k) + ... + (choose n k)\n This can be proved algebraically by induction.   \n Alternatively, we can consider the set (P n k) of \n subsets A of size k in {0,..,n-1}, so |(P n k)| = (choose n k).\n We can split this set up according to the value of (max A),\n and recover a combinatorial proof of the identity.\n\n-/\n\nlemma choose_sum' (k m : \u2115) : \n nat.choose (k + m) (k + 1) = \n  (finset.range m).sum (\u03bb i, nat.choose (k + i) k) := \nbegin\n induction m with m ih,\n {rw[finset.range_zero,finset.sum_empty,add_zero,nat.choose_succ_self]},\n {rw[finset.sum_range_succ,\u2190 ih,nat.add_succ,nat.choose, add_comm],}\nend\n\nlemma choose_sum (n k : \u2115) : \n nat.choose n.succ k.succ = (finset.Ico k n.succ).sum (\u03bb i, nat.choose i k) :=\nbegin\n by_cases h : k \u2264 n.succ,\n { let m := n.succ - k,\n   have : n.succ = k + m := by rw [add_comm, nat.sub_add_cancel h],\n   rw [this] at h \u22a2, \n   rw [choose_sum' k m],\n   let f : \u2115 \u2192 \u2115 := \u03bb p, nat.choose p k,\n   let g : \u2115 \u2192 \u2115 := has_add.add k,\n   change (finset.range m).sum (\u03bb i, f (g i)) = (finset.Ico k (k + m)).sum f,\n   rw [\u2190 @finset.sum_image \u2115 \u2115 \u2115 f _ _ (finset.range m) g\n       (\u03bb _ _ _ _, nat.add_left_cancel)],\n   have : finset.range m = finset.Ico 0 m := \n   begin\n     ext i,\n     simp only [finset.mem_range, finset.mem_Ico, nat.zero_le i, true_and]\n   end,\n   rw [this], \n   have := finset.image_add_left_Ico 0 m k,\n   rw[add_zero] at this, rw[\u2190 this]},\n  { have : finset.Ico k n.succ = \u2205 := \n     finset.Ico_eq_empty_iff.mpr (\u03bb h\u2080, h (le_of_lt h\u2080)),\n    rw[this, finset.sum_empty],\n    rw [nat.choose_eq_zero_of_lt (lt_trans (lt_of_not_ge h) k.lt_succ_self)] }\nend"}
{"text": "informal statement Let $R$ be the ring of $2 \\times 2$ matrices over the real numbers; suppose that $I$ is an ideal of $R$. Show that $I = (0)$ or $I = R$.formal statement theorem exercise_4_5_16 {p n: \u2115} (hp : nat.prime p) \n  {q : polynomial (zmod p)} (hq : irreducible q) (hn : q.degree = n) :\n  \u2203 is_fin : fintype $ polynomial (zmod p) \u29f8 ideal.span ({q} : set (polynomial $ zmod p)), \n  @card (polynomial (zmod p) \u29f8 ideal.span {q}) is_fin = p ^ n \u2227 \n  is_field (polynomial $ zmod p):="}
{"text": "/- -----------------------------------------------------------------------\nCategories.\n----------------------------------------------------------------------- -/\n\nimport ...p0_stdlib\n\nnamespace qp\n\nopen stdaux\n\nuniverse variables \u2113 \u2113obj \u2113hom \u2113obj\u2081 \u2113hom\u2081 \u2113obj\u2082 \u2113hom\u2082\n\n/-! #brief A strict category.\n-/\nstructure Cat\n    : Type ((max \u2113obj \u2113hom) + 1)\n:= (obj\n    : Type \u2113obj)\n   (hom\n     : \u2200 (x y : obj)\n       , Sort \u2113hom)\n   (id\n     : \u2200 (x : obj)\n       , hom x x)\n   (circ\n     : \u2200 {x y z : obj}\n       , hom y z \u2192 hom x y \u2192 hom x z)\n   (circ_assoc\n     : \u2200 {x y z w : obj}\n          {h : hom z w} {g : hom y z} {f : hom x y}\n       , circ h (circ g f) = circ (circ h g) f)\n   (circ_id_left\n     : \u2200 {x y : obj} {f : hom x y}\n       , circ (id y) f = f)\n   (circ_id_right\n     : \u2200 {x y : obj} {f : hom x y}\n       , circ f (id x) = f)\n\nattribute [simp] Cat.circ_id_left\nattribute [simp] Cat.circ_id_right\n\n/-! #brief Equality of categories.\n-/\ntheorem Cat.eq\n    : \u2200 {C\u2081 C\u2082 : Cat.{\u2113obj \u2113hom}}\n      , C\u2081^.obj = C\u2082^.obj\n      \u2192 C\u2081^.hom == C\u2082^.hom\n      \u2192 C\u2081^.id == C\u2082^.id\n      \u2192 @Cat.circ C\u2081 == @Cat.circ C\u2082\n      \u2192 C\u2081 = C\u2082\n| C\u2081 C\u2082 \u03c9obj \u03c9hom \u03c9id \u03c9circ\n:= begin\n     cases C\u2081 with obj\u2081 hom\u2081 id\u2081 circ\u2081 \u03c9\u2081\u2081 \u03c9\u2081\u2082 \u03c9\u2081\u2083,\n     cases C\u2082 with obj\u2082 hom\u2082 id\u2082 circ\u2082 \u03c9\u2082\u2081 \u03c9\u2082\u2082 \u03c9\u2082\u2083,\n     simp at \u03c9obj, subst \u03c9obj,\n     simp at \u03c9hom, cases \u03c9hom,\n     simp at \u03c9id, cases \u03c9id,\n     simp at \u03c9circ, cases \u03c9circ,\n     exact rfl\n   end\n\n/-! #brief Left congruence for circ.\n-/\ntheorem Cat.circ.congr_left {C : Cat.{\u2113obj \u2113hom}}\n    {x y z : C^.obj}\n    : \u2200 {g\u2081 g\u2082 : C^.hom y z}\n        {f : C^.hom x y}\n        (\u03c9g : g\u2081 = g\u2082)\n      , C^.circ g\u2081 f = C^.circ g\u2082 f\n| g .(g) f (eq.refl .(g)) := rfl\n\n/-! #brief Right congruence for circ.\n-/\ntheorem Cat.circ.congr_right {C : Cat.{\u2113obj \u2113hom}}\n    {x y z : C^.obj}\n    : \u2200 {g : C^.hom y z}\n        {f\u2081 f\u2082 : C^.hom x y}\n        (\u03c9f : f\u2081 = f\u2082)\n      , C^.circ g f\u2081 = C^.circ g f\u2082\n| g f .(f) (eq.refl .(f)) := rfl\n\n/-! #brief Bi-congruence for circ.\n-/\ntheorem Cat.circ.congr {C : Cat.{\u2113obj \u2113hom}}\n    {x y z : C^.obj}\n    : \u2200 {g\u2081 g\u2082 : C^.hom y z}\n        {f\u2081 f\u2082 : C^.hom x y}\n        (\u03c9g : g\u2081 = g\u2082)\n        (\u03c9f : f\u2081 = f\u2082)\n      , C^.circ g\u2081 f\u2081 = C^.circ g\u2082 f\u2082\n| g .(g) f .(f) (eq.refl .(g)) (eq.refl .(f)) := rfl\n\n-- An object in a category.\n-- \\[[ \\]]\nnotation `\u27e6` C `\u27e7` := Cat.obj C\n\n-- The identity hom at an object.\n-- \\langle\\langle \\rangle\\rangle\nnotation `\u27e8\u27e8` x `\u27e9\u27e9` := Cat.id _ x\n\n-- A hom in a category.\n-- \\[[ : \\to\\to \\]]\nnotation `\u27e6` C ` : ` x ` \u2192\u2192 ` y `\u27e7` := Cat.hom C x y\n\n-- Composition of hom's in a category.\n-- \\o\\o\ninfixl ` \u2218\u2218 ` : 100 := Cat.circ _\n\n/-! #brief A finite category.\n-/\nclass Cat.Finite (C : Cat.{\u2113obj \u2113hom})\n    : Type (max \u2113obj \u2113hom)\n:= (obj_fin : FinType C^.obj)\n   (hom_fin : \u2200 (x y : C^.obj), FinSort (C^.hom x y))\n\nattribute [instance] Cat.Finite.obj_fin\nattribute [instance] Cat.Finite.hom_fin\n\n\n\n/- -----------------------------------------------------------------------\nThe empty and star categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief The category with one object and one hom.\n-/\ndefinition UnitCat : Cat.{\u2113obj \u2113hom}\n:= { obj := punit\n   , hom := \u03bb u\u2081 u\u2082, punit\n   , id := \u03bb u, punit.star\n   , circ := \u03bb u\u2081 u\u2082 u\u2083 g f, punit.star\n   , circ_assoc := \u03bb u\u2081 u\u2082 u\u2083 u\u2084 h g f, rfl\n   , circ_id_left := \u03bb u\u2081 u\u2082 f, begin cases f, trivial end\n   , circ_id_right := \u03bb u\u2081 u\u2082 f, begin cases f, trivial end\n   }\n\n/-! #brief UnitCat is a finite category.\n-/\ninstance UnitCat.Finite\n    : Cat.Finite (UnitCat.{\u2113obj \u2113hom})\n:= { obj_fin := punit.FinSort\n   , hom_fin := \u03bb u\u2081 u\u2082, punit.FinSort\n   }\n\n/-! #brief The category with no objects.\n-/\ndefinition EmptyCat : Cat.{\u2113obj \u2113hom}\n:= { obj := pempty\n   , hom := \u03bb u\u2081 u\u2082, pempty\n   , id := \u03bb u, by cases u\n   , circ := \u03bb u\u2081 u\u2082 u\u2083 g f, by cases f\n   , circ_assoc := \u03bb u\u2081 u\u2082 u\u2083 u\u2084 h g f, by cases f\n   , circ_id_left := \u03bb u\u2081 u\u2082 f, by cases f\n   , circ_id_right := \u03bb u\u2081 u\u2082 f, by cases f\n   }\n\n/-! #brief EmptyCat is a finite category.\n-/\ninstance EmptyCat.Finite\n    : Cat.Finite (EmptyCat.{\u2113obj \u2113hom})\n:= { obj_fin := pempty.FinSort\n   , hom_fin := \u03bb u\u2081 u\u2082, pempty.FinSort\n   }\n\n\n\n/- -----------------------------------------------------------------------\nThe Lean categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief The category of Lean sorts at level \u2113.\n-/\ndefinition SortCat : Cat.{\u2113 \u2113}\n:= { obj := Sort.{\u2113}\n   , hom := \u03bb X Y, X \u2192 Y\n   , id := \u03bb X x, x\n   , circ := \u03bb X Y Z g f x, g (f x)\n   , circ_assoc := \u03bb X Y Z W h g f, rfl\n   , circ_id_left := \u03bb X Y f, rfl\n   , circ_id_right := \u03bb X Y f, rfl\n   }\n\n/-! #brief Composition in SortCat.\n-/\ntheorem SortCat.simp_circ\n    {X Y Z : SortCat.{\u2113}^.obj}\n    {g : SortCat^.hom Y Z} {f : SortCat^.hom X Y}\n    {x : X}\n    : SortCat^.circ g f x = g (f x)\n:= rfl\n\n/-! #brief The category of Lean propositions.\n-/\ndefinition PropCat : Cat.{0 0}\n:= SortCat.{0}\n\nexample : PropCat^.obj := true\n\n/-! #brief Composition in PropCat.\n-/\ntheorem PropCat.simp_circ\n    {X Y Z : PropCat^.obj}\n    {g : PropCat^.hom Y Z} {f : PropCat^.hom X Y}\n    {x : X}\n    : PropCat^.circ g f x = g (f x)\n:= rfl\n\n\n/-! #brief The category of Lean types at level \u2113.\n-/\ndefinition LeanCat : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= SortCat.{\u2113 + 1}\n\nexample : LeanCat.{0}^.obj := \u2115\nexample : LeanCat.{1}^.obj := \u2115 \u2192 LeanCat.{0}^.obj\nexample : LeanCat.{\u2113}^.obj := punit\nexample : LeanCat.{\u2113}^.obj := list punit\n\n/-! #brief Composition in LeanCat.\n-/\ntheorem LeanCat.simp_circ\n    {X Y Z : LeanCat.{\u2113}^.obj}\n    {g : LeanCat^.hom Y Z} {f : LeanCat^.hom X Y}\n    {x : X}\n    : LeanCat^.circ g f x = g (f x)\n:= rfl\n\n\n\n/- -----------------------------------------------------------------------\nCategories which box up certain theories.\n----------------------------------------------------------------------- -/\n\n/-! #brief The category of relations and monotone functions.\n-/\ndefinition CatOfRels : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= { obj := \u03a3 (A : Type \u2113), (A \u2192 A \u2192 Prop)\n   , hom := \u03bb A B, { f : A^.fst \u2192 B^.fst // monotone A^.snd B^.snd f }\n   , id := \u03bb A, { val := id, property := id.monotone A^.snd }\n   , circ := \u03bb A B C g f, { val := \u03bb a, g^.val (f^.val a)\n                          , property := begin\n                                          intros a\u2081 a\u2082 \u03c9,\n                                          apply g^.property,\n                                          apply f^.property,\n                                          exact \u03c9\n                                        end\n                          }\n   , circ_assoc := \u03bb A B C D h g f, subtype.eq rfl\n   , circ_id_left := \u03bb A B f, subtype.eq rfl\n   , circ_id_right := \u03bb A B f, subtype.eq rfl\n   }\n\n/-! #brief The category of preorders and monotone functions.\n-/\ndefinition CatOfPreorders : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= { obj := { A : \u03a3 (A : Type \u2113), (A \u2192 A \u2192 Prop) // reflexive A^.snd \u2227 transitive A^.snd }\n   , hom := \u03bb A B, { f : A^.val^.fst \u2192 B^.val^.fst // monotone A^.val^.snd B^.val^.snd f }\n   , id := \u03bb A, { val := id, property := id.monotone A^.val^.snd }\n   , circ := \u03bb A B C g f, { val := \u03bb a, g^.val (f^.val a)\n                          , property := begin\n                                          intros a\u2081 a\u2082 \u03c9,\n                                          apply g^.property,\n                                          apply f^.property,\n                                          exact \u03c9\n                                        end\n                          }\n   , circ_assoc := \u03bb A B C D h g f, subtype.eq rfl\n   , circ_id_left := \u03bb A B f, subtype.eq rfl\n   , circ_id_right := \u03bb A B f, subtype.eq rfl\n   }\n\n/-! #brief The category of semigroups.\n-/\ndefinition CatOfSemigroups : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= { obj := \u03a3 (A : Type \u2113), semigroup A\n   , hom := \u03bb A B, { f : A^.fst \u2192 B^.fst // @semigroup.hom _ A^.snd _ B^.snd f }\n   , id := \u03bb A, { val := id, property := @semigroup.hom_id _ A^.snd }\n   , circ := \u03bb A B C g f, { val := \u03bb a, g^.val (f^.val a)\n                          , property := @semigroup.hom_comp\n                                         _ A^.snd _ B^.snd _ C^.snd\n                                         _ g^.property _ f^.property\n                          }\n   , circ_assoc := \u03bb A B C D h g f, subtype.eq rfl\n   , circ_id_left := \u03bb A B f, subtype.eq rfl\n   , circ_id_right := \u03bb A B f, subtype.eq rfl\n   }\n\n/-! #brief The category of monoids.\n-/\ndefinition CatOfMonoids : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= { obj := \u03a3 (A : Type \u2113), monoid A\n   , hom := \u03bb A B, { f : A^.fst \u2192 B^.fst // @monoid.hom _ A^.snd _ B^.snd f }\n   , id := \u03bb A, { val := id, property := @monoid.hom_id _ A^.snd }\n   , circ := \u03bb A B C g f, { val := \u03bb a, g^.val (f^.val a)\n                          , property := @monoid.hom_comp\n                                         _ A^.snd _ B^.snd _ C^.snd\n                                         _ g^.property _ f^.property\n                          }\n   , circ_assoc := \u03bb A B C D h g f, subtype.eq rfl\n   , circ_id_left := \u03bb A B f, subtype.eq rfl\n   , circ_id_right := \u03bb A B f, subtype.eq rfl\n   }\n\n/-! #brief The category of groups.\n-/\ndefinition CatOfGroups : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= { obj := \u03a3 (A : Type \u2113), group A\n   , hom := \u03bb A B, { f : A^.fst \u2192 B^.fst // @group.hom _ A^.snd _ B^.snd f }\n   , id := \u03bb A, { val := id, property := @group.hom_id _ A^.snd }\n   , circ := \u03bb A B C g f, { val := \u03bb a, g^.val (f^.val a)\n                          , property := @group.hom_comp\n                                         _ A^.snd _ B^.snd _ C^.snd\n                                         _ g^.property _ f^.property\n                          }\n   , circ_assoc := \u03bb A B C D h g f, subtype.eq rfl\n   , circ_id_left := \u03bb A B f, subtype.eq rfl\n   , circ_id_right := \u03bb A B f, subtype.eq rfl\n   }\n\n/-! #brief The category of commutative rings.\n-/\ndefinition CatOfCommRings : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= { obj := \u03a3 (A : Type \u2113), comm_ring A\n   , hom := \u03bb A B, { f : A^.fst \u2192 B^.fst // @comm_ring.hom _ A^.snd _ B^.snd f }\n   , id := \u03bb A, { val := id, property := @comm_ring.hom_id _ A^.snd }\n   , circ := \u03bb A B C g f, { val := \u03bb a, g^.val (f^.val a)\n                          , property := @comm_ring.hom_comp\n                                         _ A^.snd _ B^.snd _ C^.snd\n                                         _ g^.property _ f^.property\n                          }\n   , circ_assoc := \u03bb A B C D h g f, subtype.eq rfl\n   , circ_id_left := \u03bb A B f, subtype.eq rfl\n   , circ_id_right := \u03bb A B f, subtype.eq rfl\n   }\n\n\n\n/- -----------------------------------------------------------------------\nCategories induced by monoids and groups.\n----------------------------------------------------------------------- -/\n\n/-! #brief A monoid category.\n-/\ndefinition MonoidCat (A : Type \u2113) [A_monoid : monoid A]\n    : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= { obj := punit\n   , hom := \u03bb u\u2081 u\u2082, A\n   , id := \u03bb u, 1\n   , circ := \u03bb u\u2081 u\u2082 u\u2083 g f, g * f\n   , circ_assoc := \u03bb u\u2081 u\u2082 u\u2083 u\u2084 h g f, eq.symm (mul_assoc h g f)\n   , circ_id_left := \u03bb u\u2081 u\u2082 f, one_mul f\n   , circ_id_right := \u03bb u\u2081 u\u2082 f, mul_one f\n   }\n\n/-! #brief A group category.\n-/\ndefinition GroupCat (A : Type \u2113) [A_group : group A]\n    : Cat.{(\u2113 + 1) (\u2113 + 1)}\n:= MonoidCat A\n\n\n\n/- -----------------------------------------------------------------------\nPreorder categories and categories of objects.\n----------------------------------------------------------------------- -/\n\n/-! #brief A preorder category.\n-/\ndefinition PreorderCat {A : Type \u2113}\n    (r : A \u2192 A \u2192 Prop)\n    (r_refl : reflexive r)\n    (r_trans : transitive r)\n    : Cat.{\u2113 0}\n:= { obj := A\n   , hom := r\n   , id := r_refl\n   , circ := \u03bb a\u2081 a\u2082 a\u2083 g f, r_trans f g\n   , circ_assoc := \u03bb a\u2081 a\u2082 a\u2083 a\u2084 h g f, proof_irrel _ _\n   , circ_id_left := \u03bb a\u2081 a\u2082 f, proof_irrel _ _\n   , circ_id_right := \u03bb a\u2081 a\u2082 f, proof_irrel _ _\n   }\n\n/-! #brief The category of natural numbers, ordered by nat.le\n-/\ndefinition NatCat : Cat.{0 0}\n:= PreorderCat nat.le @nat.le_refl @nat.le_trans\n\n/-! #brief Decidable preorders on finite types induce finite categories.\n-/\ninstance PreorderCat.Finite {A : Type \u2113}\n    (r : A \u2192 A \u2192 Prop)\n    (r_refl : reflexive r)\n    (r_trans : transitive r)\n    [A_FinType : FinType A]\n    [r_decidable : decidable_rel r]\n    : Cat.Finite (PreorderCat r r_refl r_trans)\n:= { obj_fin := A_FinType\n   , hom_fin := \u03bb a\u2081 a\u2082, @Prop.decidable_FinSort (r a\u2081 a\u2082) (r_decidable a\u2081 a\u2082)\n   }\n\n/-! #brief A category of objects.\n-/\ndefinition ObjCat (A : Type \u2113)\n    : Cat.{\u2113 0}\n:= PreorderCat (@eq A) (@eq.refl A) (@eq.trans A)\n\n/-! #brief Finite types yield finite object categories.\n-/\ninstance ObjCat.Finite (A : Type \u2113)\n    [A_FinType : FinType A]\n    : Cat.Finite (ObjCat A)\n:= PreorderCat.Finite (@eq A) (@eq.refl A) (@eq.trans A)\n\n/-! #brief The finite category with N objects.\n-/\ndefinition FinCat (N : \u2115) : Cat.{0 0}\n:= ObjCat (fin N)\n\n/-! #brief The finite category is finite.\n-/\ninstance FinCat.Finite (N : \u2115)\n    : Cat.Finite (FinCat N)\n:= ObjCat.Finite (fin N)\n\n\n\n/- -----------------------------------------------------------------------\nArrow categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief An object in an arrow category.\n-/\nstructure Arr (C : Cat.{\u2113obj \u2113hom})\n    : Type (max \u2113obj \u2113hom)\n:= (dom : C^.obj)\n   (codom : C^.obj)\n   (hom : C^.hom dom codom)\n\n/-! #brief A hom in an arrow category.\n-/\nstructure ArrHom (C : Cat.{\u2113obj \u2113hom})\n    (X Y : Arr C)\n    : Sort (max 1 \u2113hom)\n:= (hom_dom : C^.hom X^.dom Y^.dom)\n   (hom_codom : C^.hom X^.codom Y^.codom)\n   (comm : hom_codom \u2218\u2218 X^.hom = Y^.hom \u2218\u2218 hom_dom)\n\n/-! #brief Equality helper for ArrHom.\n-/\ntheorem ArrHom.eq {C : Cat.{\u2113obj \u2113hom}}\n    {X Y : Arr C}\n    : \u2200 {f\u2081 f\u2082 : ArrHom C X Y}\n        (\u03c9dom : f\u2081^.hom_dom = f\u2082^.hom_dom)\n        (\u03c9codom : f\u2081^.hom_codom = f\u2082^.hom_codom)\n      , f\u2081 = f\u2082\n| (ArrHom.mk dom codom \u03c9\u2081) (ArrHom.mk .(dom) .(codom) \u03c9\u2082)\n  (eq.refl .(dom)) (eq.refl .(codom))\n  := rfl\n\n/-! #brief The identity hom in an arrow category.\n-/\ndefinition ArrHom.id {C : Cat.{\u2113obj \u2113hom}}\n    (X : Arr C)\n    : ArrHom C X X\n:= { hom_dom := C^.id X^.dom\n   , hom_codom := C^.id X^.codom\n   , comm := by rw [C^.circ_id_left, C^.circ_id_right]\n   }\n\n/-! #brief Composition of homs in an arrow category.\n-/\ndefinition ArrHom.comp {C : Cat.{\u2113obj \u2113hom}}\n    {X Y Z : Arr C}\n    (g : ArrHom C Y Z) (f : ArrHom C X Y)\n    : ArrHom C X Z\n:= { hom_dom := g^.hom_dom \u2218\u2218 f^.hom_dom\n   , hom_codom := g^.hom_codom \u2218\u2218 f^.hom_codom\n   , comm := begin\n               repeat { rw -C^.circ_assoc }, rw f^.comm,\n               repeat { rw C^.circ_assoc }, rw g^.comm\n             end\n   }\n\n/-! #brief ArrHom.id is a left-identity for ArrHom.comp.\n-/\ntheorem ArrHom.comp_id_left {C : Cat.{\u2113obj \u2113hom}}\n    {X Y : Arr C} {f : ArrHom C X Y}\n    : ArrHom.comp (ArrHom.id Y) f = f\n:= ArrHom.eq C^.circ_id_left C^.circ_id_left\n\n/-! #brief ArrHom.id is a right-identity for ArrHom.comp.\n-/\ntheorem ArrHom.comp_id_right {C : Cat.{\u2113obj \u2113hom}}\n    {X Y : Arr C} {f : ArrHom C X Y}\n    : ArrHom.comp f (ArrHom.id X) = f\n:= ArrHom.eq C^.circ_id_right C^.circ_id_right\n\n/-! #brief ArrHom.comp is associative.\n-/\ntheorem ArrHom.comp_assoc {C : Cat.{\u2113obj \u2113hom}}\n    {X Y Z W : Arr C}\n    {h : ArrHom C Z W} {g : ArrHom C Y Z} {f : ArrHom C X Y}\n    : ArrHom.comp h (ArrHom.comp g f) = ArrHom.comp (ArrHom.comp h g) f\n:= ArrHom.eq C^.circ_assoc C^.circ_assoc\n\n\n/-! #brief An arrow category.\n-/\ndefinition ArrCat (C : Cat.{\u2113obj \u2113hom})\n    : Cat.{(max \u2113obj \u2113hom) (max 1 \u2113hom)}\n:= { obj := Arr C\n   , hom := ArrHom C\n   , id := ArrHom.id\n   , circ := @ArrHom.comp C\n   , circ_id_left := \u03bb x y f, ArrHom.comp_id_left\n   , circ_id_right := \u03bb x y f, ArrHom.comp_id_right\n   , circ_assoc := \u03bb x y z w h g f, ArrHom.comp_assoc\n   }\n\n\n\n/- -----------------------------------------------------------------------\nProduct categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief The product category.\n-/\ndefinition ProdCat (C : Cat.{\u2113obj\u2081 \u2113hom\u2081}) (D : Cat.{\u2113obj\u2082 \u2113hom\u2082})\n    : Cat.{(max \u2113obj\u2081 \u2113obj\u2082) (max 1 \u2113hom\u2081 \u2113hom\u2082)}\n:= { obj := prod C^.obj D^.obj\n   , hom := \u03bb cd\u2081 cd\u2082, pprod (C^.hom cd\u2081^.fst cd\u2082^.fst)\n                            (D^.hom cd\u2081^.snd cd\u2082^.snd)\n   , id := \u03bb cd, { fst := C^.id cd^.fst\n                 , snd := D^.id cd^.snd\n                 }\n   , circ := \u03bb x y z g f, { fst := C^.circ g^.fst f^.fst\n                          , snd := D^.circ g^.snd f^.snd\n                          }\n   , circ_assoc := \u03bb x y z w h g f, by rw [C^.circ_assoc, D^.circ_assoc]\n   , circ_id_left := \u03bb x y f, begin cases f, simp end\n   , circ_id_right := \u03bb x y f, begin cases f, simp end\n   }\n\n-- A product category.\n-- \\times\\times\ninfixr `\u00d7\u00d7` : 200 := ProdCat\n\n\n\n/- -----------------------------------------------------------------------\nOpposite categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief The opposite category.\n-/\n@[reducible] definition OpCat (C : Cat.{\u2113obj \u2113hom})\n    : Cat.{\u2113obj \u2113hom}\n:= { obj := C^.obj\n   , hom := \u03bb x y, C^.hom y x\n   , id := \u03bb x, C^.id x\n   , circ := \u03bb x y z g f, C^.circ f g\n   , circ_assoc := \u03bb x y z w h g f, eq.symm C^.circ_assoc\n   , circ_id_left := \u03bb x y f, C^.circ_id_right\n   , circ_id_right := \u03bb x y f, C^.circ_id_left\n   }\n\n-- An opposite category.\n-- \\inv\nnotation C `\u207b\u00b9` := OpCat C\n\n/-! #brief OpCat is an involution.\n-/\ntheorem OpCat_OpCat (C : Cat.{\u2113obj \u2113hom})\n    : OpCat (OpCat C) = C\n:= begin\n     apply Cat.eq,\n     { trivial },\n     { trivial },\n     { trivial },\n     { trivial }\n   end\n\n/-! #brief OpCat distributes over ProdCat.\n-/\ntheorem OpCat_ProdCat (C : Cat.{\u2113obj\u2081 \u2113hom\u2081}) (D : Cat.{\u2113obj\u2082 \u2113hom\u2082})\n    : OpCat (ProdCat C D) = ProdCat (OpCat C) (OpCat D)\n:= begin\n     apply Cat.eq,\n     { trivial },\n     { trivial },\n     { trivial },\n     { trivial }\n   end\n\n\n\n/- -----------------------------------------------------------------------\nOver and under categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief An object in an over category.\n-/\nstructure OverObj (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    : Type (max \u2113obj \u2113hom)\n:= (obj : C^.obj)\n   (hom : C^.hom obj X)\n\n/-! #brief The object contained within an over object.\n-/\n@[reducible] definition OverObj.dom {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    (A : OverObj C X)\n    : C^.obj\n:= A^.obj\n\n/-! #brief The hom contained within an over object.\n-/\n@[reducible] definition OverObj.down {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    (A : OverObj C X)\n    : C^.hom (OverObj.dom A) X\n:= A^.hom\n\n/-! #brief Eqaulity of objects in an over category.\n-/\ntheorem OverObj.eq {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    : \u2200 {A B : OverObj C X}\n         (\u03c9obj : A^.dom = B^.dom)\n         (\u03c9hom : A^.down == B^.down)\n      , A = B\n| (OverObj.mk obj hom) (OverObj.mk .(obj) .(hom))\n  (eq.refl .(obj)) (heq.refl .(hom))\n:= rfl\n\n/-! #brief A hom in an over category.\n-/\nstructure OverHom (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    (A B : OverObj C X)\n    : Sort (max 1 \u2113hom)\n:= (hom : C^.hom A^.dom B^.dom)\n   (triangle : A^.down = C^.circ B^.down hom)\n\n/-! #brief Equality of homs in an over category.\n-/\ntheorem OverHom.eq {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    {A B : OverObj C X}\n    : \u2200 {f\u2081 f\u2082 : OverHom C X A B}\n      , f\u2081^.hom = f\u2082^.hom\n      \u2192 f\u2081 = f\u2082\n| (OverHom.mk hom \u03c9\u2081) (OverHom.mk .(hom) \u03c9\u2082) (eq.refl .(hom))\n:= rfl\n\n/-! #brief Heterogeneous equality of homs in an over category.\n-/\ntheorem OverHom.heq {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    : \u2200 {A\u2081 B\u2081 A\u2082 B\u2082 : OverObj C X}\n         {f\u2081 : OverHom C X A\u2081 B\u2081}\n         {f\u2082 : OverHom C X A\u2082 B\u2082}\n      , A\u2081 = A\u2082 \u2192 B\u2081 = B\u2082 \u2192 f\u2081^.hom == f\u2082^.hom\n      \u2192 f\u2081 == f\u2082\n| (OverObj.mk a fa) (OverObj.mk b fb) (OverObj.mk .(a) .(fa)) (OverObj.mk .(b) .(fb))\n  (OverHom.mk f \u03c9f\u2081) (OverHom.mk .(f) \u03c9f\u2082) (eq.refl ._) (eq.refl ._) (heq.refl ._)\n:= heq.refl _\n\n/-! #brief The identity hom in an over category.\n-/\ndefinition OverHom.id (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    (A : OverObj C X)\n    : OverHom C X A A\n:= { hom := C^.id A^.dom\n   , triangle := eq.symm C^.circ_id_right\n   }\n\n/-! #brief Composition of homs in an over category.\n-/\ndefinition OverHom.comp (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    (P Q R : OverObj C X)\n    (g : OverHom C X Q R)\n    (f : OverHom C X P Q)\n    : OverHom C X P R\n:= { hom := C^.circ g^.hom f^.hom\n   , triangle := by rw [f^.triangle, g^.triangle, C^.circ_assoc]\n   }\n\n/-! #brief Associativity of hom composition in an over category.\n-/\ntheorem OverHom.comp_assoc (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    (P Q R S : OverObj C X)\n    (h : OverHom C X R S)\n    (g : OverHom C X Q R)\n    (f : OverHom C X P Q)\n    : OverHom.comp C X _ _ _ h (OverHom.comp C X _ _ _ g f)\n       = OverHom.comp C X _ _ _ (OverHom.comp C X _ _ _ h g) f\n:= begin\n     apply OverHom.eq,\n     exact C^.circ_assoc\n   end\n\n/-! #brief Left-identity of hom composition in an over category.\n-/\ntheorem OverHom.comp_id_left (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    (P Q : OverObj C X)\n    (f : OverHom C X P Q)\n    : OverHom.comp C X _ _ _ (OverHom.id C X _) f = f\n:= begin\n     apply OverHom.eq,\n     exact C^.circ_id_left\n   end\n\n/-! #brief Right-identity of hom composition in an over category.\n-/\ntheorem OverHom.comp_id_right (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    (P Q : OverObj C X)\n    (f : OverHom C X P Q)\n    : OverHom.comp C X _ _ _ f (OverHom.id C X _) = f\n:= begin\n     apply OverHom.eq,\n     exact C^.circ_id_right\n   end\n\n/-! #brief An over category.\n-/\ndefinition OverCat (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    : Cat.{(max \u2113obj \u2113hom) (max 1 \u2113hom)}\n:= { obj := OverObj C X\n   , hom := OverHom C X\n   , id := OverHom.id C X\n   , circ := OverHom.comp C X\n   , circ_assoc := OverHom.comp_assoc C X\n   , circ_id_left := OverHom.comp_id_left C X\n   , circ_id_right := OverHom.comp_id_right C X\n   }\n\n-- An over category.\n-- //\nnotation C `//` X := OverCat C X\n\n/-! #brief An under category.\n-/\ndefinition UnderCat (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    : Cat.{(max \u2113obj \u2113hom) (max 1 \u2113hom)}\n--:= OpCat (OverCat (OpCat C) X)\n:= OpCat (OverCat (OpCat C) X)\n\n-- An under category.\n-- \\\\\nnotation C `\\\\` X := UnderCat C X\n\n/-! #brief An object in an under category.\n-/\ndefinition UnderObj (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    : Type (max \u2113obj \u2113hom)\n:= (UnderCat C X)^.obj\n\n/-! #brief A hom in an under category.\n-/\ndefinition UnderHom (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    (A B : UnderObj C X)\n    : Sort (max 1 \u2113hom)\n:= (UnderCat C X)^.hom A B\n\n/-! #brief Constructor for an object in an under category.\n-/\ndefinition UnderObj.mk {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    {A : C^.obj} (f : C^.hom X A)\n    : UnderObj C X\n:= { obj := A, hom := f }\n\n/-! #brief The object contained within an under object.\n-/\n@[reducible] definition UnderObj.codom {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    (A : UnderObj C X)\n    : C^.obj\n:= A^.obj\n\n/-! #brief The hom contained within an under object.\n-/\n@[reducible] definition UnderObj.up {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    (A : UnderObj C X)\n    : C^.hom X (UnderObj.codom A)\n:= A^.hom\n\n/-! #brief Constructor for a hom in an under category.\n-/\ndefinition UnderHom.mk {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    {A B : UnderObj C X}\n    (f : C^.hom (UnderObj.codom A) (UnderObj.codom B))\n    (\u03c9 : B^.up = C^.circ f A^.up)\n    : UnderHom C X A B\n:= { hom := f, triangle := \u03c9 }\n\n/-! #brief The hom contained within an under hom.\n-/\n@[reducible] definition UnderHom.hom {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    {A B : UnderObj C X}\n    (f : UnderHom C X A B)\n    : C^.hom (UnderObj.codom A) (UnderObj.codom B)\n:= f^.hom\n\n/-! #brief The hom contained within an under hom.\n-/\n@[reducible] theorem UnderHom.triangle {C : Cat.{\u2113obj \u2113hom}} {X : C^.obj}\n    (A B : UnderObj C X)\n    (f : UnderHom C X A B)\n    : B^.up = UnderHom.hom f \u2218\u2218 A^.up\n:= f^.triangle\n\n\n\n/- -----------------------------------------------------------------------\nIsomorphisms in categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief An isomorphism in a category.\n-/\nstructure Iso {C : Cat.{\u2113obj \u2113hom}}\n    {c\u2081 c\u2082 : C^.obj}\n    (f : C^.hom c\u2081 c\u2082) (g : C^.hom c\u2082 c\u2081)\n    : Prop\n:= (id\u2081 : C^.circ g f = C^.id c\u2081)\n   (id\u2082 : C^.circ f g = C^.id c\u2082)\n\n/-! #brief Iso's can be 'flipped' to run in the other direction.\n-/\ndefinition Iso.flip {C : Cat.{\u2113obj \u2113hom}}\n    {c\u2081 c\u2082 : C^.obj}\n    {f : C^.hom c\u2081 c\u2082} {g : C^.hom c\u2082 c\u2081}\n    (iso : Iso f g)\n    : Iso g f\n:= { id\u2081 := iso^.id\u2082\n   , id\u2082 := iso^.id\u2081\n   }\n\n/-! #brief Iso's have unique inverses.\n-/\ndefinition Iso.inv_uniq\u2082 {C : Cat.{\u2113obj \u2113hom}}\n    {c\u2081 c\u2082 : C^.obj}\n    {f : C^.hom c\u2081 c\u2082} {g\u2081 g\u2082 : C^.hom c\u2082 c\u2081}\n    (iso\u2081 : Iso f g\u2081)\n    (iso\u2082 : Iso f g\u2082)\n    : g\u2081 = g\u2082\n:= by calc g\u2081  = g\u2081 \u2218\u2218 \u27e8\u27e8c\u2082\u27e9\u27e9    : by rw C^.circ_id_right\n           ... = g\u2081 \u2218\u2218 (f \u2218\u2218 g\u2082) : by rw iso\u2082^.id\u2082\n           ... = (g\u2081 \u2218\u2218 f) \u2218\u2218 g\u2082 : by rw C^.circ_assoc\n           ... = \u27e8\u27e8c\u2081\u27e9\u27e9 \u2218\u2218 g\u2082    : by rw iso\u2081^.id\u2081\n           ... = g\u2082              : by rw C^.circ_id_left\n\n/-! #brief Iso's have unique inverses.\n-/\ndefinition Iso.inv_uniq\u2081 {C : Cat.{\u2113obj \u2113hom}}\n    {c\u2081 c\u2082 : C^.obj}\n    {f\u2081 f\u2082 : C^.hom c\u2081 c\u2082} {g : C^.hom c\u2082 c\u2081}\n    (iso\u2081 : Iso f\u2081 g)\n    (iso\u2082 : Iso f\u2082 g)\n    : f\u2081 = f\u2082\n:= Iso.inv_uniq\u2082 (Iso.flip iso\u2081) (Iso.flip iso\u2082)\n\n/-! #brief Identity homs are isomorphisms.\n-/\ntheorem Cat.id.Iso {C : Cat.{\u2113obj \u2113hom}}\n    (c : C^.obj)\n    : Iso (C^.id c) (C^.id c)\n:= { id\u2081 := C^.circ_id_left\n   , id\u2082 := C^.circ_id_left\n   }\n\n/-! #brief Isomorphisms are closed under composition.\n-/\ntheorem Cat.circ.Iso {C : Cat.{\u2113obj \u2113hom}}\n    {c\u2081 c\u2082 c\u2083 : C^.obj}\n    {f\u2082\u2083 : C^.hom c\u2082 c\u2083} {g\u2082\u2083 : C^.hom c\u2083 c\u2082} (iso\u2082\u2083 : Iso f\u2082\u2083 g\u2082\u2083)\n    {f\u2081\u2082 : C^.hom c\u2081 c\u2082} {g\u2081\u2082 : C^.hom c\u2082 c\u2081} (iso\u2081\u2082 : Iso f\u2081\u2082 g\u2081\u2082)\n    : Iso (C^.circ f\u2082\u2083 f\u2081\u2082) (C^.circ g\u2081\u2082 g\u2082\u2083)\n:= { id\u2081 := by calc g\u2081\u2082 \u2218\u2218 g\u2082\u2083 \u2218\u2218 (f\u2082\u2083 \u2218\u2218 f\u2081\u2082)\n                        = g\u2081\u2082 \u2218\u2218 (g\u2082\u2083 \u2218\u2218 f\u2082\u2083) \u2218\u2218 f\u2081\u2082 : by repeat {rw C^.circ_assoc}\n                    ... = g\u2081\u2082 \u2218\u2218 \u27e8\u27e8c\u2082\u27e9\u27e9 \u2218\u2218 f\u2081\u2082       : by rw iso\u2082\u2083^.id\u2081\n                    ... = g\u2081\u2082 \u2218\u2218 f\u2081\u2082                 : by rw C^.circ_id_right\n                    ... = \u27e8\u27e8c\u2081\u27e9\u27e9                     : by rw iso\u2081\u2082^.id\u2081\n   , id\u2082 := by calc f\u2082\u2083 \u2218\u2218 f\u2081\u2082 \u2218\u2218 (g\u2081\u2082 \u2218\u2218 g\u2082\u2083)\n                        = f\u2082\u2083 \u2218\u2218 (f\u2081\u2082 \u2218\u2218 g\u2081\u2082) \u2218\u2218 g\u2082\u2083 : by repeat {rw C^.circ_assoc}\n                    ... = f\u2082\u2083 \u2218\u2218 \u27e8\u27e8c\u2082\u27e9\u27e9 \u2218\u2218 g\u2082\u2083       : by rw iso\u2081\u2082^.id\u2082\n                    ... = f\u2082\u2083 \u2218\u2218 g\u2082\u2083                 : by rw C^.circ_id_right\n                    ... = \u27e8\u27e8c\u2083\u27e9\u27e9                     : by rw iso\u2082\u2083^.id\u2082\n   }\n\n\n\n/- -----------------------------------------------------------------------\nMonomorphism and epimorphisms.\n----------------------------------------------------------------------- -/\n\n/-! #brief A monomorphism.\n-/\nclass Monic {C : Cat.{\u2113obj \u2113hom}} {x y : C^.obj}\n    (g : C^.hom x y)\n    : Prop\n:= (inj : \u2200 {a : C^.obj} {f\u2081 f\u2082 : C^.hom a x}\n             (\u03c9 : C^.circ g f\u2081 = C^.circ g f\u2082)\n           , f\u2081 = f\u2082)\n\n/-! #brief Helper for showing a hom is monic.\n-/\ndefinition Monic.show {C : Cat.{\u2113obj \u2113hom}} {x y : C^.obj}\n    {g : C^.hom x y}\n    (\u03c9 : \u2200 {a : C^.obj} {f\u2081 f\u2082 : C^.hom a x} (\u03c9f : C^.circ g f\u2081 = C^.circ g f\u2082), f\u2081 = f\u2082)\n    : Monic g\n:= { inj := @\u03c9 }\n\n/-! #brief Using a monic.\n-/\ndefinition monic_cancel {C : Cat.{\u2113obj \u2113hom}} {x y : C^.obj}\n    (g : C^.hom x y)\n    [g_Monic : Monic g]\n    {a : C^.obj} {f\u2081 f\u2082 : C^.hom a x}\n    (\u03c9 : C^.circ g f\u2081 = C^.circ g f\u2082)\n    : f\u2081 = f\u2082\n:= Monic.inj \u03c9\n\n/-! #brief Identity homs are monic.\n-/\ninstance Cat.id.Monic {C : Cat.{\u2113obj \u2113hom}}\n    (c : C^.obj)\n    : Monic (C^.id c)\n:= Monic.show\n    (\u03bb a f\u2081 f\u2082 \u03c9, by calc f\u2081 = \u27e8\u27e8c\u27e9\u27e9 \u2218\u2218 f\u2081 : eq.symm C^.circ_id_left\n                         ... = \u27e8\u27e8c\u27e9\u27e9 \u2218\u2218 f\u2082 : \u03c9\n                         ... = f\u2082 : C^.circ_id_left)\n\n/-! #brief Monics are closed under composition.\n-/\ninstance Monic.circ {C : Cat.{\u2113obj \u2113hom}}\n    {x y z : C^.obj}\n    {g : C^.hom y z} [g_Monic : Monic g]\n    {f : C^.hom x y} [f_Monic : Monic f]\n    : Monic (C^.circ g f)\n:= Monic.show\n    (\u03bb c f\u2081 f\u2082 \u03c9\n     , begin\n         apply monic_cancel f,\n         apply monic_cancel g,\n         repeat { rw C^.circ_assoc },\n         exact \u03c9\n       end)\n\n/-! #brief In LeanCat, monics are injective.\n-/\ntheorem LeanCat.Monic.inj {X Y : LeanCat.{\u2113}^.obj}\n    {f : LeanCat.{\u2113}^.hom X Y}\n    (f_Monic : @Monic LeanCat.{\u2113} X Y f)\n    : function.injective f\n:= \u03bb x\u2081 x\u2082 \u03c9x\n   , let f\u2081 : X \u2192 X := \u03bb x, x\u2081 in\n     let f\u2082 : X \u2192 X := \u03bb x, x\u2082 in\n     let \u03c9f : f\u2081 = f\u2082\n           := begin\n                apply @Monic.inj LeanCat.{\u2113} X Y f,\n                apply funext, intro x, exact \u03c9x\n              end\n     in calc x\u2081 = f\u2081 x\u2081  : rfl\n             ... = f\u2082 x\u2081 : by rw \u03c9f\n             ... = x\u2082    : rfl\n\n/-! #brief In LeanCat, left-inverses witness monics.\n-/\ndefinition LeanCat.Monic.by_witness {X Y : Type \u2113}\n    {f : X \u2192 Y}\n    {g : Y \u2192 X}\n    (\u03c9fg : \u2200 {x : X}, g (f x) = x)\n    : @Monic LeanCat.{\u2113} X Y f\n:= Monic.show\n    (\u03bb T f\u2081 f\u2082 \u03c9\n     , sorry)\n\n/-! #brief An epimorphism.\n-/\n@[class] definition Epic {C : Cat.{\u2113obj \u2113hom}} {x y : C^.obj}\n    (f : C^.hom x y)\n    : Prop\n:= @Monic (OpCat C) y x f\n\n/-! #brief Helper for showing a hom is epic.\n-/\ndefinition Epic.show {C : Cat.{\u2113obj \u2113hom}} {x y : C^.obj}\n    {f : C^.hom x y}\n    (\u03c9 : \u2200 {z : C^.obj} (g\u2081 g\u2082 : C^.hom y z) (\u03c9g : C^.circ g\u2081 f = C^.circ g\u2082 f), g\u2081 = g\u2082)\n    : Epic f\n:= Monic.show @\u03c9\n\n/-! #brief Using an epic.\n-/\ndefinition epic_cancel {C : Cat.{\u2113obj \u2113hom}} {x y : C^.obj}\n    (f : C^.hom x y)\n    [f_Epic : Epic f]\n    {z : C^.obj} {g\u2081 g\u2082 : C^.hom y z}\n    (\u03c9 : C^.circ g\u2081 f = C^.circ g\u2082 f)\n    : g\u2081 = g\u2082\n:= @Monic.inj (OpCat C) _ _ f f_Epic z g\u2081 g\u2082 \u03c9\n\n/-! #brief Identity homs are epic.\n-/\ninstance Cat.id.Epic {C : Cat.{\u2113obj \u2113hom}}\n    (c : C^.obj)\n    : Epic (C^.id c)\n:= Epic.show\n    (\u03bb z g\u2081 g\u2082 \u03c9, by calc g\u2081 = g\u2081 \u2218\u2218 \u27e8\u27e8c\u27e9\u27e9 : eq.symm C^.circ_id_right\n                         ... = g\u2082 \u2218\u2218 \u27e8\u27e8c\u27e9\u27e9 : \u03c9\n                         ... = g\u2082 : C^.circ_id_right)\n\n/-! #brief Epics are closed under composition.\n-/\ninstance Epic.circ {C : Cat.{\u2113obj \u2113hom}}\n    {x y z : C^.obj}\n    {g : C^.hom y z} [g_Epic : Epic g]\n    {f : C^.hom x y} [f_Epic : Epic f]\n    : Epic (C^.circ g f)\n:= Epic.show\n    (\u03bb c f\u2081 f\u2082 \u03c9\n     , begin\n         apply epic_cancel g,\n         apply epic_cancel f,\n         repeat { rw -C^.circ_assoc },\n         exact \u03c9\n       end)\n\n\n\n/- -----------------------------------------------------------------------\nCasting homs.\n----------------------------------------------------------------------- -/\n\n/-! #brief A casting hom.\n-/\ndefinition cast_hom {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {c\u2081 c\u2082 : C^.obj}\n        (\u03c9 : c\u2081 = c\u2082)\n      , C^.hom c\u2081 c\u2082\n| c .(c) (eq.refl .(c)) := C^.id c\n\n/-! #brief Casting homs are just identities.\n-/\ntheorem cast_hom.simp {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {c : C^.obj}\n        (\u03c9 : c = c)\n      , cast_hom \u03c9 = C^.id c\n| c (eq.refl .(c)) := rfl\n\n/-! #brief composition of casting homs.\n-/\ntheorem cast_hom.circ {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {c\u2081 c\u2082 c\u2083 : C^.obj}\n        {\u03c9\u2081\u2082 : c\u2081 = c\u2082}\n        {\u03c9\u2082\u2083 : c\u2082 = c\u2083}\n      , C^.circ (cast_hom \u03c9\u2082\u2083) (cast_hom \u03c9\u2081\u2082)\n         = cast_hom (eq.trans \u03c9\u2081\u2082 \u03c9\u2082\u2083)\n| c .(c) .(c) (eq.refl .(c)) (eq.refl .(c)) := C^.circ_id_left\n\n/-! #brief Left congruence of composition with casting homs.\n-/\ntheorem cast_hom.circ.congr_left {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {b c\u2081 c\u2082 d : C^.obj}\n        {\u03c9\u2081 : b = c\u2081}\n        {\u03c9\u2082 : b = c\u2082}\n        {g\u2081 : C^.hom c\u2081 d}\n        {g\u2082 : C^.hom c\u2082 d}\n        (\u03c9g : g\u2081 == g\u2082)\n      , C^.circ g\u2081 (cast_hom \u03c9\u2081) = C^.circ g\u2082 (cast_hom \u03c9\u2082)\n| b .(b) .(b) d (eq.refl .(b)) (eq.refl .(b)) g .(g) (heq.refl .(g)) := rfl\n\n/-! #brief Right congruence of composition with casting homs.\n-/\ntheorem cast_hom.circ.congr_right {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {b c\u2081 c\u2082 d : C^.obj}\n        {\u03c9\u2081 : c\u2081 = d}\n        {\u03c9\u2082 : c\u2082 = d}\n        {f\u2081 : C^.hom b c\u2081}\n        {f\u2082 : C^.hom b c\u2082}\n        (\u03c9f : f\u2081 == f\u2082)\n      , C^.circ (cast_hom \u03c9\u2081) f\u2081 = C^.circ (cast_hom \u03c9\u2082) f\u2082\n| b c .(c) .(c) (eq.refl .(c)) (eq.refl .(c)) f .(f) (heq.refl .(f)) := rfl\n\n/-! #brief Casting homs and heq.\n-/\ntheorem cast_hom.circ_left_heq {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {b c\u2081 c\u2082 : C^.obj}\n        (\u03c9 : c\u2081 = c\u2082)\n        (f : C^.hom b c\u2081)\n      , C^.circ (cast_hom \u03c9) f == f\n| b c .(c) (eq.refl .(c)) f := heq_of_eq C^.circ_id_left\n\n/-! #brief Casting homs and heq.\n-/\ntheorem cast_hom.circ_right_heq {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {c\u2081 c\u2082 d : C^.obj}\n        (\u03c9 : c\u2081 = c\u2082)\n        (g : C^.hom c\u2082 d)\n      , C^.circ g (cast_hom \u03c9) == g\n| c .(c) d (eq.refl .(c)) g := heq_of_eq C^.circ_id_right\n\n\n/-! #brief Casting homs are isos.\n-/\ntheorem cast_hom.Iso {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {c\u2081 c\u2082 : C^.obj}\n        (\u03c9\u2081\u2082 : c\u2081 = c\u2082)\n        (\u03c9\u2082\u2081 : c\u2082 = c\u2081)\n      , Iso (cast_hom \u03c9\u2081\u2082) (cast_hom \u03c9\u2082\u2081)\n| c .(c) (eq.refl .(c)) (eq.refl .(c)) := Cat.id.Iso c\n\n/-! #brief Casting homs are monic.\n-/\ninstance cast_hom.Monic {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {c\u2081 c\u2082 : C^.obj}\n        (\u03c9 : c\u2081 = c\u2082)\n      , Monic (cast_hom \u03c9)\n| c .(c) (eq.refl .(c)) := Cat.id.Monic c\n\n/-! #brief Casting homs are epic.\n-/\ninstance cast_hom.Epic {C : Cat.{\u2113obj \u2113hom}}\n    : \u2200 {c\u2081 c\u2082 : C^.obj}\n        (\u03c9 : c\u2081 = c\u2082)\n      , Epic (cast_hom \u03c9)\n| c .(c) (eq.refl .(c)) := Cat.id.Epic c\n\n\n\n/- -----------------------------------------------------------------------\nInitial and final objects in categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief A final object in a category.\n-/\nstructure IsFinal (C : Cat.{\u2113obj \u2113hom})\n    (obj : C^.obj)\n    (hom : \u2200 (c : C^.obj), C^.hom c obj)\n    : Type (max \u2113obj \u2113hom)\n:= (hom_uniq : \u2200 {c : C^.obj} {h : C^.hom c obj}, h = hom c)\n\n/-! #brief A category with a final object.\n-/\nclass HasFinal (C : Cat.{\u2113obj \u2113hom})\n    : Type (max \u2113obj \u2113hom)\n:= (obj : C^.obj)\n   (hom : \u2200 (c : C^.obj), C^.hom c obj)\n   (final : IsFinal C obj hom)\n\n/-! #brief Helper for showing a category has a final object.\n-/\ndefinition HasFinal.show {C : Cat.{\u2113obj \u2113hom}}\n    (x : C^.obj)\n    (hom : \u2200 (c : C^.obj), C^.hom c x)\n    (hom_uniq : \u2200 {c : C^.obj} {h : C^.hom c x}, h = hom c)\n    : HasFinal C\n:= { obj := x\n   , hom := hom\n   , final := { hom_uniq := @hom_uniq\n              }\n   }\n\n/-! #brief The final object in a category with a final object.\n-/\ndefinition final (C : Cat.{\u2113obj \u2113hom})\n    [C_HasFinal : HasFinal C]\n    : C^.obj\n:= HasFinal.obj C\n\n/-! #brief The final hom in a category with a final object.\n-/\ndefinition final_hom {C : Cat.{\u2113obj \u2113hom}}\n    [C_HasFinal : HasFinal C]\n    (c : C^.obj)\n    : C^.hom c (final C)\n:= HasFinal.hom c\n\n/-! #brief The final hom is unique.\n-/\ntheorem final_hom.uniq (C : Cat.{\u2113obj \u2113hom})\n    {C_HasFinal : HasFinal C}\n    {c : C^.obj} {f : C^.hom c (final C)}\n    : f = final_hom c\n:= (HasFinal.final C)^.hom_uniq\n\n/-! #brief The initial hom is unique.\n-/\ndefinition final_hom.uniq' (C : Cat.{\u2113obj \u2113hom})\n    {C_HasFinal : HasFinal C}\n    {c : C^.obj} {f g : C^.hom c (final C)}\n    : f = g\n:= eq.trans (final_hom.uniq C) (eq.symm (final_hom.uniq C))\n\n/-! #brief The final hom to the final object is the identity.\n-/\ntheorem final_hom.id (C : Cat.{\u2113obj \u2113hom})\n    {C_HasFinal : HasFinal C}\n    : final_hom (final C) = C^.id (final C)\n:= eq.symm (final_hom.uniq C)\n\n/-! #brief The unique iso between two final objects.\n-/\ndefinition final.iso {C : Cat.{\u2113obj \u2113hom}}\n    (C_HasFinal\u2081 C_HasFinal\u2082 : HasFinal C)\n    : C^.hom (@final C C_HasFinal\u2081) (@final C C_HasFinal\u2082)\n:= @final_hom C C_HasFinal\u2082 (@final C C_HasFinal\u2081)\n\n/-! #brief Final objects are unique up-to unique isomorphism.\n-/\ntheorem HasFinal_uniq {C : Cat.{\u2113obj \u2113hom}}\n    (C_HasFinal\u2081 C_HasFinal\u2082 : HasFinal C)\n    : Iso (final.iso C_HasFinal\u2081 C_HasFinal\u2082)\n          (final.iso C_HasFinal\u2082 C_HasFinal\u2081)\n:= { id\u2081 := eq.trans (@final_hom.uniq _ C_HasFinal\u2081 _ _)\n                     (eq.symm (@final_hom.uniq _ C_HasFinal\u2081 _ _))\n   , id\u2082 := eq.trans (@final_hom.uniq _ C_HasFinal\u2082 _ _)\n                     (eq.symm (@final_hom.uniq _ C_HasFinal\u2082 _ _))\n   }\n\n/-! #brief Final objects are unique up-to unique isomorphism.\n-/\ntheorem HasFinal_uniq\u2081 {C : Cat.{\u2113obj \u2113hom}}\n    (C_HasFinal\u2081 C_HasFinal\u2082 : HasFinal C)\n    {f : C^.hom (@final _ C_HasFinal\u2082) (@final _ C_HasFinal\u2081)}\n    {g : C^.hom (@final _ C_HasFinal\u2081) (@final _ C_HasFinal\u2082)}\n    (iso : Iso f g)\n    : f = final.iso C_HasFinal\u2082 C_HasFinal\u2081\n:= @final_hom.uniq _ C_HasFinal\u2081 _ _\n\n/-! #brief Final objects are unique up-to unique isomorphism.\n-/\ntheorem HasFinal_uniq\u2082 {C : Cat.{\u2113obj \u2113hom}}\n    (C_HasFinal\u2081 C_HasFinal\u2082 : HasFinal C)\n    {f : C^.hom (@final _ C_HasFinal\u2082) (@final _ C_HasFinal\u2081)}\n    {g : C^.hom (@final _ C_HasFinal\u2081) (@final _ C_HasFinal\u2082)}\n    (iso : Iso f g)\n    : g = final.iso C_HasFinal\u2081 C_HasFinal\u2082\n:= @final_hom.uniq _ C_HasFinal\u2082 _ _\n\n\n/-! #brief An initial object in a category.\n-/\ndefinition IsInit (C : Cat.{\u2113obj \u2113hom})\n    (obj : C^.obj)\n    (hom : \u2200 (c : C^.obj), C^.hom obj c)\n    : Type (max \u2113obj \u2113hom)\n:= IsFinal (OpCat C) obj hom\n\n/-! #brief A category with an initial object.\n-/\n@[class] definition HasInit (C : Cat.{\u2113obj \u2113hom})\n    : Type (max \u2113obj \u2113hom)\n:= HasFinal (OpCat C)\n\n/-! #brief Helper for showing a category has a final object.\n-/\ndefinition HasInit.show {C : Cat.{\u2113obj \u2113hom}}\n    (x : C^.obj)\n    (hom : \u2200 (c : C^.obj), C^.hom x c)\n    (hom_uniq : \u2200 {c : C^.obj} {h : C^.hom x c}, h = hom c)\n    : HasInit C\n:= HasFinal.show x hom @hom_uniq\n\n/-! #brief The initial object in a category with a initial object.\n-/\ndefinition init (C : Cat.{\u2113obj \u2113hom})\n    [C_HasInit : HasInit C]\n    : C^.obj\n:= @final (OpCat C) C_HasInit\n\n/-! #brief The initial hom in a category with a initial object.\n-/\ndefinition init_hom {C : Cat.{\u2113obj \u2113hom}}\n    [C_HasInit : HasInit C]\n    (c : C^.obj)\n    : C^.hom (init C) c\n:= @final_hom (OpCat C) C_HasInit c\n\n/-! #brief The initial hom is unique.\n-/\ndefinition init_hom.uniq (C : Cat.{\u2113obj \u2113hom})\n    {C_HasInit : HasInit C}\n    {c : C^.obj} {f : C^.hom (init C) c}\n    : f = init_hom c\n:= @final_hom.uniq (OpCat C) C_HasInit c f\n\n/-! #brief The initial hom is unique.\n-/\ndefinition init_hom.uniq' (C : Cat.{\u2113obj \u2113hom})\n    {C_HasInit : HasInit C}\n    {c : C^.obj} {f g : C^.hom (init C) c}\n    : f = g\n:= eq.trans (init_hom.uniq C) (eq.symm (init_hom.uniq C))\n\n/-! #brief The unique iso between two initial objects.\n-/\ndefinition init.iso {C : Cat.{\u2113obj \u2113hom}}\n    (C_HasInit\u2081 C_HasInit\u2082 : HasInit C)\n    : C^.hom (@init C C_HasInit\u2081) (@init C C_HasInit\u2082)\n:= @init_hom C C_HasInit\u2081 (@init C C_HasInit\u2082)\n\n/-! #brief Initial objects are unique up-to unique isomorphism.\n-/\ntheorem HasInit_uniq {C : Cat.{\u2113obj \u2113hom}}\n    (C_HasInit\u2081 C_HasInit\u2082 : HasInit C)\n    : Iso (init.iso C_HasInit\u2081 C_HasInit\u2082)\n          (init.iso C_HasInit\u2082 C_HasInit\u2081)\n:= { id\u2081 := eq.trans (@init_hom.uniq _ C_HasInit\u2081 _ _)\n                     (eq.symm (@init_hom.uniq _ C_HasInit\u2081 _ _))\n   , id\u2082 := eq.trans (@init_hom.uniq _ C_HasInit\u2082 _ _)\n                     (eq.symm (@init_hom.uniq _ C_HasInit\u2082 _ _))\n   }\n\n/-! #brief Initial and final are dual concepts.\n-/\ntheorem IsInit_dual_IsFinal (C : Cat.{\u2113obj \u2113hom})\n    : IsInit C = IsFinal (OpCat C)\n:= rfl\n\n/-! #brief Final and initial are dual concepts.\n-/\ntheorem IsFinal_dual_IsInit (C : Cat.{\u2113obj \u2113hom})\n    : IsFinal C = IsInit (OpCat C)\n:= funext (\u03bb obj, funext (\u03bb hom, begin cases C, trivial end))\n\n\n\n/- -----------------------------------------------------------------------\nExamples of initial and final objects in categories.\n----------------------------------------------------------------------- -/\n\n/-! #brief OverCat has an initial object when the global category does.\n-/\ninstance OverCat.HasInit (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    [C_HasInit : HasInit C]\n    : HasInit (OverCat C X)\n:= HasInit.show { obj := init C, hom := init_hom X }\n    (\u03bb Y, { hom := init_hom Y^.obj, triangle := init_hom.uniq' C })\n    (\u03bb Y h, OverHom.eq (init_hom.uniq C))\n\n/-! #brief OverCat has a final object.\n-/\ninstance OverCat.HasFinal (C : Cat.{\u2113obj \u2113hom}) (X : C^.obj)\n    : HasFinal (OverCat C X)\n:= HasFinal.show\n    { obj := X, hom := C^.id X }\n    (\u03bb Z, { hom := Z^.hom, triangle := eq.symm C^.circ_id_left })\n    (\u03bb Z h, OverHom.eq (eq.symm (eq.trans h^.triangle C^.circ_id_left )))\n\n/-! #brief UnitCat has an initial object.\n-/\ninstance UnitCat.HasInit\n    : HasInit UnitCat.{\u2113obj \u2113hom}\n:= HasInit.show punit.star (\u03bb c, punit.star)\n    (\u03bb c h, begin cases h, trivial end)\n\n/-! #brief UnitCat has a final object.\n-/\ninstance UnitCat.HasFinal\n    : HasFinal UnitCat.{\u2113obj \u2113hom}\n:= HasFinal.show punit.star (\u03bb c, punit.star) (\u03bb c h, begin cases h, trivial end)\n\n/-! #brief SortCat has an initial object.\n-/\ninstance SortCat.HasInit\n    : HasInit SortCat.{\u2113}\n:= HasInit.show pempty (\u03bb T e, by cases e) (\u03bb c h, funext (\u03bb e, by cases e))\n\n/-! #brief PropCat has an initial object.\n-/\ninstance PropCat.HasInit\n    : HasInit PropCat\n:= SortCat.HasInit\n\n/-! #brief LeanCat has an initial object.\n-/\ninstance LeanCat.HasInit\n    : HasInit LeanCat.{\u2113}\n:= SortCat.HasInit\n\n/-! #brief Initial objects in LeanCat are uninhabited.\n-/\ntheorem LeanCat.Init.elim\n    [LeanCat_HasInit : HasInit LeanCat.{\u2113}]\n    (e : init LeanCat.{\u2113})\n    : false\n:= by cases (init.iso LeanCat_HasInit LeanCat.HasInit e)\n\n/-! #brief SortCat has a final object.\n-/\ninstance SortCat.HasFinal\n    : HasFinal SortCat.{\u2113}\n:= HasFinal.show punit (\u03bb T t, punit.star) (\u03bb c h, funext (\u03bb t, begin cases (h t), trivial end))\n\n/-! #brief PropCat has a final object.\n-/\ninstance PropCat.HasFinal\n    : HasFinal PropCat\n:= SortCat.HasFinal\n\n/-! #brief LeanCat has a final object.\n-/\ninstance LeanCat.HasFinal\n    : HasFinal LeanCat.{\u2113}\n:= SortCat.HasFinal\n\n/-! #brief Final objects in LeanCat are uniquely inhabited.\n-/\ndefinition LeanCat.Final.intro\n    [LeanCat_HasFinal : HasFinal LeanCat.{\u2113}]\n    : final LeanCat.{\u2113}\n:= final.iso LeanCat.HasFinal LeanCat_HasFinal punit.star\n\n/-! #brief Final objects in LeanCat are uniquely.\n-/\ntheorem LeanCat.Final.uniq\n    {LeanCat_HasFinal : HasFinal LeanCat.{\u2113}}\n    {u\u2081 u\u2082 : final LeanCat.{\u2113}}\n    : u\u2081 = u\u2082\n:= let f\u2081 : LeanCat.{\u2113}^.hom punit (final LeanCat.{\u2113})\n         := \u03bb u, u\u2081 in\n   let f\u2082 : LeanCat.{\u2113}^.hom punit (final LeanCat.{\u2113})\n         := \u03bb u, u\u2082 in\n   let \u03c9f : f\u2081 = f\u2082\n         := by calc f\u2081 = @final_hom _ LeanCat_HasFinal punit : @final_hom.uniq _ LeanCat_HasFinal _ f\u2081\n                    ... = f\u2082 : eq.symm (@final_hom.uniq _ LeanCat_HasFinal _ f\u2082)\n   in by calc u\u2081 = f\u2081 punit.star : rfl\n              ... = f\u2082 punit.star : by rw \u03c9f\n              ... = u\u2082 : rfl\n\n/-! #brief The category of natural numbers has an initial object.\n-/\ninstance NatCat.HasInit\n    :HasInit NatCat\n:= HasInit.show nat.zero nat.zero_le (\u03bb c h, proof_irrel _ _)\n\nend qp\n"}
{"text": "lemma monom_eq_1 [simp]: \"monom 1 0 = 1\""}
{"text": "(*\n * Copyright 2014, NICTA\n *\n * This software may be distributed and modified according to the terms of\n * the BSD 2-Clause license. Note that NO WARRANTY is provided.\n * See \"LICENSE_BSD2.txt\" for details.\n *\n * @TAG(NICTA_BSD)\n *)\n\ntheory ptr_modifies\nimports \"Word_Lib.WordSetup\" \"CParser.CTranslation\"\nbegin\n\nexternal_file \"ptr_modifies.c\"\ninstall_C_file \"ptr_modifies.c\"\n\ncontext ptr_modifies\nbegin\n  thm foo_ptr_new_modifies\n  thm f_modifies\n  thm f_body_def\n  thm g_modifies\n  thm h_modifies\nend\n\nlemma (in f_spec) g_spec:\n  \"\\<forall> i. \\<Gamma> \\<turnstile> \\<lbrace> \\<acute>i = i \\<rbrace> \\<acute>ret__unsigned :== CALL g(\\<acute>i) \\<lbrace> \\<acute>ret__unsigned = i + 4 \\<rbrace>\"\napply vcg\napply simp\ndone\n\nend\n"}
{"text": "import data.real.irrational\nimport topology.basic\nimport algebra.order.floor\n\n\n--OUTPUT 1\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h\u03b1 : \u00ac is_rat \u03b1) : \u2200 y \u2208 Icc 0 1, \u2203 x \u2208 Icc 0 1, x \u2260 y :=\nbegin\n  assume y h1,\n  have h2 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by {\n    assume i j h3,\n    assume h4 : (i : \u211d) * \u03b1 - (i : \u211d) = (j : \u211d) * \u03b1 - (j : \u211d),\n    have h5 : (i : \u211d) * \u03b1 = (j : \u211d) * \u03b1, from by {\n      rw \u2190 h4,\n      ring,\n    },\n    have h6 : (i : \u211d) = (j : \u211d), from by {\n      rw \u2190 h5,\n      rw \u2190 mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (j : \u211d),\n      rw mul_assoc,\n      rw mul_comm \u03b1 (i : \u211d\nend --Needs more than 2000 tokens!\n\n/- FEW SHOT PROMPTS TO CODEX(START)\n/--`theorem`\nPower Set is Closed under Intersection\nLet $S$ be a set.\n\nLet $\\powerset S$ be the power set of $S$.\n\n\nThen:\n:$\\forall A, B \\in \\powerset S: A \\cap B \\in \\powerset S$\n`proof`\nLet $A, B \\in \\powerset S$.\n\nThen by the definition of power set, $A \\subseteq S$ and $B \\subseteq S$.\n\nFrom Intersection is Subset we have that $A \\cap B \\subseteq A$.\n\nIt follows from Subset Relation is Transitive that $A \\cap B \\subseteq S$.\n\nThus $A \\cap B \\in \\powerset S$ and closure is proved.\n{{qed}}\n-/\ntheorem power_set_intersection_closed {\u03b1 : Type*} (S : set \u03b1) : \u2200 A B \u2208 \ud835\udcab S, (A \u2229 B) \u2208 \ud835\udcab S :=\nbegin\n  assume (A : set \u03b1) (hA : A \u2208 \ud835\udcab S) (B : set \u03b1) (hB : B \u2208 \ud835\udcab S),\n  have h1 : (A \u2286 S) \u2227 (B \u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\n  have h2 : (A \u2229 B) \u2286 A, from by apply set.inter_subset_left,\n  have h3 : (A \u2229 B) \u2286 S, from by {apply set.subset.trans h2 h1.left},\n  show (A \u2229 B) \u2208  \ud835\udcab S, from by {apply set.mem_powerset h3},\nend\n\n/--`theorem`\nSquare of Sum\n :$\\forall x, y \\in \\R: \\paren {x + y}^2 = x^2 + 2 x y + y^2$\n`proof`\nFollows from the distribution of multiplication over addition:\n\n{{begin-eqn}}\n{{eqn | l = \\left({x + y}\\right)^2\n      | r = \\left({x + y}\\right) \\cdot \\left({x + y}\\right)\n}}\n{{eqn | r = x \\cdot \\left({x + y}\\right) + y \\cdot \\left({x + y}\\right)\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x \\cdot x + x \\cdot y + y \\cdot x + y \\cdot y\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x^2 + 2xy + y^2\n      | c = \n}}\n{{end-eqn}}\n{{qed}}\n-/\ntheorem square_of_sum (x y : \u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \nbegin\n  calc (x + y)^2 = (x+y)*(x+y) : by rw sq\n  ... = x*(x+y) + y*(x+y) : by rw add_mul\n  ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\n  ... = x^2 + 2*x*y + y^2 : by {repeat {rw \u2190 sq}, rw mul_comm y x, ring}\nend\n\n\n/--`theorem`\nIdentity of Group is Unique\nLet $\\struct {G, \\circ}$ be a group. Then there is a unique identity element $e \\in G$.\n`proof`\nFrom Group has Latin Square Property, there exists a unique $x \\in G$ such that:\n:$a x = b$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = b$\n\nSetting $b = a$, this becomes:\n\nThere exists a unique $x \\in G$ such that:\n:$a x = a$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = a$\n\nThese $x$ and $y$ are both $e$, by definition of identity element.\n{{qed}}\n-/\ntheorem group_identity_unique {G : Type*} [group G] : \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a :=\nbegin\n  have h1 : \u2200 a b : G, \u2203! x : G, a * x = b, from by {\n    assume a b : G, use a\u207b\u00b9 * b, obviously, },\n  have h2 : \u2200 a b : G, \u2203! y : G, y * a = b, from by {\n    assume a b : G, use b * a\u207b\u00b9, obviously, }, \n\n  have h3 : \u2200 a : G, \u2203! x : G, a * x = a, from \n    assume a : G, h1 a a,\n  have h4 : \u2200 a : G, \u2203! y : G, y * a = a, from\n    assume a : G, h2 a a,\n\n  have h5 : \u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\n    exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\n    (mul_one a),\n  have h6 : \u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\n    exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \n\n  show \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a, from by {\n    use (1 : G),\n    have h7 : \u2200 e : G, (\u2200 a : G, e * a = a \u2227 a * e = a) \u2192 e = 1, from by {\n      assume (e : G) (hident : \u2200 a : G, e * a = a \u2227 a * e = a),\n      have h8 : \u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\n        exists_unique.unique (h3 a) (hident a).right\n        (classical.some_spec (exists_unique.exists (h3 a))), \n      have h9 : \u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\n        exists_unique.unique (h4 a) (hident a).left\n        (classical.some_spec (exists_unique.exists (h4 a))),\n      show e = (1 : G), from eq.trans (h9 e) (h6 _),     \n    },\n    exact \u27e8by obviously, h7\u27e9,\n  }\nend\n\n/--`theorem`\nSqueeze Theorem for Real Numbers\nLet $\\sequence {x_n}$, $\\sequence {y_n}$ and $\\sequence {z_n}$ be sequences in $\\R$.\n\nLet $\\sequence {y_n}$ and $\\sequence {z_n}$ both be convergent to the following limit:\n:$\\ds \\lim_{n \\mathop \\to \\infty} y_n = l, \\lim_{n \\mathop \\to \\infty} z_n = l$\n\nSuppose that:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\n\nThen:\n:$x_n \\to l$ as $n \\to \\infty$\nthat is:\n:$\\ds \\lim_{n \\mathop \\to \\infty} x_n = l$\n\n`proof`\nFrom Negative of Absolute Value:\n:$\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n\nLet $\\epsilon > 0$.\n\nWe need to prove that:\n:$\\exists N: \\forall n > N: \\size {x_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that:\n:$\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that:\n:$\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n\n\nLet $N = \\max \\set {N_1, N_2}$.\n\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n:$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n\nBut:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n\nand so:\n:$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n\nSo:\n:$\\forall n > N: \\size {x_n - l} < \\epsilon$\n\nHence the result.\n{{qed}}\n\n-/\ntheorem squeeze_theorem_real_numbers (x y z : \u2115 \u2192 \u211d) (l : \u211d) : \nlet seq_limit : (\u2115 \u2192 \u211d) \u2192 \u211d \u2192 Prop :=  \u03bb (u : \u2115 \u2192 \u211d) (l : \u211d), \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, |u n - l| < \u03b5 in\n seq_limit y l \u2192 seq_limit z l \u2192  (\u2200 n : \u2115, (y n) \u2264 (x n) \u2227 (x n) \u2264 (z n)) \u2192 seq_limit x l :=\nbegin\n  assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \u2200 (n : \u2115), y n \u2264 x n \u2227 x n \u2264 z n) (\u03b5), \n\n  have h5 : \u2200 x, |x - l| < \u03b5 \u2194 (((l - \u03b5) < x) \u2227 (x < (l + \u03b5))), \n  from by \n  {\n    intro x0,\n    have h6 : |x0 - l| < \u03b5 \u2194 ((x0 - l) < \u03b5) \u2227 ((l - x0) < \u03b5), \n    from abs_sub_lt_iff, rw h6,\n    split, \n    rintro \u27e8 S_1, S_2 \u27e9, \n    split; linarith, \n    rintro \u27e8 S_3, S_4 \u27e9, \n    split; linarith,\n    },\n  \n  assume (h7 : \u03b5 > 0),\n  cases h2 \u03b5 h7 with N1 h8,\n  cases h3 \u03b5 h7 with N2 h9,\n\n  let N := max N1 N2,\n  use N,\n\n  have h10 : \u2200 n > N, n > N1 \u2227 n > N2 := by {\n    assume n h,\n    split,\n    exact lt_of_le_of_lt (le_max_left N1 N2) h, \n    exact lt_of_le_of_lt (le_max_right N1 N2) h,\n  },\n  \n  have h11 : \u2200 n > N, (((l - \u03b5) < (y n)) \u2227 ((y n) \u2264 (x n))) \u2227 (((x n) \u2264 (z n)) \u2227 ((z n) < l+\u03b5)), \n  from by {\n    intros n h12,\n    split,\n    {\n\n      have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\n      split,\n      exact h13.left,\n      exact (h4 n).left,\n    },\n    {        \n      have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\n      split,\n      exact (h4 n).right,\n      exact h14.right,\n    },\n    \n  },\n\n  have h15 : \u2200 n > N, ((l - \u03b5) < (x n)) \u2227 ((x n) < (l+\u03b5)), \n  from by {\n    intros n1 h16, cases (h11 n1 h16);\n    split; linarith,\n  },\n\n  show  \u2200 (n : \u2115), n > N \u2192 |x n - l| < \u03b5, \n  from by {\n    intros n h17,\n    cases h5 (x n) with h18 h19,\n    apply h19, exact h15 n h17,\n  },\nend\n\n\n/--`theorem`\nDensity of irrational orbit\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\n`proof`\nLet $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n$$\ni \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n$$\nwhich yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$. Hence,\n$$\nS:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n$$\nis an infinite subset of $\\left[0,1\\right]$.\n\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\n\nTo show that $S$ is dense in $[0, 1]$, consider $y \\in[0,1]$, and $\\epsilon>0$. Then by selecting $x \\in S$ such that $\\{x\\}<\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\cdot\\{x\\} \\leq y<(N+1) \\cdot\\{x\\}$, we get: $|y-\\{N x\\}|<\\epsilon$.\n\nQED\n-/\ntheorem \nFEW SHOT PROMPTS TO CODEX(END)-/\n"}
{"text": "def s1 := \"Hello, \"\ndef s2 := \"Nifty!\"\ndef s3 := s1 ++ s2\n\ntheorem t1 : s1 ++ s2 = s3 := _\n\ntheorem t2 : 4^2 = 16 := _\n\ntheorem t3 : s1 ++ s2 = s3 \u2227 5^2 = 25 := _\n\ntheorem t4 : \n    \u2200 (P Q R : Prop), (P \u2227 Q) \u2227 (Q \u2227 R) \u2192 (P \u2227 R) := \n    \u03bb (P Q R : Prop),\n        and.intro _ _"}
{"text": "import algebra.module.basic\nimport algebra.module.linear_map\nimport linear_algebra.basic\nimport linear_algebra.prod\nimport linear_algebra.projection\nimport order.bounded_lattice\n\n\ntheorem cpge_reduction_3_a (R : Type*) (M : Type*) \n[semiring R] [add_comm_monoid M] [module R M] \n[E : submodule R M] (u : linear_map R E E)  (v : linear_map R E E) :\n\n(u.comp v) = (v.comp u) -> v '' u.ker \u2282 u.ker \u2227 u '' v.ker \u2282 v.ker := sorry"}
{"text": "import data.real.basic\n\n#check sub_self\n#check abs_zero\n\ndef converges_to (s : \u2115 \u2192 \u211d) (a : \u211d) :=\n\u2200 \u03b5 > 0, \u2203 N, \u2200 n \u2265 N, abs (s n - a) < \u03b5\n\ntheorem converges_to_const (a : \u211d) : converges_to (\u03bb x : \u2115, a) a :=\nbegin\n  intros \u03b5 epos,\n  dsimp,\n  rw sub_self,\n  norm_num, \n  use 0, \n  intros n nge,\n  exact epos, \nend\n\nexample (a : \u211d) : converges_to (\u03bb x : \u2115, a) a :=\nbegin\n  intros \u03b5 epos,\n  use 0,\n  intros n nge,\n  dsimp,\n  rw sub_self,\n  rw abs_zero,\n  apply epos,\nend\n"}
{"text": "/-\nCopyright (c) 2021 Sara D\u00edaz Real. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Sara D\u00edaz Real\n-/\nimport data.int.basic\nimport algebra.associated\nimport tactic.linarith\nimport tactic.ring\n\n/-!\n# IMO 2001 Q6\nLet $a$, $b$, $c$, $d$ be integers with $a > b > c > d > 0$. Suppose that\n\n$$ a*c + b*d = (a + b - c + d) * (-a + b + c + d). $$\n\nProve that $a*b + c*d$ is not prime.\n\n-/\n\nvariables {a b c d : \u2124}\n\ntheorem imo2001_q6 (hd : 0 < d) (hdc : d < c) (hcb : c < b) (hba : b < a)\n  (h : a*c + b*d = (a + b - c + d) * (-a + b + c + d)) :\n  \u00ac prime (a*b + c*d) :=\nbegin\n  assume h0 : prime (a*b + c*d),\n  have ha : 0 < a, { linarith },\n  have hb : 0 < b, { linarith },\n  have hc : 0 < c, { linarith },\n  -- the key step is to show that `a*c + b*d` divides the product `(a*b + c*d) * (a*d + b*c)`\n  have dvd_mul : a*c + b*d \u2223 (a*b + c*d) * (a*d + b*c),\n  { use b^2 + b*d + d^2,\n    have equivalent_sums : a^2 - a*c + c^2 = b^2 + b*d + d^2,\n    { ring_nf at h, nlinarith only [h], },\n    calc  (a * b + c * d) * (a * d + b * c)\n        = a*c * (b^2 + b*d + d^2) + b*d * (a^2 - a*c + c^2) : by ring\n    ... = a*c * (b^2 + b*d + d^2) + b*d * (b^2 + b*d + d^2) : by rw equivalent_sums\n    ... = (a * c + b * d) * (b ^ 2 + b * d + d ^ 2)         : by ring, },\n  -- since `a*b + c*d` is prime (by assumption), it must divide `a*c + b*d` or `a*d + b*c`\n  obtain (h1 : a*b + c*d \u2223 a*c + b*d) | (h2 : a*c + b*d \u2223 a*d + b*c) :=\n    h0.left_dvd_or_dvd_right_of_dvd_mul dvd_mul,\n  -- in both cases, we derive a contradiction\n  { have aux : 0 < a*c + b*d,         { nlinarith only [ha, hb, hc, hd] },\n    have : a*b + c*d \u2264 a*c + b*d,     { from int.le_of_dvd aux h1 },\n    have : \u00ac (a*b + c*d \u2264 a*c + b*d), { nlinarith only [hba, hcb, hdc, h] },\n    contradiction, },\n  { have aux : 0 < a*d + b*c,         { nlinarith only [ha, hb, hc, hd] },\n    have : a*c + b*d \u2264 a*d + b*c,     { from int.le_of_dvd aux h2 },\n    have : \u00ac (a*c + b*d \u2264 a*d + b*c), { nlinarith only [hba, hdc, h] },\n    contradiction, },\nend\n"}
{"text": "//////////////////////////////////////////////////////////////////////////////////////\n// distribution::toolkit::distributions::chi_squared::description.hpp                //\n//                                                                                  //\n//  (C) Copyright 2009 Erwann Rogard                                                //\n//  Use, modification and distribution are subject to the                           //\n//  Boost Software License, Version 1.0. (See accompanying file                     //\n//  LICENSE_1_0.txt or copy at http://www.boost.org/LICENSE_1_0.txt)                //\n//////////////////////////////////////////////////////////////////////////////////////\n#ifndef BOOST_STATISTICS_DETAIL_DISTRIBUTION_TOOLKIT_CHI_SQUARED_DESCRIPTION_HPP_ER_2009\n#define BOOST_STATISTICS_DETAIL_DISTRIBUTION_TOOLKIT_CHI_SQUARED_DESCRIPTION_HPP_ER_2009\n#include <ostream>\n#include <boost/format.hpp>\n#include <boost/math/distributions/chi_squared.hpp>\n\nnamespace boost{\nnamespace math{\n\n    template<typename T,typename P>\n    std::string\n    description(const boost::math::chi_squared_distribution<T,P>& dist)\n    {\n        static const char* msg = \"chi_squared(%1%)\";\n        format f(msg); f % dist.degrees_of_freedom();\n        return f.str();\n    }\n    \n}// math\n}// boost\n\n\n#endif\n"}
{"text": "informal statement Let $\\Omega$ be a bounded open subset of $\\mathbb{C}$, and $\\varphi: \\Omega \\rightarrow \\Omega$ a holomorphic function. Prove that if there exists a point $z_{0} \\in \\Omega$ such that $\\varphi\\left(z_{0}\\right)=z_{0} \\quad \\text { and } \\quad \\varphi^{\\prime}\\left(z_{0}\\right)=1$ then $\\varphi$ is linear.formal statement theorem exercise_3_3 (a : \u211d) (ha : 0 < a) :\n    tendsto (\u03bb y, \u222b x in -y..y, real.cos x / (x ^ 2 + a ^ 2))\n    at_top (\ud835\udcdd (real.pi * (real.exp (-a) / a))) :="}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_547\n  (x y : \u211d)\n  (h\u2080 : x = 5)\n  (h\u2081 : y = 2) :\n  real.sqrt (x^3 - 2^y) = 11 :=\nbegin\n  simp [h\u2080, h\u2081],\n  norm_num [real.sqrt_eq_cases],\nend"}
{"text": "class CommAddSemigroup (\u03b1 : Type u) extends Add \u03b1 where\n    addComm : {a b : \u03b1} \u2192 a + b = b + a\n    addAssoc : {a b c : \u03b1} \u2192 a + b + c = a + (b + c)\n\nopen CommAddSemigroup\n\ntheorem addComm3 [CommAddSemigroup \u03b1] {a b c : \u03b1} : a + b + c = a + c + b := by {\n    have h : b + c = c + b := addComm;\n    have h' := congrArg (a + \u00b7) h;\n    simp at h';\n    rw [\u2190addAssoc] at h';\n    rw [\u2190addAssoc (a := a)] at h';\n    exact h';\n}\n\ntheorem addComm4 [CommAddSemigroup \u03b1] {a b c : \u03b1} : a + b + c = a + c + b := by {\n    rw [addAssoc, addAssoc];\n    rw [addComm (a := b)];\n}\n\ntheorem addComm5 [CommAddSemigroup \u03b1] {a b c : \u03b1} : a + b + c = a + c + b := by {\n    have h : b + c = c + b := addComm;\n    have h' := congrArg (a + \u00b7) h;\n    simp at h';\n    rw [\u2190addAssoc] at h';\n    rw [\u2190@addAssoc (a := a)] at h';\n    exact h';\n}\n\ntheorem addComm6 [CommAddSemigroup \u03b1] {a b c : \u03b1} : a + b + c = a + c + b := by {\n    have h : b + c = c + b := addComm;\n    have h' := congrArg (a + \u00b7) h;\n    simp at h';\n    rw [\u2190addAssoc] at h';\n    rw [\u2190addAssoc] at h';\n    exact h';\n}\n"}
{"text": "import Smt\n\ntheorem assoc (f : Prop \u2192 Prop \u2192 Prop) (p q r : Prop) :\n  f p (f q r) = f (f p q) r := by\n  smt\n  admit\n"}
{"text": "import data.set.basic\nvariables {\u03b1 : Type*} {\u03b2 : Type*} [s : setoid \u03b1]\n\nnamespace quotient\nlemma prod_preimage_eq_image (g : quotient s \u2192 \u03b2) {h : \u03b1 \u2192 \u03b2} (Hh : h = g \u2218 quotient.mk) (r : set (\u03b2 \u00d7 \u03b2)) :\n  {x : quotient s \u00d7 quotient s | (g x.1, g x.2) \u2208 r} =\n  (\u03bb a : \u03b1 \u00d7 \u03b1, (\u27e6a.1\u27e7, \u27e6a.2\u27e7)) '' ((\u03bb a : \u03b1 \u00d7 \u03b1, (h a.1, h a.2)) \u207b\u00b9' r) :=\n  Hh.symm \u25b8\n  set.ext (\u03bb \u27e8a\u2081, a\u2082\u27e9, \u27e8quotient.induction_on\u2082 a\u2081 a\u2082\n    (\u03bb a\u2081 a\u2082 h, \u27e8(a\u2081, a\u2082), h, rfl\u27e9),\n    \u03bb \u27e8\u27e8b\u2081, b\u2082\u27e9, h\u2081, h\u2082\u27e9, show (g a\u2081, g a\u2082) \u2208 r, from\n    have h\u2083 : \u27e6b\u2081\u27e7 = a\u2081 \u2227 \u27e6b\u2082\u27e7 = a\u2082 := prod.ext_iff.1 h\u2082,\n     h\u2083.1 \u25b8 h\u2083.2 \u25b8 h\u2081\u27e9)\n\nend quotient"}
{"text": "import data.real.basic \n\n-- TODO: Move. \nlemma mul_Inf {K : \u211d} (hK : 0 \u2264 K) {p : \u211d \u2192 Prop} \n(h : \u2203 x, 0 \u2264 x \u2227 p x) (hp : p (Inf {x | 0 \u2264 x \u2227 p x}))\n: K * Inf {x | 0 \u2264 x \u2227 p x} = Inf {y | \u2203 x, (y : \u211d) = K * x \u2227 0 \u2264 x \u2227 p x} :=\nbegin \n  rcases h with \u27e8i, hnni, hpi\u27e9,\n  let S := {y | \u2203 x, y = K * x \u2227 0 \u2264 x \u2227 p x},\n  apply le_antisymm,\n  { have h1 : (\u2203 (x : \u211d), x \u2208 S) := \u27e8K * i, \u27e8i, rfl, hnni, hpi\u27e9\u27e9,\n    have h2 : (\u2203 (x : \u211d), \u2200 (y : \u211d), y \u2208 S \u2192 x \u2264 y),\n    { existsi (0 : \u211d), rintros y \u27e8x, hy, hnnx, hpx\u27e9,\n      rw hy, exact mul_nonneg hK hnnx, },\n    rw real.le_Inf S h1 h2, rintros z \u27e8w, hz, hnnw, hpw\u27e9,\n    rw hz, mono,\n    { refine cInf_le _ \u27e8hnnw, hpw\u27e9, use 0, intros a ha, exact ha.1, },\n    { apply le_cInf,\n      { use [i, \u27e8hnni, hpi\u27e9], },\n      { intros b hb, exact hb.1, }, }, },\n  { apply real.Inf_le,\n    { use [0], intros y hy, rcases hy with \u27e8x, \u27e8hy, hnnx, hpx\u27e9\u27e9,\n      rw hy, exact mul_nonneg hK hnnx, },\n    { use [Inf {x : \u211d | 0 \u2264 x \u2227 p x}], refine \u27e8rfl, _, _\u27e9, \n      { apply le_cInf,\n        { use [i, \u27e8hnni, hpi\u27e9], },\n        { intros b hb, exact hb.1, }, },\n      { exact hp, }, }, },\nend\n"}
{"text": "/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau, Eric Wieser\n-/\nimport linear_algebra.span\nimport linear_algebra.bilinear_map\n\n/-!\n# Images of pairs of submodules under bilinear maps\n\n> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.\n> Any changes to this file require a corresponding PR to mathlib4.\n\nThis file provides `submodule.map\u2082`, which is later used to implement `submodule.has_mul`.\n\n## Main results\n\n* `submodule.map\u2082_eq_span_image2`: the image of two submodules under a bilinear map is the span of\n  their `set.image2`.\n\n## Notes\n\nThis file is quite similar to the n-ary section of `data.set.basic` and to `order.filter.n_ary`.\nPlease keep them in sync.\n-/\n\nuniverses u\u03b9 u v\n\nopen set\nopen_locale big_operators\nopen_locale pointwise\n\nnamespace submodule\n\nvariables {\u03b9 : Sort u\u03b9} {R M N P : Type*}\nvariables [comm_semiring R] [add_comm_monoid M] [add_comm_monoid N] [add_comm_monoid P]\nvariables [module R M] [module R N] [module R P]\n\n/-- Map a pair of submodules under a bilinear map.\n\nThis is the submodule version of `set.image2`.  -/\ndef map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : submodule R M) (q : submodule R N) : submodule R P :=\n\u2a06 s : p, q.map $ f s\n\ntheorem apply_mem_map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) {m : M} {n : N}\n  {p : submodule R M} {q : submodule R N} (hm : m \u2208 p) (hn : n \u2208 q) : f m n \u2208 map\u2082 f p q :=\n(le_supr _ \u27e8m, hm\u27e9 : _ \u2264 map\u2082 f p q) \u27e8n, hn, rfl\u27e9\n\ntheorem map\u2082_le {f : M \u2192\u2097[R] N \u2192\u2097[R] P}\n  {p : submodule R M} {q : submodule R N} {r : submodule R P} :\n  map\u2082 f p q \u2264 r \u2194 \u2200 (m \u2208 p) (n \u2208 q), f m n \u2208 r :=\n\u27e8\u03bb H m hm n hn, H $ apply_mem_map\u2082 _ hm hn,\n \u03bb H, supr_le $ \u03bb \u27e8m, hm\u27e9, map_le_iff_le_comap.2 $ \u03bb n hn, H m hm n hn\u27e9\n\nvariables R\ntheorem map\u2082_span_span (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (s : set M) (t : set N) :\n  map\u2082 f (span R s) (span R t) = span R (set.image2 (\u03bb m n, f m n) s t) :=\nbegin\n  apply le_antisymm,\n  { rw map\u2082_le, intros a ha b hb,\n    apply span_induction ha,\n    work_on_goal 1 { intros, apply span_induction hb,\n      work_on_goal 1 { intros, exact subset_span \u27e8_, _, \u2039_\u203a, \u2039_\u203a, rfl\u27e9 } },\n    all_goals {\n      intros,\n      simp only [linear_map.map_zero, linear_map.zero_apply, zero_mem,\n        linear_map.map_add, linear_map.add_apply, linear_map.map_smul, linear_map.smul_apply] },\n    all_goals {\n      solve_by_elim [add_mem _ _, zero_mem _, smul_mem _ _ _]\n        { max_depth := 4, discharger := tactic.interactive.apply_instance } } },\n  { rw span_le, rintros _ \u27e8a, b, ha, hb, rfl\u27e9,\n    exact apply_mem_map\u2082 _ (subset_span ha) (subset_span hb) }\nend\nvariables {R}\n\n@[simp] theorem map\u2082_bot_right (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : submodule R M) : map\u2082 f p \u22a5 = \u22a5 :=\neq_bot_iff.2 $ map\u2082_le.2 $ \u03bb m hm n hn,\n  by { rw [submodule.mem_bot] at hn \u22a2, rw [hn, linear_map.map_zero] }\n\n@[simp] theorem map\u2082_bot_left (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (q : submodule R N) : map\u2082 f \u22a5 q = \u22a5 :=\neq_bot_iff.2 $ map\u2082_le.2 $ \u03bb m hm n hn,\n  by { rw [submodule.mem_bot] at hm \u22a2, rw [hm, linear_map.map_zero\u2082] }\n\n@[mono] theorem map\u2082_le_map\u2082 {f : M \u2192\u2097[R] N \u2192\u2097[R] P}\n  {p\u2081 p\u2082 : submodule R M} {q\u2081 q\u2082 : submodule R N} (hp : p\u2081 \u2264 p\u2082) (hq : q\u2081 \u2264 q\u2082) :\n  map\u2082 f p\u2081 q\u2081 \u2264 map\u2082 f p\u2082 q\u2082 :=\nmap\u2082_le.2 $ \u03bb m hm n hn, apply_mem_map\u2082 _ (hp hm) (hq hn)\n\ntheorem map\u2082_le_map\u2082_left {f : M \u2192\u2097[R] N \u2192\u2097[R] P}\n  {p\u2081 p\u2082 : submodule R M} {q : submodule R N} (h : p\u2081 \u2264 p\u2082) : map\u2082 f p\u2081 q \u2264 map\u2082 f p\u2082 q :=\nmap\u2082_le_map\u2082 h (le_refl q)\n\ntheorem map\u2082_le_map\u2082_right {f : M \u2192\u2097[R] N \u2192\u2097[R] P}\n  {p : submodule R M} {q\u2081 q\u2082 : submodule R N} (h : q\u2081 \u2264 q\u2082): map\u2082 f p q\u2081 \u2264 map\u2082 f p q\u2082 :=\nmap\u2082_le_map\u2082 (le_refl p) h\n\ntheorem map\u2082_sup_right (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : submodule R M) (q\u2081 q\u2082 : submodule R N) :\n  map\u2082 f p (q\u2081 \u2294 q\u2082) = map\u2082 f p q\u2081 \u2294 map\u2082 f p q\u2082 :=\nle_antisymm (map\u2082_le.2 $ \u03bb m hm np hnp, let \u27e8n, hn, p, hp, hnp\u27e9 := mem_sup.1 hnp in\n  mem_sup.2 \u27e8_, apply_mem_map\u2082 _ hm hn, _, apply_mem_map\u2082 _ hm hp, hnp \u25b8 (map_add _ _ _).symm\u27e9)\n(sup_le (map\u2082_le_map\u2082_right le_sup_left) (map\u2082_le_map\u2082_right le_sup_right))\n\ntheorem map\u2082_sup_left (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p\u2081 p\u2082 : submodule R M) (q : submodule R N) :\n  map\u2082 f (p\u2081 \u2294 p\u2082) q = map\u2082 f p\u2081 q \u2294 map\u2082 f p\u2082 q :=\nle_antisymm (map\u2082_le.2 $ \u03bb mn hmn p hp, let \u27e8m, hm, n, hn, hmn\u27e9 := mem_sup.1 hmn in\n  mem_sup.2 \u27e8_, apply_mem_map\u2082 _ hm hp, _, apply_mem_map\u2082 _ hn hp,\n    hmn \u25b8 (linear_map.map_add\u2082 _ _ _ _).symm\u27e9)\n(sup_le (map\u2082_le_map\u2082_left le_sup_left) (map\u2082_le_map\u2082_left le_sup_right))\n\nlemma image2_subset_map\u2082 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : submodule R M) (q : submodule R N) :\n  set.image2 (\u03bb m n, f m n) (\u2191p : set M) (\u2191q : set N) \u2286 (\u2191(map\u2082 f p q) : set P) :=\nby { rintros _ \u27e8i, j, hi, hj, rfl\u27e9, exact apply_mem_map\u2082 _ hi hj }\n\nlemma map\u2082_eq_span_image2 (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : submodule R M) (q : submodule R N) :\n  map\u2082 f p q = span R (set.image2 (\u03bb m n, f m n) (p : set M) (q : set N)) :=\nby rw [\u2190 map\u2082_span_span, span_eq, span_eq]\n\nlemma map\u2082_flip (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (p : submodule R M) (q : submodule R N) :\n  map\u2082 f.flip q p = map\u2082 f p q :=\nby { rw [map\u2082_eq_span_image2, map\u2082_eq_span_image2, set.image2_swap], refl }\n\n\n\nlemma map\u2082_supr_right (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (s : submodule R M) (t : \u03b9 \u2192 submodule R N) :\n  map\u2082 f s (\u2a06 i, t i) = \u2a06 i, map\u2082 f s (t i) :=\nbegin\n  suffices :\n    map\u2082 f (span R s) (\u2a06 i, span R (t i : set N)) = (\u2a06 i, map\u2082 f (span R s) (span R (t i))),\n  { simpa only [span_eq] using this },\n  simp_rw [map\u2082_span_span, \u2190 span_Union, map\u2082_span_span, set.image2_Union_right],\nend\n\ntheorem map\u2082_span_singleton_eq_map (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (m : M) :\n  map\u2082 f (span R {m}) = map (f m) :=\nbegin\n  funext, rw map\u2082_eq_span_image2, apply le_antisymm,\n  { rw [span_le, set.image2_subset_iff],\n    intros x hx y hy,\n    obtain \u27e8a, rfl\u27e9 := mem_span_singleton.1 hx,\n    rw [f.map_smul],\n    exact smul_mem _ a (mem_map_of_mem hy) },\n  { rintro _ \u27e8n, hn, rfl\u27e9,\n    exact subset_span \u27e8m, n, mem_span_singleton_self m, hn, rfl\u27e9 },\nend\n\ntheorem map\u2082_span_singleton_eq_map_flip (f : M \u2192\u2097[R] N \u2192\u2097[R] P) (s : submodule R M) (n : N) :\n  map\u2082 f s (span R {n}) = map (f.flip n) s :=\nby rw [\u2190 map\u2082_span_singleton_eq_map, map\u2082_flip]\n\nend submodule\n"}
{"text": "my_f(x,y) = 2*x+3*y\n\nderivative_of_my_f(x,y) = ForwardDiff.derivative(x->my_f(x,y),x)\n"}
{"text": "/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n\n! This file was ported from Lean 3 source module analysis.complex.upper_half_plane.metric\n! leanprover-community/mathlib commit f06058e64b7e8397234455038f3f8aec83aaba5a\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Analysis.Complex.UpperHalfPlane.Topology\nimport Mathbin.Analysis.SpecialFunctions.Arsinh\nimport Mathbin.Geometry.Euclidean.Inversion\n\n/-!\n# Metric on the upper half-plane\n\nIn this file we define a `metric_space` structure on the `upper_half_plane`. We use hyperbolic\n(Poincar\u00e9) distance given by\n`dist z w = 2 * arsinh (dist (z : \u2102) w / (2 * real.sqrt (z.im * w.im)))` instead of the induced\nEuclidean distance because the hyperbolic distance is invariant under holomorphic automorphisms of\nthe upper half-plane. However, we ensure that the projection to `topological_space` is\ndefinitionally equal to the induced topological space structure.\n\nWe also prove that a metric ball/closed ball/sphere in Poincar\u00e9 metric is a Euclidean ball/closed\nball/sphere with another center and radius.\n\n-/\n\n\nnoncomputable section\n\nopen UpperHalfPlane ComplexConjugate NNReal Topology MatrixGroups\n\nopen Set Metric Filter Real\n\nvariable {z w : \u210d} {r R : \u211d}\n\nnamespace UpperHalfPlane\n\ninstance : Dist \u210d :=\n  \u27e8fun z w => 2 * arsinh (dist (z : \u2102) w / (2 * sqrt (z.im * w.im)))\u27e9\n\ntheorem dist_eq (z w : \u210d) : dist z w = 2 * arsinh (dist (z : \u2102) w / (2 * sqrt (z.im * w.im))) :=\n  rfl\n#align upper_half_plane.dist_eq UpperHalfPlane.dist_eq\n\ntheorem sinh_half_dist (z w : \u210d) :\n    sinh (dist z w / 2) = dist (z : \u2102) w / (2 * sqrt (z.im * w.im)) := by\n  rw [dist_eq, mul_div_cancel_left (arsinh _) two_ne_zero, sinh_arsinh]\n#align upper_half_plane.sinh_half_dist UpperHalfPlane.sinh_half_dist\n\ntheorem cosh_half_dist (z w : \u210d) :\n    cosh (dist z w / 2) = dist (z : \u2102) (conj (w : \u2102)) / (2 * sqrt (z.im * w.im)) :=\n  by\n  have H\u2081 : (2 ^ 2 : \u211d) = 4 := by norm_num1\n  have H\u2082 : 0 < z.im * w.im := mul_pos z.im_pos w.im_pos\n  have H\u2083 : 0 < 2 * sqrt (z.im * w.im) := mul_pos two_pos (sqrt_pos.2 H\u2082)\n  rw [\u2190 sq_eq_sq (cosh_pos _).le (div_nonneg dist_nonneg H\u2083.le), cosh_sq', sinh_half_dist, div_pow,\n    div_pow, one_add_div (pow_ne_zero 2 H\u2083.ne'), mul_pow, sq_sqrt H\u2082.le, H\u2081]\n  congr 1\n  simp only [Complex.dist_eq, Complex.sq_abs, Complex.normSq_sub, Complex.normSq_conj,\n    Complex.conj_conj, Complex.mul_re, Complex.conj_re, Complex.conj_im, coe_im]\n  ring\n#align upper_half_plane.cosh_half_dist UpperHalfPlane.cosh_half_dist\n\ntheorem tanh_half_dist (z w : \u210d) : tanh (dist z w / 2) = dist (z : \u2102) w / dist (z : \u2102) (conj \u2191w) :=\n  by\n  rw [tanh_eq_sinh_div_cosh, sinh_half_dist, cosh_half_dist, div_div_div_comm, div_self, div_one]\n  exact (mul_pos (zero_lt_two' \u211d) (sqrt_pos.2 <| mul_pos z.im_pos w.im_pos)).ne'\n#align upper_half_plane.tanh_half_dist UpperHalfPlane.tanh_half_dist\n\ntheorem exp_half_dist (z w : \u210d) :\n    exp (dist z w / 2) = (dist (z : \u2102) w + dist (z : \u2102) (conj \u2191w)) / (2 * sqrt (z.im * w.im)) := by\n  rw [\u2190 sinh_add_cosh, sinh_half_dist, cosh_half_dist, add_div]\n#align upper_half_plane.exp_half_dist UpperHalfPlane.exp_half_dist\n\ntheorem cosh_dist (z w : \u210d) : cosh (dist z w) = 1 + dist (z : \u2102) w ^ 2 / (2 * z.im * w.im) := by\n  rw [dist_eq, cosh_two_mul, cosh_sq', add_assoc, \u2190 two_mul, sinh_arsinh, div_pow, mul_pow,\n    sq_sqrt (mul_pos z.im_pos w.im_pos).le, sq (2 : \u211d), mul_assoc, \u2190 mul_div_assoc, mul_assoc,\n    mul_div_mul_left _ _ (two_ne_zero' \u211d)]\n#align upper_half_plane.cosh_dist UpperHalfPlane.cosh_dist\n\ntheorem sinh_half_dist_add_dist (a b c : \u210d) :\n    sinh ((dist a b + dist b c) / 2) =\n      (dist (a : \u2102) b * dist (c : \u2102) (conj \u2191b) + dist (b : \u2102) c * dist (a : \u2102) (conj \u2191b)) /\n        (2 * sqrt (a.im * c.im) * dist (b : \u2102) (conj \u2191b)) :=\n  by\n  simp only [add_div _ _ (2 : \u211d), sinh_add, sinh_half_dist, cosh_half_dist, div_mul_div_comm]\n  rw [\u2190 add_div, Complex.dist_self_conj, coe_im, abs_of_pos b.im_pos, mul_comm (dist \u2191b _),\n    dist_comm (b : \u2102), Complex.dist_conj_comm, mul_mul_mul_comm, mul_mul_mul_comm _ _ _ b.im]\n  congr 2\n  rw [sqrt_mul, sqrt_mul, sqrt_mul, mul_comm (sqrt a.im), mul_mul_mul_comm, mul_self_sqrt,\n      mul_comm] <;>\n    exact (im_pos _).le\n#align upper_half_plane.sinh_half_dist_add_dist UpperHalfPlane.sinh_half_dist_add_dist\n\nprotected theorem dist_comm (z w : \u210d) : dist z w = dist w z := by\n  simp only [dist_eq, dist_comm (z : \u2102), mul_comm]\n#align upper_half_plane.dist_comm UpperHalfPlane.dist_comm\n\ntheorem dist_le_iff_le_sinh :\n    dist z w \u2264 r \u2194 dist (z : \u2102) w / (2 * sqrt (z.im * w.im)) \u2264 sinh (r / 2) := by\n  rw [\u2190 div_le_div_right (zero_lt_two' \u211d), \u2190 sinh_le_sinh, sinh_half_dist]\n#align upper_half_plane.dist_le_iff_le_sinh UpperHalfPlane.dist_le_iff_le_sinh\n\ntheorem dist_eq_iff_eq_sinh :\n    dist z w = r \u2194 dist (z : \u2102) w / (2 * sqrt (z.im * w.im)) = sinh (r / 2) := by\n  rw [\u2190 div_left_inj' (two_ne_zero' \u211d), \u2190 sinh_inj, sinh_half_dist]\n#align upper_half_plane.dist_eq_iff_eq_sinh UpperHalfPlane.dist_eq_iff_eq_sinh\n\ntheorem dist_eq_iff_eq_sq_sinh (hr : 0 \u2264 r) :\n    dist z w = r \u2194 dist (z : \u2102) w ^ 2 / (4 * z.im * w.im) = sinh (r / 2) ^ 2 :=\n  by\n  rw [dist_eq_iff_eq_sinh, \u2190 sq_eq_sq, div_pow, mul_pow, sq_sqrt, mul_assoc]\n  \u00b7 norm_num\n  \u00b7 exact (mul_pos z.im_pos w.im_pos).le\n  \u00b7 exact div_nonneg dist_nonneg (mul_nonneg zero_le_two <| sqrt_nonneg _)\n  \u00b7 exact sinh_nonneg_iff.2 (div_nonneg hr zero_le_two)\n#align upper_half_plane.dist_eq_iff_eq_sq_sinh UpperHalfPlane.dist_eq_iff_eq_sq_sinh\n\nprotected theorem dist_triangle (a b c : \u210d) : dist a c \u2264 dist a b + dist b c :=\n  by\n  rw [dist_le_iff_le_sinh, sinh_half_dist_add_dist, div_mul_eq_div_div _ _ (dist _ _), le_div_iff,\n    div_mul_eq_mul_div]\n  \u00b7\n    exact\n      div_le_div_of_le (mul_nonneg zero_le_two (sqrt_nonneg _))\n        (EuclideanGeometry.mul_dist_le_mul_dist_add_mul_dist (a : \u2102) b c (conj \u2191b))\n  \u00b7 rw [dist_comm, dist_pos, Ne.def, Complex.eq_conj_iff_im]\n    exact b.im_ne_zero\n#align upper_half_plane.dist_triangle UpperHalfPlane.dist_triangle\n\ntheorem dist_le_dist_coe_div_sqrt (z w : \u210d) : dist z w \u2264 dist (z : \u2102) w / sqrt (z.im * w.im) :=\n  by\n  rw [dist_le_iff_le_sinh, \u2190 div_mul_eq_div_div_swap, self_le_sinh_iff]\n  exact div_nonneg dist_nonneg (mul_nonneg zero_le_two (sqrt_nonneg _))\n#align upper_half_plane.dist_le_dist_coe_div_sqrt UpperHalfPlane.dist_le_dist_coe_div_sqrt\n\n/-- An auxiliary `metric_space` instance on the upper half-plane. This instance has bad projection\nto `topological_space`. We replace it later. -/\ndef metricSpaceAux : MetricSpace \u210d where\n  dist := dist\n  dist_self z := by rw [dist_eq, dist_self, zero_div, arsinh_zero, MulZeroClass.mul_zero]\n  dist_comm := UpperHalfPlane.dist_comm\n  dist_triangle := UpperHalfPlane.dist_triangle\n  eq_of_dist_eq_zero z w h := by\n    simpa [dist_eq, Real.sqrt_eq_zero', (mul_pos z.im_pos w.im_pos).not_le, Subtype.coe_inj] using h\n#align upper_half_plane.metric_space_aux UpperHalfPlane.metricSpaceAux\n\nopen Complex\n\ntheorem cosh_dist' (z w : \u210d) :\n    Real.cosh (dist z w) = ((z.re - w.re) ^ 2 + z.im ^ 2 + w.im ^ 2) / (2 * z.im * w.im) :=\n  by\n  have H : 0 < 2 * z.im * w.im := mul_pos (mul_pos two_pos z.im_pos) w.im_pos\n  field_simp [cosh_dist, Complex.dist_eq, Complex.sq_abs, norm_sq_apply, H, H.ne']\n  ring\n#align upper_half_plane.cosh_dist' UpperHalfPlane.cosh_dist'\n\n/-- Euclidean center of the circle with center `z` and radius `r` in the hyperbolic metric. -/\ndef center (z : \u210d) (r : \u211d) : \u210d :=\n  \u27e8\u27e8z.re, z.im * cosh r\u27e9, mul_pos z.im_pos (cosh_pos _)\u27e9\n#align upper_half_plane.center UpperHalfPlane.center\n\n@[simp]\ntheorem center_re (z r) : (center z r).re = z.re :=\n  rfl\n#align upper_half_plane.center_re UpperHalfPlane.center_re\n\n@[simp]\ntheorem center_im (z r) : (center z r).im = z.im * cosh r :=\n  rfl\n#align upper_half_plane.center_im UpperHalfPlane.center_im\n\n@[simp]\ntheorem center_zero (z : \u210d) : center z 0 = z :=\n  Subtype.ext <| ext rfl <| by rw [coe_im, coe_im, center_im, Real.cosh_zero, mul_one]\n#align upper_half_plane.center_zero UpperHalfPlane.center_zero\n\ntheorem dist_coe_center_sq (z w : \u210d) (r : \u211d) :\n    dist (z : \u2102) (w.center r) ^ 2 =\n      2 * z.im * w.im * (cosh (dist z w) - cosh r) + (w.im * sinh r) ^ 2 :=\n  by\n  have H : 2 * z.im * w.im \u2260 0 := by apply_rules [mul_ne_zero, two_ne_zero, im_ne_zero]\n  simp only [Complex.dist_eq, Complex.sq_abs, norm_sq_apply, coe_re, coe_im, center_re, center_im,\n    cosh_dist', mul_div_cancel' _ H, sub_sq z.im, mul_pow, Real.cosh_sq, sub_re, sub_im, mul_sub, \u2190\n    sq]\n  ring\n#align upper_half_plane.dist_coe_center_sq UpperHalfPlane.dist_coe_center_sq\n\ntheorem dist_coe_center (z w : \u210d) (r : \u211d) :\n    dist (z : \u2102) (w.center r) =\n      sqrt (2 * z.im * w.im * (cosh (dist z w) - cosh r) + (w.im * sinh r) ^ 2) :=\n  by rw [\u2190 sqrt_sq dist_nonneg, dist_coe_center_sq]\n#align upper_half_plane.dist_coe_center UpperHalfPlane.dist_coe_center\n\ntheorem cmp_dist_eq_cmp_dist_coe_center (z w : \u210d) (r : \u211d) :\n    cmp (dist z w) r = cmp (dist (z : \u2102) (w.center r)) (w.im * sinh r) :=\n  by\n  letI := metric_space_aux\n  cases' lt_or_le r 0 with hr\u2080 hr\u2080\n  \u00b7 trans Ordering.gt\n    exacts[(hr\u2080.trans_le dist_nonneg).cmp_eq_gt,\n      ((mul_neg_of_pos_of_neg w.im_pos (sinh_neg_iff.2 hr\u2080)).trans_le dist_nonneg).cmp_eq_gt.symm]\n  have hr\u2080' : 0 \u2264 w.im * sinh r := mul_nonneg w.im_pos.le (sinh_nonneg_iff.2 hr\u2080)\n  have hzw\u2080 : 0 < 2 * z.im * w.im := mul_pos (mul_pos two_pos z.im_pos) w.im_pos\n  simp only [\u2190 cosh_strict_mono_on.cmp_map_eq dist_nonneg hr\u2080, \u2190\n    (@strictMonoOn_pow \u211d _ _ two_pos).cmp_map_eq dist_nonneg hr\u2080', dist_coe_center_sq]\n  rw [\u2190 cmp_mul_pos_left hzw\u2080, \u2190 cmp_sub_zero, \u2190 mul_sub, \u2190 cmp_add_right, zero_add]\n#align upper_half_plane.cmp_dist_eq_cmp_dist_coe_center UpperHalfPlane.cmp_dist_eq_cmp_dist_coe_center\n\ntheorem dist_eq_iff_dist_coe_center_eq : dist z w = r \u2194 dist (z : \u2102) (w.center r) = w.im * sinh r :=\n  eq_iff_eq_of_cmp_eq_cmp (cmp_dist_eq_cmp_dist_coe_center z w r)\n#align upper_half_plane.dist_eq_iff_dist_coe_center_eq UpperHalfPlane.dist_eq_iff_dist_coe_center_eq\n\n@[simp]\ntheorem dist_self_center (z : \u210d) (r : \u211d) : dist (z : \u2102) (z.center r) = z.im * (cosh r - 1) :=\n  by\n  rw [dist_of_re_eq (z.center_re r).symm, dist_comm, Real.dist_eq, mul_sub, mul_one]\n  exact abs_of_nonneg (sub_nonneg.2 <| le_mul_of_one_le_right z.im_pos.le (one_le_cosh _))\n#align upper_half_plane.dist_self_center UpperHalfPlane.dist_self_center\n\n@[simp]\ntheorem dist_center_dist (z w : \u210d) : dist (z : \u2102) (w.center (dist z w)) = w.im * sinh (dist z w) :=\n  dist_eq_iff_dist_coe_center_eq.1 rfl\n#align upper_half_plane.dist_center_dist UpperHalfPlane.dist_center_dist\n\ntheorem dist_lt_iff_dist_coe_center_lt : dist z w < r \u2194 dist (z : \u2102) (w.center r) < w.im * sinh r :=\n  lt_iff_lt_of_cmp_eq_cmp (cmp_dist_eq_cmp_dist_coe_center z w r)\n#align upper_half_plane.dist_lt_iff_dist_coe_center_lt UpperHalfPlane.dist_lt_iff_dist_coe_center_lt\n\ntheorem lt_dist_iff_lt_dist_coe_center : r < dist z w \u2194 w.im * sinh r < dist (z : \u2102) (w.center r) :=\n  lt_iff_lt_of_cmp_eq_cmp (cmp_eq_cmp_symm.1 <| cmp_dist_eq_cmp_dist_coe_center z w r)\n#align upper_half_plane.lt_dist_iff_lt_dist_coe_center UpperHalfPlane.lt_dist_iff_lt_dist_coe_center\n\ntheorem dist_le_iff_dist_coe_center_le : dist z w \u2264 r \u2194 dist (z : \u2102) (w.center r) \u2264 w.im * sinh r :=\n  le_iff_le_of_cmp_eq_cmp (cmp_dist_eq_cmp_dist_coe_center z w r)\n#align upper_half_plane.dist_le_iff_dist_coe_center_le UpperHalfPlane.dist_le_iff_dist_coe_center_le\n\ntheorem le_dist_iff_le_dist_coe_center : r < dist z w \u2194 w.im * sinh r < dist (z : \u2102) (w.center r) :=\n  lt_iff_lt_of_cmp_eq_cmp (cmp_eq_cmp_symm.1 <| cmp_dist_eq_cmp_dist_coe_center z w r)\n#align upper_half_plane.le_dist_iff_le_dist_coe_center UpperHalfPlane.le_dist_iff_le_dist_coe_center\n\n/-- For two points on the same vertical line, the distance is equal to the distance between the\nlogarithms of their imaginary parts. -/\ntheorem dist_of_re_eq (h : z.re = w.re) : dist z w = dist (log z.im) (log w.im) :=\n  by\n  have h\u2080 : 0 < z.im / w.im := div_pos z.im_pos w.im_pos\n  rw [dist_eq_iff_dist_coe_center_eq, Real.dist_eq, \u2190 abs_sinh, \u2190 log_div z.im_ne_zero w.im_ne_zero,\n      sinh_log h\u2080, dist_of_re_eq, coe_im, coe_im, center_im, cosh_abs, cosh_log h\u2080, inv_div] <;>\n    [skip, exact h]\n  nth_rw 4 [\u2190 abs_of_pos w.im_pos]\n  simp only [\u2190 _root_.abs_mul, coe_im, Real.dist_eq]\n  congr 1\n  field_simp [z.im_pos, w.im_pos, z.im_ne_zero, w.im_ne_zero]\n  ring\n#align upper_half_plane.dist_of_re_eq UpperHalfPlane.dist_of_re_eq\n\n/-- Hyperbolic distance between two points is greater than or equal to the distance between the\nlogarithms of their imaginary parts. -/\ntheorem dist_log_im_le (z w : \u210d) : dist (log z.im) (log w.im) \u2264 dist z w :=\n  calc\n    dist (log z.im) (log w.im) = @dist \u210d _ \u27e8\u27e80, z.im\u27e9, z.im_pos\u27e9 \u27e8\u27e80, w.im\u27e9, w.im_pos\u27e9 :=\n      Eq.symm <| @dist_of_re_eq \u27e8\u27e80, z.im\u27e9, z.im_pos\u27e9 \u27e8\u27e80, w.im\u27e9, w.im_pos\u27e9 rfl\n    _ \u2264 dist z w :=\n      mul_le_mul_of_nonneg_left\n        (arsinh_le_arsinh.2 <|\n          div_le_div_of_le (mul_nonneg zero_le_two (sqrt_nonneg _)) <| by\n            simpa [sqrt_sq_eq_abs] using Complex.abs_im_le_abs (z - w))\n        zero_le_two\n    \n#align upper_half_plane.dist_log_im_le UpperHalfPlane.dist_log_im_le\n\ntheorem im_le_im_mul_exp_dist (z w : \u210d) : z.im \u2264 w.im * exp (dist z w) :=\n  by\n  rw [\u2190 div_le_iff' w.im_pos, \u2190 exp_log z.im_pos, \u2190 exp_log w.im_pos, \u2190 Real.exp_sub, exp_le_exp]\n  exact (le_abs_self _).trans (dist_log_im_le z w)\n#align upper_half_plane.im_le_im_mul_exp_dist UpperHalfPlane.im_le_im_mul_exp_dist\n\ntheorem im_div_exp_dist_le (z w : \u210d) : z.im / exp (dist z w) \u2264 w.im :=\n  (div_le_iff (exp_pos _)).2 (im_le_im_mul_exp_dist z w)\n#align upper_half_plane.im_div_exp_dist_le UpperHalfPlane.im_div_exp_dist_le\n\n/-- An upper estimate on the complex distance between two points in terms of the hyperbolic distance\nand the imaginary part of one of the points. -/\ntheorem dist_coe_le (z w : \u210d) : dist (z : \u2102) w \u2264 w.im * (exp (dist z w) - 1) :=\n  calc\n    dist (z : \u2102) w \u2264 dist (z : \u2102) (w.center (dist z w)) + dist (w : \u2102) (w.center (dist z w)) :=\n      dist_triangle_right _ _ _\n    _ = w.im * (exp (dist z w) - 1) := by\n      rw [dist_center_dist, dist_self_center, \u2190 mul_add, \u2190 add_sub_assoc, Real.sinh_add_cosh]\n    \n#align upper_half_plane.dist_coe_le UpperHalfPlane.dist_coe_le\n\n/-- An upper estimate on the complex distance between two points in terms of the hyperbolic distance\nand the imaginary part of one of the points. -/\ntheorem le_dist_coe (z w : \u210d) : w.im * (1 - exp (-dist z w)) \u2264 dist (z : \u2102) w :=\n  calc\n    w.im * (1 - exp (-dist z w)) =\n        dist (z : \u2102) (w.center (dist z w)) - dist (w : \u2102) (w.center (dist z w)) :=\n      by\n      rw [dist_center_dist, dist_self_center, \u2190 Real.cosh_sub_sinh]\n      ring\n    _ \u2264 dist (z : \u2102) w := sub_le_iff_le_add.2 <| dist_triangle _ _ _\n    \n#align upper_half_plane.le_dist_coe UpperHalfPlane.le_dist_coe\n\n/-- The hyperbolic metric on the upper half plane. We ensure that the projection to\n`topological_space` is definitionally equal to the subtype topology. -/\ninstance : MetricSpace \u210d :=\n  metricSpaceAux.replaceTopology <|\n    by\n    refine' le_antisymm (continuous_id_iff_le.1 _) _\n    \u00b7 refine' (@continuous_iff_continuous_dist _ _ metric_space_aux.to_pseudo_metric_space _ _).2 _\n      have : \u2200 x : \u210d \u00d7 \u210d, 2 * Real.sqrt (x.1.im * x.2.im) \u2260 0 := fun x =>\n        mul_ne_zero two_ne_zero (Real.sqrt_pos.2 <| mul_pos x.1.im_pos x.2.im_pos).ne'\n      -- `continuity` fails to apply `continuous.div`\n      apply_rules [Continuous.div, Continuous.mul, continuous_const, Continuous.arsinh,\n        Continuous.dist, continuous_coe.comp, continuous_fst, continuous_snd,\n        real.continuous_sqrt.comp, continuous_im.comp]\n    \u00b7 letI : MetricSpace \u210d := metric_space_aux\n      refine' le_of_nhds_le_nhds fun z => _\n      rw [nhds_induced]\n      refine' (nhds_basis_ball.le_basis_iff (nhds_basis_ball.comap _)).2 fun R hR => _\n      have h\u2081 : 1 < R / im z + 1 := lt_add_of_pos_left _ (div_pos hR z.im_pos)\n      have h\u2080 : 0 < R / im z + 1 := one_pos.trans h\u2081\n      refine' \u27e8log (R / im z + 1), Real.log_pos h\u2081, _\u27e9\n      refine' fun w hw => (dist_coe_le w z).trans_lt _\n      rwa [\u2190 lt_div_iff' z.im_pos, sub_lt_iff_lt_add, \u2190 Real.lt_log_iff_exp_lt h\u2080]\n\ntheorem im_pos_of_dist_center_le {z : \u210d} {r : \u211d} {w : \u2102} (h : dist w (center z r) \u2264 z.im * sinh r) :\n    0 < w.im :=\n  calc\n    0 < z.im * (cosh r - sinh r) := mul_pos z.im_pos (sub_pos.2 <| sinh_lt_cosh _)\n    _ = (z.center r).im - z.im * sinh r := (mul_sub _ _ _)\n    _ \u2264 (z.center r).im - dist (z.center r : \u2102) w := (sub_le_sub_left (by rwa [dist_comm]) _)\n    _ \u2264 w.im := sub_le_comm.1 <| (le_abs_self _).trans (abs_im_le_abs <| z.center r - w)\n    \n#align upper_half_plane.im_pos_of_dist_center_le UpperHalfPlane.im_pos_of_dist_center_le\n\ntheorem image_coe_closedBall (z : \u210d) (r : \u211d) :\n    (coe : \u210d \u2192 \u2102) '' closedBall z r = closedBall (z.center r) (z.im * sinh r) :=\n  by\n  ext w; constructor\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9\n    exact dist_le_iff_dist_coe_center_le.1 hw\n  \u00b7 intro hw\n    lift w to \u210d using im_pos_of_dist_center_le hw\n    exact mem_image_of_mem _ (dist_le_iff_dist_coe_center_le.2 hw)\n#align upper_half_plane.image_coe_closed_ball UpperHalfPlane.image_coe_closedBall\n\ntheorem image_coe_ball (z : \u210d) (r : \u211d) :\n    (coe : \u210d \u2192 \u2102) '' ball z r = ball (z.center r) (z.im * sinh r) :=\n  by\n  ext w; constructor\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9\n    exact dist_lt_iff_dist_coe_center_lt.1 hw\n  \u00b7 intro hw\n    lift w to \u210d using im_pos_of_dist_center_le (ball_subset_closed_ball hw)\n    exact mem_image_of_mem _ (dist_lt_iff_dist_coe_center_lt.2 hw)\n#align upper_half_plane.image_coe_ball UpperHalfPlane.image_coe_ball\n\ntheorem image_coe_sphere (z : \u210d) (r : \u211d) :\n    (coe : \u210d \u2192 \u2102) '' sphere z r = sphere (z.center r) (z.im * sinh r) :=\n  by\n  ext w; constructor\n  \u00b7 rintro \u27e8w, hw, rfl\u27e9\n    exact dist_eq_iff_dist_coe_center_eq.1 hw\n  \u00b7 intro hw\n    lift w to \u210d using im_pos_of_dist_center_le (sphere_subset_closed_ball hw)\n    exact mem_image_of_mem _ (dist_eq_iff_dist_coe_center_eq.2 hw)\n#align upper_half_plane.image_coe_sphere UpperHalfPlane.image_coe_sphere\n\ninstance : ProperSpace \u210d := by\n  refine' \u27e8fun z r => _\u27e9\n  rw [\u2190 inducing_coe.is_compact_iff, image_coe_closed_ball]\n  apply is_compact_closed_ball\n\ntheorem isometry_vertical_line (a : \u211d) : Isometry fun y => mk \u27e8a, exp y\u27e9 (exp_pos y) :=\n  by\n  refine' Isometry.of_dist_eq fun y\u2081 y\u2082 => _\n  rw [dist_of_re_eq]\n  exacts[congr_arg\u2082 _ (log_exp _) (log_exp _), rfl]\n#align upper_half_plane.isometry_vertical_line UpperHalfPlane.isometry_vertical_line\n\ntheorem isometry_real_vadd (a : \u211d) : Isometry ((\u00b7 +\u1d65 \u00b7) a : \u210d \u2192 \u210d) :=\n  Isometry.of_dist_eq fun y\u2081 y\u2082 => by simp only [dist_eq, coe_vadd, vadd_im, dist_add_left]\n#align upper_half_plane.isometry_real_vadd UpperHalfPlane.isometry_real_vadd\n\ntheorem isometry_pos_mul (a : { x : \u211d // 0 < x }) : Isometry ((\u00b7 \u2022 \u00b7) a : \u210d \u2192 \u210d) :=\n  by\n  refine' Isometry.of_dist_eq fun y\u2081 y\u2082 => _\n  simp only [dist_eq, coe_pos_real_smul, pos_real_im]; congr 2\n  rw [dist_smul\u2080, mul_mul_mul_comm, Real.sqrt_mul (mul_self_nonneg _), Real.sqrt_mul_self_eq_abs,\n    Real.norm_eq_abs, mul_left_comm]\n  exact mul_div_mul_left _ _ (mt _root_.abs_eq_zero.1 a.2.ne')\n#align upper_half_plane.isometry_pos_mul UpperHalfPlane.isometry_pos_mul\n\n/-- `SL(2, \u211d)` acts on the upper half plane as an isometry.-/\ninstance : IsometricSMul SL(2, \u211d) \u210d :=\n  \u27e8fun g =>\n    by\n    have h\u2080 : Isometry (fun z => ModularGroup.s \u2022 z : \u210d \u2192 \u210d) :=\n      Isometry.of_dist_eq fun y\u2081 y\u2082 =>\n        by\n        have h\u2081 : 0 \u2264 im y\u2081 * im y\u2082 := mul_nonneg y\u2081.property.le y\u2082.property.le\n        have h\u2082 : Complex.abs (y\u2081 * y\u2082) \u2260 0 := by simp [y\u2081.ne_zero, y\u2082.ne_zero]\n        simp only [dist_eq, modular_S_smul, inv_neg, neg_div, div_mul_div_comm, coe_mk, mk_im,\n          div_one, Complex.inv_im, Complex.neg_im, coe_im, neg_neg, Complex.normSq_neg,\n          mul_eq_mul_left_iff, Real.arsinh_inj, bit0_eq_zero, one_ne_zero, or_false_iff,\n          dist_neg_neg, mul_neg, neg_mul, dist_inv_inv\u2080 y\u2081.ne_zero y\u2082.ne_zero, \u2190 map_mul, \u2190\n          Complex.normSq_mul, Real.sqrt_div h\u2081, \u2190 Complex.abs_apply, mul_div (2 : \u211d),\n          div_div_div_comm, div_self h\u2082, Complex.norm_eq_abs]\n    by_cases hc : g 1 0 = 0\n    \u00b7 obtain \u27e8u, v, h\u27e9 := exists_SL2_smul_eq_of_apply_zero_one_eq_zero g hc\n      rw [h]\n      exact (isometry_real_vadd v).comp (isometry_pos_mul u)\n    \u00b7 obtain \u27e8u, v, w, h\u27e9 := exists_SL2_smul_eq_of_apply_zero_one_ne_zero g hc\n      rw [h]\n      exact\n        (isometry_real_vadd w).comp (h\u2080.comp <| (isometry_real_vadd v).comp <| isometry_pos_mul u)\u27e9\n\nend UpperHalfPlane\n\n"}
{"text": "-- Notes 11/26/2019\n\n\n-- false is not provable, except from a contradiction\n-- if we reach a proof of false, our proposition must be false\n\n-- false also implies anything\nexample : false \u2192 0 = 1 := false.elim\n\nexample : \u2200 (P : Prop), false \u2192 P := \u03bb (p), \u03bb (f), false.elim f\n\n#check @false.elim\n\n-- If we can show that P \u2192 false, then P must not be true\n-- No proof could exist for P\n\naxiom P : Prop\n\nexample : P \u2192 \u00acP \u2192 false := \nbegin\n    assume hp,\n    assume hnp,\n    contradiction\nend\n\nexample : P \u2192 \u00acP \u2192 false :=\n    \u03bb (hp),\n        \u03bb (hnp),\n            (hnp hp)\n\nexample : P \u2192 \u00ac P \u2192 0 = 1 :=\n    \u03bb (hp),\n        \u03bb (hnp),\n            false.elim (hnp hp)\n\nexample : P \u2192 (P \u2192 \u00ac P) \u2192 false :=\nbegin\n    assume hp,\n    assume pnp,\n    apply pnp hp,\n    exact hp,\nend\n\naxiom Q : Prop\naxiom q : Q\n\nexample : P \u2228 Q :=\nbegin\n    apply or.intro_right, -- or.intro_right lets you construct a proof of P \u2228 Q from Q\n    exact q,\nend\n\naxiom excluded_middle : \u2200 (P : Prop), P \u2228 \u00acP \n\nexample : P \u2228 \u00acP := \nbegin\n    exact (excluded_middle P),\nend\n\n-- or elimination : P \u2228 Q \u2192 (P \u2192 R) \u2192 (Q \u2192 R) \u2192 R\n-- if we have P or Q, and P implies R, and Q implies R, then R must be true!!\n\n\n-- case analysis\n\naxioms\n    (R : Prop)\n    (p : P)\n    (pr : P \u2192 R)\n    (qr : Q \u2192 R)\n\nexample : (P \u2228 Q) \u2192 R :=\nbegin\n    assume pq,\n    apply or.elim pq pr qr,\nend\n\nexample : (P \u2228 Q) \u2192 R :=\n    \u03bb pq,\n        match pq with\n        | or.inl hp := pr hp\n        | or.inr hq := qr hq\n        end\n\nexample : (P \u2228 Q) \u2192 R :=\nbegin\n    assume pq,\n    cases pq with hp hq,\n    apply pr hp,\n    apply qr hq,\nend"}
{"text": "informal statement If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$).formal statement theorem exercise_4_2a\n  {\u03b1 : Type} [metric_space \u03b1]\n  {\u03b2 : Type} [metric_space \u03b2]\n  (f : \u03b1 \u2192 \u03b2)\n  (h\u2081 : continuous f)\n  : \u2200 (x : set \u03b1), f '' (closure x) \u2286 closure (f '' x) :="}
{"text": "State Before: \u03b1 : Type u\n\u03b2 : Type v\n\u03b9 : Type ?u.76247\n\u03c0 : \u03b9 \u2192 Type ?u.76252\ninst\u271d\u00b9 : TopologicalSpace \u03b1\ninst\u271d : TopologicalSpace \u03b2\ns t : Set \u03b1\nh :\n  \u2200 {\u03b9 : Type u} (Z : \u03b9 \u2192 Set \u03b1),\n    (\u2200 (i : \u03b9), IsClosed (Z i)) \u2192 (\u22c2 (i : \u03b9), Z i) = \u2205 \u2192 \u2203 t, (\u22c2 (i : \u03b9) (_ : i \u2208 t), Z i) = \u2205\n\u03b9\u271d : Type u\nZ : \u03b9\u271d \u2192 Set \u03b1\n\u22a2 (\u2200 (i : \u03b9\u271d), IsClosed (Z i)) \u2192 (univ \u2229 \u22c2 (i : \u03b9\u271d), Z i) = \u2205 \u2192 \u2203 t, (univ \u2229 \u22c2 (i : \u03b9\u271d) (_ : i \u2208 t), Z i) = \u2205 State After: no goals Tactic: simpa using h Z"}
{"text": "lemma poly_shift_id [simp]: \"poly_shift 0 = (\\<lambda>x. x)\""}
{"text": "lemma psize_eq_0_iff [simp]: \"psize p = 0 \\<longleftrightarrow> p = 0\""}
{"text": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n\nimport number_theory.arithmetic_function\nimport number_theory.lucas_lehmer\nimport algebra.geom_sum\nimport ring_theory.multiplicity\n\n/-!\n# Perfect Numbers\n\nThis file proves Theorem 70 from the [100 Theorems List](https://www.cs.ru.nl/~freek/100/).\n\nThe theorem characterizes even perfect numbers.\n\nEuclid proved that if `2 ^ (k + 1) - 1` is prime (these primes are known as Mersenne primes),\n  then `2 ^ k * 2 ^ (k + 1) - 1` is perfect.\n\nEuler proved the converse, that if `n` is even and perfect, then there exists `k` such that\n  `n = 2 ^ k * 2 ^ (k + 1) - 1` and `2 ^ (k + 1) - 1` is prime.\n\n## References\nhttps://en.wikipedia.org/wiki/Euclid%E2%80%93Euler_theorem\n-/\n\nlemma odd_mersenne_succ (k : \u2115) : \u00ac 2 \u2223 mersenne (k + 1) :=\nby simp [\u2190 even_iff_two_dvd, \u2190 nat.even_succ, nat.succ_eq_add_one] with parity_simps\n\nnamespace nat\nopen arithmetic_function finset\nopen_locale arithmetic_function\n\nlemma sigma_two_pow_eq_mersenne_succ (k : \u2115) : \u03c3 1 (2 ^ k) = mersenne (k + 1) :=\nby simpa [mersenne, prime_two, \u2190 geom_sum_mul_add 1 (k+1)]\n\n\n/-- Euclid's theorem that Mersenne primes induce perfect numbers -/\ntheorem perfect_two_pow_mul_mersenne_of_prime (k : \u2115) (pr : (mersenne (k + 1)).prime) :\n  perfect ((2 ^ k) * mersenne (k + 1)) :=\nbegin\n  rw [perfect_iff_sum_divisors_eq_two_mul, \u2190 mul_assoc, \u2190 pow_succ, \u2190 sigma_one_apply, mul_comm,\n    is_multiplicative_sigma.map_mul_of_coprime\n        (nat.prime_two.coprime_pow_of_not_dvd (odd_mersenne_succ _)),\n    sigma_two_pow_eq_mersenne_succ],\n  { simp [pr, nat.prime_two] },\n  { apply mul_pos (pow_pos _ k) (mersenne_pos (nat.succ_pos k)),\n    norm_num }\nend\n\nlemma ne_zero_of_prime_mersenne (k : \u2115) (pr : (mersenne (k + 1)).prime) :\n  k \u2260 0 :=\nbegin\n  rintro rfl,\n  simpa [mersenne, not_prime_one] using pr,\nend\n\ntheorem even_two_pow_mul_mersenne_of_prime (k : \u2115) (pr : (mersenne (k + 1)).prime) :\n  even ((2 ^ k) * mersenne (k + 1)) :=\nby simp [ne_zero_of_prime_mersenne k pr] with parity_simps\n\nlemma eq_two_pow_mul_odd {n : \u2115} (hpos : 0 < n) :\n  \u2203 (k m : \u2115), n = 2 ^ k * m \u2227 \u00ac even m :=\nbegin\n  have h := (multiplicity.finite_nat_iff.2 \u27e8nat.prime_two.ne_one, hpos\u27e9),\n  cases multiplicity.pow_multiplicity_dvd h with m hm,\n  use [(multiplicity 2 n).get h, m],\n  refine \u27e8hm, _\u27e9,\n  rw even_iff_two_dvd,\n  have hg := multiplicity.is_greatest' h (nat.lt_succ_self _),\n  contrapose! hg,\n  rcases hg with \u27e8k, rfl\u27e9,\n  apply dvd.intro k,\n  rw [pow_succ', mul_assoc, \u2190 hm],\nend\n\n/-- Euler's theorem that even perfect numbers can be factored as a\n  power of two times a Mersenne prime. -/\ntheorem eq_two_pow_mul_prime_mersenne_of_even_perfect {n : \u2115} (ev : even n) (perf : perfect n) :\n  \u2203 (k : \u2115), prime (mersenne (k + 1)) \u2227 n = 2 ^ k * mersenne (k + 1) :=\nbegin\n  have hpos := perf.2,\n  rcases eq_two_pow_mul_odd hpos with \u27e8k, m, rfl, hm\u27e9,\n  use k,\n  rw [perfect_iff_sum_divisors_eq_two_mul hpos, \u2190 sigma_one_apply,\n    is_multiplicative_sigma.map_mul_of_coprime (nat.prime_two.coprime_pow_of_not_dvd hm).symm,\n    sigma_two_pow_eq_mersenne_succ, \u2190 mul_assoc, \u2190 pow_succ] at perf,\n  rcases nat.coprime.dvd_of_dvd_mul_left\n    (nat.prime_two.coprime_pow_of_not_dvd (odd_mersenne_succ _)) (dvd.intro _ perf) with \u27e8j, rfl\u27e9,\n  rw [\u2190 mul_assoc, mul_comm _ (mersenne _), mul_assoc] at perf,\n  have h := mul_left_cancel' (ne_of_gt (mersenne_pos (nat.succ_pos _))) perf,\n  rw [sigma_one_apply, sum_divisors_eq_sum_proper_divisors_add_self, \u2190 succ_mersenne, add_mul,\n    one_mul, add_comm] at h,\n  have hj := add_left_cancel h,\n  cases sum_proper_divisors_dvd (by { rw hj, apply dvd.intro_left (mersenne (k + 1)) rfl }),\n  { have j1 : j = 1 := eq.trans hj.symm h_1,\n    rw [j1, mul_one, sum_proper_divisors_eq_one_iff_prime] at h_1,\n    simp [h_1, j1] },\n  { have jcon := eq.trans hj.symm h_1,\n    rw [\u2190 one_mul j, \u2190 mul_assoc, mul_one] at jcon,\n    have jcon2 := mul_right_cancel' _ jcon,\n    { exfalso,\n      cases k,\n      { apply hm,\n        rw [\u2190 jcon2, pow_zero, one_mul, one_mul] at ev,\n        rw [\u2190 jcon2, one_mul],\n        exact ev },\n      apply ne_of_lt _ jcon2,\n      rw [mersenne, \u2190 nat.pred_eq_sub_one, lt_pred_iff, \u2190 pow_one (nat.succ 1)],\n      apply pow_lt_pow (nat.lt_succ_self 1) (nat.succ_lt_succ (nat.succ_pos k)) },\n    contrapose! hm,\n    simp [hm] }\nend\n\n/-- The Euclid-Euler theorem characterizing even perfect numbers -/\ntheorem even_and_perfect_iff {n : \u2115} :\n  (even n \u2227 perfect n) \u2194 \u2203 (k : \u2115), prime (mersenne (k + 1)) \u2227 n = 2 ^ k * mersenne (k + 1) :=\nbegin\n  split,\n  { rintro \u27e8ev, perf\u27e9,\n    exact eq_two_pow_mul_prime_mersenne_of_even_perfect ev perf },\n  { rintro \u27e8k, pr, rfl\u27e9,\n    exact \u27e8even_two_pow_mul_mersenne_of_prime k pr, perfect_two_pow_mul_mersenne_of_prime k pr\u27e9 }\nend\n\nend nat\n"}
{"text": "Require Import Program Arith.\n\nProgram Fixpoint check_n  (n : nat) (P : { i | i < n } -> bool) (p : nat)\n  (H : forall (i : { i | i < n }), i < p -> P i = true)\n  {measure (n - p)} :\n  Exc (forall (p : { i | i < n}), P p = true) :=\n  match le_lt_dec n p with\n  | left _ => value _\n  | right cmp =>\n      if dec (P p) then\n        check_n n P (S p) _\n      else\n        error\n  end.\n\nRequire Import Omega.\n\nSolve Obligations with program_simpl ; auto with *; try omega.\n\nNext Obligation.\n  apply H. simpl. omega.\nDefined.\n\nNext Obligation. \n  case (le_lt_dec p i) ; intros. assert(i = p) by omega. subst.\n  revert H0. clear_subset_proofs. auto.\n  apply H. simpl. assumption. Defined.\n"}
{"text": "/-\nCopyright (c) 2023 Mar\u00eda In\u00e9s de Frutos-Fern\u00e1ndez. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthor : Mar\u00eda In\u00e9s de Frutos-Fern\u00e1ndez\n-/\n\nimport tactic \nimport data.real.basic\n\n/-\n# L\u00edmites de secuencias en Lean\nEscribimos la definic\u00f3n `\u03b5` - `N` del l\u00edmite de una secuencia de\nn\u00fameros reales y demostramos resultados sobre l\u00edmites.\n\nNOTA: adaptado de los cursos de formalizaci\u00f3n de Kevin Buzzard.\n-/\n\n/- ### Notaci\u00f3n lambda (\u03bb) para funciones\nRecordatorio: para representar una funci\u00f3n `f` en Lean, utilizamos notaci\u00f3n lambda:\n`\u03bb x, f x` es la funci\u00f3n que asigna a `x` el valor `f (x)`. -/\n\ndef f : \u2115 \u2192 \u211d := \u03bb n, n^2 + 3 -- `f(n) = n^2 + 3`\n\nexample : f 3 = 12 :=\nbegin\n  rw f,\n  dsimp only, -- Para simplificar la aplicaci\u00f3n de funciones\n  norm_num, -- Normaliza expresiones num\u00e9ricas\nend\n\n/-\n## L\u00edmite de una secuencia\n-/\n\n/-- Si `a(n)` es una secuencia de n\u00fameros reales y `L` es un real,\n `tends_to a L` dice que el l\u00edmite de `a(n)` cuando `n \u2192 \u221e` es `L`. -/\ndef tends_to (a : \u2115 \u2192 \u211d) (L : \u211d) : Prop :=\n\u2200 \u03b5 > 0, \u2203 N : \u2115, \u2200 n, N \u2264 n \u2192 |a n - L| < \u03b5\n\n/-- Este lema nos permite reescribir la definici\u00f3n de `tends_to` en nuestras pruebas. -/\ntheorem tends_to_def {a : \u2115 \u2192 \u211d} {t : \u211d} :\n  tends_to a t \u2194 \u2200 \u03b5, 0 < \u03b5 \u2192 \u2203 B : \u2115, \u2200 n, B \u2264 n \u2192 |a n - t| < \u03b5 :=\nbegin\n  refl\nend\n\n/-\n## Ejercicios\n-/\n\n/-- El l\u00edmite de la secuencia constante con valor `c` es `c`. -/\ntheorem tends_to_const (c : \u211d) : tends_to (\u03bb n, c) c :=\nbegin\n  rw tends_to_def,\n  intros \u03b5 h\u03b5,\n  use 0,\n  intros n hn,\n  simp only [sub_self, abs_zero],\n  exact h\u03b5,\nend\n\n/-- Si `a(n)` tiende a `L` entonces `a(n) + c` tiende a `t + c` -/\ntheorem tends_to_add_const {a : \u2115 \u2192 \u211d} {L : \u211d} (c : \u211d)\n  (h : tends_to a L) :\n  tends_to (\u03bb n, a n + c) (L + c) :=\nbegin\n  intros \u03b5 h\u03b5,\n  specialize h \u03b5 h\u03b5,\n  cases h with N hN,\n  use N,\n  intros n hn,\n  dsimp only,\n  convert hN n hn using 1,\n  simp only [add_sub_add_right_eq_sub],\nend\n\n/-- Si `a(n)` tiende a `L`, entonces `-a(n)` tiende a `-L`.\nSi simplificar la expresi\u00f3n dentro del valor absoluto te est\u00e1\ndando problemas, ve a la hoja `reales.lean`.\n-/\ntheorem tends_to_neg {a : \u2115 \u2192 \u211d} {L : \u211d} (ha : tends_to a L) :\n  tends_to (\u03bb n, - a n) (-L) :=\nbegin\n  intros \u03b5 h\u03b5,\n  obtain \u27e8N, hN\u27e9 := ha \u03b5 h\u03b5,\n  use N,\n  intros n hn,\n  dsimp only,\n  rw [neg_sub_neg, abs_sub_comm],\n  exact hN n hn,\nend\n\n/-- Si `a(n)` tiende a `La` y `b(n)` tiende a `Lb` entonces `a(n) + b(n)`\ntiende a `La + Lb`.\nEsta demostraci\u00f3n es m\u00e1s complicada que las anteriores.\n-/\ntheorem tends_to_add {a b : \u2115 \u2192 \u211d} {La Lb : \u211d}\n  (ha : tends_to a La) (hb : tends_to b Lb) :\n  tends_to (\u03bb n, a n + b n) (La + Lb) :=\nbegin\n  intros \u03b5 h\u03b5,\n  obtain \u27e8Na, hNa\u27e9 := ha (\u03b5/2) (by linarith),\n  obtain \u27e8Nb, hNb\u27e9 := hb (\u03b5/2) (by linarith),\n  use max Na Nb,\n  intros n hn,\n  dsimp only,\n  rw max_le_iff at hn,\n  specialize hNa n hn.1,\n  specialize hNb n hn.2,\n  rw abs_lt at hNa hNb \u22a2,\n  split; -- El `;` en lugar de `,` hace que la siguiente instrucci\u00f3n se aplique a todas las metas.\n  linarith,\nend\n\n/-- Si `a(n)` tiende a `La` y `b(n)` tiende a `Lb` entonces `a(n) - b(n)`\ntiende a `La - Lb`. -/\ntheorem tends_to_sub {a b : \u2115 \u2192 \u211d} {La Lb : \u211d}\n  (ha : tends_to a La) (hb : tends_to b Lb) :\n  tends_to (\u03bb n, a n - b n) (La - Lb) :=\nbegin\n  exact tends_to_add ha (tends_to_neg hb),\nend\n\n/-- Si `a(n)` tiende a `L`, entonces `c*a(n)` tiende a `c*L`.\nPista: tratad el caso `c = 0` por separado, utilizando `by_cases hc : c = 0`.\n-/\nlemma tends_to_mul_const_left {a : \u2115 \u2192 \u211d} {L c : \u211d} (h : tends_to a L) :\n  tends_to (\u03bb n, c * (a n)) (c * L) := \nbegin\n  intros \u03b5 h\u03b5,\n  by_cases hc : c = 0,\n  { use 0,\n    intros n hn,\n    simp only [hc, zero_mul, tsub_zero, abs_zero],\n    exact h\u03b5 },\n  { have h\u03b5' : 0 < \u03b5/|c|,\n    { apply div_pos h\u03b5 (abs_pos.mpr hc) },  \n    obtain \u27e8N, hN\u27e9 := h (\u03b5/|c|) h\u03b5',\n    use N,\n    intros n hn,\n    dsimp only,\n    rw [\u2190 mul_sub, abs_mul, \u2190 lt_div_iff' (abs_pos.mpr hc)],\n    exact hN n hn,\n  }\nend\n\n/- Lema del sandwich. -/\ntheorem sandwich (a b c : \u2115 \u2192 \u211d) (L : \u211d) (ha : tends_to a L) (hc : tends_to c L) \n  (hab : \u2200 n, a n \u2264 b n) (hbc : \u2200 n, b n \u2264 c n) : \n  tends_to b L :=\nbegin\n  intros \u03b5 h\u03b5,\n  obtain \u27e8Na, hNa\u27e9 := ha \u03b5 h\u03b5,  \n  obtain \u27e8Nc, hNc\u27e9 := hc \u03b5 h\u03b5, \n  use max Na Nc,\n  intros n hn,\n  rw max_le_iff at hn,\n  specialize hNa n hn.1,\n  specialize hNc n hn.2,\n  rw abs_lt at hNa hNc \u22a2,\n  specialize hab n,\n  specialize hbc n,\n  split;\n  linarith,\nend\n"}
{"text": "informal statement Let $V$ be a vector space over an infinite field $F$. Show that $V$ cannot be the set-theoretic union of a finite number of proper subspaces of $V$.formal statement theorem exercise_5_3_10 : is_algebraic \u211a (cos (real.pi / 180)) :="}
{"text": "\npostulate\n  T : Set \u2192 Set\n  X : Set\n\n  Class : Set \u2192 Set\n  member : \u2200 {A} {{C : Class A}} \u2192 A \u2192 A\n\n  iX : Class X\n  iT : \u2200 {A} {{CA : Class A}} \u2192 Class (T A)\n\n-- Should get type Class (T X),\n-- not {{_ : Class X}} \u2192 Class (T X)\niTX = iT {A = X}\n\n-- Fails if not expanding instance argument in iTX\nf : T X \u2192 T X\nf = member\n"}
{"text": "(*\n * Copyright 2014, NICTA\n *\n * This software may be distributed and modified according to the terms of\n * the GNU General Public License version 2. Note that NO WARRANTY is provided.\n * See \"LICENSE_GPLv2.txt\" for details.\n *\n * @TAG(NICTA_GPL)\n *)\n\ntheory CToCRefine\n\nimports\n\t\"../../spec/cspec/Substitute\"\n    \"../SimplRewrite\"\n    \"../TypHeapLib\"\nbegin\n\nlemma spec_statefn_simulates_lookup_tree_Node:\n  \"\\<lbrakk> exec_statefn_simulates g UNIV UNIV v v';\n     spec_statefn_simulates g (lookup_tree a f) (lookup_tree c f);\n     spec_statefn_simulates g (lookup_tree b f) (lookup_tree d f) \\<rbrakk>\n    \\<Longrightarrow> spec_statefn_simulates g (lookup_tree (Node n v a b) f) (lookup_tree (Node n v' c d) f)\"\n  by (simp add: spec_statefn_simulates_def)\n\nlemma spec_statefn_simulates_lookup_tree_Leaf:\n  \"spec_statefn_simulates g (lookup_tree Leaf f) (lookup_tree Leaf f')\"\n  by (simp add: spec_statefn_simulates_def)\n\nML {*\nfun mk_meta_eq_safe t = mk_meta_eq t\n  handle THM _ => t;\n\nval unfold_bodies = Simplifier.make_simproc @{context} \"unfold constants named *_body\"\n  {lhss = [@{term \"v\"}],\n   proc= fn _ =>\n  (fn ctxt => (fn t => case head_of (Thm.term_of t) of\n    Const (s, _) => if String.isSuffix \"_body\" s\n       then try (Global_Theory.get_thm (Proof_Context.theory_of ctxt) #> mk_meta_eq_safe) (suffix \"_def\" s)\n       else NONE\n   | _ => NONE))}\n*}\n\ntheorem spec_refine:\n  notes if_split[split del]\n  shows\n  \"spec_statefn_simulates id (kernel_all_global_addresses.\\<Gamma> symbol_table)\n     (kernel_all_substitute.\\<Gamma> symbol_table domain)\"\n  apply (simp add: kernel_all_global_addresses.\\<Gamma>_def kernel_all_substitute.\\<Gamma>_def)\n  apply (intro spec_statefn_simulates_lookup_tree_Node spec_statefn_simulates_lookup_tree_Leaf)\n  apply (tactic {* ALLGOALS (asm_simp_tac (put_simpset HOL_ss @{context} addsimps @{thms switch.simps fst_conv snd_conv}\n                  addsimprocs [unfold_bodies] |> Splitter.del_split @{thm if_split}))\n              THEN ALLGOALS (TRY o resolve_tac @{context} @{thms exec_statefn_simulates_refl}) *})\n\n  apply (tactic {* ALLGOALS (REPEAT_ALL_NEW (resolve_tac @{context} @{thms exec_statefn_simulates_comI\n                      exec_statefn_simulates_additionals})) *})\n  apply (unfold id_apply)\n  apply (tactic {* ALLGOALS (TRY o resolve_tac @{context} @{thms refl bij_id}) *})\n  apply (tactic {* ALLGOALS (TRY o (resolve_tac @{context} @{thms subsetI} THEN' resolve_tac @{context} @{thms CollectI}\n           THEN' REPEAT_ALL_NEW (eresolve_tac @{context} @{thms IntE CollectE conjE exE h_t_valid_c_guard conjI} ORELSE' assume_tac @{context}))) *})\n  (*\n    apply (tactic {* ALLGOALS (TRY o ((REPEAT_ALL_NEW (rtac @{thm c_guard_field}) THEN' etac @{thm h_t_valid_c_guard})\n                          THEN_ALL_NEW simp_tac @{simpset}\n                          THEN_ALL_NEW simp_tac @{simpset}\n                          THEN_ALL_NEW K no_tac))  *})\n  *)\n  apply (rule bij_id[simplified id_def])+\n  done (* Woo! *)\n\nend\n\n"}
{"text": "import Smt\n\ntheorem refl (p : Prop) : p = p := by\n  smt\n"}
{"text": "State Before: V : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\np : Walk G u v\nH : SimpleGraph V\nhp : \u2200 (e : Sym2 V), e \u2208 edges p \u2192 e \u2208 edgeSet H\npp : IsPath p\n\u22a2 IsPath (Walk.transfer p H hp) State After: no goals Tactic: induction p with\n| nil => simp\n| cons _ _ ih =>\n  simp only [Walk.transfer, cons_isPath_iff, support_transfer _ ] at pp \u22a2\n  exact \u27e8ih _ pp.1, pp.2\u27e9 State Before: case nil\nV : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\np : Walk G u v\nH : SimpleGraph V\nu\u271d : V\nhp : \u2200 (e : Sym2 V), e \u2208 edges Walk.nil \u2192 e \u2208 edgeSet H\npp : IsPath Walk.nil\n\u22a2 IsPath (Walk.transfer Walk.nil H hp) State After: no goals Tactic: simp State Before: case cons\nV : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\np : Walk G u v\nH : SimpleGraph V\nu\u271d v\u271d w\u271d : V\nh\u271d : Adj G u\u271d v\u271d\np\u271d : Walk G v\u271d w\u271d\nih : \u2200 (hp : \u2200 (e : Sym2 V), e \u2208 edges p\u271d \u2192 e \u2208 edgeSet H), IsPath p\u271d \u2192 IsPath (Walk.transfer p\u271d H hp)\nhp : \u2200 (e : Sym2 V), e \u2208 edges (cons h\u271d p\u271d) \u2192 e \u2208 edgeSet H\npp : IsPath (cons h\u271d p\u271d)\n\u22a2 IsPath (Walk.transfer (cons h\u271d p\u271d) H hp) State After: case cons\nV : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\np : Walk G u v\nH : SimpleGraph V\nu\u271d v\u271d w\u271d : V\nh\u271d : Adj G u\u271d v\u271d\np\u271d : Walk G v\u271d w\u271d\nih : \u2200 (hp : \u2200 (e : Sym2 V), e \u2208 edges p\u271d \u2192 e \u2208 edgeSet H), IsPath p\u271d \u2192 IsPath (Walk.transfer p\u271d H hp)\nhp : \u2200 (e : Sym2 V), e \u2208 edges (cons h\u271d p\u271d) \u2192 e \u2208 edgeSet H\npp : IsPath p\u271d \u2227 \u00acu\u271d \u2208 support p\u271d\n\u22a2 IsPath (Walk.transfer p\u271d H (_ : \u2200 (e : Sym2 V), e \u2208 edges p\u271d \u2192 e \u2208 edgeSet H)) \u2227 \u00acu\u271d \u2208 support p\u271d Tactic: simp only [Walk.transfer, cons_isPath_iff, support_transfer _ ] at pp \u22a2 State Before: case cons\nV : Type u\nV' : Type v\nV'' : Type w\nG : SimpleGraph V\nG' : SimpleGraph V'\nG'' : SimpleGraph V''\nu v : V\np : Walk G u v\nH : SimpleGraph V\nu\u271d v\u271d w\u271d : V\nh\u271d : Adj G u\u271d v\u271d\np\u271d : Walk G v\u271d w\u271d\nih : \u2200 (hp : \u2200 (e : Sym2 V), e \u2208 edges p\u271d \u2192 e \u2208 edgeSet H), IsPath p\u271d \u2192 IsPath (Walk.transfer p\u271d H hp)\nhp : \u2200 (e : Sym2 V), e \u2208 edges (cons h\u271d p\u271d) \u2192 e \u2208 edgeSet H\npp : IsPath p\u271d \u2227 \u00acu\u271d \u2208 support p\u271d\n\u22a2 IsPath (Walk.transfer p\u271d H (_ : \u2200 (e : Sym2 V), e \u2208 edges p\u271d \u2192 e \u2208 edgeSet H)) \u2227 \u00acu\u271d \u2208 support p\u271d State After: no goals Tactic: exact \u27e8ih _ pp.1, pp.2\u27e9"}
{"text": "header {* \\isaheader{Generic Compare Algorithms} *}\ntheory Gen_Comp\nimports \n  \"../Intf/Intf_Comp\" \n  \"../../../Automatic_Refinement/Automatic_Refinement\"\nbegin\n\nsubsection {* Order for Product *}\n(* TODO: Optimization? Or only go via prod_cmp? *)\nlemma autoref_prod_cmp_dflt_id[autoref_rules_raw]: \n  \"(dflt_cmp op \\<le> op <, dflt_cmp op \\<le> op <) \\<in>\n    \\<langle>Id,Id\\<rangle>prod_rel \\<rightarrow> \\<langle>Id,Id\\<rangle>prod_rel \\<rightarrow> Id\"\n  by auto\n\nlemma gen_prod_cmp_dflt[autoref_rules_raw]:\n  assumes PRIO_TAG_GEN_ALGO\n  assumes \"GEN_OP cmp1 (dflt_cmp op \\<le> op <) (R1 \\<rightarrow> R1 \\<rightarrow> Id)\"\n  assumes \"GEN_OP cmp2 (dflt_cmp op \\<le> op <) (R2 \\<rightarrow> R2 \\<rightarrow> Id)\"\n  shows \"(cmp_prod cmp1 cmp2, dflt_cmp op \\<le> op <) \\<in>\n    \\<langle>R1,R2\\<rangle>prod_rel \\<rightarrow> \\<langle>R1,R2\\<rangle>prod_rel \\<rightarrow> Id\"\nproof -\n  have E: \"dflt_cmp op \\<le> op < \n    = cmp_prod (dflt_cmp op \\<le> op <) (dflt_cmp op \\<le> op <)\"\n    by (auto simp: dflt_cmp_def prod_less_def prod_le_def intro!: ext)\n\n  show ?thesis\n    using assms\n    unfolding autoref_tag_defs E\n    by parametricity\nqed\n\n\nend\n"}
{"text": "State Before: q : \u211a\nx y : \u211d\n\u22a2 Irrational (x + y) \u2192 Irrational x \u2228 Irrational y State After: q : \u211a\nx y : \u211d\n\u22a2 \u00acx + y \u2208 Set.range Rat.cast \u2192 \u00acx \u2208 Set.range Rat.cast \u2228 \u00acy \u2208 Set.range Rat.cast Tactic: delta Irrational State Before: q : \u211a\nx y : \u211d\n\u22a2 \u00acx + y \u2208 Set.range Rat.cast \u2192 \u00acx \u2208 Set.range Rat.cast \u2228 \u00acy \u2208 Set.range Rat.cast State After: q : \u211a\nx y : \u211d\n\u22a2 x \u2208 Set.range Rat.cast \u2227 y \u2208 Set.range Rat.cast \u2192 x + y \u2208 Set.range Rat.cast Tactic: contrapose! State Before: q : \u211a\nx y : \u211d\n\u22a2 x \u2208 Set.range Rat.cast \u2227 y \u2208 Set.range Rat.cast \u2192 x + y \u2208 Set.range Rat.cast State After: case intro.intro.intro\nq rx ry : \u211a\n\u22a2 \u2191rx + \u2191ry \u2208 Set.range Rat.cast Tactic: rintro \u27e8\u27e8rx, rfl\u27e9, \u27e8ry, rfl\u27e9\u27e9 State Before: case intro.intro.intro\nq rx ry : \u211a\n\u22a2 \u2191rx + \u2191ry \u2208 Set.range Rat.cast State After: no goals Tactic: exact \u27e8rx + ry, cast_add rx ry\u27e9"}
{"text": "lemma reflect_poly_1 [simp]: \"reflect_poly 1 = 1\""}
{"text": "/-\nCopyright (c) 2023 David Loeffler. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Loeffler\n\n! This file was ported from Lean 3 source module number_theory.modular_forms.jacobi_theta\n! leanprover-community/mathlib commit fe44cd36149e675eb5dec87acc7e8f1d6568e081\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.NumberTheory.ModularForms.Basic\nimport Mathbin.Analysis.SpecialFunctions.Gaussian\nimport Mathbin.Analysis.Calculus.Series\nimport Mathbin.Analysis.Complex.LocallyUniformLimit\n\n/-! # Jacobi's theta function\n\nThis file defines the Jacobi theta function\n\n$$\\theta(\\tau) = \\sum_{n \\in \\mathbb{Z}} \\exp (i \\pi n ^ 2 \\tau),$$\n\nand proves the modular transformation properties `\u03b8 (\u03c4 + 2) = \u03b8 \u03c4` and\n`\u03b8 (-1 / \u03c4) = (-I * \u03c4) ^ (1 / 2) * \u03b8 \u03c4`, using Poisson's summation formula for the latter. We also\nshow that `\u03b8` is differentiable on `\u210d`, and `\u03b8(\u03c4) - 1` has exponential decay as `im \u03c4 \u2192 \u221e`.\n-/\n\n\nopen Complex Real Asymptotics\n\nopen Real BigOperators UpperHalfPlane Manifold\n\n/-- Jacobi's theta function `\u2211' (n : \u2124), exp (\u03c0 * I * n ^ 2 * \u03c4)`. -/\nnoncomputable def jacobiTheta (\u03c4 : \u210d) : \u2102 :=\n  \u2211' n : \u2124, cexp (\u03c0 * I * n ^ 2 * \u03c4)\n#align jacobi_theta jacobiTheta\n\ntheorem norm_exp_mul_sq_le {z : \u2102} (hz : 0 < z.im) (n : \u2124) :\n    \u2016cexp (\u03c0 * I * n ^ 2 * z)\u2016 \u2264 exp (-\u03c0 * z.im) ^ n.natAbs :=\n  by\n  let y := rexp (-\u03c0 * z.im)\n  have h : y < 1 := exp_lt_one_iff.mpr (mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hz)\n  refine' (le_of_eq _).trans (_ : y ^ n ^ 2 \u2264 _)\n  \u00b7 rw [Complex.norm_eq_abs, Complex.abs_exp]\n    have : (\u2191\u03c0 * I * n ^ 2 * z).re = -\u03c0 * z.im * n ^ 2 :=\n      by\n      rw [(by\n          push_cast\n          ring : \u2191\u03c0 * I * n ^ 2 * z = \u2191(\u03c0 * n ^ 2) * (z * I)),\n        of_real_mul_re, mul_I_re]\n      ring\n    obtain \u27e8m, hm\u27e9 := Int.eq_ofNat_of_zero_le (sq_nonneg n)\n    rw [this, exp_mul, \u2190 Int.cast_pow, rpow_int_cast, hm, zpow_ofNat]\n  \u00b7 have : n ^ 2 = \u2191(n.nat_abs ^ 2) := by rw [Nat.cast_pow, Int.natAbs_sq]\n    rw [this, zpow_ofNat]\n    exact pow_le_pow_of_le_one (exp_pos _).le h.le ((sq n.nat_abs).symm \u25b8 n.nat_abs.le_mul_self)\n#align norm_exp_mul_sq_le norm_exp_mul_sq_le\n\ntheorem exists_summable_bound_exp_mul_sq {R : \u211d} (hR : 0 < R) :\n    \u2203 bd : \u2124 \u2192 \u211d,\n      Summable bd \u2227 \u2200 {\u03c4 : \u2102} (h\u03c4 : R \u2264 \u03c4.im) (n : \u2124), \u2016cexp (\u03c0 * I * n ^ 2 * \u03c4)\u2016 \u2264 bd n :=\n  by\n  let y := rexp (-\u03c0 * R)\n  have h : y < 1 := exp_lt_one_iff.mpr (mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) hR)\n  refine' \u27e8fun n => y ^ n.natAbs, summable_int_of_summable_nat _ _, fun \u03c4 h\u03c4 n => _\u27e9\n  pick_goal 3\n  \u00b7 refine' (norm_exp_mul_sq_le (hR.trans_le h\u03c4) n).trans _\n    refine' pow_le_pow_of_le_left (exp_pos _).le (real.exp_le_exp.mpr _) _\n    rwa [mul_le_mul_left_of_neg (neg_lt_zero.mpr pi_pos)]\n  all_goals\n    simpa only [Int.natAbs_neg, Int.natAbs_ofNat] using\n      summable_geometric_of_lt_1 (Real.exp_pos _).le h\n#align exists_summable_bound_exp_mul_sq exists_summable_bound_exp_mul_sq\n\ntheorem summable_exp_mul_sq {z : \u2102} (hz : 0 < z.im) :\n    Summable fun n : \u2124 => cexp (\u03c0 * I * n ^ 2 * z) :=\n  let \u27e8bd, h, h'\u27e9 := exists_summable_bound_exp_mul_sq hz\n  summable_norm_iff.mp (summable_of_nonneg_of_le (fun n => norm_nonneg _) (h' <| le_refl _) h)\n#align summable_exp_mul_sq summable_exp_mul_sq\n\ntheorem jacobiTheta_two_vadd (\u03c4 : \u210d) : jacobiTheta ((2 : \u211d) +\u1d65 \u03c4) = jacobiTheta \u03c4 :=\n  by\n  refine' tsum_congr fun n => _\n  rw [UpperHalfPlane.coe_vadd, of_real_bit0, of_real_one]\n  suffices cexp (\u2191\u03c0 * I * \u2191n ^ 2 * 2) = 1 by rw [mul_add, Complex.exp_add, this, one_mul]\n  rw [(by\n      push_cast\n      ring : \u2191\u03c0 * I * \u2191n ^ 2 * 2 = \u2191(n ^ 2) * (2 * \u03c0 * I)),\n    Complex.exp_int_mul, Complex.exp_two_pi_mul_i, one_zpow]\n#align jacobi_theta_two_vadd jacobiTheta_two_vadd\n\ntheorem jacobiTheta_t_sq_smul (\u03c4 : \u210d) : jacobiTheta (ModularGroup.t ^ 2 \u2022 \u03c4) = jacobiTheta \u03c4 :=\n  by\n  suffices : (2 : \u211d) +\u1d65 \u03c4 = ModularGroup.t ^ (2 : \u2124) \u2022 \u03c4; exact this \u25b8 jacobiTheta_two_vadd \u03c4\n  simp only [\u2190 Subtype.coe_inj, UpperHalfPlane.modular_t_zpow_smul, Int.cast_two]\n#align jacobi_theta_T_sq_smul jacobiTheta_t_sq_smul\n\ntheorem jacobiTheta_s_smul (\u03c4 : \u210d) :\n    jacobiTheta (ModularGroup.s \u2022 \u03c4) = (-I * \u03c4) ^ (1 / 2 : \u2102) * jacobiTheta \u03c4 :=\n  by\n  unfold jacobiTheta\n  rw [UpperHalfPlane.modular_s_smul, UpperHalfPlane.coe_mk]\n  have ha : 0 < (-I * \u03c4).re :=\n    by\n    rw [neg_mul, neg_re, mul_re, I_re, I_im, MulZeroClass.zero_mul, one_mul, zero_sub, neg_neg]\n    exact \u03c4.im_pos\n  have ha' : (-I * \u03c4) ^ (1 / 2 : \u2102) \u2260 0 :=\n    by\n    rw [Ne.def, cpow_eq_zero_iff]\n    contrapose! ha\n    rw [ha.1, zero_re]\n  have h\u03c4 : (\u03c4 : \u2102) \u2260 0 := \u03c4.ne_zero\n  have := Complex.tsum_exp_neg_mul_int_sq ha\n  rw [mul_comm ((1 : \u2102) / _) _, mul_one_div, eq_div_iff ha', mul_comm _ (_ ^ _), eq_comm] at this\n  convert this using 3\n  \u00b7 ext1 n\n    congr 1\n    field_simp [h\u03c4, I_ne_zero]\n    ring_nf\n    rw [I_sq, mul_neg, mul_one, neg_mul, neg_neg]\n  \u00b7 ext1 n\n    congr 1\n    ring_nf\n#align jacobi_theta_S_smul jacobiTheta_s_smul\n\ntheorem hasSum_nat_jacobiTheta (\u03c4 : \u210d) :\n    HasSum (fun n : \u2115 => cexp (\u03c0 * I * (n + 1) ^ 2 * \u03c4)) ((jacobiTheta \u03c4 - 1) / 2) :=\n  by\n  have := (summable_exp_mul_sq \u03c4.im_pos).HasSum.sum_nat_of_sum_int\n  rw [\u2190 @hasSum_nat_add_iff' \u2102 _ _ _ _ 1] at this\n  simp_rw [Finset.sum_range_one, Int.cast_neg, Int.cast_ofNat, Nat.cast_zero, neg_zero,\n    Int.cast_zero, sq (0 : \u2102), MulZeroClass.mul_zero, MulZeroClass.zero_mul, neg_sq, \u2190 mul_two,\n    Complex.exp_zero, add_sub_assoc, (by norm_num : (1 : \u2102) - 1 * 2 = -1), \u2190 sub_eq_add_neg,\n    Nat.cast_add, Nat.cast_one] at this\n  convert this.div_const 2\n  simp_rw [mul_div_cancel _ two_ne_zero]\n#align has_sum_nat_jacobi_theta hasSum_nat_jacobiTheta\n\ntheorem jacobiTheta_eq_tsum_nat (\u03c4 : \u210d) :\n    jacobiTheta \u03c4 = 1 + 2 * \u2211' n : \u2115, cexp (\u03c0 * I * (n + 1) ^ 2 * \u03c4) := by\n  rw [(hasSum_nat_jacobiTheta \u03c4).tsum_eq, mul_div_cancel' _ (two_ne_zero' \u2102), \u2190 add_sub_assoc,\n    add_sub_cancel']\n#align jacobi_theta_eq_tsum_nat jacobiTheta_eq_tsum_nat\n\n/-- An explicit upper bound for `\u2016jacobi_theta \u03c4 - 1\u2016`. -/\ntheorem norm_jacobiTheta_sub_one_le (\u03c4 : \u210d) :\n    \u2016jacobiTheta \u03c4 - 1\u2016 \u2264 2 / (1 - exp (-\u03c0 * \u03c4.im)) * exp (-\u03c0 * \u03c4.im) :=\n  by\n  suffices \u2016\u2211' n : \u2115, cexp (\u03c0 * I * (n + 1) ^ 2 * \u03c4)\u2016 \u2264 exp (-\u03c0 * \u03c4.im) / (1 - exp (-\u03c0 * \u03c4.im)) by\n    calc\n      \u2016jacobiTheta \u03c4 - 1\u2016 = 2 * \u2016\u2211' n : \u2115, cexp (\u03c0 * I * (n + 1) ^ 2 * \u03c4)\u2016 := by\n        rw [sub_eq_iff_eq_add'.mpr (jacobiTheta_eq_tsum_nat \u03c4), norm_mul, Complex.norm_eq_abs,\n          Complex.abs_two]\n      _ \u2264 2 * (rexp (-\u03c0 * \u03c4.im) / (1 - rexp (-\u03c0 * \u03c4.im))) := by\n        rwa [mul_le_mul_left (zero_lt_two' \u211d)]\n      _ = 2 / (1 - rexp (-\u03c0 * \u03c4.im)) * rexp (-\u03c0 * \u03c4.im) := by rw [div_mul_comm, mul_comm]\n      \n  have : \u2200 n : \u2115, \u2016cexp (\u03c0 * I * (n + 1) ^ 2 * \u03c4)\u2016 \u2264 exp (-\u03c0 * \u03c4.im) ^ (n + 1) :=\n    by\n    intro n\n    simpa only [Int.cast_add, Int.cast_one] using norm_exp_mul_sq_le \u03c4.im_pos (n + 1)\n  have s :\n    HasSum (fun n : \u2115 => rexp (-\u03c0 * \u03c4.im) ^ (n + 1)) (exp (-\u03c0 * \u03c4.im) / (1 - exp (-\u03c0 * \u03c4.im))) :=\n    by\n    simp_rw [pow_succ, div_eq_mul_inv, hasSum_mul_left_iff (Real.exp_ne_zero _)]\n    exact\n      hasSum_geometric_of_lt_1 (exp_pos (-\u03c0 * \u03c4.im)).le\n        (exp_lt_one_iff.mpr <| mul_neg_of_neg_of_pos (neg_lt_zero.mpr pi_pos) \u03c4.im_pos)\n  have aux : Summable fun n : \u2115 => \u2016cexp (\u2191\u03c0 * I * (\u2191n + 1) ^ 2 * \u2191\u03c4)\u2016 :=\n    summable_of_nonneg_of_le (fun n => norm_nonneg _) this s.summable\n  exact\n    (norm_tsum_le_tsum_norm aux).trans ((tsum_mono aux s.summable this).trans (le_of_eq s.tsum_eq))\n#align norm_jacobi_theta_sub_one_le norm_jacobiTheta_sub_one_le\n\n/-- The norm of `jacobi_theta \u03c4 - 1` decays exponentially as `im \u03c4 \u2192 \u221e`. -/\ntheorem isO_atImInfty_jacobiTheta_sub_one :\n    IsO UpperHalfPlane.atImInfty (fun \u03c4 => jacobiTheta \u03c4 - 1) fun \u03c4 => rexp (-\u03c0 * \u03c4.im) :=\n  by\n  simp_rw [is_O, is_O_with, Filter.Eventually, UpperHalfPlane.atImInfty_mem]\n  refine' \u27e82 / (1 - rexp (-\u03c0)), 1, fun \u03c4 h\u03c4 => (norm_jacobiTheta_sub_one_le \u03c4).trans _\u27e9\n  rw [Real.norm_eq_abs, Real.abs_exp]\n  refine' mul_le_mul_of_nonneg_right _ (exp_pos _).le\n  rw [div_le_div_left (zero_lt_two' \u211d), sub_le_sub_iff_left, exp_le_exp, neg_mul, neg_le_neg_iff]\n  \u00b7 exact le_mul_of_one_le_right pi_pos.le h\u03c4\n  \u00b7 rw [sub_pos, exp_lt_one_iff, neg_mul, neg_lt_zero]\n    exact mul_pos pi_pos \u03c4.im_pos\n  \u00b7 rw [sub_pos, exp_lt_one_iff, neg_lt_zero]\n    exact pi_pos\n#align is_O_at_im_infty_jacobi_theta_sub_one isO_atImInfty_jacobiTheta_sub_one\n\ntheorem differentiableAt_tsum_exp_mul_sq (\u03c4 : \u210d) :\n    DifferentiableAt \u2102 (fun z => \u2211' n : \u2124, cexp (\u03c0 * I * n ^ 2 * z)) \u2191\u03c4 :=\n  by\n  suffices :\n    \u2200 (y : \u211d) (hy : 0 < y),\n      DifferentiableOn \u2102 (fun z => \u2211' n : \u2124, cexp (\u03c0 * I * n ^ 2 * z)) { w : \u2102 | y < im w }\n  exact\n    let \u27e8y, hy, hy'\u27e9 := exists_between \u03c4.im_pos\n    (this y hy).DifferentiableAt\n      ((complex.continuous_im.is_open_preimage _ isOpen_Ioi).mem_nhds (\u03c4.coe_im \u25b8 hy'))\n  intro y hy\n  have h1 :\n    \u2200 (n : \u2124) (w : \u2102) (hw : y < im w),\n      DifferentiableWithinAt \u2102 (fun v : \u2102 => cexp (\u2191\u03c0 * I * \u2191n ^ 2 * v)) { z : \u2102 | y < im z } w :=\n    fun n w hw => (differentiable_at_id.const_mul _).cexp.DifferentiableWithinAt\n  have h2 : IsOpen { w : \u2102 | y < im w } := continuous_im.is_open_preimage _ isOpen_Ioi\n  obtain \u27e8bd, bd_s, le_bd\u27e9 := exists_summable_bound_exp_mul_sq hy\n  exact differentiable_on_tsum_of_summable_norm bd_s h1 h2 fun i w hw => le_bd (le_of_lt hw) i\n#align differentiable_at_tsum_exp_mul_sq differentiableAt_tsum_exp_mul_sq\n\ntheorem mdifferentiable_jacobiTheta : Mdifferentiable \ud835\udcd8(\u2102) \ud835\udcd8(\u2102) jacobiTheta := fun \u03c4 =>\n  (differentiableAt_tsum_exp_mul_sq \u03c4).MdifferentiableAt.comp \u03c4 \u03c4.mdifferentiable_coe\n#align mdifferentiable_jacobi_theta mdifferentiable_jacobiTheta\n\ntheorem continuous_jacobiTheta : Continuous jacobiTheta :=\n  mdifferentiable_jacobiTheta.Continuous\n#align continuous_jacobi_theta continuous_jacobiTheta\n\n"}
{"text": "Require Import LiterateCoq.Tactics.\nRequire Import Compiler.\nRequire Import ZArith.\n\n\nLemma list_pointless_split : forall A B:Type, forall l : list A, forall x : B,\n        match l with | nil => x | (_ :: _)%list => x end = x.\nProof.\n  destruct l; eauto.\nQed.\nLemma list_pointless_split' : forall A B:Type, forall l : list A, forall x : B,\n        match l with | nil => x | (_ :: nil)%list => x | (_ :: _ :: _)%list => x end = x.\nProof.\n  destruct l; intros; eauto. destruct l; eauto.\nQed.\n\n\nLemma eval_step : forall a : Arith, forall s : list Num.Int, forall xs : list StackOp, \n        eval s (compile a ++ xs) = eval (eval' a :: s) xs.\nProof.\n  hint_rewrite List.app_assoc_reverse.\n  hint_rewrite list_pointless_split, list_pointless_split'.\n  \n  induction a; intros; simpl; iauto;\n\n    hint_rewrite IHa1, IHa2; iauto'.\nQed.\n\nLemma compiler_correctness' : forall a : Arith, forall s : list Num.Int, \n      eval s (compile a) = Data.Either.Right (eval' a).\nProof.\n  hint_rewrite eval_step.\n  hint_rewrite list_pointless_split, list_pointless_split'.\n  \n  induction a; intros; simpl; hint_simpl; iauto'.\nQed.  \n  \n\nTheorem compiler_correctness : forall a : Arith, eval nil (compile a) = Data.Either.Right (eval' a).\nProof.\n  hint compiler_correctness'.\n  intros; iauto.\nQed.\n"}
{"text": "/-\nCopyright (c) 2019 Alexander Bentkamp. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Alexander Bentkamp, Yury Kudriashov\n-/\nimport Mathlib.PrePort\nimport Mathlib.Lean3Lib.init.default\nimport Mathlib.data.set.intervals.ord_connected\nimport Mathlib.data.set.intervals.image_preimage\nimport Mathlib.data.complex.module\nimport Mathlib.linear_algebra.affine_space.affine_map\nimport Mathlib.algebra.module.ordered\nimport Mathlib.PostPort\n\nuniverses u u_1 v v' w x u' \n\nnamespace Mathlib\n\n/-!\n# Convex sets and functions on real vector spaces\n\nIn a real vector space, we define the following objects and properties.\n\n* `segment x y` is the closed segment joining `x` and `y`.\n* A set `s` is `convex` if for any two points `x y \u2208 s` it includes `segment x y`;\n* A function `f : E \u2192 \u03b2` is `convex_on` a set `s` if `s` is itself a convex set, and for any two\n  points `x y \u2208 s` the segment joining `(x, f x)` to `(y, f y)` is (non-strictly) above the graph\n  of `f`; equivalently, `convex_on f s` means that the epigraph\n  `{p : E \u00d7 \u03b2 | p.1 \u2208 s \u2227 f p.1 \u2264 p.2}` is a convex set;\n* Center mass of a finite set of points with prescribed weights.\n* Convex hull of a set `s` is the minimal convex set that includes `s`.\n* Standard simplex `std_simplex \u03b9 [fintype \u03b9]` is the intersection of the positive quadrant with\n  the hyperplane `s.sum = 1` in the space `\u03b9 \u2192 \u211d`.\n\nWe also provide various equivalent versions of the definitions above, prove that some specific sets\nare convex, and prove Jensen's inequality.\n\nNote: To define convexity for functions `f : E \u2192 \u03b2`, we need `\u03b2` to be an ordered vector space,\ndefined using the instance `ordered_semimodule \u211d \u03b2`.\n\n## Notations\n\nWe use the following local notations:\n\n* `I = Icc (0:\u211d) 1`;\n* `[x, y] = segment x y`.\n\nThey are defined using `local notation`, so they are not available outside of this file.\n-/\n\n/-! ### Segment -/\n\n/-- Segments in a vector space. -/\ndef segment {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) (y : E) : set E :=\n  set_of\n    fun (z : E) =>\n      \u2203 (a : \u211d), \u2203 (b : \u211d), \u2203 (ha : 0 \u2264 a), \u2203 (hb : 0 \u2264 b), \u2203 (hab : a + b = 1), a \u2022 x + b \u2022 y = z\n\ntheorem segment_symm {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) (y : E) :\n    segment x y = segment y x :=\n  sorry\n\ntheorem left_mem_segment {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) (y : E) :\n    x \u2208 segment x y :=\n  sorry\n\ntheorem right_mem_segment {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) (y : E) :\n    y \u2208 segment x y :=\n  segment_symm y x \u25b8 left_mem_segment y x\n\ntheorem segment_same {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) :\n    segment x x = singleton x :=\n  sorry\n\ntheorem segment_eq_image {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) (y : E) :\n    segment x y = (fun (\u03b8 : \u211d) => (1 - \u03b8) \u2022 x + \u03b8 \u2022 y) '' set.Icc 0 1 :=\n  sorry\n\ntheorem segment_eq_image' {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) (y : E) :\n    segment x y = (fun (\u03b8 : \u211d) => x + \u03b8 \u2022 (y - x)) '' set.Icc 0 1 :=\n  sorry\n\ntheorem segment_eq_image\u2082 {E : Type u} [add_comm_group E] [vector_space \u211d E] (x : E) (y : E) :\n    segment x y =\n        (fun (p : \u211d \u00d7 \u211d) => prod.fst p \u2022 x + prod.snd p \u2022 y) ''\n          set_of fun (p : \u211d \u00d7 \u211d) => 0 \u2264 prod.fst p \u2227 0 \u2264 prod.snd p \u2227 prod.fst p + prod.snd p = 1 :=\n  sorry\n\ntheorem segment_eq_Icc {a : \u211d} {b : \u211d} (h : a \u2264 b) : segment a b = set.Icc a b := sorry\n\ntheorem segment_eq_Icc' (a : \u211d) (b : \u211d) : segment a b = set.Icc (min a b) (max a b) := sorry\n\ntheorem segment_eq_interval (a : \u211d) (b : \u211d) : segment a b = set.interval a b := segment_eq_Icc' a b\n\ntheorem mem_segment_translate {E : Type u} [add_comm_group E] [vector_space \u211d E] (a : E) {x : E}\n    {b : E} {c : E} : a + x \u2208 segment (a + b) (a + c) \u2194 x \u2208 segment b c :=\n  sorry\n\ntheorem segment_translate_preimage {E : Type u} [add_comm_group E] [vector_space \u211d E] (a : E)\n    (b : E) (c : E) : (fun (x : E) => a + x) \u207b\u00b9' segment (a + b) (a + c) = segment b c :=\n  set.ext fun (x : E) => mem_segment_translate a\n\ntheorem segment_translate_image {E : Type u} [add_comm_group E] [vector_space \u211d E] (a : E) (b : E)\n    (c : E) : (fun (x : E) => a + x) '' segment b c = segment (a + b) (a + c) :=\n  Eq.subst (segment_translate_preimage a b c) (set.image_preimage_eq (segment (a + b) (a + c)))\n    (add_left_surjective a)\n\n/-! ### Convexity of sets -/\n\n/-- Convexity of sets. -/\ndef convex {E : Type u} [add_comm_group E] [vector_space \u211d E] (s : set E) :=\n  \u2200 {x y : E}, x \u2208 s \u2192 y \u2208 s \u2192 \u2200 {a b : \u211d}, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s\n\ntheorem convex_iff_forall_pos {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} :\n    convex s \u2194\n        \u2200 {x y : E}, x \u2208 s \u2192 y \u2208 s \u2192 \u2200 {a b : \u211d}, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 x + b \u2022 y \u2208 s :=\n  sorry\n\ntheorem convex_iff_segment_subset {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} :\n    convex s \u2194 \u2200 {x y : E}, x \u2208 s \u2192 y \u2208 s \u2192 segment x y \u2286 s :=\n  sorry\n\ntheorem convex.segment_subset {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    (h : convex s) {x : E} {y : E} (hx : x \u2208 s) (hy : y \u2208 s) : segment x y \u2286 s :=\n  iff.mp convex_iff_segment_subset h x y hx hy\n\n/-- Alternative definition of set convexity, in terms of pointwise set operations. -/\ntheorem convex_iff_pointwise_add_subset {E : Type u} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} : convex s \u2194 \u2200 {a b : \u211d}, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 s + b \u2022 s \u2286 s :=\n  sorry\n\n/-- Alternative definition of set convexity, using division. -/\ntheorem convex_iff_div {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} :\n    convex s \u2194\n        \u2200 {x y : E},\n          x \u2208 s \u2192\n            y \u2208 s \u2192\n              \u2200 {a b : \u211d}, 0 \u2264 a \u2192 0 \u2264 b \u2192 0 < a + b \u2192 (a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y \u2208 s :=\n  sorry\n\n/-! ### Examples of convex sets -/\n\ntheorem convex_empty {E : Type u} [add_comm_group E] [vector_space \u211d E] : convex \u2205 := sorry\n\ntheorem convex_singleton {E : Type u} [add_comm_group E] [vector_space \u211d E] (c : E) :\n    convex (singleton c) :=\n  sorry\n\ntheorem convex_univ {E : Type u} [add_comm_group E] [vector_space \u211d E] : convex set.univ :=\n  fun (_x _x_1 : E) (_x : _x \u2208 set.univ) (_x : _x_1 \u2208 set.univ) (_x _x_2 : \u211d) (_x_3 : 0 \u2264 _x)\n    (_x_4 : 0 \u2264 _x_2) (_x : _x + _x_2 = 1) => trivial\n\ntheorem convex.inter {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {t : set E}\n    (hs : convex s) (ht : convex t) : convex (s \u2229 t) :=\n  fun (x y : E) (hx : x \u2208 s \u2229 t) (hy : y \u2208 s \u2229 t) (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b)\n    (hab : a + b = 1) =>\n    { left := hs (and.left hx) (and.left hy) ha hb hab,\n      right := ht (and.right hx) (and.right hy) ha hb hab }\n\ntheorem convex_sInter {E : Type u} [add_comm_group E] [vector_space \u211d E] {S : set (set E)}\n    (h : \u2200 (s : set E), s \u2208 S \u2192 convex s) : convex (\u22c2\u2080S) :=\n  fun (x y : E) (hx : x \u2208 \u22c2\u2080S) (hy : y \u2208 \u22c2\u2080S) (a b : \u211d) (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1)\n    (s : set E) (hs : s \u2208 S) => h s hs (hx s hs) (hy s hs) ha hb hab\n\ntheorem convex_Inter {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b9 : Sort u_1}\n    {s : \u03b9 \u2192 set E} (h : \u2200 (i : \u03b9), convex (s i)) : convex (set.Inter fun (i : \u03b9) => s i) :=\n  Eq.subst (set.sInter_range s) convex_sInter (iff.mpr set.forall_range_iff h)\n\ntheorem convex.prod {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {s : set E} {t : set F} (hs : convex s) (ht : convex t) :\n    convex (set.prod s t) :=\n  sorry\n\ntheorem convex.combo_to_vadd {E : Type u} [add_comm_group E] [vector_space \u211d E] {a : \u211d} {b : \u211d}\n    {x : E} {y : E} (h : a + b = 1) : a \u2022 x + b \u2022 y = b \u2022 (y - x) + x :=\n  sorry\n\n/--\nApplying an affine map to an affine combination of two points yields\nan affine combination of the images.\n-/\ntheorem convex.combo_affine_apply {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {a : \u211d} {b : \u211d} {x : E} {y : E} {f : affine_map \u211d E F}\n    (h : a + b = 1) : coe_fn f (a \u2022 x + b \u2022 y) = a \u2022 coe_fn f x + b \u2022 coe_fn f y :=\n  sorry\n\n/-- The preimage of a convex set under an affine map is convex. -/\ntheorem convex.affine_preimage {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] (f : affine_map \u211d E F) {s : set F} (hs : convex s) :\n    convex (\u21d1f \u207b\u00b9' s) :=\n  sorry\n\n/-- The image of a convex set under an affine map is convex. -/\ntheorem convex.affine_image {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] (f : affine_map \u211d E F) {s : set E} (hs : convex s) :\n    convex (\u21d1f '' s) :=\n  sorry\n\ntheorem convex.linear_image {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {s : set E} (hs : convex s) (f : linear_map \u211d E F) :\n    convex (\u21d1f '' s) :=\n  convex.affine_image (linear_map.to_affine_map f) hs\n\ntheorem convex.is_linear_image {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {s : set E} (hs : convex s) {f : E \u2192 F}\n    (hf : is_linear_map \u211d f) : convex (f '' s) :=\n  convex.linear_image hs (is_linear_map.mk' f hf)\n\ntheorem convex.linear_preimage {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {s : set F} (hs : convex s) (f : linear_map \u211d E F) :\n    convex (\u21d1f \u207b\u00b9' s) :=\n  convex.affine_preimage (linear_map.to_affine_map f) hs\n\ntheorem convex.is_linear_preimage {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {s : set F} (hs : convex s) {f : E \u2192 F}\n    (hf : is_linear_map \u211d f) : convex (f \u207b\u00b9' s) :=\n  convex.linear_preimage hs (is_linear_map.mk' f hf)\n\ntheorem convex.neg {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} (hs : convex s) :\n    convex ((fun (z : E) => -z) '' s) :=\n  convex.is_linear_image hs is_linear_map.is_linear_map_neg\n\ntheorem convex.neg_preimage {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    (hs : convex s) : convex ((fun (z : E) => -z) \u207b\u00b9' s) :=\n  convex.is_linear_preimage hs is_linear_map.is_linear_map_neg\n\ntheorem convex.smul {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} (c : \u211d)\n    (hs : convex s) : convex (c \u2022 s) :=\n  convex.linear_image hs (coe_fn (linear_map.lsmul \u211d E) c)\n\ntheorem convex.smul_preimage {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} (c : \u211d)\n    (hs : convex s) : convex ((fun (z : E) => c \u2022 z) \u207b\u00b9' s) :=\n  convex.linear_preimage hs (coe_fn (linear_map.lsmul \u211d E) c)\n\ntheorem convex.add {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {t : set E}\n    (hs : convex s) (ht : convex t) : convex (s + t) :=\n  eq.mpr (id (Eq._oldrec (Eq.refl (convex (s + t))) (Eq.symm set.add_image_prod)))\n    (convex.is_linear_image (convex.prod hs ht) is_linear_map.is_linear_map_add)\n\ntheorem convex.sub {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {t : set E}\n    (hs : convex s) (ht : convex t) :\n    convex ((fun (x : E \u00d7 E) => prod.fst x - prod.snd x) '' set.prod s t) :=\n  convex.is_linear_image (convex.prod hs ht) is_linear_map.is_linear_map_sub\n\ntheorem convex.translate {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    (hs : convex s) (z : E) : convex ((fun (x : E) => z + x) '' s) :=\n  convex.affine_image (affine_map.const \u211d E z +\u1d65 affine_map.id \u211d E) hs\n\n/-- The translation of a convex set is also convex. -/\ntheorem convex.translate_preimage_right {E : Type u} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} (hs : convex s) (a : E) : convex ((fun (z : E) => a + z) \u207b\u00b9' s) :=\n  convex.affine_preimage (affine_map.const \u211d E a +\u1d65 affine_map.id \u211d E) hs\n\n/-- The translation of a convex set is also convex. -/\ntheorem convex.translate_preimage_left {E : Type u} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} (hs : convex s) (a : E) : convex ((fun (z : E) => z + a) \u207b\u00b9' s) :=\n  sorry\n\ntheorem convex.affinity {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    (hs : convex s) (z : E) (c : \u211d) : convex ((fun (x : E) => z + c \u2022 x) '' s) :=\n  convex.affine_image (affine_map.const \u211d E z +\u1d65 c \u2022 affine_map.id \u211d E) hs\n\ntheorem real.convex_iff_ord_connected {s : set \u211d} : convex s \u2194 set.ord_connected s := sorry\n\ntheorem convex.ord_connected {s : set \u211d} : convex s \u2192 set.ord_connected s :=\n  iff.mp real.convex_iff_ord_connected\n\ntheorem convex_Iio (r : \u211d) : convex (set.Iio r) := set.ord_connected.convex set.ord_connected_Iio\n\ntheorem convex_Ioi (r : \u211d) : convex (set.Ioi r) := set.ord_connected.convex set.ord_connected_Ioi\n\ntheorem convex_Iic (r : \u211d) : convex (set.Iic r) := set.ord_connected.convex set.ord_connected_Iic\n\ntheorem convex_Ici (r : \u211d) : convex (set.Ici r) := set.ord_connected.convex set.ord_connected_Ici\n\ntheorem convex_Ioo (r : \u211d) (s : \u211d) : convex (set.Ioo r s) :=\n  set.ord_connected.convex set.ord_connected_Ioo\n\ntheorem convex_Ico (r : \u211d) (s : \u211d) : convex (set.Ico r s) :=\n  set.ord_connected.convex set.ord_connected_Ico\n\ntheorem convex_Ioc (r : \u211d) (s : \u211d) : convex (set.Ioc r s) :=\n  set.ord_connected.convex set.ord_connected_Ioc\n\ntheorem convex_Icc (r : \u211d) (s : \u211d) : convex (set.Icc r s) :=\n  set.ord_connected.convex set.ord_connected_Icc\n\ntheorem convex_interval (r : \u211d) (s : \u211d) : convex (set.interval r s) :=\n  set.ord_connected.convex set.ord_connected_interval\n\ntheorem convex_segment {E : Type u} [add_comm_group E] [vector_space \u211d E] (a : E) (b : E) :\n    convex (segment a b) :=\n  sorry\n\ntheorem convex_halfspace_lt {E : Type u} [add_comm_group E] [vector_space \u211d E] {f : E \u2192 \u211d}\n    (h : is_linear_map \u211d f) (r : \u211d) : convex (set_of fun (w : E) => f w < r) :=\n  convex.is_linear_preimage (convex_Iio r) h\n\ntheorem convex_halfspace_le {E : Type u} [add_comm_group E] [vector_space \u211d E] {f : E \u2192 \u211d}\n    (h : is_linear_map \u211d f) (r : \u211d) : convex (set_of fun (w : E) => f w \u2264 r) :=\n  convex.is_linear_preimage (convex_Iic r) h\n\ntheorem convex_halfspace_gt {E : Type u} [add_comm_group E] [vector_space \u211d E] {f : E \u2192 \u211d}\n    (h : is_linear_map \u211d f) (r : \u211d) : convex (set_of fun (w : E) => r < f w) :=\n  convex.is_linear_preimage (convex_Ioi r) h\n\ntheorem convex_halfspace_ge {E : Type u} [add_comm_group E] [vector_space \u211d E] {f : E \u2192 \u211d}\n    (h : is_linear_map \u211d f) (r : \u211d) : convex (set_of fun (w : E) => r \u2264 f w) :=\n  convex.is_linear_preimage (convex_Ici r) h\n\ntheorem convex_hyperplane {E : Type u} [add_comm_group E] [vector_space \u211d E] {f : E \u2192 \u211d}\n    (h : is_linear_map \u211d f) (r : \u211d) : convex (set_of fun (w : E) => f w = r) :=\n  id\n    (eq.mpr\n      (id\n        (Eq._oldrec (Eq.refl (convex (f \u207b\u00b9' set_of fun (p : \u211d) => p = r)))\n          set.set_of_eq_eq_singleton))\n      (convex.is_linear_preimage (convex_singleton r) h))\n\ntheorem convex_halfspace_re_lt (r : \u211d) : convex (set_of fun (c : \u2102) => complex.re c < r) :=\n  convex_halfspace_lt (is_linear_map.mk complex.add_re complex.smul_re) r\n\ntheorem convex_halfspace_re_le (r : \u211d) : convex (set_of fun (c : \u2102) => complex.re c \u2264 r) :=\n  convex_halfspace_le (is_linear_map.mk complex.add_re complex.smul_re) r\n\ntheorem convex_halfspace_re_gt (r : \u211d) : convex (set_of fun (c : \u2102) => r < complex.re c) :=\n  convex_halfspace_gt (is_linear_map.mk complex.add_re complex.smul_re) r\n\ntheorem convex_halfspace_re_lge (r : \u211d) : convex (set_of fun (c : \u2102) => r \u2264 complex.re c) :=\n  convex_halfspace_ge (is_linear_map.mk complex.add_re complex.smul_re) r\n\ntheorem convex_halfspace_im_lt (r : \u211d) : convex (set_of fun (c : \u2102) => complex.im c < r) :=\n  convex_halfspace_lt (is_linear_map.mk complex.add_im complex.smul_im) r\n\ntheorem convex_halfspace_im_le (r : \u211d) : convex (set_of fun (c : \u2102) => complex.im c \u2264 r) :=\n  convex_halfspace_le (is_linear_map.mk complex.add_im complex.smul_im) r\n\ntheorem convex_halfspace_im_gt (r : \u211d) : convex (set_of fun (c : \u2102) => r < complex.im c) :=\n  convex_halfspace_gt (is_linear_map.mk complex.add_im complex.smul_im) r\n\ntheorem convex_halfspace_im_lge (r : \u211d) : convex (set_of fun (c : \u2102) => r \u2264 complex.im c) :=\n  convex_halfspace_ge (is_linear_map.mk complex.add_im complex.smul_im) r\n\n/-! ### Convex combinations in intervals -/\n\ntheorem convex.combo_self {\u03b1 : Type v'} [linear_ordered_field \u03b1] (a : \u03b1) {x : \u03b1} {y : \u03b1}\n    (h : x + y = 1) : a = x * a + y * a :=\n  sorry\n\n/--\nIf `x` is in an `Ioo`, it can be expressed as a convex combination of the endpoints.\n-/\ntheorem convex.mem_Ioo {\u03b1 : Type v'} [linear_ordered_field \u03b1] {a : \u03b1} {b : \u03b1} {x : \u03b1} (h : a < b) :\n    x \u2208 set.Ioo a b \u2194\n        \u2203 (x_a : \u03b1), \u2203 (x_b : \u03b1), 0 < x_a \u2227 0 < x_b \u2227 x_a + x_b = 1 \u2227 x_a * a + x_b * b = x :=\n  sorry\n\n/-- If `x` is in an `Ioc`, it can be expressed as a convex combination of the endpoints. -/\ntheorem convex.mem_Ioc {\u03b1 : Type v'} [linear_ordered_field \u03b1] {a : \u03b1} {b : \u03b1} {x : \u03b1} (h : a < b) :\n    x \u2208 set.Ioc a b \u2194\n        \u2203 (x_a : \u03b1), \u2203 (x_b : \u03b1), 0 \u2264 x_a \u2227 0 < x_b \u2227 x_a + x_b = 1 \u2227 x_a * a + x_b * b = x :=\n  sorry\n\n/-- If `x` is in an `Ico`, it can be expressed as a convex combination of the endpoints. -/\ntheorem convex.mem_Ico {\u03b1 : Type v'} [linear_ordered_field \u03b1] {a : \u03b1} {b : \u03b1} {x : \u03b1} (h : a < b) :\n    x \u2208 set.Ico a b \u2194\n        \u2203 (x_a : \u03b1), \u2203 (x_b : \u03b1), 0 < x_a \u2227 0 \u2264 x_b \u2227 x_a + x_b = 1 \u2227 x_a * a + x_b * b = x :=\n  sorry\n\n/-- If `x` is in an `Icc`, it can be expressed as a convex combination of the endpoints. -/\ntheorem convex.mem_Icc {\u03b1 : Type v'} [linear_ordered_field \u03b1] {a : \u03b1} {b : \u03b1} {x : \u03b1} (h : a \u2264 b) :\n    x \u2208 set.Icc a b \u2194\n        \u2203 (x_a : \u03b1), \u2203 (x_b : \u03b1), 0 \u2264 x_a \u2227 0 \u2264 x_b \u2227 x_a + x_b = 1 \u2227 x_a * a + x_b * b = x :=\n  sorry\n\ntheorem submodule.convex {E : Type u} [add_comm_group E] [vector_space \u211d E] (K : submodule \u211d E) :\n    convex \u2191K :=\n  id\n    fun (x y : E) (\u1fb0 : x \u2208 \u2191K) (\u1fb0_1 : y \u2208 \u2191K) (a b : \u211d) (\u1fb0_2 : 0 \u2264 a) (\u1fb0_3 : 0 \u2264 b)\n      (\u1fb0_4 : a + b = 1) =>\n      submodule.add_mem K (submodule.smul_mem K a \u1fb0) (submodule.smul_mem K b \u1fb0_1)\n\ntheorem subspace.convex {E : Type u} [add_comm_group E] [vector_space \u211d E] (K : subspace \u211d E) :\n    convex \u2191K :=\n  submodule.convex K\n\n/-! ### Convex and concave functions -/\n\n/-- Convexity of functions -/\ndef convex_on {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] (s : set E) (f : E \u2192 \u03b2) :=\n  convex s \u2227\n    \u2200 {x y : E},\n      x \u2208 s \u2192 y \u2208 s \u2192 \u2200 {a b : \u211d}, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y\n\n/-- Concavity of functions -/\ndef concave_on {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] (s : set E) (f : E \u2192 \u03b2) :=\n  convex s \u2227\n    \u2200 {x y : E},\n      x \u2208 s \u2192 y \u2208 s \u2192 \u2200 {a b : \u211d}, 0 \u2264 a \u2192 0 \u2264 b \u2192 a + b = 1 \u2192 a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)\n\n/-- A function `f` is concave iff `-f` is convex. -/\n@[simp] theorem neg_convex_on_iff {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b3 : Type u_1}\n    [ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] (s : set E) (f : E \u2192 \u03b3) :\n    convex_on s (-f) \u2194 concave_on s f :=\n  sorry\n\n/-- A function `f` is concave iff `-f` is convex. -/\n@[simp] theorem neg_concave_on_iff {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b3 : Type u_1}\n    [ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] (s : set E) (f : E \u2192 \u03b3) :\n    concave_on s (-f) \u2194 convex_on s f :=\n  eq.mpr\n    (id\n      (Eq._oldrec (Eq.refl (concave_on s (-f) \u2194 convex_on s f))\n        (Eq.symm (propext (neg_convex_on_iff s (-f))))))\n    (eq.mpr (id (Eq._oldrec (Eq.refl (convex_on s ( --f) \u2194 convex_on s f)) (neg_neg f)))\n      (iff.refl (convex_on s f)))\n\ntheorem convex_on_id {s : set \u211d} (hs : convex s) : convex_on s id := sorry\n\ntheorem concave_on_id {s : set \u211d} (hs : convex s) : concave_on s id := sorry\n\ntheorem convex_on_const {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] (c : \u03b2) (hs : convex s) :\n    convex_on s fun (x : E) => c :=\n  sorry\n\ntheorem concave_on_const {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] (c : \u03b2) (hs : convex s) :\n    concave_on s fun (x : E) => c :=\n  convex_on_const c hs\n\ntheorem convex_on_iff_div {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} :\n    convex_on s f \u2194\n        convex s \u2227\n          \u2200 {x y : E},\n            x \u2208 s \u2192\n              y \u2208 s \u2192\n                \u2200 {a b : \u211d},\n                  0 \u2264 a \u2192\n                    0 \u2264 b \u2192\n                      0 < a + b \u2192\n                        f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y) \u2264\n                          (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y :=\n  sorry\n\ntheorem concave_on_iff_div {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} :\n    concave_on s f \u2194\n        convex s \u2227\n          \u2200 {x y : E},\n            x \u2208 s \u2192\n              y \u2208 s \u2192\n                \u2200 {a b : \u211d},\n                  0 \u2264 a \u2192\n                    0 \u2264 b \u2192\n                      0 < a + b \u2192\n                        (a / (a + b)) \u2022 f x + (b / (a + b)) \u2022 f y \u2264\n                          f ((a / (a + b)) \u2022 x + (b / (a + b)) \u2022 y) :=\n  convex_on_iff_div\n\n/-- For a function on a convex set in a linear ordered space, in order to prove that it is convex\nit suffices to verify the inequality `f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y` only for `x < y`\nand positive `a`, `b`. The main use case is `E = \u211d` however one can apply it, e.g., to `\u211d^n` with\nlexicographic order. -/\ntheorem linear_order.convex_on_of_lt {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} [linear_order E]\n    (hs : convex s)\n    (hf :\n      \u2200 {x y : E},\n        x \u2208 s \u2192\n          y \u2208 s \u2192\n            x < y \u2192\n              \u2200 {a b : \u211d}, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 f (a \u2022 x + b \u2022 y) \u2264 a \u2022 f x + b \u2022 f y) :\n    convex_on s f :=\n  sorry\n\n/-- For a function on a convex set in a linear ordered space, in order to prove that it is concave\nit suffices to verify the inequality `a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)` only for `x < y`\nand positive `a`, `b`. The main use case is `E = \u211d` however one can apply it, e.g., to `\u211d^n` with\nlexicographic order. -/\ntheorem linear_order.concave_on_of_lt {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} [linear_order E]\n    (hs : convex s)\n    (hf :\n      \u2200 {x y : E},\n        x \u2208 s \u2192\n          y \u2208 s \u2192\n            x < y \u2192\n              \u2200 {a b : \u211d}, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 f x + b \u2022 f y \u2264 f (a \u2022 x + b \u2022 y)) :\n    concave_on s f :=\n  linear_order.convex_on_of_lt hs hf\n\n/-- For a function `f` defined on a convex subset `D` of `\u211d`, if for any three points `x<y<z`\nthe slope of the secant line of `f` on `[x, y]` is less than or equal to the slope\nof the secant line of `f` on `[x, z]`, then `f` is convex on `D`. This way of proving convexity\nof a function is used in the proof of convexity of a function with a monotone derivative. -/\ntheorem convex_on_real_of_slope_mono_adjacent {s : set \u211d} (hs : convex s) {f : \u211d \u2192 \u211d}\n    (hf :\n      \u2200 {x y z : \u211d},\n        x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y)) :\n    convex_on s f :=\n  sorry\n\n/-- For a function `f` defined on a subset `D` of `\u211d`, if `f` is convex on `D`, then for any three\npoints `x<y<z`, the slope of the secant line of `f` on `[x, y]` is less than or equal to the slope\nof the secant line of `f` on `[x, z]`. -/\ntheorem convex_on.slope_mono_adjacent {s : set \u211d} {f : \u211d \u2192 \u211d} (hf : convex_on s f) {x : \u211d} {y : \u211d}\n    {z : \u211d} (hx : x \u2208 s) (hz : z \u2208 s) (hxy : x < y) (hyz : y < z) :\n    (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y) :=\n  sorry\n\n/-- For a function `f` defined on a convex subset `D` of `\u211d`, `f` is convex on `D` iff for any three\npoints `x<y<z` the slope of the secant line of `f` on `[x, y]` is less than or equal to the slope\nof the secant line of `f` on `[x, z]`. -/\ntheorem convex_on_real_iff_slope_mono_adjacent {s : set \u211d} (hs : convex s) {f : \u211d \u2192 \u211d} :\n    convex_on s f \u2194\n        \u2200 {x y z : \u211d},\n          x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f y - f x) / (y - x) \u2264 (f z - f y) / (z - y) :=\n  { mp := convex_on.slope_mono_adjacent, mpr := convex_on_real_of_slope_mono_adjacent hs }\n\n/-- For a function `f` defined on a convex subset `D` of `\u211d`, if for any three points `x<y<z`\nthe slope of the secant line of `f` on `[x, y]` is greater than or equal to the slope\nof the secant line of `f` on `[x, z]`, then `f` is concave on `D`. -/\ntheorem concave_on_real_of_slope_mono_adjacent {s : set \u211d} (hs : convex s) {f : \u211d \u2192 \u211d}\n    (hf :\n      \u2200 {x y z : \u211d},\n        x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f z - f y) / (z - y) \u2264 (f y - f x) / (y - x)) :\n    concave_on s f :=\n  sorry\n\n/-- For a function `f` defined on a subset `D` of `\u211d`, if `f` is concave on `D`, then for any three\npoints `x<y<z`, the slope of the secant line of `f` on `[x, y]` is greater than or equal to the\nslope of the secant line of `f` on `[x, z]`. -/\ntheorem concave_on.slope_mono_adjacent {s : set \u211d} {f : \u211d \u2192 \u211d} (hf : concave_on s f) {x : \u211d} {y : \u211d}\n    {z : \u211d} (hx : x \u2208 s) (hz : z \u2208 s) (hxy : x < y) (hyz : y < z) :\n    (f z - f y) / (z - y) \u2264 (f y - f x) / (y - x) :=\n  sorry\n\n/-- For a function `f` defined on a convex subset `D` of `\u211d`, `f` is concave on `D` iff for any\nthree points `x<y<z` the slope of the secant line of `f` on `[x, y]` is greater than or equal to\nthe slope of the secant line of `f` on `[x, z]`. -/\ntheorem concave_on_real_iff_slope_mono_adjacent {s : set \u211d} (hs : convex s) {f : \u211d \u2192 \u211d} :\n    concave_on s f \u2194\n        \u2200 {x y z : \u211d},\n          x \u2208 s \u2192 z \u2208 s \u2192 x < y \u2192 y < z \u2192 (f z - f y) / (z - y) \u2264 (f y - f x) / (y - x) :=\n  { mp := concave_on.slope_mono_adjacent, mpr := concave_on_real_of_slope_mono_adjacent hs }\n\ntheorem convex_on.subset {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {t : set E} {f : E \u2192 \u03b2}\n    (h_convex_on : convex_on t f) (h_subset : s \u2286 t) (h_convex : convex s) : convex_on s f :=\n  { left := h_convex,\n    right :=\n      fun (x y : E) (hx : x \u2208 s) (hy : y \u2208 s) =>\n        and.right h_convex_on x y (h_subset hx) (h_subset hy) }\n\ntheorem concave_on.subset {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {t : set E} {f : E \u2192 \u03b2}\n    (h_concave_on : concave_on t f) (h_subset : s \u2286 t) (h_convex : convex s) : concave_on s f :=\n  convex_on.subset h_concave_on h_subset h_convex\n\ntheorem convex_on.add {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} {g : E \u2192 \u03b2} (hf : convex_on s f)\n    (hg : convex_on s g) : convex_on s fun (x : E) => f x + g x :=\n  sorry\n\ntheorem concave_on.add {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} {g : E \u2192 \u03b2} (hf : concave_on s f)\n    (hg : concave_on s g) : concave_on s fun (x : E) => f x + g x :=\n  convex_on.add hf hg\n\ntheorem convex_on.smul {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] [ordered_semimodule \u211d \u03b2] {f : E \u2192 \u03b2} {c : \u211d}\n    (hc : 0 \u2264 c) (hf : convex_on s f) : convex_on s fun (x : E) => c \u2022 f x :=\n  sorry\n\ntheorem concave_on.smul {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] [ordered_semimodule \u211d \u03b2] {f : E \u2192 \u03b2}\n    {c : \u211d} (hc : 0 \u2264 c) (hf : concave_on s f) : concave_on s fun (x : E) => c \u2022 f x :=\n  convex_on.smul hc hf\n\n/-- A convex function on a segment is upper-bounded by the max of its endpoints. -/\ntheorem convex_on.le_on_segment' {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [linear_ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} {x : E} {y : E} {a : \u211d} {b : \u211d} (hf : convex_on s f) (hx : x \u2208 s) (hy : y \u2208 s)\n    (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) : f (a \u2022 x + b \u2022 y) \u2264 max (f x) (f y) :=\n  sorry\n\n/-- A concave function on a segment is lower-bounded by the min of its endpoints. -/\ntheorem concave_on.le_on_segment' {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [linear_ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} {x : E} {y : E} {a : \u211d} {b : \u211d} (hf : concave_on s f) (hx : x \u2208 s) (hy : y \u2208 s)\n    (ha : 0 \u2264 a) (hb : 0 \u2264 b) (hab : a + b = 1) : min (f x) (f y) \u2264 f (a \u2022 x + b \u2022 y) :=\n  convex_on.le_on_segment' hf hx hy ha hb hab\n\n/-- A convex function on a segment is upper-bounded by the max of its endpoints. -/\ntheorem convex_on.le_on_segment {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [linear_ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} (hf : convex_on s f) {x : E} {y : E} {z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 segment x y) : f z \u2264 max (f x) (f y) :=\n  sorry\n\n/-- A concave function on a segment is lower-bounded by the min of its endpoints. -/\ntheorem concave_on.le_on_segment {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [linear_ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} (hf : concave_on s f) {x : E} {y : E} {z : E} (hx : x \u2208 s) (hy : y \u2208 s)\n    (hz : z \u2208 segment x y) : min (f x) (f y) \u2264 f z :=\n  convex_on.le_on_segment hf hx hy hz\n\ntheorem convex_on.convex_le {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] [ordered_semimodule \u211d \u03b2] {f : E \u2192 \u03b2}\n    (hf : convex_on s f) (r : \u03b2) : convex (has_sep.sep (fun (x : E) => f x \u2264 r) s) :=\n  sorry\n\ntheorem concave_on.concave_le {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] [ordered_semimodule \u211d \u03b2] {f : E \u2192 \u03b2}\n    (hf : concave_on s f) (r : \u03b2) : convex (has_sep.sep (fun (x : E) => r \u2264 f x) s) :=\n  convex_on.convex_le hf r\n\ntheorem convex_on.convex_lt {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [ordered_cancel_add_comm_monoid \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} (hf : convex_on s f) (r : \u03b3) : convex (has_sep.sep (fun (x : E) => f x < r) s) :=\n  sorry\n\ntheorem concave_on.convex_lt {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [ordered_cancel_add_comm_monoid \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} (hf : concave_on s f) (r : \u03b3) : convex (has_sep.sep (fun (x : E) => r < f x) s) :=\n  convex_on.convex_lt hf r\n\ntheorem convex_on.convex_epigraph {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3] {f : E \u2192 \u03b3}\n    (hf : convex_on s f) :\n    convex (set_of fun (p : E \u00d7 \u03b3) => prod.fst p \u2208 s \u2227 f (prod.fst p) \u2264 prod.snd p) :=\n  sorry\n\ntheorem concave_on.convex_hypograph {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3] {f : E \u2192 \u03b3}\n    (hf : concave_on s f) :\n    convex (set_of fun (p : E \u00d7 \u03b3) => prod.fst p \u2208 s \u2227 prod.snd p \u2264 f (prod.fst p)) :=\n  convex_on.convex_epigraph hf\n\ntheorem convex_on_iff_convex_epigraph {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {\u03b3 : Type u_1} [ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} :\n    convex_on s f \u2194\n        convex (set_of fun (p : E \u00d7 \u03b3) => prod.fst p \u2208 s \u2227 f (prod.fst p) \u2264 prod.snd p) :=\n  sorry\n\ntheorem concave_on_iff_convex_hypograph {E : Type u} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} {\u03b3 : Type u_1} [ordered_add_comm_group \u03b3] [semimodule \u211d \u03b3] [ordered_semimodule \u211d \u03b3]\n    {f : E \u2192 \u03b3} :\n    concave_on s f \u2194\n        convex (set_of fun (p : E \u00d7 \u03b3) => prod.fst p \u2208 s \u2227 prod.snd p \u2264 f (prod.fst p)) :=\n  convex_on_iff_convex_epigraph\n\n/-- If a function is convex on `s`, it remains convex when precomposed by an affine map. -/\ntheorem convex_on.comp_affine_map {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2]\n    [semimodule \u211d \u03b2] {f : F \u2192 \u03b2} (g : affine_map \u211d E F) {s : set F} (hf : convex_on s f) :\n    convex_on (\u21d1g \u207b\u00b9' s) (f \u2218 \u21d1g) :=\n  sorry\n\n/-- If a function is concave on `s`, it remains concave when precomposed by an affine map. -/\ntheorem concave_on.comp_affine_map {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2]\n    [semimodule \u211d \u03b2] {f : F \u2192 \u03b2} (g : affine_map \u211d E F) {s : set F} (hf : concave_on s f) :\n    concave_on (\u21d1g \u207b\u00b9' s) (f \u2218 \u21d1g) :=\n  convex_on.comp_affine_map g hf\n\n/-- If `g` is convex on `s`, so is `(g \u2218 f)` on `f \u207b\u00b9' s` for a linear `f`. -/\ntheorem convex_on.comp_linear_map {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2]\n    [semimodule \u211d \u03b2] {g : F \u2192 \u03b2} {s : set F} (hg : convex_on s g) (f : linear_map \u211d E F) :\n    convex_on (\u21d1f \u207b\u00b9' s) (g \u2218 \u21d1f) :=\n  convex_on.comp_affine_map (linear_map.to_affine_map f) hg\n\n/-- If `g` is concave on `s`, so is `(g \u2218 f)` on `f \u207b\u00b9' s` for a linear `f`. -/\ntheorem concave_on.comp_linear_map {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {\u03b2 : Type u_1} [ordered_add_comm_monoid \u03b2]\n    [semimodule \u211d \u03b2] {g : F \u2192 \u03b2} {s : set F} (hg : concave_on s g) (f : linear_map \u211d E F) :\n    concave_on (\u21d1f \u207b\u00b9' s) (g \u2218 \u21d1f) :=\n  concave_on.comp_affine_map (linear_map.to_affine_map f) hg\n\n/-- If a function is convex on `s`, it remains convex after a translation. -/\ntheorem convex_on.translate_right {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} {s : set E} {a : E}\n    (hf : convex_on s f) : convex_on ((fun (z : E) => a + z) \u207b\u00b9' s) (f \u2218 fun (z : E) => a + z) :=\n  convex_on.comp_affine_map (affine_map.const \u211d E a +\u1d65 affine_map.id \u211d E) hf\n\n/-- If a function is concave on `s`, it remains concave after a translation. -/\ntheorem concave_on.translate_right {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} {s : set E} {a : E}\n    (hf : concave_on s f) : concave_on ((fun (z : E) => a + z) \u207b\u00b9' s) (f \u2218 fun (z : E) => a + z) :=\n  concave_on.comp_affine_map (affine_map.const \u211d E a +\u1d65 affine_map.id \u211d E) hf\n\n/-- If a function is convex on `s`, it remains convex after a translation. -/\ntheorem convex_on.translate_left {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} {s : set E} {a : E}\n    (hf : convex_on s f) : convex_on ((fun (z : E) => a + z) \u207b\u00b9' s) (f \u2218 fun (z : E) => z + a) :=\n  sorry\n\n/-- If a function is concave on `s`, it remains concave after a translation. -/\ntheorem concave_on.translate_left {E : Type u} [add_comm_group E] [vector_space \u211d E] {\u03b2 : Type u_1}\n    [ordered_add_comm_monoid \u03b2] [semimodule \u211d \u03b2] {f : E \u2192 \u03b2} {s : set E} {a : E}\n    (hf : concave_on s f) : concave_on ((fun (z : E) => a + z) \u207b\u00b9' s) (f \u2218 fun (z : E) => z + a) :=\n  sorry\n\n/-! ### Center of mass -/\n\n/-- Center of mass of a finite collection of points with prescribed weights.\nNote that we require neither `0 \u2264 w i` nor `\u2211 w = 1`. -/\ndef finset.center_mass {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (t : finset \u03b9) (w : \u03b9 \u2192 \u211d) (z : \u03b9 \u2192 E) : E :=\n  (finset.sum t fun (i : \u03b9) => w i)\u207b\u00b9 \u2022 finset.sum t fun (i : \u03b9) => w i \u2022 z i\n\ntheorem finset.center_mass_empty {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (w : \u03b9 \u2192 \u211d) (z : \u03b9 \u2192 E) : finset.center_mass \u2205 w z = 0 :=\n  sorry\n\ntheorem finset.center_mass_pair {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (i : \u03b9) (j : \u03b9) (w : \u03b9 \u2192 \u211d) (z : \u03b9 \u2192 E) (hne : i \u2260 j) :\n    finset.center_mass (insert i (singleton j)) w z =\n        (w i / (w i + w j)) \u2022 z i + (w j / (w i + w j)) \u2022 z j :=\n  sorry\n\ntheorem finset.center_mass_insert {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (i : \u03b9) (t : finset \u03b9) {w : \u03b9 \u2192 \u211d} (z : \u03b9 \u2192 E) (ha : \u00aci \u2208 t)\n    (hw : (finset.sum t fun (j : \u03b9) => w j) \u2260 0) :\n    finset.center_mass (insert i t) w z =\n        (w i / (w i + finset.sum t fun (j : \u03b9) => w j)) \u2022 z i +\n          ((finset.sum t fun (j : \u03b9) => w j) / (w i + finset.sum t fun (j : \u03b9) => w j)) \u2022\n            finset.center_mass t w z :=\n  sorry\n\ntheorem finset.center_mass_singleton {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (i : \u03b9) {w : \u03b9 \u2192 \u211d} (z : \u03b9 \u2192 E) (hw : w i \u2260 0) : finset.center_mass (singleton i) w z = z i :=\n  sorry\n\ntheorem finset.center_mass_eq_of_sum_1 {E : Type u} {\u03b9 : Type w} [add_comm_group E]\n    [vector_space \u211d E] (t : finset \u03b9) {w : \u03b9 \u2192 \u211d} (z : \u03b9 \u2192 E)\n    (hw : (finset.sum t fun (i : \u03b9) => w i) = 1) :\n    finset.center_mass t w z = finset.sum t fun (i : \u03b9) => w i \u2022 z i :=\n  sorry\n\ntheorem finset.center_mass_smul {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (c : \u211d) (t : finset \u03b9) {w : \u03b9 \u2192 \u211d} (z : \u03b9 \u2192 E) :\n    (finset.center_mass t w fun (i : \u03b9) => c \u2022 z i) = c \u2022 finset.center_mass t w z :=\n  sorry\n\n/-- A convex combination of two centers of mass is a center of mass as well. This version\ndeals with two different index types. -/\ntheorem finset.center_mass_segment' {E : Type u} {\u03b9 : Type w} {\u03b9' : Type x} [add_comm_group E]\n    [vector_space \u211d E] (s : finset \u03b9) (t : finset \u03b9') (ws : \u03b9 \u2192 \u211d) (zs : \u03b9 \u2192 E) (wt : \u03b9' \u2192 \u211d)\n    (zt : \u03b9' \u2192 E) (hws : (finset.sum s fun (i : \u03b9) => ws i) = 1)\n    (hwt : (finset.sum t fun (i : \u03b9') => wt i) = 1) (a : \u211d) (b : \u211d) (hab : a + b = 1) :\n    a \u2022 finset.center_mass s ws zs + b \u2022 finset.center_mass t wt zt =\n        finset.center_mass\n          (finset.map function.embedding.inl s \u222a finset.map function.embedding.inr t)\n          (sum.elim (fun (i : \u03b9) => a * ws i) fun (j : \u03b9') => b * wt j) (sum.elim zs zt) :=\n  sorry\n\n/-- A convex combination of two centers of mass is a center of mass as well. This version\nworks if two centers of mass share the set of original points. -/\ntheorem finset.center_mass_segment {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (s : finset \u03b9) (w\u2081 : \u03b9 \u2192 \u211d) (w\u2082 : \u03b9 \u2192 \u211d) (z : \u03b9 \u2192 E)\n    (hw\u2081 : (finset.sum s fun (i : \u03b9) => w\u2081 i) = 1) (hw\u2082 : (finset.sum s fun (i : \u03b9) => w\u2082 i) = 1)\n    (a : \u211d) (b : \u211d) (hab : a + b = 1) :\n    a \u2022 finset.center_mass s w\u2081 z + b \u2022 finset.center_mass s w\u2082 z =\n        finset.center_mass s (fun (i : \u03b9) => a * w\u2081 i + b * w\u2082 i) z :=\n  sorry\n\ntheorem finset.center_mass_ite_eq {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    (i : \u03b9) (t : finset \u03b9) (z : \u03b9 \u2192 E) (hi : i \u2208 t) :\n    finset.center_mass t (fun (j : \u03b9) => ite (i = j) 1 0) z = z i :=\n  sorry\n\ntheorem finset.center_mass_subset {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    {t : finset \u03b9} {w : \u03b9 \u2192 \u211d} (z : \u03b9 \u2192 E) {t' : finset \u03b9} (ht : t \u2286 t')\n    (h : \u2200 (i : \u03b9), i \u2208 t' \u2192 \u00aci \u2208 t \u2192 w i = 0) :\n    finset.center_mass t w z = finset.center_mass t' w z :=\n  sorry\n\ntheorem finset.center_mass_filter_ne_zero {E : Type u} {\u03b9 : Type w} [add_comm_group E]\n    [vector_space \u211d E] {t : finset \u03b9} {w : \u03b9 \u2192 \u211d} (z : \u03b9 \u2192 E) :\n    finset.center_mass (finset.filter (fun (i : \u03b9) => w i \u2260 0) t) w z = finset.center_mass t w z :=\n  sorry\n\n/-- The center of mass of a finite subset of a convex set belongs to the set\nprovided that all weights are non-negative, and the total weight is positive. -/\ntheorem convex.center_mass_mem {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} {t : finset \u03b9} {w : \u03b9 \u2192 \u211d} {z : \u03b9 \u2192 E} (hs : convex s) :\n    (\u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i) \u2192\n        (0 < finset.sum t fun (i : \u03b9) => w i) \u2192\n          (\u2200 (i : \u03b9), i \u2208 t \u2192 z i \u2208 s) \u2192 finset.center_mass t w z \u2208 s :=\n  sorry\n\ntheorem convex.sum_mem {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    {t : finset \u03b9} {w : \u03b9 \u2192 \u211d} {z : \u03b9 \u2192 E} (hs : convex s) (h\u2080 : \u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i)\n    (h\u2081 : (finset.sum t fun (i : \u03b9) => w i) = 1) (hz : \u2200 (i : \u03b9), i \u2208 t \u2192 z i \u2208 s) :\n    (finset.sum t fun (i : \u03b9) => w i \u2022 z i) \u2208 s :=\n  sorry\n\ntheorem convex_iff_sum_mem {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} :\n    convex s \u2194\n        \u2200 (t : finset E) (w : E \u2192 \u211d),\n          (\u2200 (i : E), i \u2208 t \u2192 0 \u2264 w i) \u2192\n            (finset.sum t fun (i : E) => w i) = 1 \u2192\n              (\u2200 (x : E), x \u2208 t \u2192 x \u2208 s) \u2192 (finset.sum t fun (x : E) => w x \u2022 x) \u2208 s :=\n  sorry\n\n/-- Jensen's inequality, `finset.center_mass` version. -/\ntheorem convex_on.map_center_mass_le {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} {t : finset \u03b9} {w : \u03b9 \u2192 \u211d} {z : \u03b9 \u2192 E} {f : E \u2192 \u211d} (hf : convex_on s f)\n    (h\u2080 : \u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i) (hpos : 0 < finset.sum t fun (i : \u03b9) => w i)\n    (hmem : \u2200 (i : \u03b9), i \u2208 t \u2192 z i \u2208 s) :\n    f (finset.center_mass t w z) \u2264 finset.center_mass t w (f \u2218 z) :=\n  sorry\n\n/-- Jensen's inequality, `finset.sum` version. -/\ntheorem convex_on.map_sum_le {E : Type u} {\u03b9 : Type w} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} {t : finset \u03b9} {w : \u03b9 \u2192 \u211d} {z : \u03b9 \u2192 E} {f : E \u2192 \u211d} (hf : convex_on s f)\n    (h\u2080 : \u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i) (h\u2081 : (finset.sum t fun (i : \u03b9) => w i) = 1)\n    (hmem : \u2200 (i : \u03b9), i \u2208 t \u2192 z i \u2208 s) :\n    f (finset.sum t fun (i : \u03b9) => w i \u2022 z i) \u2264 finset.sum t fun (i : \u03b9) => w i * f (z i) :=\n  sorry\n\n/-- If a function `f` is convex on `s` takes value `y` at the center of mass of some points\n`z i \u2208 s`, then for some `i` we have `y \u2264 f (z i)`. -/\ntheorem convex_on.exists_ge_of_center_mass {E : Type u} {\u03b9 : Type w} [add_comm_group E]\n    [vector_space \u211d E] {s : set E} {t : finset \u03b9} {w : \u03b9 \u2192 \u211d} {z : \u03b9 \u2192 E} {f : E \u2192 \u211d}\n    (h : convex_on s f) (hw\u2080 : \u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i)\n    (hws : 0 < finset.sum t fun (i : \u03b9) => w i) (hz : \u2200 (i : \u03b9), i \u2208 t \u2192 z i \u2208 s) :\n    \u2203 (i : \u03b9), \u2203 (H : i \u2208 t), f (finset.center_mass t w z) \u2264 f (z i) :=\n  sorry\n\n/-! ### Convex hull -/\n\n/-- The convex hull of a set `s` is the minimal convex set that includes `s`. -/\ndef convex_hull {E : Type u} [add_comm_group E] [vector_space \u211d E] (s : set E) : set E :=\n  set.Inter fun (t : set E) => set.Inter fun (hst : s \u2286 t) => set.Inter fun (ht : convex t) => t\n\ntheorem subset_convex_hull {E : Type u} [add_comm_group E] [vector_space \u211d E] (s : set E) :\n    s \u2286 convex_hull s :=\n  set.subset_Inter\n    fun (t : set E) =>\n      set.subset_Inter fun (hst : s \u2286 t) => set.subset_Inter fun (ht : convex t) => hst\n\ntheorem convex_convex_hull {E : Type u} [add_comm_group E] [vector_space \u211d E] (s : set E) :\n    convex (convex_hull s) :=\n  convex_Inter fun (t : set E) => convex_Inter fun (ht : s \u2286 t) => convex_Inter id\n\ntheorem convex_hull_min {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {t : set E}\n    (hst : s \u2286 t) (ht : convex t) : convex_hull s \u2286 t :=\n  set.Inter_subset_of_subset t\n    (set.Inter_subset_of_subset hst (set.Inter_subset (fun (ht : convex t) => t) ht))\n\ntheorem convex_hull_mono {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E} {t : set E}\n    (hst : s \u2286 t) : convex_hull s \u2286 convex_hull t :=\n  convex_hull_min (set.subset.trans hst (subset_convex_hull t)) (convex_convex_hull t)\n\ntheorem convex.convex_hull_eq {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    (hs : convex s) : convex_hull s = s :=\n  set.subset.antisymm (convex_hull_min (set.subset.refl s) hs) (subset_convex_hull s)\n\n@[simp] theorem convex_hull_singleton {E : Type u} [add_comm_group E] [vector_space \u211d E] {x : E} :\n    convex_hull (singleton x) = singleton x :=\n  convex.convex_hull_eq (convex_singleton x)\n\ntheorem is_linear_map.image_convex_hull {E : Type u} {F : Type v} [add_comm_group E]\n    [vector_space \u211d E] [add_comm_group F] [vector_space \u211d F] {s : set E} {f : E \u2192 F}\n    (hf : is_linear_map \u211d f) : f '' convex_hull s = convex_hull (f '' s) :=\n  sorry\n\ntheorem linear_map.image_convex_hull {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] {s : set E} (f : linear_map \u211d E F) :\n    \u21d1f '' convex_hull s = convex_hull (\u21d1f '' s) :=\n  is_linear_map.image_convex_hull (linear_map.is_linear f)\n\ntheorem finset.center_mass_mem_convex_hull {E : Type u} {\u03b9 : Type w} [add_comm_group E]\n    [vector_space \u211d E] {s : set E} (t : finset \u03b9) {w : \u03b9 \u2192 \u211d} (hw\u2080 : \u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i)\n    (hws : 0 < finset.sum t fun (i : \u03b9) => w i) {z : \u03b9 \u2192 E} (hz : \u2200 (i : \u03b9), i \u2208 t \u2192 z i \u2208 s) :\n    finset.center_mass t w z \u2208 convex_hull s :=\n  convex.center_mass_mem (convex_convex_hull s) hw\u2080 hws\n    fun (i : \u03b9) (hi : i \u2208 t) => subset_convex_hull s (hz i hi)\n\n-- TODO : Do we need other versions of the next lemma?\n\n/-- Convex hull of `s` is equal to the set of all centers of masses of `finset`s `t`, `z '' t \u2286 s`.\nThis version allows finsets in any type in any universe. -/\ntheorem convex_hull_eq {E : Type u} [add_comm_group E] [vector_space \u211d E] (s : set E) :\n    convex_hull s =\n        set_of\n          fun (x : E) =>\n            \u2203 (\u03b9 : Type u'),\n              \u2203 (t : finset \u03b9),\n                \u2203 (w : \u03b9 \u2192 \u211d),\n                  \u2203 (z : \u03b9 \u2192 E),\n                    \u2203 (hw\u2080 : \u2200 (i : \u03b9), i \u2208 t \u2192 0 \u2264 w i),\n                      \u2203 (hw\u2081 : (finset.sum t fun (i : \u03b9) => w i) = 1),\n                        \u2203 (hz : \u2200 (i : \u03b9), i \u2208 t \u2192 z i \u2208 s), finset.center_mass t w z = x :=\n  sorry\n\n/-- Maximum principle for convex functions. If a function `f` is convex on the convex hull of `s`,\nthen `f` can't have a maximum on `convex_hull s` outside of `s`. -/\ntheorem convex_on.exists_ge_of_mem_convex_hull {E : Type u} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} {f : E \u2192 \u211d} (hf : convex_on (convex_hull s) f) {x : E} (hx : x \u2208 convex_hull s) :\n    \u2203 (y : E), \u2203 (H : y \u2208 s), f x \u2264 f y :=\n  sorry\n\ntheorem finset.convex_hull_eq {E : Type u} [add_comm_group E] [vector_space \u211d E] (s : finset E) :\n    convex_hull \u2191s =\n        set_of\n          fun (x : E) =>\n            \u2203 (w : E \u2192 \u211d),\n              \u2203 (hw\u2080 : \u2200 (y : E), y \u2208 s \u2192 0 \u2264 w y),\n                \u2203 (hw\u2081 : (finset.sum s fun (y : E) => w y) = 1), finset.center_mass s w id = x :=\n  sorry\n\ntheorem set.finite.convex_hull_eq {E : Type u} [add_comm_group E] [vector_space \u211d E] {s : set E}\n    (hs : set.finite s) :\n    convex_hull s =\n        set_of\n          fun (x : E) =>\n            \u2203 (w : E \u2192 \u211d),\n              \u2203 (hw\u2080 : \u2200 (y : E), y \u2208 s \u2192 0 \u2264 w y),\n                \u2203 (hw\u2081 : (finset.sum (set.finite.to_finset hs) fun (y : E) => w y) = 1),\n                  finset.center_mass (set.finite.to_finset hs) w id = x :=\n  sorry\n\ntheorem convex_hull_eq_union_convex_hull_finite_subsets {E : Type u} [add_comm_group E]\n    [vector_space \u211d E] (s : set E) :\n    convex_hull s = set.Union fun (t : finset E) => set.Union fun (w : \u2191t \u2286 s) => convex_hull \u2191t :=\n  sorry\n\ntheorem is_linear_map.convex_hull_image {E : Type u} {F : Type v} [add_comm_group E]\n    [vector_space \u211d E] [add_comm_group F] [vector_space \u211d F] {f : E \u2192 F} (hf : is_linear_map \u211d f)\n    (s : set E) : convex_hull (f '' s) = f '' convex_hull s :=\n  sorry\n\ntheorem linear_map.convex_hull_image {E : Type u} {F : Type v} [add_comm_group E] [vector_space \u211d E]\n    [add_comm_group F] [vector_space \u211d F] (f : linear_map \u211d E F) (s : set E) :\n    convex_hull (\u21d1f '' s) = \u21d1f '' convex_hull s :=\n  is_linear_map.convex_hull_image (linear_map.is_linear f) s\n\n/-! ### Simplex -/\n\n/-- The standard simplex in the space of functions `\u03b9 \u2192 \u211d` is the set\nof vectors with non-negative coordinates with total sum `1`. -/\ndef std_simplex (\u03b9 : Type u_1) [fintype \u03b9] : set (\u03b9 \u2192 \u211d) :=\n  set_of fun (f : \u03b9 \u2192 \u211d) => (\u2200 (x : \u03b9), 0 \u2264 f x) \u2227 (finset.sum finset.univ fun (x : \u03b9) => f x) = 1\n\ntheorem std_simplex_eq_inter (\u03b9 : Type w) [fintype \u03b9] :\n    std_simplex \u03b9 =\n        (set.Inter fun (x : \u03b9) => set_of fun (f : \u03b9 \u2192 \u211d) => 0 \u2264 f x) \u2229\n          set_of fun (f : \u03b9 \u2192 \u211d) => (finset.sum finset.univ fun (x : \u03b9) => f x) = 1 :=\n  sorry\n\ntheorem convex_std_simplex (\u03b9 : Type w) [fintype \u03b9] : convex (std_simplex \u03b9) := sorry\n\ntheorem ite_eq_mem_std_simplex {\u03b9 : Type w} [fintype \u03b9] (i : \u03b9) :\n    (fun (j : \u03b9) => ite (i = j) 1 0) \u2208 std_simplex \u03b9 :=\n  sorry\n\n/-- `std_simplex \u03b9` is the convex hull of the canonical basis in `\u03b9 \u2192 \u211d`. -/\ntheorem convex_hull_basis_eq_std_simplex {\u03b9 : Type w} [fintype \u03b9] :\n    convex_hull (set.range fun (i j : \u03b9) => ite (i = j) 1 0) = std_simplex \u03b9 :=\n  sorry\n\n/-- The convex hull of a finite set is the image of the standard simplex in `s \u2192 \u211d`\nunder the linear map sending each function `w` to `\u2211 x in s, w x \u2022 x`.\n\nSince we have no sums over finite sets, we use sum over `@finset.univ _ hs.fintype`.\nThe map is defined in terms of operations on `(s \u2192 \u211d) \u2192\u2097[\u211d] \u211d` so that later we will not need\nto prove that this map is linear. -/\ntheorem set.finite.convex_hull_eq_image {E : Type u} [add_comm_group E] [vector_space \u211d E]\n    {s : set E} (hs : set.finite s) :\n    convex_hull s =\n        \u21d1(finset.sum finset.univ\n              fun (x : \u21a5s) => linear_map.smul_right (linear_map.proj x) (subtype.val x)) ''\n          std_simplex \u21a5s :=\n  sorry\n\n/-- All values of a function `f \u2208 std_simplex \u03b9` belong to `[0, 1]`. -/\ntheorem mem_Icc_of_mem_std_simplex {\u03b9 : Type w} [fintype \u03b9] {f : \u03b9 \u2192 \u211d} (hf : f \u2208 std_simplex \u03b9)\n    (x : \u03b9) : f x \u2208 set.Icc 0 1 :=\n  { left := and.left hf x,\n    right :=\n      and.right hf \u25b8\n        finset.single_le_sum (fun (y : \u03b9) (hy : y \u2208 finset.univ) => and.left hf y)\n          (finset.mem_univ x) }\n\nend Mathlib"}
{"text": "/-\nCopyright (c) 2022 Michael Stoll. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Michael Stoll\n\n! This file was ported from Lean 3 source module data.fin.tuple.bubble_sort_induction\n! leanprover-community/mathlib commit 4c19a16e4b705bf135cf9a80ac18fcc99c438514\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathlib.Data.Fin.Tuple.Sort\nimport Mathlib.Data.Fintype.Perm\nimport Mathlib.Order.WellFounded\n\n/-!\n# \"Bubble sort\" induction\n\nWe implement the following induction principle `Tuple.bubble_sort_induction`\non tuples with values in a linear order `\u03b1`.\n\nLet `f : Fin n \u2192 \u03b1` and let `P` be a predicate on `Fin n \u2192 \u03b1`. Then we can show that\n`f \u2218 sort f` satisfies `P` if `f` satisfies `P`, and whenever some `g : Fin n \u2192 \u03b1`\nsatisfies `P` and `g i > g j` for some `i < j`, then `g \u2218 swap i j` also satisfies `P`.\n\nWe deduce it from a stronger variant `Tuple.bubble_sort_induction'`, which\nrequires the assumption only for `g` that are permutations of `f`.\n\nThe latter is proved by well-founded induction via `WellFounded.induction_bot'`\nwith respect to the lexicographic ordering on the finite set of all permutations of `f`.\n-/\n\n\nnamespace Tuple\n\n/-- *Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satsifies `P` and `P` is preserved on permutations of `f` when swapping two\nantitone values. -/\ntheorem bubble_sort_induction' {n : \u2115} {\u03b1 : Type _} [LinearOrder \u03b1] {f : Fin n \u2192 \u03b1}\n    {P : (Fin n \u2192 \u03b1) \u2192 Prop} (hf : P f)\n    (h :\n      \u2200 (\u03c3 : Equiv.Perm (Fin n)) (i j : Fin n),\n        i < j \u2192 (f \u2218 \u03c3) j < (f \u2218 \u03c3) i \u2192 P (f \u2218 \u03c3) \u2192 P (f \u2218 \u03c3 \u2218 Equiv.swap i j)) :\n    P (f \u2218 sort f) := by\n  letI := @Preorder.lift _ (Lex (Fin n \u2192 \u03b1)) _ fun \u03c3 : Equiv.Perm (Fin n) => toLex (f \u2218 \u03c3)\n  refine'\n    @WellFounded.induction_bot' _ _ _ (@Finite.Preorder.wellFounded_lt (Equiv.Perm (Fin n)) _ _)\n      (Equiv.refl _) (sort f) P (fun \u03c3 => f \u2218 \u03c3) (fun \u03c3 h\u03c3 hf\u03c3 => _) hf\n  obtain \u27e8i, j, hij\u2081, hij\u2082\u27e9 := antitone_pair_of_not_sorted' h\u03c3\n  exact \u27e8\u03c3 * Equiv.swap i j, Pi.lex_desc hij\u2081 hij\u2082, h \u03c3 i j hij\u2081 hij\u2082 hf\u03c3\u27e9\n#align tuple.bubble_sort_induction' Tuple.bubble_sort_induction'\n\n/-- *Bubble sort induction*: Prove that the sorted version of `f` has some property `P`\nif `f` satsifies `P` and `P` is preserved when swapping two antitone values. -/\ntheorem bubble_sort_induction {n : \u2115} {\u03b1 : Type _} [LinearOrder \u03b1] {f : Fin n \u2192 \u03b1}\n    {P : (Fin n \u2192 \u03b1) \u2192 Prop} (hf : P f)\n    (h : \u2200 (g : Fin n \u2192 \u03b1) (i j : Fin n), i < j \u2192 g j < g i \u2192 P g \u2192 P (g \u2218 Equiv.swap i j)) :\n    P (f \u2218 sort f) :=\n  bubble_sort_induction' hf fun _ => h _\n#align tuple.bubble_sort_induction Tuple.bubble_sort_induction\n\nend Tuple\n"}
{"text": "import hilbert.wr.or\nimport hilbert.wr.or_bot\n\nnamespace clfrags\n    namespace hilbert\n        namespace wr\n            namespace or_bot\n                theorem  db\u2081_or {a b : Prop} (h\u2081 : or b (or a bot)) : or b a :=\n                    have h\u2082 : or (or b a) bot, from or.d\u2084 h\u2081,\n                    show or b a, from db\u2081 h\u2082\n\n                theorem  b\u2081 {a : Prop} (h\u2081 : bot) : a :=\n                    have h\u2082 : or bot a, from or.d\u2081 h\u2081,\n                    have h\u2083 : or a bot, from or.d\u2083 h\u2082,\n                    show a, from db\u2081 h\u2083\n            end or_bot\n        end wr\n    end hilbert\nend clfrags\n\n"}
{"text": "Require ILLImplementation.\nRequire ResILLBase.\n\nExtract Inductive bool => \"bool\" [ \"true\" \"false\" ].\nExtract Inductive sumbool => \"bool\" [\"true\" \"false\" ].\nExtract Inductive sumor => \"option\" [\"Some\" \"None\" ].\nExtract Inductive option => \"option\" [\"Some\" \"None\" ].\nExtract Inductive unit => \"unit\" [\"()\"].\nExtract Inductive nat => \"Common.Types.nat\" [\"Common.Types.O\" \"Common.Types.S\"].\nExtract Inductive list => \"list\" [ \"[]\" \"(::)\" ].\nExtract Inductive prod => \"(*)\" [ \"(,)\" ].\n\nRecursive Extraction Library ILLImplementation.\nRecursive Extraction Library ResILLBase.\n\n(*\n   Local Variables:\n   coq-prog-args: (\"-emacs-U\" \"-I\" \"..\" \"-R\" \".\" \"ILL\")\n   End:\n   *)\n"}
{"text": "[STATEMENT]\nlemma rule_states_l_correct[simp]: \n  \"ls_\\<alpha> (rule_states_l r) = rule_states r\"\n  \"ls_invar (rule_states_l r)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. ls.\\<alpha> (rule_states_l r) = rule_states r &&& ls.invar (rule_states_l r)\n[PROOF STEP]\nby (cases r, simp add: ls.correct)+"}
{"text": "import algebra.group_power tactic.norm_num algebra.big_operators\n\ntheorem Q2 (n : \u2115) : n \u2265 2 \u2192 nat.pow 4 n > nat.pow 3 n + nat.pow 2 n :=\n"}
{"text": "      PRINT X ++ 5\n      END"}
{"text": "State Before: f g : \u2102 \u2192 \u2102\ns : Set \u2102\nf' g' x c : \u2102\n\u22a2 \u2191((g x * f x ^ (g x - 1)) \u2022 ContinuousLinearMap.smulRight 1 f' +\n          (f x ^ g x * log (f x)) \u2022 ContinuousLinearMap.smulRight 1 g')\n      1 =\n    g x * f x ^ (g x - 1) * f' + f x ^ g x * log (f x) * g' State After: no goals Tactic: simp only [Algebra.id.smul_eq_mul, one_mul, ContinuousLinearMap.one_apply,\n  ContinuousLinearMap.smulRight_apply, ContinuousLinearMap.add_apply, Pi.smul_apply,\n  ContinuousLinearMap.coe_smul']"}
{"text": "[STATEMENT]\nlemma eval_tm_SNOC[simp]:\n  \"\\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow>\n   eval_tm (SNOC x \\<AA>) is = eval_tm \\<AA> is + 2 ^ Length \\<AA> * scalar_product x is\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<lbrakk>length is \\<le> #\\<^sub>V \\<AA>; #\\<^sub>V \\<AA> = length x\\<rbrakk> \\<Longrightarrow> eval_tm (SNOC x \\<AA>) is = eval_tm \\<AA> is + 2 ^ Length \\<AA> * scalar_product (map of_bool x) is\n[PROOF STEP]\nby transfer (auto simp: scalar_product_SNOC[symmetric]\n    intro!: arg_cong2[of _ _ _ _ scalar_product] nth_equalityI)"}
{"text": "Welcome to Coq 8.4pl4 (November 2015)\n\nCoq < Theorem mult_0_plus' : forall n m : nat, (0 + n) * m = n * m.\n1 subgoal\n  \n  ============================\n   forall n m : nat, (0 + n) * m = n * m\n\nmult_0_plus' < Proof.\n1 subgoal\n  \n  ============================\n   forall n m : nat, (0 + n) * m = n * m\n\nmult_0_plus' < info_auto.\n(* info auto : *)\n intro.\n intro.\n apply @eq_refl.\nNo more subgoals.\n\nmult_0_plus' < Qed.\ninfo_auto.\n\nmult_0_plus' is defined\n"}
{"text": "variables (f : \u2115 \u2192 \u2115) (a b : \u2115)\n\nexample (h\u2081 : a = b) (h\u2082 : f a = 0) : f b = 0 :=\nbegin\n  rw [\u2190h\u2081, h\u2082]\nend\n"}
{"text": "theory Scratch\nimports Main\nbegin\n\nlemma \\<open>\\<forall>x. P x\\<close>\n  oops\n\ntext \\<open>This is another test.\n  There are multiple things to do.\n  \\<close>\n\nnotepad\nbegin\n  fix S T :: 'a\n  have \\<open>T = S\\<close>\n    if \\<open>S = T\\<close>\n    for S\n    using that\n    by auto\n\n  have \\<open>T = S\\<close>\n    if \\<open>S = T\\<close>\n    for S\n    unfolding that\n    by auto\nend\n\ndatatype finite_type = A | B\n\ninstantiation finite_type :: finite\nbegin\nlemma UNIV_finite_type: \\<open>UNIV = {A, B}\\<close>\n  apply auto\n  using finite_type.exhaust by blast\n\ninstance\n  apply standard\n  unfolding UNIV_finite_type\n  apply auto\n  done\nend\n\nproposition\n  fixes x\n  assumes\n    \\<open>P x\\<close> and\n    \\<open>Q x\\<close>\n  obtains y z where\n    \\<open>y = P x\\<close> and\n    \\<open>z = Q x\\<close> and\n    \\<open>True\\<close>\n  using TrueI\n  oops\n\nlemma \\<open>P x\\<close>\nproof -\n  have \\<open>P x\\<close>\n    if \\<open>P x\\<close>\n    for x\n  proof -\n    have \\<open>P x\\<close>\n      if \\<open>P x\\<close>\n      for x\n      by (use that in auto)\n    have \\<open>True\\<close>\n      by auto\n    show ?thesis\n      using that by auto\n  qed\n  then show \\<open>?thesis\\<close>\n    oops\n\nlemma \\<open>True\\<close>\n  ..\n\nlemma \\<open>P x\\<close> if \\<open>P x\\<close>\nproof -\n  show \\<open>P x\\<close>\n    by (use that in auto)\nqed\n\nlemma \\<open>P x\\<close> for x :: \\<open>nat list\\<close>\nproof (induction x)\n  case Nil\n  then show ?case sorry\nnext\n  case (Cons a x)\n  have H: \\<open>P \\<Longrightarrow> P\\<close> for P\n    by auto\n  show ?case\n    apply -\n    apply (rule H)\n    sorry\nqed\n\n\nlemma \\<open>P x\\<close> for x :: \\<open>nat list\\<close>\nproof -\n  show \\<open>P x\\<close> for x\n  proof (induction x)\n    case Nil\n    then show ?case sorry\n  next\n    case (Cons a x)\n    then show ?case sorry\n  qed\nqed\n\nsection \\<open>There is more\\<close>\nsubsection \\<open>Indented to the right\\<close>\n\nnotepad\nbegin\n  have P if \"P ==> P\" for P\n    apply (rule that)\n    subgoal sorry\n    done\nend\n\nlemma name_with_boundary: \\<open>P \\<Longrightarrow> P\\<close>\n  by auto\n\nlemma \\<open>P \\<Longrightarrow> P\\<close>\n  apply (rule\n    name_with_boundary)\n  oops\n\n\nsection \\<open>Known indentation bugs\\<close>\nnotepad\nbegin\n  have P if \"P \\<Longrightarrow> P\" \"P\" for P\n    apply (rule that)\n    subgoal apply (rule that(2))\n    done \\<comment> \\<open>This done is wrong, but I cannot fix it without knowdegde from the goals.\\<close>\n    done\nend\n\ntext \\<open>The labels in the following predicate is wrongly indented, but jEdit is not better:\\<close>\ninductive rtranclp :: \\<open>('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a \\<Rightarrow> 'a \\<Rightarrow> bool\\<close> for r :: \\<open>'a \\<Rightarrow> 'a \\<Rightarrow> bool\\<close> where\n  base:\n  \\<open>rtranclp r a a\\<close> |\n  step:\n  \\<open>rtranclp r a c\\<close>\n  if\n    \\<open>r a b\\<close>\n    \\<open>rtranclp r b c\\<close>\n\n\nsection \\<open>Test part\\<close>\n\nlemma False\n  by auto\n\nlemma True\n  by simp\n\nlemma True\n  by simp\n\nend\n"}
{"text": "#ifndef _GDRDGEMM_H\n#define _GDRDGEMM_H\n\n#ifndef MKL\n#include <cblas.h>\n#else\n#include <mkl_cblas.h>\n#endif\n\n#define NMAT 2048\nvoid gdr_check_and_restart(double a[][NMAT],\n\t\t\t   double b[][NMAT], \n\t\t\t   double c[][NMAT]);\n\nvoid gdrblas_dgemm\n(\n#ifndef MKL \n   const enum CBLAS_ORDER             ORDER,\n   const enum CBLAS_TRANSPOSE             TRANSA,\n   const enum CBLAS_TRANSPOSE             TRANSB,\n#else\n   const CBLAS_ORDER             ORDER,\n   const CBLAS_TRANSPOSE             TRANSA,\n   const CBLAS_TRANSPOSE             TRANSB,\n#endif   \n   const int                        M,\n   const int                        N,\n   const int                        K,\n   const double                     ALPHA,\n   const double *                   A,\n   const int                        LDA,\n   const double *                   B,\n   const int                        LDB,\n   const double                     BETA,\n   double *                         C,\n   const int                        LDC\n   );\n\nvoid mygdrdgemm(int m,\n\t\tint n,\n\t\tint k,\n\t\tdouble alpha,\n\t\tdouble * a,\n\t\tint na,\n\t\tdouble * b,\n\t\tint nb,\n\t\tdouble beta,\n\t\tdouble * c,\n\t\tint nc);\n\n#endif\n"}
{"text": "/-\nCopyright (c) 2022 Jannis Limperg. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Asta H. From, Jannis Limperg\n-/\n\n-- This test checks whether the output of trace.aesop.proof is\n-- copy-and-pastable. When the test breaks because Aesop's output has changed,\n-- please copy-and-paste the output to All.split_cons\u2082 and check whether it\n-- still works.\n\nimport Aesop\n\n@[aesop safe [constructors, (cases (patterns := [All _ [], All _ (_ :: _)]))]]\ninductive All (P : \u03b1 \u2192 Prop) : List \u03b1 \u2192 Prop\n  | nil : All P []\n  | cons {x xs} : P x \u2192 All P xs \u2192 All P (x :: xs)\n\ntheorem All.split_cons (P : \u03b1 \u2192 Prop) (x : \u03b1) (xs : List \u03b1) (h : All P (x :: xs))\n  : P x \u2227 All P xs := by\n  set_option trace.aesop.proof true in\n  aesop\n\nset_option linter.unusedVariables false in\ntheorem All.split_cons\u2082 (P : \u03b1 \u2192 Prop) (x : \u03b1) (xs : List \u03b1) (h : All P (x :: xs))\n  : P x \u2227 All P xs :=\n      (fun (h_1 : All P (x :: xs)) =>\n          ((fun (h_2 : All P (x :: xs)) =>\n                (All.casesOn (P := P) (motive := fun a x_1 => x :: xs = a \u2192 HEq h x_1 \u2192 P x \u2227 All P xs) h_2\n                    (fun h_1 => List.noConfusion h_1) fun {x_1} {xs_1} a a_1 h_1 =>\n                    List.noConfusion h_1 fun head_eq =>\n                      Eq.ndrec (motive := fun {x_1} =>\n                        \u2200 (a : P x_1), xs = xs_1 \u2192 HEq h (All.cons (P := P) a a_1) \u2192 P x \u2227 All P xs)\n                        (fun a tail_eq =>\n                          Eq.ndrec (motive := fun {xs_1} =>\n                            \u2200 (a_1 : All P xs_1), HEq h (All.cons (P := P) a a_1) \u2192 P x \u2227 All P xs)\n                            (fun a_1 h_1 =>\n                              Eq.ndrec (motive := fun h => P x \u2227 All P xs)\n                                (of_eq_true (Eq.trans (congr (congrArg And (eq_true a)) (eq_true a_1)) (and_self True)))\n                                (Eq.symm (eq_of_heq h_1)))\n                            tail_eq a_1)\n                        head_eq a :\n                  x :: xs = x :: xs \u2192 HEq h h_2 \u2192 P x \u2227 All P xs))\n              h_1 :\n            x :: xs = x :: xs \u2192 HEq h h_1 \u2192 P x \u2227 All P xs))\n        h (Eq.refl (x :: xs)) (HEq.refl h)\n"}
{"text": "theorem my_first_theorem\n(P : Prop) : P \u2192 P :=\nbegin\nintro,\nassumption,\nend\n"}
{"text": "informal statement Let $f: S^{1} \\rightarrow \\mathbb{R}$ be a continuous map. Show there exists a point $x$ of $S^{1}$ such that $f(x)=f(-x)$.formal statement theorem exercise_25_4 {X : Type*} [topological_space X]\n  [loc_path_connected_space X] (U : set X) (hU : is_open U)\n  (hcU : is_connected U) : is_path_connected U :="}
{"text": "/-\nThis example demonstrates why allowing types such as\n\ninductive D : Type :=\n| intro : (D \u2192 D) \u2192 D\n\nwould make the system inconsistent\n-/\n\n/- If we were allowed to form the inductive type\n\n     inductive D : Type :=\n     | intro : (D \u2192 D) \u2192 D\n\n   we would get the following\n-/\nuniverse l\n-- The new type A\naxiom D : Type.{l}\n-- The constructor\naxiom introD : (D \u2192 D) \u2192 D\n-- The eliminator\naxiom recD   : \u03a0 {C : D \u2192 Type}, (\u03a0 (f : D \u2192 D) (r : \u03a0 d, C (f d)), C (introD f)) \u2192 (\u03a0 (d : D), C d)\n-- We would also get a computational rule for the eliminator, but we don't need it for deriving the inconsistency.\n\nnoncomputable definition id' : D \u2192 D := \u03bbd, d\nnoncomputable definition v  : D     := introD id'\n\ntheorem inconsistent : false :=\nrecD (\u03bb f ih, ih v) v\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_11\n  (a b : \u211d)\n  (h\u2080 : a \u2260 b)\n  (h\u2081 : a \u2260 2*b)\n  (h\u2082 : (4 * a + 3 * b) / (a - 2 * b) = 5) :\n  (a + 11 * b) / (a - b) = 2 :=\nbegin\n  field_simp [*, sub_ne_zero, mul_assoc, mul_comm] at *,\n  linarith,\nend"}
{"text": "lemma iff_trans (P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R) :=\nbegin\n    intros pq qr,\n    split,\n    {\n        intro p,\n        apply qr.1,\n        apply pq.1,\n        exact p,\n    },\n    {\n        intro r,\n        apply pq.2,\n        apply qr.2,\n        exact r,\n    },\nend\n\nlemma iff_trans_2 (P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R) :=\nbegin\n    intros pq qr,\n    rw pq,\n    rw qr,\nend"}
{"text": "partial def inf (u : Unit) : List Unit := u :: inf u\n\ntheorem aa : False :=\n  nomatch (\u27e8inf._unsafe_rec (), rfl\u27e9 : \u2203 l, l = () :: l)\n"}
{"text": "lemma le_refl (x : mynat) : x \u2264 x :=\nbegin\nuse 0,\nrefl,\nend\n"}
{"text": "open classical\n\ntheorem Ex009(a b c: Prop): \u00acc \u2192 a \u2228 ((a \u2228 c) \u2192 b):= \nassume H1:\u00acc ,\n  have A:\u00ac(a \u2228 ((a \u2228 c) \u2192 b)) \u2192 false, from \n  (\n    assume H2:\u00ac(a \u2228 ((a \u2228 c) \u2192 b)),\n    have B:(a \u2228 c) \u2192 b, from \n    (\n      assume H3:a \u2228 c,\n      show b , from or.elim H3 \n      (\n        assume H4:a,\n        have D:a \u2228 ((a \u2228 c) \u2192 b), from or.inl H4,\n        have false, from H2 D,\n        show b,from false.elim this\n      )\n      (\n        assume H5:c,\n        have E:false, from H1 H5,\n        show b,from false.elim E\n      )\n    ),\n    have  a \u2228 ((a \u2228 c) \u2192 b), from or.inr B,\n    show false, from H2 this\n  ),\n  have F:\u00ac\u00ac(a \u2228 ((a \u2228 c) \u2192 b)), from not.intro A,\n  by_contradiction\n  (\n    assume H6:\u00ac(a \u2228 ((a \u2228 c) \u2192 b)),\n    show false, from F H6\n  )\n"}
{"text": "/-\nCopyright (c) 2023 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\nimport Mathlib.Tactic.SolveByElim\n\nregister_label_attr ineq_rules\n\nregister_label_attr ineq_extra\n\nregister_label_attr mod_rules\n\nregister_label_attr mod_extra\n\nregister_label_attr iff_rules\n\nsyntax (name := RelSyntax) \"mod_subst\" \" [\" term,* \"] \" : tactic\nsyntax (name := ExtraSyntax) \"extra\" : tactic\n\nopen Lean Mathlib Tactic\n\ndef RelConfig : SolveByElim.Config :=\n{ transparency := .instances\n  -- On applying a lemma or hypothesis successfully, don't backtrack\n  failAtMaxDepth := false\n  maxDepth := 50 }\n\ndef Lean.MVarId.Rel (attr : Name) (add : List Term) (m : MessageData)\n    (disch : MVarId \u2192 MetaM (Option (List MVarId)) := fun _ => pure none)\n    (proc : List MVarId \u2192 List MVarId \u2192 MetaM (Option (List MVarId)) := fun _ _ => pure none)\n    (g : MVarId) :\n    MetaM (List MVarId) := do\n  let cfg : SolveByElim.Config := { RelConfig with discharge := disch, proc := proc }\n  let [] \u2190 SolveByElim.solveByElim.processSyntax cfg true false add [] #[mkIdent attr] [g]\n    | throwError m\n  return []\n"}
{"text": "import data.nat.order.basic\n\n-- Utility library for three maxes of \u2115\n\n/-- maximum of three natural numbers. -/\ndef max3 (a b c : \u2115) : \u2115 := max (max a b) c\n\ntheorem max3_mul_left (a b c d : \u2115) :\n  max3 (a * b) (a * c) (a * d) = a * max3 b c d :=\nbegin\n  -- This is hard: should I use `max_mul_of_nonneg`\n  -- or `max_mul_mul_left`?\n  rw nat.mul_comm a (max3 b c d),\n  simp_rw max3,\n  rw max_mul_of_nonneg _ _ (zero_le a),\n  rw max_mul_of_nonneg _ _ (zero_le a),\n  repeat {rw nat.mul_comm a _},\nend\n\ntheorem le_max3_first (a b c : \u2115) : a \u2264 max3 a b c :=\n  le_max_of_le_left (le_max_left _ _)\n\ntheorem le_max3_second (a b c : \u2115) : b \u2264 max3 a b c :=\n  le_max_of_le_left (le_max_right _ _)\n\ntheorem le_max3_third (a b c : \u2115) : c \u2264 max3 a b c :=\n  le_max_right _ _\n\ntheorem max3_lt_iff {a b c d : \u2115} : \n  max3 a b c < d \u2194 a < d \u2227 b < d \u2227 c < d :=\nbegin\n  rw max3, simp only [max_lt_iff], tauto,\nend\n\ntheorem add3_le_three_mul_max3 (a b c : \u2115) : \n  a + b + c \u2264 3 * max3 a b c :=\nbegin\n  rw (show 3 = 2 + 1, by exact rfl),\n  rw [nat.succ_mul, two_mul],\n  apply nat.add_le_add _ (le_max3_third _ _ _),\n  apply nat.add_le_add _ (le_max3_second _ _ _),\n  exact le_max3_first _ _ _,\nend\n\ntheorem weighted_average_le_max3 {p q r a b c: \u2115} :\n  p*a + q*b + r*c \u2264 (p+q+r)*(max3 a b c) := \nbegin\n  simp_rw add_mul,\n  apply nat.add_le_add,\n  apply nat.add_le_add,\n  exact nat.mul_le_mul (le_refl _) (le_max3_first _ _ _),\n  exact nat.mul_le_mul (le_refl _) (le_max3_second _ _ _),\n  exact nat.mul_le_mul (le_refl _) (le_max3_third _ _ _),\nend"}
{"text": "\n\n\\section{Contextual Rewriting}\n\nArbitrary extra contextual rewrites can be introduced by\nusing \"congurence rules\".  These are theorems of a particular\nshape.\n\nThe general form must be:\n\\begin{verbatim}\n|- !x1 x1' ... xn xn'.\n     (!v11...v1m. x1 v11 ... v1m = x1' v11 ... v1m) ==>\n     (!v21...v2m. [P[x1,v21,...v2m] ==>] x2 v21 ... v2m = x2' v21 ... v2m) ==>\n     ...\n     F[x1,x2,..,xn] = F[x1',x2',..,xn']\n\\end{verbatim}\nThat probably doesn't make much sense.  Think of F as the construct\nover which you are expressing the congruence.  Think of x1,x2,...xn\nas the sub-constructs which are being rewritten, some of them under\nadditional assumptions.  The implications (one on each line in the \nsample above) state the necessary results which need to be derived \nabout the subcomponents before the congruence can be deduced.  Some\nof these subcomponenets may be rewritten with extra assumpions - this\nis indicated by P[x1] above.\n\nSome subcomponents may also be functions - in this case we want\nto rewrite them as applied to sets of variables v1...v1m etc.\nSee the rule for restricted quantifiers for examples.\nThe simplifier does a degree of higher order matching when\nthese variables are specified.\n\nSome examples:\n\\begin{verbatim}\n |- !g g' t t' e e'.\n       (g = g') ==>\n       (g ==> (t = t')) ==>\n       (~g ==> (e = e')) ==>\n       ((g => t | e) = (g' => t' | e')) : thm\n\n  |- !P P' Q Q'.\n       (!x. P x = P' x) ==>\n       (!x. P x ==> (Q x = Q' x)) ==>\n       (RES_EXISTS P Q = RES_EXISTS P' Q') : thm\n\\end{verbatim}\n\n\n\n\n\\section{Contextual Rewriting}\n\nContextual rewriting lets you add assumptions to your rewrite\nset as you descend into a term.\n\nThe most obvious contextual rewrite is for terms of the form:\n\\begin{verbatim}\n\t\tP ==> Q\n\\end{verbatim}\nThe simplifier can use any rewrites that come from P\nwhen rewriting Q.  \n\nOther contextual rewrites included are:\n\\begin{verbatim}\n\t      P => T1 | T2  (assume P when rewriting T1, ~P when rewriting T2)\n\t      !x::P. T1[x]  (assume \"P x\" when rewriting T1[x])\n\t      ?x::P. T1[x]  (assume \"P x\" when rewriting T1[x])\n\t      \\x::P. T1[x]  (assume \"P x\" when rewriting T1[x])\n\\end{verbatim}\n\n\n\\section{Conditional Rewriting}\n\nAny theorem which can be converted to the form\n\\begin{verbatim}\n\t|- P1[x1...xm] ==> ... Pm[x1...xm] ==> (T1[x1...xm] = T2 [x1...xm])\n\\end{verbatim}\ncan potentially be used as a conditional rewrite.  This is \nlike the existing conditional rewriting in HOL.  However, the process\nof producing conditional rewrites is automated by setting the \"rewrite\nmaker\" in your simpset.  For example, res\\_quan\\_ss (the simpset\nfor the res\\_quan library) extends the rewrite maker to be able to convert\ntheorems such as:\n\\begin{verbatim}\n|- !n. !w ::(PWORDLEN n). NBWORD n (BNVAL w) = w : thm\n\\end{verbatim}\ninto conditional rewrites.  The above theorem will become:\n\\begin{verbatim}\n|- PWORDLEN n w ==> (NBWORD n (BNVAL w) = w)\n\\end{verbatim}\nand will only be applied if \"PWORDLEN n w\" can be solved in the\ncontext-of-application.  Here \"n\" and \"w\" will be instantiated\nto the correct arguments.\n\n\\section{Adding Arbitrary Conversions}\n\nYou can add conversions to the simpset which might (potentially)\nget applied at every point in the term. \n\nSimpsets can contain arbitrary user conversions, as well as\nrewrites and contextual-rewrites.  Conversions are keyed by\nterm patterns (implemented using termnets).  Thus a conversion\nwon't even be called if the target term doesn't match \n(in the termnet sense of matching) it's key.  This just acts\nas a simple optimization/filter.\n\nFor example, BETA\\_CONV is keyed on the term \n\\begin{verbatim}\n(--`(\\x. t) y`--).  \n\\end{verbatim}\n\\footnote{I'm not sure if the HOL implementation of term nets handles keys\nwhich contain abstractions efficiently}\n\n\n\\section{AC Rewriting/Rewritng with Permutative Theorems}\n\nNormally, these rewrites such as:\n\\begin{verbatim}\nADD_SYM |- !x y. x + y = y + x\n\\end{verbatim}\ncause {\\tt REWRITE\\_TAC} to loop.  However, the simplifier only applies\nthem in certain situations, namely when the term they produce\nis strictly less than the original term according to a built in\nterm ordering.  \\footnote{Note that the term ordering in hol90\nis broken, so a much less efficient term ordering is defined in\nthe simplifier.  This should be fixed in the next release of hol90.}\n\nBy putting three theorems in your simpset: associativity, commutativity and\nleft-commutativity, you get AC-normalization for free.  You\nhave to be careful about this:\n\\begin{itemize}\n   \\item The associative laws must always be oriented from left\n   to right, as in {\\tt |- f(f(x,y),z)) = f(x,f(y,z))}.  Otherwise\n   HOL will loop.\n   \\item You need to add left-commutativity to get full normalization:\n   {\\tt |- f(x,f(y,z)) = f(y,f(x,z))}.  This follows easily\n   from associativity and commutativity.\n\\end{itemize}\n\nAC normalization with the simplifier is comparatively expensive.\nTerms of  20 or more operations can take a long time to\nnormalize.  Smaller terms are OK, but in general it may be a problem\nto include AC normalization in all your simpsets.  Experiment\nand see!\n\nSee the Isabelle reference manual chapter 10 for more details on\nAC normalization.\n\n\\subsection{Examples of AC Normalization}\n\n\\begin{verbatim}\n- SIMP_CONV ac_arithmetic_ss (--`(x + 3) + 4 + (y + 2)`--);\nval it = |- (x + 3) + 4 + y + 2 = 2 + 3 + 4 + x + y : thm\n\\end{verbatim}\n\n\n\\chapter{Efficiency and Memory Usage}\n\n\\section{Memory Usage}\n\nAfter loading hol\\_ss, arith\\_ss,reduce\\_ss, taut\\_ss,\nres\\_quan\\_ss, and pred\\_set\\_ss:\n\\begin{verbatim}\n[Major collection... 99% used (11674608/11678744), 2300 msec]\n\\end{verbatim}\nWithout these:\n\\begin{verbatim}\n[Major collection... 99% used (10103312/10108132), 1950 msec]\n\\end{verbatim}\n"}
{"text": "\ndata _\u00d7_ (A B : Set) : Set where\n  _,_ : A \u2192 B \u2192 A \u00d7 B\n\npostulate\n  M   : Set \u2192 Set\n  _>>=_ : \u2200{A B : Set} \u2192 M A \u2192 (A \u2192 M B) \u2192 M B\n\ninfixr 1 bind\nbind : _\nbind = _>>=_\n\ninfix 0 id\nid : \u2200{A : Set} \u2192 A \u2192 A\nid = \u03bb x \u2192 x\n\nsyntax id  x             = do x\nsyntax bind ma (\u03bb x \u2192 f) = x \u2190 ma , f\n\nswapM\u2032 : \u2200 {A B} \u2192 M (A \u00d7 B) \u2192 M (B \u00d7 A)\nswapM\u2032 mAB =\n  do\n     (a , b) \u2190 mAB\n   , return $ b , a\n\n-- Was:\n-- An internal error has occurred. Please report this as a bug.\n-- Location of the error:\n-- src/full/Agda/TypeChecking/Monad/Base.hs:1793\n"}
{"text": "import Smt\n\ntheorem falsum : \u00acFalse := by\n  smt\n"}
{"text": "lemma cCons_0_Nil_eq [simp]: \"0 ## [] = []\""}
{"text": "import tactic\nimport tactic.induction\n\nimport .base\n\nlemma A_pw_1_not_hws : \u00acA_hws 1 :=\nbegin\n  sorry\nend"}
{"text": "lemma contractible_empty [simp]: \"contractible {}\""}
{"text": "(*\n   Authors: Asta Halkj\u00e6r From, Agnes Moesg\u00e5rd Eschen & J\u00f8rgen Villadsen, DTU Compute\n*)\n\ntheory System_H1 imports System_L1 begin\n\ntext \\<open>System H from David Hilbert: Die logischen Grundlagen der Mathematik (1922)\\<close>\n\ntext \\<open>Derivations are taken from: On Axiom Systems of Propositional Calculi. I\n                                  by Yasuyuki Imai and Kiyoshi Iseki (1965)\\<close>\n\ninductive H (\\<open>\\<HH>\\<close>) where\n  H_MP: \\<open>\\<HH> q\\<close> if \\<open>\\<HH> p\\<close> and \\<open>\\<HH> (p \\<rightarrow> q)\\<close> |\n  H_1:  \\<open>\\<HH> (p \\<rightarrow> (q \\<rightarrow> p))\\<close> |\n  H_2:  \\<open>\\<HH> ((p \\<rightarrow> (q \\<rightarrow> r)) \\<rightarrow> (q \\<rightarrow> (p \\<rightarrow> r)))\\<close> |\n  H_3:  \\<open>\\<HH> ((q \\<rightarrow> r) \\<rightarrow> ((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)))\\<close> |\n  H_4:  \\<open>\\<HH> (p \\<rightarrow> ((\\<sim> p) \\<rightarrow> q))\\<close> |\n  H_5:  \\<open>\\<HH> ((p \\<rightarrow> q) \\<rightarrow> (((\\<sim> p) \\<rightarrow> q) \\<rightarrow> q))\\<close>\n\nlemma H_6: \\<open>\\<HH> ((p \\<rightarrow> q) \\<rightarrow> ((q \\<rightarrow> r) \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using H_2 H_3 H_MP by metis\n\nlemma H_7: \\<open>\\<HH> (q \\<rightarrow> (p \\<rightarrow> p))\\<close>\n  using H_2 H_1 H_MP by metis\n\nlemma H_8: \\<open>\\<HH> (p \\<rightarrow> p)\\<close>\n  using H_1 H_7 H_MP by metis\n\nlemma H_9: \\<open>\\<HH> (((\\<sim> p) \\<rightarrow> p) \\<rightarrow> p)\\<close>\n  using H_5 H_8 H_MP by metis\n\ntheorem H_iff_L1: \\<open>\\<HH> p \\<longleftrightarrow> \\<turnstile> p\\<close>\nproof\n  have L1_H_1: \\<open>\\<turnstile> (p \\<rightarrow> (q \\<rightarrow> p))\\<close> for p q\n    using L1_completeness by simp\n  have L1_H_2: \\<open>\\<turnstile> ((p \\<rightarrow> (q \\<rightarrow> r)) \\<rightarrow> (q \\<rightarrow> (p \\<rightarrow> r)))\\<close> for p q r\n    using L1_completeness by simp\n  have L1_H_3: \\<open>\\<turnstile> ((q \\<rightarrow> r) \\<rightarrow> ((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)))\\<close> for p q r\n    using L1_completeness by simp\n  have L1_H_4: \\<open>\\<turnstile> (p \\<rightarrow> ((\\<sim> p) \\<rightarrow> q))\\<close> for p q\n    using L1_completeness by simp\n  have L1_H_5: \\<open>\\<turnstile> ((p \\<rightarrow> q) \\<rightarrow> (((\\<sim> p) \\<rightarrow> q) \\<rightarrow> q))\\<close> for p q\n    using L1_completeness by simp\n  show \\<open>\\<turnstile> p\\<close> if \\<open>\\<HH> p\\<close>\n    using that by (induct) (metis MP, metis L1_H_1, metis L1_H_2,\n        metis L1_H_3, metis L1_H_4, metis L1_H_5)\n  show \\<open>\\<HH> p\\<close> if \\<open>\\<turnstile> p\\<close>\n    using that by (induct) (metis H_MP, metis H_6, metis H_9, metis H_4)\nqed\n\ntheorem H_soundness: \\<open>\\<HH> p \\<Longrightarrow> I \\<Turnstile> p\\<close>\n  by (induct rule: H.induct) auto\n\ntheorem H_completeness: \\<open>\\<forall>I. (I \\<Turnstile> p) \\<Longrightarrow> \\<HH> p\\<close>\n  using H_iff_L1 by (simp add: L1_completeness)\n\nsection \\<open>Soundness and Completeness\\<close>\n\ntheorem main: \\<open>valid p = \\<HH> p\\<close>\n  unfolding valid_def using H_soundness H_completeness by blast\n\nlemmas H1 = H.intros main\n\nend\n"}
{"text": "{-# LANGUAGE Haskell98 #-}\n{-# LINE 1 \"src/Data/Complex/Compat.hs\" #-}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n{-# LANGUAGE CPP, NoImplicitPrelude #-}\nmodule Data.Complex.Compat (\n  module Base\n) where\n\nimport Data.Complex as Base\n\n"}
{"text": "State Before: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\n\u22a2 IsElementary (\u2191(LHom.substructureReduct LHom.sumInl) S) State After: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\n\u22a2 \u2200 (n : \u2115) (\u03c6 : BoundedFormula L Empty (n + 1)) (x : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S })\n    (a : M),\n    BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a) \u2192\n      \u2203 b, BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) \u2191b) Tactic: apply (LHom.sumInl.substructureReduct S).isElementary_of_exists State Before: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\n\u22a2 \u2200 (n : \u2115) (\u03c6 : BoundedFormula L Empty (n + 1)) (x : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S })\n    (a : M),\n    BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a) \u2192\n      \u2203 b, BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) \u2191b) State After: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\nn : \u2115\n\u03c6 : BoundedFormula L Empty (n + 1)\nx : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S }\na : M\nh : BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a)\n\u22a2 \u2203 b, BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) \u2191b) Tactic: intro n \u03c6 x a h State Before: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\nn : \u2115\n\u03c6 : BoundedFormula L Empty (n + 1)\nx : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S }\na : M\nh : BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a)\n\u22a2 \u2203 b, BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) \u2191b) State After: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\nn : \u2115\n\u03c6 : BoundedFormula L Empty (n + 1)\nx : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S }\na : M\nh : BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a)\n\u03c6' : Functions (Language.sum L (skolem\u2081 L)) n := LHom.onFunction LHom.sumInr \u03c6\n\u22a2 \u2203 b, BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) \u2191b) Tactic: let \u03c6' : (L.sum L.skolem\u2081).Functions n := LHom.sumInr.onFunction \u03c6 State Before: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\nn : \u2115\n\u03c6 : BoundedFormula L Empty (n + 1)\nx : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S }\na : M\nh : BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a)\n\u03c6' : Functions (Language.sum L (skolem\u2081 L)) n := LHom.onFunction LHom.sumInr \u03c6\n\u22a2 \u2203 b, BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) \u2191b) State After: no goals Tactic: exact\n  \u27e8\u27e8funMap \u03c6' ((\u2191) \u2218 x), S.fun_mem (LHom.sumInr.onFunction \u03c6) ((\u2191) \u2218 x) (by\n    exact fun i => (x i).2)\u27e9,\n    by exact Classical.epsilon_spec (p := fun a => BoundedFormula.Realize \u03c6 default\n        (Fin.snoc (Subtype.val \u2218 x) a)) \u27e8a, h\u27e9\u27e9 State Before: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\nn : \u2115\n\u03c6 : BoundedFormula L Empty (n + 1)\nx : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S }\na : M\nh : BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a)\n\u03c6' : Functions (Language.sum L (skolem\u2081 L)) n := LHom.onFunction LHom.sumInr \u03c6\n\u22a2 \u2200 (i : Fin n), (Subtype.val \u2218 x) i \u2208 \u2191S State After: no goals Tactic: exact fun i => (x i).2 State Before: L : Language\nM : Type w\ninst\u271d\u00b9 : Nonempty M\ninst\u271d : Structure L M\nS : Substructure (Language.sum L (skolem\u2081 L)) M\nn : \u2115\n\u03c6 : BoundedFormula L Empty (n + 1)\nx : Fin n \u2192 { x // x \u2208 \u2191(LHom.substructureReduct LHom.sumInl) S }\na : M\nh : BoundedFormula.Realize \u03c6 default (Fin.snoc (Subtype.val \u2218 x) a)\n\u03c6' : Functions (Language.sum L (skolem\u2081 L)) n := LHom.onFunction LHom.sumInr \u03c6\n\u22a2 BoundedFormula.Realize \u03c6 default\n    (Fin.snoc (Subtype.val \u2218 x)\n      \u2191{ val := funMap \u03c6' (Subtype.val \u2218 x),\n          property := (_ : funMap (LHom.onFunction LHom.sumInr \u03c6) (Subtype.val \u2218 x) \u2208 \u2191S) }) State After: no goals Tactic: exact Classical.epsilon_spec (p := fun a => BoundedFormula.Realize \u03c6 default\n (Fin.snoc (Subtype.val \u2218 x) a)) \u27e8a, h\u27e9"}
{"text": "useful-lemma : \u2200 {a} {A : Set a} \u2192 A\nuseful-lemma = useful-lemma\n"}
{"text": "From LF Require Export Logic.\nFrom Coq Require Import Lia.\n\nModule IndProp.\nSet Warnings \"-notation-overridden,-parsing,-deprecated-hint-without-locality\".\n\n(*\n  Definition ev (n : nat) : Prop := even n = true.\n  Defivition Ev (n : nat) : Prop := exists (x : nat), n = double x.\n*)\n\nInductive ev : nat -> Prop :=\n  | ev_0 : ev 0\n  | ev_SS (n : nat) (H : ev n) : ev (S (S n)).\n\n\nTheorem ev_4 : ev 4.\nProof. apply ev_SS. apply ev_SS. apply ev_0. Qed.\n\nTheorem ev_4' : ev 4.\nProof. apply (ev_SS 2 (ev_SS 0 ev_0)). Qed.\n\nTheorem ev_plus4 : forall n, ev n -> ev (4 + n).\nProof.\n  intros n. simpl. intros Hn.\n  apply ev_SS. apply ev_SS. apply Hn.\nQed.\n\nSearch (nat -> nat).\n\nTheorem ev_double : forall n,\n  ev (Logic.double n).\nProof.\n  intros n.\n  induction n as [| n' H ].\n  - simpl.\n    apply ev_0.\n  - simpl.\n    apply ev_SS.\n    apply H.\nQed.\n\nTheorem ev_inversion : forall (n : nat), \n  ev n -> (n = 0) \\/ (exists n', n = S (S n') /\\ ev n').\nProof.\n  intros n [ | n' Hev ].\n  - left. reflexivity.\n  - right. exists n'. split.\n    + reflexivity.\n    + apply Hev.\nQed. \n\nTheorem ev_minus2 : forall n,\n  ev n -> ev (pred (pred n)).\nProof.\n  intros n E.\n  destruct E as [| n' E'] eqn:EE.\n  - (* E = ev_0 *) simpl. apply ev_0.\n  - (* E = ev_SS n' E' *) simpl. apply E'.\nQed.\n\n\n\nTheorem evSS_ev : forall n,\n  ev (S (S n)) -> ev n.\nProof.\n  intros n E.\n  destruct E as [| n' E'] eqn:EE.\n  - (* E = ev_0. *)\n    (* We must prove that n is even from no assumptions! *)\nAbort.\n\nTheorem evSS_ev_remember : forall n,\n  ev (S (S n)) -> ev n.\nProof.\n  intros n E. \n  remember (S (S n)) as k eqn:Hk.\n  destruct E as [|n' E'] eqn:EE.\n  - discriminate Hk.\n  - injection Hk as Hk'. rewrite <- Hk'. apply E'.\nQed.\n\nTheorem evSS_ev : forall n, ev (S (S n)) -> ev n.\nProof.\n  intros n H. \n  apply ev_inversion in H.\n  destruct H as [H0|H1].\n  - discriminate H0.\n  - destruct H1 as [n' [Hnm Hev]]. injection Hnm as Heq.\n    rewrite Heq. apply Hev.\nQed.\n\nTheorem evSS_ev' : forall n,\n  ev (S (S n)) -> ev n.\nProof.\n  intros n E.\n  inversion E as [| n' E' Heq].\n  (* We are in the E = ev_SS n' E' case now. *)\n  apply E'.\nQed.\n\n\nTheorem SSSSev__even : forall n,\n  ev (S (S (S (S n)))) -> ev n.\nProof.\n  intros n H.\n  inversion H as [| n' E' Heq ].\n  inversion E' as [| n'' E'' Heq' ].\n  apply E''.\nQed.\n\nTheorem ev5_nonsense :\n  ev 5 -> 2 + 2 = 9.\nProof.\n  intros H.\n  inversion H as [| n E Heq].\n  inversion E as [| n' E' Heq'].\n  inversion E'.\nQed.\n\n\nNotation \"x :: y\" := (cons x y)\n                     (at level 60, right associativity).\nNotation \"[ ]\" := nil.\nNotation \"[ x ; .. ; y ]\" := (cons x .. (cons y []) ..).\nNotation \"x ++ y\" := (app x y)\n                     (at level 60, right associativity).\nSearch cons.\n\nTheorem inversion_ex1 : forall (n m o : nat),\n  [n; m] = [o; o] ->\n  [n] = [m].\nProof.\n  intros n m o H. inversion H. reflexivity. Qed.\n\nTheorem inversion_ex2 : forall (n : nat),\n  S n = O -> 2 + 2 = 5.\nProof.\n  intros n contra. inversion contra. Qed.\n\n\nLemma tst : forall n, \n  (exists k, n = Logic.double k) -> (exists k', S (S n) = Logic.double k').\nProof.\n  intros n [k H].\n  exists (S k).\n  simpl.\n  rewrite <- H.\n  reflexivity.\nQed.\n\n\nLemma ev_Even_firsttry : forall n,\n  ev n -> Logic.Even n.\nProof.\n  unfold Logic.Even.\n  intros n H.\n  inversion H as [HEq | n' E HEq].\n  - exists O. reflexivity.\n  - apply tst.\n    generalize dependent E. (* Prooving the same theorem *)\nAbort.\n\nInclude Logic.\n\nLemma ev_Even : forall n, ev n -> Even n.\nProof.\n  intros n E.\n  induction E as [| n' E' IH ].\n  - (* E = ev_0 *)\n    unfold Even. exists 0. reflexivity.\n  - (* E = ev_SS n' E'\n       with IH : Even E' *)\n    unfold Even in IH.\n    destruct IH as [k Hk].\n    rewrite Hk.\n    unfold Even. exists (S k). simpl. reflexivity.\nQed.\n\nTheorem ev_Even_iff : forall n,\n  ev n <-> Even n.\nProof.\n  intros n. split.\n  - (* -> *) apply ev_Even.\n  - (* <- *) unfold Even. intros [k Hk]. rewrite Hk. apply ev_double.\nQed.\n\nTheorem ev_sum : forall n m, ev n -> ev m -> ev (n + m).\nProof.\n  intros n m Hn Hm.\n  induction Hn as [| n' Hn' H ].\n  - simpl. apply Hm.\n  - simpl. apply ev_SS. apply H.\nQed.\n\n\n\n\n\n\n\n\nInductive ev' : nat -> Prop :=\n  | ev'_0 : ev' 0\n  | ev'_2 : ev' 2\n  | ev'_sum n m (Hn : ev' n) (Hm : ev' m) : ev' (n + m).\n\nTheorem ev'_ev : forall n, ev' n <-> ev n.\nProof.\n  intros n.\n  split.\n  - intros H'.\n    induction H' as [ | | n m Hn Hn' Hm Hm'].\n    + apply ev_0.\n    + apply ev_SS. apply ev_0.\n    + apply ev_sum.\n      * apply Hn'.\n      * apply Hm'.\n  - intros H'.\n    induction H' as [ | n Hn H ].\n    + apply ev'_0.\n    + apply (ev'_sum 2 n ev'_2 H).\nQed.\n\nTheorem ev_ev__ev : forall n m,\n  ev (n + m) -> ev n -> ev m.\nProof.\n  intros n m Hnm Hn.\n  induction Hn as [| n' Hn' H].\n  - simpl in Hnm. apply Hnm.\n  - apply H. simpl in Hnm.\n    remember (S (S (n' + m))) as k eqn:Hk.\n    destruct Hnm as [| nm' Hnm'] eqn:E.\n    + discriminate Hk.\n    + injection Hk as Hk'.\n      rewrite <- Hk'.\n      apply Hnm'.\nQed.\n\n\nLemma es_sum : forall n m, \n  ev (n + m) -> (ev n /\\ ev m) \\/ (~(ev n) /\\ ~(ev m)).\nProof.\n  intros n m H.\n  induction n as [| n' Hn ].\n  - simpl in H.\n    left. split.\n    + apply ev_0.\n    + apply H.\nAbort.\n\nTheorem ev_ev__ev1 : forall n m,\n  ev n -> ev m -> ev (n + m).\nProof.\n  intros n m Hn Hm.\n  induction Hn as [| n' Hn' H].\n  - simpl. apply Hm.\n  - simpl. apply ev_SS. apply H.\nQed.\n\nLemma tst1 : forall n, ev (n + n).\nProof.\n  intros n.\n  induction n as [| n' H'].\n  - simpl. apply ev_0.\n  - simpl. rewrite -> PeanoNat.Nat.add_comm. simpl. apply ev_SS. apply H'.\nQed.\n\nSearch (?a + (?b + ?c) = ?a + ?b + ?c).\nTheorem ev_plus_plus : forall n m p,\n  ev (n + m) -> ev (n + p) -> ev (m + p).\nProof.\n  intros n m p Hnm Hnp.\n  assert(H: ev (n + m + (n + p))). {\n    apply (ev_ev__ev1 (n + m) (n + p) Hnm Hnp).\n  }\n  rewrite -> PeanoNat.Nat.add_assoc in H.\n  rewrite -> PeanoNat.Nat.add_comm in H.\n  rewrite -> (PeanoNat.Nat.add_comm (n + m) n) in H.\n  rewrite -> PeanoNat.Nat.add_comm in H.\n  rewrite -> (PeanoNat.Nat.add_assoc) in H.\n  rewrite <- (PeanoNat.Nat.add_assoc) in H.\n  apply (ev_ev__ev _ _ H (tst1 n)).\nQed.\n\n\nModule Playground.\n\nInductive le : nat -> nat -> Prop :=\n  | le_n (n : nat) : le n n\n  | le_S (n m : nat) (H : le n m) : le n (S m).\nNotation \"n <= m\" := (le n m).\n\nTheorem test_le1 : 3 <= 3.\nProof. apply le_n. Qed.\n\nTheorem test_le2 : 3 <= 6.\nProof. apply le_S. apply le_S. apply le_S. apply le_n. Qed.\n\nTheorem test_le3 : (2 <= 1) -> 2 + 2 = 5.\nProof. intros H. inversion H. inversion H2. Qed.\n\nDefinition lt (n m : nat) := le (S n) m.\nNotation \"m < n\" := (lt m n).\n\nTheorem test_lt1 : 2 < 3.\nProof. unfold lt. apply le_n. Qed.\n\n\nLemma O_lowest : forall n, 0 <= n.\nProof.\n  intros n.\n  induction n as [| n' IH ].\n  - apply le_n.\n  - apply le_S. apply IH.\nQed.\n\nLemma O_split : forall a b, \n  0 = a + b -> a = 0 /\\ b = 0.\nProof.\n  intros a b H.\n  destruct a as [| a'].\n  - destruct b as [| b'].\n    + split. reflexivity. reflexivity.\n    + simpl in H. discriminate H.\n  - simpl in H. discriminate H.\nQed.\n\nLemma m_le_mplus : forall m k, \n  m <= m + k.\nProof.\n  intros m k.\n  induction k as [| k' IH].\n  - rewrite -> PeanoNat.Nat.add_comm. simpl. apply le_n.\n  - rewrite -> PeanoNat.Nat.add_comm.\n    simpl.\n    apply le_S.\n    rewrite -> PeanoNat.Nat.add_comm.\n    apply IH.\nQed.\n\nLemma tst : forall m n, \n  m <= n <-> exists k, n = m + k.\nProof.\n  intros m n.\n  split.\n  {\n    intros Hmn.\n    induction Hmn as [mn | m n Hmn' IH ].\n    - exists O.\n      rewrite -> PeanoNat.Nat.add_comm.\n      reflexivity.\n    - destruct IH as [k IH'].\n      exists (S k).\n      rewrite -> IH'.\n      rewrite -> (PeanoNat.Nat.add_comm m (S k)).\n      simpl.\n      rewrite -> (PeanoNat.Nat.add_comm m k).\n      reflexivity.\n    }\n    {\n      intros [k He].\n      rewrite -> He.\n      apply m_le_mplus.\n    }\nQed.\n\nLemma le_trans : forall m n o, \n  m <= n -> n <= o -> m <= o.\nProof.\n  intros m n o Hmn Hno.\n  destruct (tst m n) as [H1mn H2mn].\n  destruct (tst n o) as [H1no H2no].\n  destruct (H1mn Hmn) as [k1 E1].\n  destruct (H1no Hno) as [k2 E2].\n  rewrite -> E1 in E2.\n  rewrite <- PeanoNat.Nat.add_assoc in E2.\n  rewrite -> tst.\n  exists (k1 + k2).\n  apply E2.\nQed. \n\nTheorem O_le_n : forall n, 0 <= n.\nProof. apply O_lowest. Qed.\n\nTheorem n_le_m__Sn_le_Sm : forall n m,\n  n <= m -> S n <= S m.\nProof.\n  intros n m Hnm.\n  induction Hnm as [n | n m Hnm' IH].\n  - apply le_n.\n  - apply le_S.\n    apply IH.\nQed.\n\nTheorem n_lower_O_is_O: forall n, n <= 0 -> n = 0.\nProof.\n  intros n H.\n  remember 0 as o.\n  destruct H as [k | x y Hxy].\n  - rewrite -> Heqo.\n    reflexivity.\n  - discriminate Heqo.\nQed.\n\nTheorem Sn_le_m__n_le_m : forall n m,\n  S n <= m -> n <= m.\nProof.\n  intros n m Hsnm.\n  remember (S n) as sn.\n  destruct Hsnm as [nm | n' m' Hnm ].\n  - rewrite -> Heqsn.\n    apply le_S.\n    apply le_n.\n  - apply le_S.\n    destruct (tst n n') as [Htstl Htstr].\n    assert (G: n <= n'). {\n      apply Htstr.\n      exists 1.\n      rewrite -> PeanoNat.Nat.add_comm.\n      simpl.\n      apply Heqsn.\n    }\n    apply (le_trans n n' m').\n    apply G.\n    apply Hnm.\nQed.\n\nTheorem Sn_le_Sm__n_le_m : forall n m,\n  S n <= S m -> n <= m.\nProof.\n  intros n m Hsnsm.\n  rewrite -> tst.\n  assert (H: exists k : nat, m = n + k). {\n    destruct (tst (S n) (S m)) as [Htstl Htstr].\n    simpl in Htstl.\n    destruct (Htstl Hsnsm) as [k G].\n    injection G as G'.\n    exists k.\n    apply G'.\n  }\n  apply H.\nQed.\n\nTheorem Sn_le_Sm__n_le_m' : forall n m,\n  S n <= S m -> n <= m.\nProof.\n  intros n m H.\n  remember (S n) as sn eqn:Esn.\n  remember (S m) as sm eqn:Esm.\n  induction H as [n' | n' m' H' IH].\n  - rewrite -> Esn in Esm.\n    injection Esm as G.\n    rewrite -> G.\n    apply (le_n m).\n  - injection Esm as G.\n    rewrite -> G in H'.\n    rewrite -> Esn in H'.\n    apply Sn_le_m__n_le_m.\n    apply H'.\nQed.\n\nTheorem lt_ge_cases : forall n m,\n  n < m \\/ m <= n.\nProof.\n  intros n.\n  induction n as [| n' IHn ].\n  - unfold lt.\n    intros m.\n    induction m as [| m' IHm].\n    + right. apply le_n.\n    + destruct IHm as [IHml | IHmr].\n      * left. apply le_S. apply IHml.\n      * assert (G: m' = 0). {apply n_lower_O_is_O. apply IHmr. }\n        left.\n        rewrite -> G.\n        apply le_n.\n  - unfold lt.\n    intros m.\n    induction m as [| m' IHm].\n    + right. apply O_lowest.\n    + destruct IHm as [IHml | IHmr].\n      * left. \n        apply le_S in IHml.\n        apply IHml.\n      * unfold lt in IHn.\n        destruct (IHn m') as [IHnl | IHnr].\n        -- left. apply n_le_m__Sn_le_Sm. apply IHnl.\n        -- right. apply n_le_m__Sn_le_Sm. apply IHnr.\nQed.\n\nTheorem le_plus_l : forall a b,\n  a <= a + b.\nProof. apply m_le_mplus. Qed. \n\nTheorem plus_le : forall a b m,\n  a + b <= m -> a <= m /\\ b <= m.\nProof.\n  intros a b m H.\n  assert (G: exists k, m = a + b + k). {\n    destruct (tst (a + b) m) as [Tl Tr].\n    apply (Tl H).\n  }\n  split.\n  - destruct (tst a m) as [Tl Tr].\n    apply Tr.\n    destruct G as [k Hd].\n    exists (b + k).\n    rewrite -> PeanoNat.Nat.add_assoc.\n    apply Hd.\n  - destruct (tst b m) as [Tl Tr].\n    apply Tr.\n    destruct G as [k Hd].\n    exists (a + k).\n    rewrite -> PeanoNat.Nat.add_assoc.\n    rewrite -> (PeanoNat.Nat.add_comm b a).\n    apply Hd.\nQed.\n\nTheorem t: forall n m, n < S m -> S n <= m. \nProof.\n  unfold lt.\n  Admitted.\n\nTheorem le_symm_fw : forall n m p, n + m <= n + p -> m <= p.\nProof.\n  intros n.\n  induction n as [| n' IH ].\n  - simpl. intros m p H. apply H.\n  - intros m p. simpl. intros H. \n    apply (Sn_le_Sm__n_le_m (n' + m) (n' + p)) in H.\n    apply IH.\n    apply H.\nQed.\n\nTheorem add_le_cases : forall n m p q,\n  n + m <= p + q -> n <= p \\/ m <= q.\nProof.\n  intros n.\n  induction n as [| n' IH ].\n  - simpl. intros m p q H.\n    left. apply O_lowest.\n  - simpl. intros m p q H.\n    assert (G' : n' <= p \\/ S m <= q). {\n      apply IH.\n      rewrite -> (PeanoNat.Nat.add_comm n' (S m)).\n      simpl.\n      rewrite -> (PeanoNat.Nat.add_comm m n').\n      apply H.\n    }\n    destruct G' as [G'l | G'r].\n    + destruct G'l as [n' | n' p HH].\n      * assert (H0: S m <= q). {\n          apply (le_symm_fw n').\n          rewrite -> (PeanoNat.Nat.add_comm n' (S m)).\n          simpl.\n          rewrite -> (PeanoNat.Nat.add_comm m n').\n          apply H.\n        }\n        right.\n        apply Sn_le_m__n_le_m.\n        apply H0.\n      * left.\n        apply n_le_m__Sn_le_Sm.\n        apply HH.\n    + right. apply Sn_le_m__n_le_m. apply G'r.\nQed.\n\nTheorem plus_le_compat_l : forall n m p,\n  n <= m -> p + n <= p + m.\nProof.\n  intros n m p.\n  induction p as [| p' IH ].\n  - simpl. intros H. apply H.\n  - intros H. simpl. \n    apply n_le_m__Sn_le_Sm.\n    apply IH.\n    apply H.\nQed.\n\nTheorem plus_le_compat_r : forall n m p,\n  n <= m -> n + p <= m + p.\nProof.\n  intros n m p.\n  rewrite -> (PeanoNat.Nat.add_comm n p).\n  rewrite -> (PeanoNat.Nat.add_comm m p).\n  apply plus_le_compat_l.\nQed.\n\nTheorem le_plus_trans : forall n m p,\n  n <= m ->\n  n <= m + p.\nProof.\n  intros n m p.\n  induction p as [| p' IH].\n  - intros H. rewrite -> (PeanoNat.Nat.add_comm m 0). simpl. apply H.\n  - intros H.\n    rewrite -> (PeanoNat.Nat.add_comm m (S p')).\n    simpl.\n    apply le_S.\n    rewrite -> (PeanoNat.Nat.add_comm p' m).\n    apply IH.\n    apply H.\nQed.\n\nTheorem n_lt_m__n_le_m : forall n m,\n  n < m ->\n  n <= m.\nProof.\n  intros n m.\n  unfold lt.\n  apply Sn_le_m__n_le_m.\nQed.\n\n\nLemma less_one: forall a b,  S a <= b -> 1 <= b.\nProof.\n  intros a b.\n  induction a as [| a' IH ].\n  - intros H. apply H.\n  - intros H. \n    apply Sn_le_m__n_le_m in H.\n    apply IH.\n    apply H.\nQed.\n\nLemma nothing_less_O : forall n, \n  S n <= 0 -> False.\nProof.\n  intros n H.\n  remember (S n) as k.\n  remember 0 as o.\n  destruct H as [n' | n' o'].\n  - rewrite -> Heqo in Heqk.\n    discriminate Heqk.\n  - discriminate Heqo.\nQed.\n\nTheorem plus_lt : forall a b m,\n  a + b < m -> a < m /\\ b < m.\nProof.\n  intros a.\n  unfold lt.\n  induction a as [| a' IH ].\n  - intros b m H.\n    simpl in H.\n    split.\n    + apply (less_one b). apply H.\n    + apply H.\n  - intros b m H.\n    destruct m as [| m'].\n    + exfalso.\n      apply (nothing_less_O (S a' + b) H).\n    + destruct m' as [| m''].\n      * apply Sn_le_Sm__n_le_m' in H.\n        simpl in H.\n        exfalso.\n        apply (nothing_less_O (a' + b) H).\n      * apply Sn_le_Sm__n_le_m' in H.\n        simpl in H.\n        destruct (IH b (S m'') H) as [IHl IHr].\n        split.\n        -- apply n_le_m__Sn_le_Sm.\n           apply IHl.\n        -- apply le_S.\n           apply IHr.\nQed.\n\nTheorem leb_complete : forall n m,\n  n <=? m = true -> n <= m.\nProof.\n  intros n.\n  induction n as [| n' IHn ].\n  - intros m H. apply O_lowest.\n  - destruct m as [| m'].\n    + intros H.\n      simpl in H. discriminate H.\n    + intros H. simpl in H.\n      apply n_le_m__Sn_le_Sm.\n      apply IHn.\n      apply H.\nQed.\n\nLemma leb_refl : forall n,\n  n <=? n = true.\nProof.\n  intros n.\n  induction n as [| n' IH ].\n  - reflexivity.\n  - simpl. apply IH.\nQed.\n\nLemma leb_s_rev : forall n m,\n  S n <=? m = true -> n <=? m = true.\nProof.\n  intros n m H.\n  generalize dependent n.\n  induction m as [| m' IHm ].\n  - intros n H. simpl in H. discriminate H.\n  - intros n H. simpl in H.\n    destruct n as [| n'] eqn: En.\n    + reflexivity.\n    + simpl.\n      apply (IHm n').\n      apply H.\nQed.\n\nLemma leb_s : forall n m,\n  n <=? m = true -> n <=? S m = true.\nProof.\n  intros n m H.\n  generalize dependent m.\n  induction n as [| n' IHn ].\n  - reflexivity.\n  - destruct m as [| m'] eqn: Em.\n    + intros H. simpl in H. discriminate H.\n    + simpl. intros H.\n      apply (IHn m').\n      apply H.\nQed.\n\nTheorem leb_correct : forall n m,\n  n <= m -> n <=? m = true.\nProof.\n  intros n m H.\n  induction m as [| m' IHm ].\n  - apply n_lower_O_is_O in H.\n    rewrite -> H.\n    reflexivity.\n  - remember (S m') as sm' eqn:Hsm.\n    destruct H as [n | n m H'].\n    + apply leb_refl.\n    + injection Hsm as Hsm'.\n      rewrite <- Hsm' in IHm.\n      apply IHm in H'.\n      apply leb_s.\n      apply H'.\nQed.\n\nTheorem leb_iff : forall n m,\n  n <=? m = true <-> n <= m.\nProof.\n  intros n m. split.\n  - apply leb_complete.\n  - apply leb_correct.\nQed.\n\nTheorem leb_true_trans : forall n m o,\n  n <=? m = true -> m <=? o = true -> n <=? o = true.\nProof.\n  intros n m o Hnm Hmo.\n  rewrite -> leb_iff in Hnm.\n  rewrite -> leb_iff in Hmo.\n  rewrite -> leb_iff.\n  apply (le_trans n m o Hnm Hmo).\nQed.\n\nEnd Playground.\n\n\nInductive total_relation : nat -> nat -> Prop :=\n  | total n m : total_relation n m.\n\nExample total_ex: total_relation 9 666.\nProof. apply total. Qed.\n\n\nInductive empty_relation : nat -> nat -> Prop :=.\nExample empty_ex: empty_relation 1 1.\nProof. Abort.\n\n\nModule R.\n\nInductive R : nat -> nat -> nat -> Prop :=\n  | c1 : R 0 0 0\n  | c2 m n o (H : R m n o )                : R (S m) n (S o)\n  | c3 m n o (H : R m n o )                : R m (S n) (S o)\n(*  | c4 m n o (H : R (S m) (S n) (S (S o))) : R m n o\n    | c5 m n o (H : R m n o )                : R n m o\n*)\n.\n\nLemma exr1: R 1 1 2.\nProof. apply c3. apply c2. apply c1. Qed. \n\nLemma exr2: R 2 2 6.\nProof. apply c3. apply c2. Abort.\n\nSearch (nat -> nat -> nat).\nDefinition fR : nat -> nat -> nat := PeanoNat.Nat.add.\n\n\nTheorem R_equiv_fR : forall m n o, \n  R m n o <-> fR m n = o.\nProof.\n  intros m n o.\n  split.\n  - intros H.\n    induction H as [| m n o H2 IH2 | m n o H3 IH3 ].\n    + reflexivity.\n    + simpl. rewrite -> IH2. reflexivity.\n    + unfold fR. \n      unfold fR in IH3. \n      rewrite -> PeanoNat.Nat.add_comm. \n      simpl. \n      rewrite -> PeanoNat.Nat.add_comm. \n      rewrite -> IH3. \n      reflexivity.\n  - intros H.\n    generalize dependent n.\n    generalize dependent o.\n    induction m as [| m' IHm ].\n    + intros o n H.\n      simpl in H.\n      rewrite -> H.\n      assert (R_0_n_n : forall n, R 0 n n). {\n        intros k.\n        induction k as [| k' IHk ].\n        - apply c1.\n        - apply c3. apply IHk.\n      }\n      apply R_0_n_n.\n    + intros o n H.\n      simpl in H.\n      unfold fR in IHm.\n      unfold fR in H.\n      destruct o as [| o'].\n      * discriminate H.\n      * apply c2.\n        apply IHm.\n        injection H as H'.\n        apply H'.\nQed.\n\nEnd R.\n\n\n\nModule Sublist.\n\nInductive subseq : list nat -> list nat -> Prop :=\n  | empty l                     : subseq nil        l\n  | add   a s l (H: subseq s l) : subseq (cons a s) (cons a l)\n  | add_l a s l (H: subseq s l) : subseq s          (cons a l)\n.\n\nNotation \"a $ b\" := (subseq a b)\n                    (at level 60).\n\nTheorem subseq_refl : forall (l : list nat), subseq l l.\nProof.\n  intros l.\n  induction l as [| hl tl IHl].\n  - apply empty.\n  - apply (add hl). apply IHl.\nQed.\n\nTheorem subseq_app : forall (s l l' : list nat),\n  subseq s l ->\n  subseq s (l ++ l').\nProof.\n  intros s l l' H.\n  generalize dependent s.\n  generalize dependent l'.\n  induction l as [| hl tl IHl ].\n  - intros l' s H. simpl.\n    remember [] as k eqn:Ek. \n    destruct H as [l | a s l | a s l].\n    + apply empty.\n    + discriminate Ek.\n    + discriminate Ek.\n  - remember (hl :: tl) as k eqn:Ek.\n    intros l' s H.\n    rewrite -> Ek.\n    simpl.\n    destruct H as [lh | ah sh lh H' | ah sh lh H'].\n    + apply empty.\n    + \n      injection Ek as Ea Es.\n      rewrite -> Ea.\n      apply add.\n      apply IHl.\n      rewrite <- Es.\n      apply H'.\n    + injection Ek as Ea Es.\n      apply add_l.\n      apply IHl.\n      rewrite <- Es.\n      apply H'.\nQed.\n\nLemma ht_subset_then_t_subset : forall a s l, \n  subseq (a :: s) l -> subseq s l.\nProof.\n  intros a s l H.\n  remember (a :: s) as k eqn:Ek.\n  induction H as [l | a' s' l' H' IH | a' s' l' H' IH].\n  - discriminate Ek.\n  - injection Ek as Eka Eks.\n    apply add_l.\n    rewrite -> Eks in H'.\n    apply H'.\n  - apply add_l.\n    apply IH.\n    apply Ek.\nQed.\n\nLemma false_sublist: forall s, subseq s [ ] -> s = [ ].\nProof.\n  intros s H.\n  remember [ ] as k eqn:Ek.\n  destruct H as [ l | a s' l | a s' l].\n  - rewrite -> Ek. reflexivity.\n  - discriminate Ek.\n  - discriminate Ek.\nQed.\n\nLemma destruct_second_cons : forall a h t, \n  subseq a (h :: t) -> \n  (exists at', a = h :: at' /\\ subseq at' t)\n  \\/\n  subseq a t.\nProof.\n  intros a h t H.\n  remember (h :: t) as k eqn:Ek.\n  destruct a as [| ah at' ] eqn:Ea.\n  - right. apply empty.\n  - destruct H as [l | hH sH lH H' | hH sH lH H' ].\n    + right. apply empty.\n    + left.\n      exists sH.\n      injection Ek as Ek1 Ek2.\n      split.\n      * rewrite -> Ek1. reflexivity.\n      * rewrite <- Ek2. apply H'.\n    + right.\n      injection Ek as Ek1 Ek2.\n      rewrite <- Ek2.\n      apply H'.\nQed.\n\n\nLemma elim_same_head : forall h a b, (h :: a) $ (h :: b) -> a $ b.\nProof.\n  intros h a b H.\n  remember (h :: a) as ra eqn:Era.\n  remember (h :: b) as rb eqn:Erb.\n  induction H as [l | h' s l H' IH | h' s l H' IH].\n  - discriminate Era.\n  - injection Era as Era1 Era2.\n    injection Erb as Erb1 Erb2.\n    rewrite <- Erb2.\n    rewrite <- Era2.\n    apply H'.\n  - rewrite -> Era in H'.\n    injection Erb as Erb1 Erb2.\n    rewrite -> Erb2 in H'.\n    apply ht_subset_then_t_subset in H'.\n    apply H'.\nQed.\n\n\nTheorem subseq_trans_h2: forall a b c,\n  a $ b -> b $ c -> a $ c.\nProof.\n  intros a b c H1 H2.\n  generalize dependent a.\n  induction H2 as [l | h s l H2' IH | h s l H2' IH ].\n  - intros a H1.\n    apply false_sublist in H1.\n    rewrite -> H1.\n    apply empty.\n  - intros a H1.\n    assert (G: (exists at', a = h :: at' /\\ subseq at' s) \\/ subseq a s). {\n      apply destruct_second_cons.\n      apply H1.\n    }\n    destruct G as [[atail [HAeq Hatail]] | Has ].\n    + rewrite -> HAeq.\n      apply add.\n      rewrite -> HAeq in H1.\n      apply elim_same_head in H1.\n      apply IH.\n      apply H1.\n    + apply add_l.\n      apply IH.\n      apply Has.\n  - intros a H1.\n    apply add_l.\n    apply IH.\n    apply H1.\nQed.\n\nTheorem subseq_trans : forall (l1 l2 l3 : list nat),\n  subseq l1 l2 ->\n  subseq l2 l3 ->\n  subseq l1 l3.\nProof.\n  apply subseq_trans_h2.\nQed.\n\nEnd Sublist.\n\nInductive R : nat -> list nat -> Prop :=\n  | c1                    : R 0     []\n  | c2 n l (H: R n     l) : R (S n) (n :: l)\n  | c3 n l (H: R (S n) l) : R n     l.\n\n(* Which of the following propositions are provable? *)\nTheorem tr1: R 2 [1;0].\nProof. apply c2. apply c2. apply c1. Qed.\n\nTheorem tr2: R 1 [1;2;1;0].\nProof. apply c3. apply c2. apply c3. apply c3. apply c2. apply c2. apply c2. apply c1. Qed.\n\nTheorem tr3: R 6 [3;2;1;0].\nProof. Abort.\n\n\nModule RegExp.\n\nInductive reg_exp (T : Type) : Type :=\n  | EmptySet\n  | EmptyStr\n  | Char (t : T)\n  | App (r1 r2 : reg_exp T)\n  | Union (r1 r2 : reg_exp T)\n  | Star (r : reg_exp T).\nArguments EmptySet {T}.\nArguments EmptyStr {T}.\nArguments Char {T} _.\nArguments App {T} _ _.\nArguments Union {T} _ _.\nArguments Star {T} _.\n\nReserved Notation \"s =~ re\" (at level 80).\n\n\n(*\n    The expression EmptySet does not match any string.\n    The expression EmptyStr matches the empty string [].\n    The expression Char x matches the one-character string [x].\n    If re1 matches s1, and re2 matches s2, then App re1 re2 matches s1 ++ s2.\n    If at least one of re1 and re2 matches s, then Union re1 re2 matches s.\n    Finally, if we can write some string s as the concatenation of a sequence of \n      strings s = s_1 ++ ... ++ s_k, and the expression re matches each one of the \n      strings s_i, then Star re matches s.\n    In particular, the sequence of strings may be empty, so Star re always matches \n      the empty string [] no matter what re is.\n*)\nInductive exp_match {T} : list T -> reg_exp T -> Prop :=\n  | MEmpty : [] =~ EmptyStr\n  | MChar x : [x] =~ (Char x)\n  | MApp s1 re1 s2 re2\n             (H1 : s1 =~ re1)\n             (H2 : s2 =~ re2)\n           : (s1 ++ s2) =~ (App re1 re2)\n  | MUnionL s1 re1 re2\n                (H1 : s1 =~ re1)\n              : s1 =~ (Union re1 re2)\n  | MUnionR re1 s2 re2\n                (H2 : s2 =~ re2)\n              : s2 =~ (Union re1 re2)\n  | MStar0 re : [] =~ (Star re)\n  | MStarApp s1 s2 re\n                 (H1 : s1 =~ re)\n                 (H2 : s2 =~ (Star re))\n               : (s1 ++ s2) =~ (Star re)\n  where \"s =~ re\" := (exp_match s re).\n\nExample reg_exp_ex1 : [1] =~ Char 1.\nProof. apply MChar. Qed.\n\nExample reg_exp_ex2 : [1; 2] =~ App (Char 1) (Char 2).\nProof.\n  apply (MApp [1] _ [2] _).\n  - apply MChar.\n  - apply MChar.\nQed.\n\nExample reg_exp_ex3 : ~ ([1; 2] =~ Char 1).\nProof.\n  intros H. \n(*  remember ([1; 2]) as k eqn:Ek.\n\n  destruct H as [| c | s1 re1 s2 re2 h1 h2 | s1 re1 re2 h1 | re1 s2 re2 h2 | re | s1s2 h1 h2] eqn:E.\n  - \n*)\n  inversion H.\nQed.\n\nFixpoint reg_exp_of_list {T} (l : list T) : reg_exp T:=\n  match l with\n  | [ ]     => EmptyStr\n  | x :: l' => App (Char x) (reg_exp_of_list l')\n  end.\n\n\nExample reg_exp_ex4 : [1; 2; 3] =~ reg_exp_of_list [1; 2; 3].\nProof.\n  simpl. apply (MApp [1]).\n  { apply MChar. }\n  apply (MApp [2]).\n  { apply MChar. }\n  apply (MApp [3]).\n  { apply MChar. }\n  apply MEmpty.\nQed.\n\nSearch (?s ++ [] = ?s).\nLemma MStar1 : forall T s (re : reg_exp T) ,\n    s =~ re -> s =~ Star re.\nProof.\n  intros T s re H.\n  assert (G: s ++ [] =~ Star re). {\n   apply (MStarApp s [] re).\n   - apply H.\n   - apply MStar0.\n  }\n  rewrite -> List.app_nil_r in G.\n  apply G.\nQed.\n\n\nLemma empty_is_empty : forall T (s : list T),\n  ~ (s =~ EmptySet).\nProof.\n  intros T s.\n  unfold not.\n  intros H.\n  inversion H.\nQed.\n\nLemma MUnion' : forall T (s : list T) (re1 re2 : reg_exp T),\n  s =~ re1 \\/ s =~ re2 ->\n  s =~ Union re1 re2.\nProof.\n  intros T s re1 re2 H.\n  destruct H as [Hl | Hr].\n  - apply (MUnionL).\n    apply Hl.\n  - apply (MUnionR).\n    apply Hr.\nQed.\n\n(* \n  The next lemma is stated in terms of the fold function from the Poly chapter: \n  If ss : list (list T) represents a sequence of strings s1, ..., sn, then fold \n  app ss [] is the result of concatenating them all together.\n*)\n\nFixpoint fold {X Y: Type} (f : X -> Y -> Y) (l : list X) (b : Y): Y :=\n  match l with\n  | nil    => b\n  | h :: t => f h (fold f t b)\n  end.\n\nLemma MStar' : forall T (ss : list (list T)) (re : reg_exp T),\n  (forall s, In s ss -> s =~ re) ->\n  fold (@app T) ss [] =~ Star re.\nProof.\n  intros T ss.\n  induction ss as [| h t IH].\n  - simpl. intros re H. apply MStar0.\n  - simpl. intros re H.\n    apply (MStarApp h (fold (@app T) t [ ])).\n    + apply H. left. reflexivity.\n    + apply IH.\n      intros l H'.\n      apply H.\n      right.\n      apply H'.\nQed.\n\nTheorem reg_exp_of_list_refl: forall T (s: list T),\n  s =~ reg_exp_of_list s.\nProof.\n  intros T s.\n  induction s as [| h t IH ].\n  - simpl. apply MEmpty.\n  - simpl.\n    assert (G: h :: t = [h] ++ t). {\n      reflexivity.\n    }\n    rewrite -> G.\n    apply MApp.\n    + apply MChar.\n    + apply IH.\nQed.\n\nLemma reg_exp_of_list_spec : forall T (s1 s2 : list T),\n  s1 =~ reg_exp_of_list s2 <-> s1 = s2.\nProof.\n  intros T s1 s2.\n  split.\n  - generalize dependent s1.\n    induction s2 as [| h t IH ].\n    + intros s1 H.\n      simpl in H. \n      inversion H.\n      reflexivity.\n    + intros s1 H.\n      simpl in H.\n      inversion H. (* Only one branch with App *)\n      inversion H3.\n      simpl.\n      rewrite -> (IH s2 H4).\n      reflexivity.\n  - intros H.\n    rewrite <- H.\n    apply reg_exp_of_list_refl.\nQed.\n\n\nFixpoint re_chars {T} (re : reg_exp T) : list T :=\n  match re with\n  | EmptySet      => []\n  | EmptyStr      => []\n  | Char x        => [x]\n  | App re1 re2   => re_chars re1 ++ re_chars re2\n  | Union re1 re2 => re_chars re1 ++ re_chars re2\n  | Star re       => re_chars re\n  end.\n\nTheorem in_re_match : forall T (s : list T) (re : reg_exp T) (x : T),\n  s =~ re ->\n  In x s ->\n  In x (re_chars re).\nProof.\n  intros T s re x H Hin.\n  induction H as [| c \n                  | s1 re1 s2 re2 H1 IH1 H2 IH2\n                  | s1 re1 re2 H1 IH\n                  | re1 s2 re2 H2 IH\n                  | re\n                  | s1 s2 re H1 IH1 H2 IH2 ].\n  - (* MEmpty  *)\n    simpl in Hin. exfalso. apply Hin.\n  - (* MChar *)\n    simpl. simpl in Hin. apply Hin.\n  - (* MApp *)\n    simpl. rewrite In_app_iff. \n    rewrite In_app_iff in Hin. \n    destruct Hin as [Hinl | Hinr]. \n    + left.  apply IH1. apply Hinl.\n    + right. apply IH2. apply Hinr.\n  - (* MUnionL *)\n    simpl. rewrite In_app_iff. left. apply IH. apply Hin.\n  - (* MUnionR *)\n    simpl. rewrite In_app_iff. right. apply IH. apply Hin.\n  - (* MStar0 *)\n    simpl in Hin. exfalso. apply Hin.\n  - (* MStarApp *)\n    rewrite In_app_iff in Hin. \n    destruct Hin as [Hinl | Hinr].\n    + simpl. apply IH1. apply Hinl.\n    + simpl. apply IH2. apply Hinr.\nQed.\n\nFixpoint re_not_empty {T : Type} (re : reg_exp T) : bool :=\n  match re with\n  | EmptySet      => false\n  | EmptyStr      => true\n  | Char x        => true\n  | App re1 re2   => re_not_empty re1 && re_not_empty re2\n  | Union re1 re2 => re_not_empty re1 || re_not_empty re2\n  | Star re       => true\n  end.\n\nSearch (orb ?a ?b = orb ?b ?a).\n\nLemma re_not_empty_correct : forall T (re : reg_exp T),\n  (exists s, s =~ re) <-> re_not_empty re = true.\nProof.\n  intros T re.\n  split.\n  - intros [s H].\n    induction H as [| c \n                | s1 re1 s2 re2 H1 IH1 H2 IH2\n                | s1 re1 re2 H1 IH\n                | re1 s2 re2 H2 IH\n                | re\n                | s1 s2 re H1 IH1 H2 IH2 ].\n    + (* MEmpty  *)\n      simpl. reflexivity.\n    + (* MChar *)\n      simpl. reflexivity.\n    + (* MApp *)\n      simpl. rewrite -> IH1. rewrite -> IH2. reflexivity.\n    + (* MUnionL *)\n      simpl. rewrite -> IH. reflexivity.\n    + (* MUnionR *)\n      simpl. rewrite -> IH. rewrite Bool.orb_comm. reflexivity.\n    + (* MStar0 *)\n      reflexivity. \n    + (* MStarApp *)\n      reflexivity.\n  - intros H.\n    induction re as [|\n                    | c\n                    | re1 IH1 re2 IH2\n                    | re1 IH1 re2 IH2\n                    | r IH ].\n    + (* EmptySet *)\n      simpl in H. discriminate H.\n    + (* EmptyStr *)\n      simpl in H. exists [ ]. apply MEmpty.\n    + (* Char (c : T) *)\n      exists [c]. apply MChar.\n    + (* App (r1 r2 : reg_exp T) *)\n      simpl in H.\n      destruct (re_not_empty re1).\n      -- destruct (re_not_empty re2).\n         ++ simpl in H.\n            destruct (IH1 H) as [s1 H'1].\n            destruct (IH2 H) as [s2 H'2].\n            exists (s1 ++ s2).\n            apply (MApp _ _ _ _ H'1 H'2).\n         ++ discriminate H.\n      -- discriminate H.\n    + (* Union (r1 r2 : reg_exp T) *)\n      simpl in H.\n      destruct (re_not_empty re1).\n      -- destruct (IH1 H) as [s H'].\n         exists s.\n         apply (MUnionL _ _ _ H').\n      -- destruct (re_not_empty re2).\n         ++ destruct (IH2 H) as [s H'].\n            exists s.\n            apply (MUnionR _ _ _ H').\n         ++ discriminate H.\n    + (* Star (r : reg_exp T). *)\n      exists [].\n      apply MStar0.\nQed.\n\n\n\n\nTheorem app_assoc : forall A (l m n:list A),\n  l ++ m ++ n = (l ++ m) ++ n.\nProof.\n  intros A l m n.\n  induction l as [| h t H ].\n  - reflexivity.\n  - simpl.\n    rewrite -> H.\n    reflexivity.\nQed.\n\n\nLemma star_app: forall T (s1 s2 : list T) (re : reg_exp T),\n  s1 =~ Star re ->\n  s2 =~ Star re ->\n  s1 ++ s2 =~ Star re.\nProof.\n  intros T s1 s2 re H1.\n  remember (Star re) as re' eqn: Ere'.\n  generalize dependent s2.\n  induction H1\n    as [|x'|s1 re1 s2' re2 Hmatch1 IH1 Hmatch2 IH2\n        |s1 re1 re2 Hmatch IH|re1 s2' re2 Hmatch IH\n        |re''|s1 s2' re'' Hmatch1 IH1 Hmatch2 IH2].\n  - (* MEmpty *) discriminate.\n  - (* MChar *) discriminate.\n  - (* MApp *) discriminate.\n  - (* MUnionL *) discriminate.\n  - (* MUnionR *) discriminate.\n  - (* MStar0 *)\n    injection Ere' as Heqre''. intros s H. apply H.\n  - (* MStarApp *)\n    injection Ere' as Heqre''.\n    intros s2 H1. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hmatch1.\n    + apply IH2.\n      * rewrite Heqre''. reflexivity.\n      * apply H1.\nQed.\n\n\nLemma Star_lemm: forall T (s1 s2 : list T) re,\n  s1 =~ re -> s2 =~ Star re -> (s1 ++ s2) =~ Star re.\nProof.\n  intros T s1 s2 re H1 H2.\n  apply (MStarApp s1 _ _ H1) in H2.\n  apply H2.\nQed.\n\nSearch (?l ++ [] = ?l).\n\nLemma MStar'' : forall T (s : list T) (re : reg_exp T),\n  s =~ Star re ->\n  exists ss : list (list T), (s = fold (@app T) ss []) /\\ (forall s', In s' ss -> s' =~ re).\nProof.\n  intros T s re H.\n  remember (Star re) as k eqn:Ek.\n  induction H as [| c \n                  | s1 re1 s2 re2 H1 IH1 H2 IH2\n                  | s1 re1 re2 H1 IH\n                  | re1 s2 re2 H2 IH\n                  | re1\n                  | s1 s2 re1 H1 IH1 H2 IH2 ].\n  - discriminate Ek.\n  - discriminate Ek.\n  - discriminate Ek.\n  - discriminate Ek.\n  - discriminate Ek.\n  - exists [].\n    simpl.\n    split.\n    + reflexivity.\n    + intros s' F. exfalso. apply F.\n  - destruct (IH2 Ek) as [ss [H'1 H'2]]. (* Get list of matched strings from Inductive Hypo *)\n    exists ([s1] ++ ss).\n    split.\n    + simpl.\n      rewrite <- H'1.\n      reflexivity.\n    + intros s'.\n      simpl. \n      intros G.\n      destruct G as [G1 | G2].\n      * rewrite <- G1.\n        injection Ek as Ek'.\n        rewrite <- Ek'.\n        apply H1.\n      * apply H'2.\n        apply G2.\nQed.\n\nModule Pumping.\n\nFixpoint pumping_constant {T} (re : reg_exp T) : nat :=\n  match re with\n  | EmptySet => 1\n  | EmptyStr => 1\n  | Char _ => 2\n  | App re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Union re1 re2 =>\n      pumping_constant re1 + pumping_constant re2\n  | Star r => pumping_constant r\n  end.\n\nLemma pumping_constant_ge_1 : forall T (re : reg_exp T),\n    pumping_constant re >= 1.\nProof.\nAdmitted.\n(*\n  intros T re. induction re.\n  - (* EmptySet *)\n    apply le_n.\n  - (* EmptyStr *)\n    apply le_n.\n  - (* Char *)\n    apply le_S. apply le_n.\n  - (* App *)\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  - (* Union *)\n    simpl.\n    apply le_trans with (n:=pumping_constant re1).\n    apply IHre1. apply le_plus_l.\n  - (* Star *)\n    simpl. apply IHre.\nQed.\n*)\n\nLemma pumping_constant_0_false : forall T (re : reg_exp T),\n    pumping_constant re = 0 -> False.\nProof.\n  intros T re H.\n  assert (Hp1 : pumping_constant re >= 1).\n  { apply pumping_constant_ge_1. }\n  inversion Hp1 as [Hp1'| p Hp1' Hp1''].\n  - rewrite H in Hp1'. discriminate Hp1'.\n  - rewrite H in Hp1''. discriminate Hp1''.\nQed.\n\nFixpoint napp {T} (n : nat) (l : list T) : list T :=\n  match n with\n  | 0 => []\n  | S n' => l ++ napp n' l\n  end.\n\nLemma napp_plus: forall T (n m : nat) (l : list T),\n  napp (n + m) l = napp n l ++ napp m l.\nProof.\n  intros T n m l.\n  induction n as [|n IHn].\n  - reflexivity.\n  - simpl. rewrite IHn, app_assoc. reflexivity.\nQed.\n\nLemma napp_star :\n  forall T m s1 s2 (re : reg_exp T),\n    s1 =~ re -> s2 =~ Star re ->\n    napp m s1 ++ s2 =~ Star re.\nProof.\n  intros T m s1 s2 re Hs1 Hs2.\n  induction m.\n  - simpl. apply Hs2.\n  - simpl. rewrite <- app_assoc.\n    apply MStarApp.\n    + apply Hs1.\n    + apply IHm.\nQed.\n\n\nSearch (?l ++ [] = ?l).\nSearch (length (?s1 ++ ?s2) = length (?s1) + length (?s2)).\nSearch (?a + ?b <= ?c + ?d -> ?a <= ?c \\/ ?b <= ?d).\nSearch (?a + ?b <= ?c -> ?a <= ?c /\\ ?b <= ?c).\nSearch (?a <= ?b + ?c -> ?a <= ?b /\\ ?a <= ?c).\n(*Search (plus_le).\nSearch (le_plus).*)\nLemma plus_le: forall a b c, a + b <= c -> a <= c /\\ b <= c.\nProof. Admitted.\n\nLemma le_plus: forall a b c, a <= b + c -> a <= b /\\ a <= c.\nProof. Admitted.\n\nLemma weak_pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\\n    s2 <> [] /\\\n    forall m, s1 ++ napp m s2 ++ s3 =~ re.\nProof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | re1 s2 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  - (* MEmpty *)\n    simpl. intros contra. inversion contra.\n  - (* MChar *)\n    exists [].\n    simpl in H.\n    inversion H.\n    inversion H1.\n  - (* MApp *)\n    simpl.\n    intros H.\n    rewrite -> List.app_length in H.\n    destruct (PeanoNat.Nat.add_le_cases _ _ _ _ H) as [Hl | Hr ].\n    + destruct (IH1 Hl) as [s2' [s3' [s4' [G1 [G2 G3]]]]].\n      exists s2'.\n      exists s3'.\n      exists (s4' ++ s2).\n      split.\n      * rewrite -> G1.\n        rewrite <- app_assoc.\n        rewrite <- app_assoc.\n        reflexivity.\n      * split.\n        -- apply G2.\n        -- intros m.\n           rewrite -> app_assoc.\n           rewrite -> app_assoc.\n           rewrite <- (app_assoc _ s2' (napp m s3') s4').\n           apply MApp.\n           ++ apply (G3 m).\n           ++ apply Hmatch2.\n    + destruct (IH2 Hr) as [s2' [s3' [s4' [G1 [G2 G3]]]]].\n      exists (s1 ++ s2').\n      exists s3'.\n      exists s4'.\n      split.\n      * rewrite -> G1.\n        rewrite <- app_assoc.\n        reflexivity.\n      * split.\n        -- apply G2.\n        -- intros m.\n           rewrite <- app_assoc.\n           apply MApp.\n           ++ apply Hmatch1.\n           ++ apply (G3 m).\n  - (* MUnionL *) \n    simpl.\n    intros H.\n    destruct (plus_le _ _ _ H) as [Hre1 Hre2].\n    destruct (IH Hre1) as [s2' [s3' [s4' [G1 [G2 G3]]]]].\n    exists s2'.\n    exists s3'.\n    exists s4'.\n    split.\n    + apply G1.\n    + split.\n      * apply G2.\n      * intros m.\n        apply MUnionL.\n        apply G3.\n  - (* MUnionR *)\n    simpl.\n    intros H.\n    destruct (plus_le _ _ _ H) as [Hre1 Hre2].\n    destruct (IH Hre2) as [s2' [s3' [s4' [G1 [G2 G3]]]]].\n    exists s2'.\n    exists s3'.\n    exists s4'.\n    split.\n    + apply G1.\n    + split.\n      * apply G2.\n      * intros m.\n        apply MUnionR.\n        apply G3.\n  - (* MStar0 *)\n    intros H.\n    simpl in H.\n    destruct (pumping_constant_ge_1 T re).\n    + inversion H.\n    + inversion H.\n  - (* MStarApp *)\n    simpl.\n    intros H.\n    rewrite -> List.app_length in H.\n    destruct (le_plus _ _ _ H) as [Hl Hr ].\n    destruct (IH1 Hl) as [s2' [s3' [s4' [G1 [G2 G3]]]]].\n    destruct (IH2 Hr) as [s2'2 [s3'2 [s4'2 [G12 [G22 G32]]]]].\n    exists s2'.\n    exists s3'.\n    exists (s4' ++ s2).\n    split.\n    + rewrite -> G1.\n      rewrite <- (app_assoc _).\n      rewrite <- (app_assoc _).\n      reflexivity.\n    + split.\n      * apply G2.\n      * intros m.\n        rewrite -> (app_assoc _).\n        rewrite -> (app_assoc _).\n        rewrite <- (app_assoc _ s2').\n        apply MStarApp.\n        -- apply (G3 m).\n        -- apply Hmatch2.\nQed.\n\nLemma pumping : forall T (re : reg_exp T) s,\n  s =~ re ->\n  pumping_constant re <= length s ->\n  exists s1 s2 s3,\n    s = s1 ++ s2 ++ s3 /\\ s2 <> [] \n      /\\ length s1 + length s2 <= pumping_constant re /\\ forall m, s1 ++ napp m s2 ++ s3 =~ re.\nProof.\n  intros T re s Hmatch.\n  induction Hmatch\n    as [ | x | s1 re1 s2 re2 Hmatch1 IH1 Hmatch2 IH2\n       | s1 re1 re2 Hmatch IH | re1 s2 re2 Hmatch IH\n       | re | s1 s2 re Hmatch1 IH1 Hmatch2 IH2 ].\n  - (* MEmpty *)\n    simpl. intros contra. inversion contra.\nAdmitted.\n\n\nEnd Pumping.\n\nEnd RegExp.\n\n\nInductive reflect (P : Prop) : bool -> Prop :=\n  | ReflectT (H : P) : reflect P true\n  | ReflectF (H : ~ P) : reflect P false.\n\nTheorem iff_reflect : forall P b, (P <-> b = true) -> reflect P b.\nProof.\n  intros P b H. destruct b eqn:Eb.\n  - apply ReflectT. rewrite H. reflexivity.\n  - apply ReflectF. rewrite H. intros H'. discriminate.\nQed.\n\nTheorem reflect_iff : forall P b, reflect P b -> (P <-> b = true).\nProof.\n  intros P b H.\n  destruct H as [p | p].\n  - split.\n    + intros P'. reflexivity.\n    + intros T. apply p.\n  - split.\n    + intros P'. exfalso. apply (p P').\n    + intros F. discriminate F.\nQed.\n\nLemma eqb_eq : forall m n, n = m <-> (n =? m) = true.\nProof.\n  intros m n.\n  split.\n  - intros H.\n    rewrite -> H.\n    assert(G: forall n, (n =? n) = true). {\n      intros k.\n      induction k as [| k' IH].\n      - reflexivity.\n      - simpl. rewrite -> IH. reflexivity.\n    }\n    apply G. \n  - generalize dependent m.\n    induction n as [| n' IH].\n    + destruct m as [| m'].\n      * simpl. intros H. reflexivity.\n      * simpl. intros H. discriminate H.\n    + destruct m as [| m'].\n      * simpl. intros H. discriminate H.\n      * simpl. intros H. rewrite -> (IH m' H). reflexivity.\nQed.\n\n\nLemma eqbP : forall n m, reflect (n = m) (n =? m).\nProof.\n  intros n m. apply iff_reflect. rewrite eqb_eq. reflexivity.\nQed.\n\n\nFixpoint filter {X: Type} (test: X -> bool) (l: list X) : list X :=\n  match l with\n  | []     => []\n  | h :: t =>\n    if test h \n    then h :: (filter test t)\n    else filter test t\n  end.\n\nTheorem filter_not_empty_In' : forall n l,\n  filter (fun x => n =? x) l <> [] ->\n  In n l.\nProof.\n  intros n l. induction l as [|m l' IHl'].\n  - (* l =  *)\n    simpl. intros H. apply H. reflexivity.\n  - (* l = m :: l' *)\n    simpl. destruct (eqbP n m) as [H | H].\n    + (* n = m *)\n      intros _. rewrite H. left. reflexivity.\n    + (* n <> m *)\n      intros H'. right. apply IHl'. apply H'.\nQed.\n\n\nFixpoint count n l :=\n  match l with\n  | [] => 0\n  | m :: l' => (if n =? m then 1 else 0) + count n l'\n  end.\n\nTheorem eqbP_practice : forall n l,\n  count n l = 0 -> ~(In n l).\nProof.\n  intros n l H.\n  induction l as [| h t IH ].\n  - simpl in H. simpl. unfold not. intros F. apply F.\n  - simpl.\n    simpl in H.\n    destruct (eqbP n h) as [Heq | Heq].\n    + simpl in H.\n      discriminate H.\n    + simpl in H.\n      apply IH in H.\n      unfold not.\n      intros G.\n      destruct G as [G1 | G2].\n      * apply Heq.\n        symmetry.\n        apply G1.\n      * apply H.\n        apply G2.\nQed.\n\n\nModule Stutter.\nInductive nostutter {X:Type} : list X -> Prop :=\n  | empty : nostutter nil\n  | one x : nostutter [x]\n  | add n x t (Hneq : n <> x) (Hh : nostutter (x :: t)) : nostutter (n :: x :: t)\n.\n\nExample test_nostutter_1: nostutter [3;1;4;1;5;6].\nProof. repeat constructor; apply eqb_neq; auto. Qed.\n\nExample test_nostutter_2: nostutter (@nil nat).\nProof. repeat constructor; apply eqb_neq; auto. Qed.\n\nExample test_nostutter_3: nostutter [5].\nProof. repeat constructor; auto. Qed.\n\nExample test_nostutter_4: not (nostutter [3;1;1;4]).\nProof. intro.\n  repeat match goal with\n    h: nostutter _ |- _ => inversion h; clear h; subst\n  end.\n  contradiction; auto. Qed.\nEnd Stutter.\n\n\nModule InOrderMerged.\nInductive in_order_merged {X:Type} : list X -> list X -> list X -> Prop :=\n  | empty : in_order_merged nil nil nil\n  | addl n l1 l2 lr (H: in_order_merged l1 l2 lr) : in_order_merged (n :: l1) l2 (n :: lr)\n  | addr n l1 l2 lr (H: in_order_merged l1 l2 lr) : in_order_merged l1 (n :: l2) (n :: lr)\n.\n\nExample ex1 : in_order_merged [1;6;2] [4;3] [1;4;6;2;3].\nProof. apply addl. apply addr. apply addl. apply addl. apply addr. apply empty. Qed.\n\nFixpoint elem_of (l: list nat) (x : nat) : bool :=\n  match l with\n  | nil => false\n  | cons h t => if h =? x then true else elem_of t x\n  end.\n\nLemma same_start_list: forall T (h : T) (t t': list T), t = t' -> h :: t = h :: t'.\nProof.\n  intros T h t t' H.\n  rewrite -> H.\n  reflexivity.\nQed.\n\nLemma add_false_simpl: forall P, (False \\/ P) -> P.\nProof.\n  intros P H.\n  destruct H as [l | r].\n  - exfalso. apply l.\n  - apply r.\nQed.\n\n\nLemma inP : forall (x : nat) (l : list nat), \n  reflect (In x l) (elem_of l x).\nProof.\n  intros x l.\n  induction l as [| h t H].\n  - simpl. apply ReflectF. unfold not. intros F. apply F.\n  - simpl. \n    destruct (eqbP h x) as [Hhx|Hhx].\n    + apply ReflectT.\n      left. apply Hhx.\n    + unfold not in Hhx.\n      destruct H.\n      * apply ReflectT. right. apply H.\n      * apply ReflectF. unfold not.\n        intros HF.\n        destruct HF as [HFl|HFr].\n        -- apply Hhx. apply HFl.\n        -- apply H. apply HFr.\nQed.\n\nLemma neg_app: forall A B, (~ (A \\/ B)) <-> ~A /\\ ~B.\nProof.\n  intros A B.\n  split.\n  * intros H.\n    split.\n    - unfold not in H.\n      unfold not.\n      intros AH.\n      apply H.\n      apply (or_intro_l A _ AH).\n    - unfold not in H.\n      unfold not.\n      intros BH.\n      apply H.\n      apply (or_intro_r A B BH).\n  * intros [Hl Hr].\n    unfold not.\n    intros Hor.\n    destruct Hor as [Horl | Horr].\n    - apply Hl. apply Horl.\n    - apply Hr. apply Horr.\nQed.\n\nTheorem sum_nas_no_item: forall A (x: A) l1 l2 lr, \n  in_order_merged l1 l2 lr -> (~ In x l1 /\\ ~ In x l2 ) -> (~ (In x lr)).\nProof.\n  intros A x l1 l2 lr H1 H2.\n  induction H1 as [| n l1' l2' lr' H1' IH| n l1' l2' lr' H1' IH].\n  - destruct H2 as [H2l H2r].\n    apply H2l.\n  - simpl. apply neg_app.\n    simpl in H2. rewrite -> neg_app in H2.\n    destruct H2 as [[Hneq Hxl1] Hxl2].\n    split.\n    + apply Hneq.\n    + apply IH.\n      split.\n      * apply Hxl1.\n      * apply Hxl2.\n  - simpl. apply neg_app.\n    simpl in H2. rewrite -> neg_app in H2.\n    destruct H2 as [Hxl1 [Hneq Hxl2]].\n    split.\n    + apply Hneq.\n    + apply IH.\n      split.\n      * apply Hxl1.\n      * apply Hxl2.\nQed.\n\nLemma elem_of_h: forall h t, \n  elem_of (h :: t) h = true.\nProof.\n  intros h t.\n  simpl.\n  destruct (eqbP h h) as [Hr | Hr].\n  - reflexivity.\n  - exfalso. apply Hr. reflexivity.\nQed.\n\nLemma n_eq_n: forall n, n =? n = true.\nProof.\n  intros n.\n  destruct (eqbP n n) as [Hl | Hr].\n  - reflexivity.\n  - exfalso. apply Hr. reflexivity.\nQed.\n\nLemma if_with_same_res: forall A (b : bool) (r: A), (if b then r else r) = r.\nProof.\n  intros A b r.\n  destruct b.\n  - reflexivity.\n  - reflexivity.\nQed.\n\nLemma add_existed: forall n l, \n  In n l -> (forall x, elem_of (n :: l) x = elem_of l x).\nProof.\n  intros n l H x.\n  simpl.\n  destruct (eqbP n x) as [Hl | Hr].\n  - rewrite <- Hl.\n    destruct (inP n l) as [Hl' | Hr'].\n    + reflexivity.\n    + exfalso. apply Hr'. apply H.\n  - reflexivity.\nQed.\n\nLemma filter_lemm: forall n l m, \n  In n l -> filter (elem_of (n :: l)) m = filter (elem_of l) m.\nProof.\n  intros n l m H.\n  simpl.\n  induction m as [| mh mt IH].\n  - reflexivity.\n  - simpl.\n    destruct (eqbP n mh) as [Hl | Hr].\n    + rewrite <- Hl.\n      destruct (inP n l) as [Hl' | Hr'].\n      * rewrite <- IH. reflexivity.\n      * exfalso. apply Hr'. apply H.\n    + rewrite -> IH. reflexivity.\nQed.\n  \nLemma tst: forall n p l, ~ In n l -> filter (fun x : nat => if n =? x then true else p x) l = filter p l.\nProof.\n  intros n p l H.\n  induction l as [| h t IH].\n  - reflexivity.\n  - simpl.\n    destruct (eqbP n h).\n    + exfalso. apply H. simpl. left. rewrite -> H0. reflexivity.\n    + assert (G: ~ In n t). {\n        simpl in H.\n        apply neg_app in H.\n        destruct H as [Hl Hr].\n        apply Hr.\n      }\n      rewrite -> (IH G).\n      reflexivity.\nQed.\n\nLemma exclusion_rev: forall A (l1 l2 : list A), \n  (forall x, In x l1 -> ~(In x l2)) -> (forall x, In x l2 -> ~(In x l1)).\nProof.\n  intros A l1 l2 H x H2.\n  unfold not.\n  intros G.\n  apply (H x G).\n  apply H2.\nQed.\n\nTheorem filter_preserve_ord: forall l1 l2 lr, \n  in_order_merged l1 l2 lr -> (forall x, In x l1 -> ~(In x l2)) -> filter (elem_of l1) lr = l1.\nProof.\n  intros l1 l2 lr H Hexcl.\n  induction H as [| n l1' l2' lr' H' IH| n l1' l2' lr' H' IH].\n  - reflexivity.\n  - destruct (inP n l1') as [Hl | Hr].\n    + rewrite -> (filter_lemm _ _ _ Hl).\n      simpl.\n      assert (G: elem_of l1' n = true). {\n        destruct (inP n l1').\n        - reflexivity.\n        - exfalso. apply H. apply Hl.\n      }\n      rewrite -> G.\n      assert (G': forall x : nat, In x l1' -> ~ In x l2'). {\n        intros x HIn.\n        apply Hexcl.\n        simpl. right. apply HIn.\n      }\n      rewrite -> (IH G').\n      reflexivity.\n    + simpl.\n      rewrite -> n_eq_n.\n      assert (Hnl2': ~ In n l2'). {\n        apply Hexcl.\n        simpl. left. reflexivity.\n      }\n      assert (Hnlr': ~ In n lr'). {\n        apply (sum_nas_no_item _ _ _ _ _ H').\n        split. apply Hr. apply Hnl2'.\n      }\n      rewrite -> (tst n (elem_of l1') lr' Hnlr').\n      assert (G: forall x : nat, In x l1' -> ~ In x l2'). {\n        intros x H.\n        apply Hexcl.\n        simpl.\n        right. apply H.\n      }\n      rewrite -> (IH G).\n      reflexivity.\n  - simpl.\n    destruct (inP n l1') as [Hl | Hr].\n    + apply Hexcl in Hl.\n      simpl in Hl.\n      rewrite -> neg_app in Hl.\n      destruct Hl as [Hll Hlr].\n      exfalso. apply Hll. reflexivity.\n    + assert (G: forall x : nat, In x l1' -> ~ In x l2'). {\n        intros x H.\n        apply Hexcl in H.\n        simpl in H.\n        rewrite -> neg_app in H.\n        destruct H as [Hl' Hr'].\n        apply Hr'.\n      }\n      rewrite -> (IH G).\n      reflexivity.\nQed.\n\nEnd InOrderMerged.\n\n(*\nA different way to characterize the behavior of filter goes like this: \n  Among all subsequences of l with the property that test \n  evaluates to true on all their members, filter test l is \n  the longest. Formalize this claim and prove it. \n*)\n\n\nModule Pal.\n\nInductive pal {X:Type} : list X -> Prop :=\n  | empty : pal nil \n  | one (c : X) : pal [c]\n  | step (c: X) (l: list X) (H: pal l): pal (c :: l ++ [c])\n.\n\nExample pal_e1: pal [1; 2; 3; 3; 2; 1].\nProof. Admitted.\n\nTheorem pal_app_rev: forall {X:Type} (l: list X), \n  pal (l ++ rev l).\nProof.\n  intros X l.\n  induction l as [|h t IH].\n  - simpl. apply empty.\n  - simpl. \n    assert (G: (h :: t ++ rev t ++ [h]) = (h :: (t ++ rev t) ++ [h])). {\n      rewrite <- (app_assoc ).\n      reflexivity.\n    }\n    rewrite -> G.\n    apply step.\n    apply IH.\nQed.\n\nLemma Geq: forall {X: Type} (l1 l2 l3: list X), \n  l1 = l2 -> l1 ++ l3 = l2 ++ l3.\nProof.\n  intros X l1 l2 l3 H.\n  rewrite -> H.\n  reflexivity.\nQed.\n\nLemma Rev_concat: forall {X: Type} l (c: X), \n  rev (l ++ [c]) = c :: (rev l).\nProof.\n  intros X l c.\n  induction l as [| h t IH].\n  - reflexivity.\n  - simpl. \n    apply (Geq (rev (t ++ [c])) (c :: rev t) [h]).\n    apply IH.\nQed.\n\nLemma concat_inj: forall {X: Type} (l1 l2: list X) (x1 x2: X),\n  l1 ++ [x1] = l2 ++ [x2] -> l1 = l2 /\\ x1 = x2.\nProof.\n  intros X l1.\n  induction l1 as [| h t IH].\n  - simpl.\n    destruct l2 as [| l2h l2t ] eqn: El2.\n    + simpl.\n      intros x1 x2 H.\n      split.\n      * reflexivity.\n      * injection H as H'.\n        apply H'.\n    + intros x1 x2.\n      simpl.\n      intros H.\n      injection H as H1 H2.\n      destruct l2t as [|l2th l2tt].\n      * simpl in H2. discriminate H2.\n      * simpl in H2. discriminate H2.\n  - simpl.\n    intros l2 x1 x2 H.\n    destruct l2 as [| l2h l2t] eqn:El2.\n    + simpl in H.\n      injection H as H'1 H'2.\n      destruct t as [| th tt ] eqn:Et.\n      * simpl in H'2. discriminate H'2.\n      * simpl in H'2. discriminate H'2.\n    + simpl in H.\n      injection H as H'1 H'2.\n      destruct (IH l2t x1 x2 H'2) as [G1 G2].\n      split.\n      * rewrite <- H'1.\n        rewrite <- G1.\n        reflexivity.\n      * apply G2.\nQed.\n\nTheorem pal_rev: forall {X: Type} (l: list X),\n  pal l -> l = rev l.\nProof.\n  intros X l H.\n  induction H as [| c | c l H' IH].\n  - simpl. reflexivity.\n  - simpl. reflexivity.\n  - simpl.\n    apply (Geq (c ::l) (rev (l ++ [c])) [c]).\n    rewrite -> Rev_concat.\n    rewrite <- IH.\n    reflexivity.\nQed.\n\n(*\nLemma tst: forall {X: Type} l m (x: X), \n  x :: l = m ++ [x] -> ((l = nil /\\ m = nil) \\/ (exists l', l = l' ++ [x] /\\ m = x :: l')).\nProof.\n  intros X l m x H.\n  generalize dependent m.\n  generalize dependent x.\n  destruct l as [| h t ].\n  - left. split.\n    + reflexivity.\n    + destruct m as [| mh mt] eqn:Em.\n      * reflexivity.\n      * simpl in H.\n        injection H as InjH.\n        destruct mt as [| mtH mtT].\n        -- simpl in H. discriminate H.\n        -- simpl in H. discriminate H.\n  - intros x m H.\n    assert(G: exists k, m = x :: k). {\n      destruct m as [| mh mt].\n      + simpl in H. injection H as H'. discriminate H'.\n      + simpl in H. injection H as H'.\n        exists mt. \n        rewrite -> H'.\n        reflexivity.\n    }\n    destruct G as [k Hm].\n    right.\n    exists k.\n    split.\n    + rewrite -> Hm in H.\n      simpl in H.\n      injection H as Hr.\n      apply Hr.\n    + apply Hm.\nQed.\n*)\n\nLemma rev_empty: forall {X: Type} (l: list X), \n  rev l = [] -> l = [].\nProof.\n  intros X l H.\n  destruct l as [|h t] eqn:El.\n  - reflexivity.\n  - simpl in H. \n    destruct (rev t) as [| rh rt] eqn:Erev.\n    + simpl in H.\n      discriminate H.\n    + simpl in H.\n      discriminate H.\nQed.\n\nLemma destruct_last: forall {X: Type} (l: list X),\n  l = [] \\/ exists l' t, l = l' ++ [t].\nProof.\n  intros X l.\n  induction l as [|h t IH].\n  - left. reflexivity.\n  - right.\n    destruct IH as [IHl | IHr].\n    + exists [].\n      exists h.\n      rewrite -> IHl.\n      reflexivity.\n    + destruct IHr as [lH [tH Hh]].\n      exists (h :: lH).\n      exists tH.\n      simpl.\n      rewrite <- Hh.\n      reflexivity.\nQed.\n\nLemma rev_add_last: forall {X: Type} l (t: X), \n  rev (l ++ [t]) = t :: (rev l).\nProof.\n  intros X l.\n  induction l as [| lh lt IH].\n  - intros t. simpl. reflexivity.\n  - intros t. simpl.\n    rewrite -> IH.\n    simpl.\n    reflexivity.\nQed.\n(*\nLemma tst3 : forall {X: Type} (h: X) l,\n  h :: l = rev (h :: l) -> l = [] \\/ exists l', l' = rev l' /\\ h :: l' ++ [h] = h :: l.\nProof.\n  intros X h l H.\n  simpl in H.\n  destruct (rev l) as [|revH revT] eqn:Erev.\n  - apply rev_empty in Erev.\n    left. apply Erev.\n  - right.\n    exists revT.\n    split.\n    + destruct (destruct_last l) as [H1 | H2].\n      * rewrite -> H1 in Erev.\n        simpl in Erev.\n        discriminate Erev.\n      * destruct H2 as [lStart [lLast lEq]].\n        rewrite -> lEq in H.\n        rewrite -> lEq in Erev.\n        assert (G1: rev lStart = revT). {\n          rewrite -> rev_add_last in Erev.\n          injection Erev as Erev'1 Erev'2.\n          apply Erev'2.\n        }\n        assert (G2: lStart = revT). {\n          simpl in H.\n          injection H as H'1 H'2.\n          destruct (concat_inj lStart revT lLast h H'2) as [ErevT Eh].\n          apply ErevT.\n        }\n        rewrite -> G2 in G1.\n        symmetry.\n        apply G1.\n    + assert (G: revT ++ [h] = l -> h :: revT ++ [h] = h :: l). {\n        intros Hg.\n        rewrite -> Hg.\n        reflexivity.\n      }\n      apply G.\n      simpl in H.\n      injection H as H'1 H'2.\n      symmetry. apply H'2.\nQed.\n*)\nLemma add_any_side_same_len: forall {X: Type} (l: list X) (a b: X), \n  length (a :: l) = length (l ++ [b]).\nProof.\n  intros X l.\n  induction l as [| h t IH].\n  - intros a b. reflexivity.\n  - intros a b. simpl. rewrite <- (IH a b). reflexivity.\nQed.\n\nLemma list_split: forall {X: Type} (l: list X),\n  (exists l1   l2, length l1 = length l2 /\\ l = l1 ++        l2) \\/ \n  (exists l1 c l2, length l1 = length l2 /\\ l = l1 ++ [c] ++ l2).\nProof.\n  intros X l.\n  induction l as [| h t IH].\n  - left. exists []. exists [].\n    simpl.\n    split.\n    + reflexivity.\n    + reflexivity.\n  - assert (G: forall l m, l = m -> h :: l = h :: m). {\n      intros l m Hg.\n      rewrite -> Hg. \n      reflexivity.\n    }\n    destruct IH as [[l1 [l2 H ]] | [l1 [c [l2 H]]]].\n    + right.\n      destruct (destruct_last l1) as [Hd | Hd].\n      * exists []. exists h. exists [].\n        simpl.\n        rewrite -> Hd in H.\n        simpl in H.\n        destruct H as [H1 H2].\n        assert (G': l2 = []). {\n          destruct l2 as [| hl2 tl2].\n          - reflexivity.\n          - simpl in H1. discriminate H1.\n        }\n        rewrite -> G' in H2.\n        split. reflexivity. rewrite -> H2. reflexivity.\n      * destruct Hd as [l' [t' Hl1]].\n        exists (h :: l').\n        exists t'.\n        exists l2.\n        destruct H as [H1 H2].\n        split.\n        -- rewrite -> (add_any_side_same_len l' h t').\n           rewrite <- Hl1.\n           apply H1.\n        -- rewrite -> H2.\n           rewrite -> Hl1.\n           simpl.\n           apply G.\n           rewrite -> app_assoc.\n           simpl.\n           reflexivity.\n    + left.\n      exists (h :: l1).\n      exists (c :: l2).\n      destruct H as [H1 H2].\n      split.\n      * simpl. rewrite -> H1. reflexivity.\n      * simpl. rewrite -> H2.\n        apply G.\n        simpl.\n        reflexivity.\nQed.\n\nLemma len_add_last: forall {X: Type} l (x: X), \n  length (l ++ [x]) = S (length l).\nProof.\n  intros X l x.\n  rewrite <- (add_any_side_same_len l x x).\n  reflexivity.\nQed.\n\n\nLemma step_rev: forall {X: Type} l (x: X), \n  (x :: l ++ [x]) = rev (x :: l ++ [x]) -> l = rev l.\nProof.\n  intros X l x H.\n  simpl in H.\n  rewrite -> rev_add_last in H.\n  simpl in H.\n  injection H as H1.\n  destruct (concat_inj l (rev l) x x H1).\n  apply H.\nQed.\n\nTheorem pal_rev': forall {X: Type} (l : list X), \n  l = rev l -> pal l.\nProof.\n  intros X l H.\n  destruct (list_split l) as [Hl | Hr].\n  - destruct Hl as [l1 [l2 [EqLen EqL ]]].\n    generalize dependent l.\n    generalize dependent l2.\n    induction l1 as [| h t IH].\n    + intros l2 EqLen l H EqL.\n      assert (Hl2Empty: l2 = []). {\n        simpl in EqLen.\n        destruct l2 as [| l2h l2t].\n        - reflexivity.\n        - simpl in EqLen. discriminate EqLen.\n      }\n      rewrite -> Hl2Empty in EqL.\n      simpl in EqL.\n      rewrite -> EqL.\n      apply empty.\n    + intros l2 EqLen l H EqL.\n      destruct (destruct_last l2) as [Hd | Hd].\n      * rewrite -> Hd in EqLen. discriminate EqLen.\n      * destruct Hd as [l' [h' El2]].\n        rewrite -> El2 in EqL.\n        assert (G: h = h'). {\n          rewrite -> EqL in H.\n          rewrite <- (app_assoc) in H.\n          rewrite -> (rev_add_last ((h :: t) ++ l') h') in H.\n          rewrite -> (app_assoc) in H.\n          simpl in H.\n          injection H as H1.\n          apply H1.\n        }\n        rewrite <- G in EqL.\n        rewrite -> EqL.\n        simpl.\n        rewrite <- (app_assoc).\n        apply step.\n        assert (G1: length t = length l'). {\n          rewrite -> El2 in EqLen.\n          rewrite -> len_add_last in EqLen.\n          simpl.\n          injection EqLen as EqLen'.\n          apply EqLen'.\n        }\n        assert (G2: (t ++ l') = rev (t ++ l')). {\n          simpl in EqL.\n          rewrite -> EqL in H.\n          rewrite <- (app_assoc) in H.\n          destruct (step_rev (t ++ l') h H) as [H'].\n          reflexivity.\n        }\n        apply (IH l' G1 (t ++ l') G2).\n        reflexivity.\n  - destruct Hr as [l1 [c [l2 [EqLen EqL ]]]].\n    generalize dependent l.\n    generalize dependent l2.\n    induction l1 as [| h t IH].\n    + intros l2 EqLen l H EqL.\n      assert (Hl2Empty: l2 = []). {\n        simpl in EqLen.\n        destruct l2 as [| l2h l2t].\n        - reflexivity.\n        - simpl in EqLen. discriminate EqLen.\n      }\n      rewrite -> Hl2Empty in EqL.\n      simpl in EqL.\n      rewrite -> EqL.\n      apply one.\n    + intros l2 EqLen l H EqL.\n      destruct (destruct_last l2) as [Hd | Hd].\n      * rewrite -> Hd in EqLen. discriminate EqLen.\n      * destruct Hd as [l' [h' El2]].\n        rewrite -> El2 in EqL.\n        assert (G: h = h'). {\n          rewrite -> EqL in H.\n          rewrite <- (app_assoc) in H.\n          rewrite <- (app_assoc) in H.\n          rewrite -> (rev_add_last (((h :: t) ++ [c]) ++ l') h') in H.\n          rewrite -> (app_assoc) in H.\n          simpl in H.\n          injection H as H1.\n          apply H1.\n        }\n        rewrite <- G in EqL.\n        rewrite -> EqL.\n        rewrite <- (app_assoc).\n        rewrite <- (app_assoc).\n        simpl.\n        apply step.\n        rewrite -> (app_assoc).\n        assert (G1: length t = length l'). {\n          rewrite -> El2 in EqLen.\n          rewrite -> len_add_last in EqLen.\n          simpl.\n          injection EqLen as EqLen'.\n          apply EqLen'.\n        }\n        assert (G2: (t ++ [c] ++ l') = rev (t ++ [c] ++ l')). {\n          rewrite <- (app_assoc) in EqL.\n          rewrite <- (app_assoc) in EqL.\n          simpl in EqL.\n          rewrite -> EqL in H.\n          rewrite -> (app_assoc _ t [c] l') in H.\n          destruct (step_rev (t ++ [c] ++ l') h H) as [H'].\n          reflexivity.\n        }\n        apply (IH l' G1 (t ++ [c] ++ l') G2).\n        reflexivity.\nQed.\n\n\nEnd Pal.\n\nDefinition disjoint {X: Type} (l1 l2 : list X): Prop := \n  forall (a: X), In a l1 -> ~(In a l2).\n\nInductive NoDup {X: Type} : list X -> Prop :=\n  | emptyNoDup : NoDup []\n  | consNoDup (l: list X) (x: X) (H: NoDup l) (N: ~(In x l)) : NoDup (x :: l)\n.\n\nSearch or.\n\nLemma not_in_sum: forall {X: Type} (x: X) (a b: list X), \n  ~ In x a /\\ ~ In x b -> ~ In x (a ++ b).\nProof.\n  intros X x a b [Ha Hb].\n  induction a as [| h t IH].\n  - simpl. apply Hb.\n  - simpl.\n    simpl in Ha.\n    assert (G: forall A B, ~(A \\/ B) -> ~A /\\ ~B). {\n      intros A B H.\n      unfold not in H.\n      split.\n      + unfold not. intros HA. apply H. apply (or_introl HA).\n      + unfold not. intros HB. apply H. apply (or_intror HB).\n    }\n    unfold not.\n    intros [Hl | Hr].\n    + apply (Ha (or_introl Hl)).\n    + apply G in Ha.\n      destruct Ha as [Hal Har].\n      apply IH.\n      apply Har.\n      apply Hr.\nQed.\n\n\n\nTheorem no_dup_in_concat: forall {X: Type} (l1 l2: list X), \n  NoDup l1 /\\ NoDup l2 /\\ disjoint l1 l2 -> NoDup (l1 ++ l2).\nProof.\n  intros X l1 l2 [Hnd1 [Hnd2 Hd]].\n  induction l1 as [| h t IH].\n  - simpl. apply Hnd2.\n  - assert (G: NoDup t). {\n      remember (h :: t) as k.\n      destruct Hnd1 as [| l x H' N'] eqn:E.\n      + discriminate Heqk.\n      + injection Heqk as Heqk1 Heqk2.\n        rewrite <- Heqk2.\n        apply H'.\n    }\n    assert (G1: disjoint t l2). {\n      unfold disjoint.\n      unfold disjoint in Hd.\n      simpl in Hd.\n      intros a Inat.\n      apply (Hd a (or_intror Inat)).\n    }\n    assert (G2': ~ In h l2). {\n      unfold disjoint in Hd.\n      apply Hd.\n      simpl. left. reflexivity.\n    }\n    assert (G2'': ~ In h t). {\n      remember (h :: t) as k.\n      destruct Hnd1 as [| l x H' N'] eqn:E.\n      - discriminate Heqk.\n      - injection Heqk as Heqk1 Heqk2.\n        rewrite <- Heqk2.\n        rewrite <- Heqk1.\n        apply N'.\n    }\n    assert (G2: ~ In h (t ++ l2)). {\n      unfold disjoint in Hd.\n      apply not_in_sum.\n      split.\n      + apply G2''.\n      + apply G2'.\n    }\n    simpl.\n    apply (consNoDup (t ++ l2) h (IH G G1)).\n    apply G2.\nQed.\n\n\n\nModule PigeonHoles.\nLemma in_split : forall (X:Type) (x:X) (l:list X),\n  In x l -> exists l1 l2, l = l1 ++ x :: l2.\nProof.\n  intros X x l H.\n  induction l as [| h t IH].\n  - simpl in H. exfalso. apply H.\n  - simpl in H.\n    destruct H as [Hl | Hr].\n    + rewrite <- Hl.\n      exists [].\n      exists t.\n      reflexivity.\n    + destruct (IH Hr) as [l1 [l2 H']].\n      exists (h :: l1).\n      exists l2.\n      simpl.\n      rewrite <- H'.\n      reflexivity.\nQed.\n\nInductive repeats {X:Type} : list X -> Prop :=\n  | add_repeated    (l: list X) (x: X) (H: In x l):    repeats (x :: l)\n  | add_to_repeated (l: list X) (x: X) (H: repeats l): repeats (x :: l) \n.\n\n\nSearch \"<\".\n\n(* PeanoNat.Nat.nlt_0_r *)\nLemma nothing_less_0: forall n, n < 0 -> False.\nProof.\n  intros n H.\nAdmitted.\n\n\nDefinition contains_items {X: Type} (l2 l1: list X) := \n  (forall x : X, In x l1 -> In x l2).\n\n\nInductive uniques {X:Type} : list X -> Prop :=\n  | nil_unique : uniques []\n  | add_unique (l: list X) (x: X) (H: ~ In x l): uniques (x :: l)\n.\n\nLemma unique_shorter: forall {X: Type} (l1 l2: list X),\n  contains_items l2 l1 -> uniques l2 -> length l2 <= length l1.\nProof. Admitted.\n\nSearch (length ?l = 0 -> ?l = []).\n\n\nLemma remove_uniq_item: forall {X: Type} l (x: X), \n  ~(repeats l) -> In x l -> \n  exists l', ~ In x l' /\\ S (length l') = length l /\\ (~ repeats l') /\\ contains_items l l'.\nProof.\n  intros X l x Hnr Hin.\n  induction l as [| h t IH].\n  - simpl in Hin. exfalso. apply Hin.\n  - simpl in Hin.\n    destruct Hin as [Ehx | Hxint] eqn:Ehin.\n    + exists t.\n      split.\n      * intros Hxint.\n        rewrite <- Ehx in Hxint.\n        apply Hnr.\n        apply add_repeated.\n        apply Hxint.\n      * split.\n        ** reflexivity.\n        ** split.\n           *** intros Hrt. apply Hnr. apply add_to_repeated. apply Hrt.\n           *** unfold contains_items.\n               intros x' Hx'int. simpl.\n               right. apply Hx'int.\n    + assert (G: ~ repeats t). {\n        intros Hrt. apply Hnr. apply add_to_repeated. apply Hrt.\n      }\n      destruct (IH G Hxint) as [l' Hs].\n      exists (h :: l').\n      split.\n      * intros Hxinhl'. simpl in Hxinhl'.\n        destruct Hxinhl' as [Ehx | Hxinl'].\n        ** rewrite -> Ehx in Hnr.\n           apply Hnr. apply add_repeated. apply Hxint.\n        ** destruct Hs as [Hxninl' Q].\n           apply Hxninl'. apply Hxinl'.\n      * split.\n        ** simpl. \n           destruct Hs as [Q [Hlenl't W]].\n           rewrite <- Hlenl't.\n           reflexivity.\n        ** split.\n           *** intros Hrhl'.\n               remember (h :: l') as k eqn:Ek.\n               destruct Hrhl' as [dl' dh dG | dl' dh dG].\n               **** injection Ek as Ehdh Eldl.\n                    rewrite -> Ehdh in dG.\n                    rewrite -> Eldl in dG.\n                    destruct Hs as [_ [_ [_ Hci]]].\n                    unfold contains_items in Hci.\n                    apply Hnr.\n                    apply add_repeated.\n                    apply (Hci h dG).\n               **** injection Ek as Ehdh Eldl.\n                    rewrite -> Eldl in dG.\n                    destruct Hs as [_ [_ [Hnrl' _]]].\n                    apply Hnrl'. apply dG.\n           *** unfold contains_items.\n               intros x' Hinx'hl'.\n               simpl in Hinx'hl'.\n               simpl.\n               destruct Hinx'hl' as [Ehx' | Hx'int].\n               **** left. apply Ehx'.\n               **** right. destruct Hs as [_ [_ [_ Hci]]]. apply Hci. apply Hx'int.\nQed.\n\nLemma remove_item: forall {X: Type} l (x: X), \n  In x l -> \n  exists l', S (length l') = length l /\\ contains_items l l' /\\ (forall i : X, In i l -> (i = x) \\/ In i l').\nProof.\n  intros X l x Hxinl.\n  induction l as [| h t IH].\n  - simpl in Hxinl. exfalso. apply Hxinl.\n  - simpl in Hxinl.\n    destruct Hxinl as [Ehx | Hxint].\n    + exists t.\n      simpl. split.\n      * reflexivity.\n      * split.\n        ++ unfold contains_items. simpl.\n           intros j Hj. right. apply Hj.\n        ++ intros x' [Hx'l | Hx'r].\n            ** rewrite <- Hx'l.\n               left. apply Ehx.\n            ** right. apply Hx'r.\n    + destruct (IH Hxint) as [l' [Hlen [Hci Hcirev]]].\n      exists (h :: l').\n      split.\n      * simpl. rewrite -> Hlen. reflexivity.\n      * split.\n        ++ unfold contains_items. simpl.\n            intros x' [Geq | Gin].\n            +++ left. apply Geq.\n            +++ right. apply (Hci x' Gin).\n        ++ intros x' Hiinht.\n           destruct Hiinht as [Hx'h | Hx'int].\n           -- right. simpl. left. apply Hx'h.\n           -- apply (Hcirev x') in Hx'int.\n              destruct Hx'int as [Hx'intl | Hx'intr].\n              --- left. apply Hx'intl.\n              --- right. simpl. right. apply Hx'intr.\nQed.\n\n\n(*\nLemma same_items: forall {X: Type} (l1 l2: list X),\n  length l1 = length l2 -> \n  ~(repeats l1) -> \n  contains_items l2 l1 -> \n  contains_items l1 l2.\nProof.\n  intros X l1.\n  induction l1 as [| h t IH].\n  - intros l2 Hlen Hnr Hci.\n    assert (G: l2 = []). {\n      remember [] as k eqn: Ek.\n      destruct l2 as [| h' t' ].\n      + rewrite -> Ek. reflexivity.\n      + rewrite -> Ek in Hlen. simpl in Hlen. discriminate Hlen.\n    }\n    rewrite -> G in Hci.\n    rewrite -> G.\n    apply Hci.\n  - intros l2 Hlen Hnr Hci.\n    unfold contains_items.\n    intros x Hxl2.\n    simpl.\n    unfold contains_items in IH.\n    destruct l2 as [| l2h l2t].\n    + simpl in Hlen. discriminate Hlen.\n    + \n*)\n\nLemma step_contains_items:forall {X: Type} l (h: X) t,\n  contains_items l (h :: t) -> contains_items l t.\nProof.\n  intros X l h t.\n  unfold contains_items.\n  simpl.\n  intros H.\n  intros x H'.\n  apply (H x (or_intror H')).\nQed.\n\nDefinition excluded_middle := forall P : Prop, P \\/ ~P.\n\nLemma empty_nas_no_repeats: forall {X: Type}, repeats (@nil X) -> False.\nProof.\n  intros X H.\n  remember [] as k eqn:Ek.\n  destruct H as [l x H' | l x H'].\n  - discriminate Ek.\n  - discriminate Ek.\nQed.\n\nLemma qwe: forall {X: Type} (l1 l2: list X) (x: X), \n  length (x :: l1) = length l2 -> contains_items l2 (x :: l1) -> \n  exists l2', length l1 = length l2' /\\ contains_items l2' l1.\nProof.\nAdmitted.\n\nLemma tst: forall {X: Type} (l1 l2: list X) (x: X), \n  excluded_middle ->\n  length l1 = length l2 -> contains_items l2 (x :: l1) \n  -> repeats (x :: l1).\nProof.\n  intros X l1.\n  induction l1 as [| h t IH].\n  - intros l2 x EM Hlen Hci.\n    assert (G: l2 = []). {\n      simpl in Hlen.\n      destruct l2 as [| h' t'].\n      + reflexivity.\n      + simpl in Hlen. discriminate Hlen.\n    }\n    rewrite -> G in Hci.\n    unfold contains_items in Hci.\n    simpl in Hci.\n    exfalso. apply (Hci x).\n    left. reflexivity.\n  - intros l2 x EM Hlen Hci.\n    assert (G: In h l2). {\n      unfold contains_items in Hci.\n      apply Hci.\n      simpl. right. left. reflexivity.\n    }\n    assert (G1: repeats (x :: t)). {\n      destruct (remove_item l2 h G) as [l' [Hlen' [Hci' Hcirev]]].\n      apply (IH l' x EM).\n      + rewrite <- Hlen in Hlen'. simpl in Hlen'. injection Hlen' as Hlen'.\n        symmetry. apply Hlen'.\n      + unfold contains_items.\n        intros i Hiin.\n  (*TODO*)\nAdmitted.\n\nTheorem pigeonhole_principle: excluded_middle ->\n  forall (X:Type) (l1 l2: list X),\n  (forall x, In x l1 -> In x l2) ->\n  length l2 < length l1 ->\n  repeats l1.\nProof.\n  intros EM X l1. \n  induction l1 as [|x l1' IHl1'].\n  - intros l2 HIn HLen.\n    simpl in HLen.\n    exfalso.\n    apply (PeanoNat.Nat.nlt_0_r (length l2) HLen).\n  - intros l2 HIn HLen.\n    remember (length(x :: l1')) as k eqn: Ek.\n    destruct HLen as [| k' HLen'].\n    + simpl in Ek.\n      injection Ek as Ek.\n      symmetry in Ek.\n      apply (tst l1' l2 x EM Ek HIn).\n    + simpl in Ek.\n      injection Ek as Ek.\n      rewrite -> Ek in HLen'.\n      assert (G: repeats l1'). {\n        apply (IHl1' l2 (step_contains_items l2 x l1' HIn) HLen').\n      }\n      apply add_to_repeated.\n      apply G.\nQed.\n\nEnd PigeonHoles.\n\n\nEnd IndProp."}
{"text": "import Smt\n\ntheorem disjunctive_syllogism (p q : Prop) : p \u2228 q \u2192 \u00acp \u2192 q := by\n  smt\n"}
{"text": "(* Contribution to the Coq Library   V6.3 (July 1999)                    *)\n\n(****************************************************************************)\n(* This contribution was updated for Coq V5.10 by the COQ workgroup.        *)\n(* January 1995                                                             *)\n(****************************************************************************)\n(*                                drinker.v                                 *)\n(****************************************************************************)\n\n\nTheorem drinker's_theorem :\n (forall P : Prop, P \\/ ~ P) ->\n forall (U : Set) (x : U) (Q : U -> Prop),\n exists x : U, Q x -> forall x : U, Q x.\nintros Excluded_middle U x Q.\ngeneralize (Excluded_middle (exists x : U, ~ Q x)); intro h; elim h; intro H';\n clear h.\nelim H'; intros z E; clear H'.\nexists z; intro H'0.\nelim E; assumption.\n\nexists x; intros H'0 x0.\ngeneralize (Excluded_middle (Q x0)); intro h; elim h; intro H'1; clear h;\n auto.\nelim H'; exists x0; assumption.\nQed."}
{"text": "-- Print a nat using well-founded recursion\ndef natPrintAux (n : Nat) (sink : List Char) : List Char :=\n  if h0 : n < 10\n  then (n.digitChar :: sink)\n  else natPrintAux (n / 10) (Nat.digitChar (n % 10) :: sink)\ntermination_by' measure (fun \u27e8n, _\u27e9 => n)\ndecreasing_by sorry\n\n-- I meant to write `simp only [natPrintAux]`, but accidentally referenced the current theorem\ntheorem natPrintAux_eq (n : Nat) (sink : List Char) :\n        natPrintAux n sink = if n < 10 then (n.digitChar :: sink) else natPrintAux (n / 10) (Nat.digitChar (n % 10) :: sink) := by\n  simp only [natPrintAux_eq]\n"}
{"text": "Goal forall P Q, P <-> Q -> P -> Q.\nProof.\n  intros P Q H. Fail rewrite H.\nAbort.\n\nRequire Import List.\n\nGoal forall P Q, P <-> Q -> P -> Q.\nProof.\n  intros P Q H. rewrite H. easy.\nQed.\n"}
{"text": "(* Require Export Field_theory. *)\nRequire Import ZArith.\nOpen Scope Z_scope.\n\nGoal forall a b c : Z,\n  (a+b+c)^2 =\n  a * a + b^2 + c * c + 2 * a * b + 2 * a * c + 2 * b * c.\n  intros.\n  ring.\nQed."}
{"text": "[STATEMENT]\nlemma Limit_vid_on_in_Vset:\n  assumes \"Limit \\<alpha>\" and \"A \\<in>\\<^sub>\\<circ> Vset \\<alpha>\"\n  shows \"vid_on A \\<in>\\<^sub>\\<circ> Vset \\<alpha>\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. vid_on A \\<in>\\<^sub>\\<circ> Vset \\<alpha>\n[PROOF STEP]\nby\n    (\n      rule vbrelation.vbrelation_Limit_in_VsetI\n        [\n          OF vbrelation_vid_on assms(1) ,\n          unfolded vdomain_vid_on vrange_vid_on, OF assms(2,2)\n        ]\n    )"}
{"text": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n\n! This file was ported from Lean 3 source module algebraic_geometry.morphisms.quasi_separated\n! leanprover-community/mathlib commit d39590fc8728fbf6743249802486f8c91ffe07bc\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.AlgebraicGeometry.Morphisms.QuasiCompact\nimport Mathbin.Topology.QuasiSeparated\n\n/-!\n# Quasi-separated morphisms\n\nA morphism of schemes `f : X \u27f6 Y` is quasi-separated if the diagonal morphism `X \u27f6 X \u00d7[Y] X` is\nquasi-compact.\n\nA scheme is quasi-separated if the intersections of any two affine open sets is quasi-compact.\n(`algebraic_geometry.quasi_separated_space_iff_affine`)\n\nWe show that a morphism is quasi-separated if the preimage of every affine open is quasi-separated.\n\nWe also show that this property is local at the target,\nand is stable under compositions and base-changes.\n\n## Main result\n- `is_localization_basic_open_of_qcqs` (**Qcqs lemma**):\n  If `U` is qcqs, then `\u0393(X, D(f)) \u2243 \u0393(X, U)_f` for every `f : \u0393(X, U)`.\n\n-/\n\n\nnoncomputable section\n\nopen CategoryTheory CategoryTheory.Limits Opposite TopologicalSpace\n\nuniverse u\n\nopen AlgebraicGeometry\n\nnamespace AlgebraicGeometry\n\nvariable {X Y : Scheme.{u}} (f : X \u27f6 Y)\n\n/-- A morphism is `quasi_separated` if diagonal map is quasi-compact. -/\n@[mk_iff]\nclass QuasiSeparated (f : X \u27f6 Y) : Prop where\n  diagonalQuasiCompact : QuasiCompact (pullback.diagonal f)\n#align algebraic_geometry.quasi_separated AlgebraicGeometry.QuasiSeparated\n\n/-- The `affine_target_morphism_property` corresponding to `quasi_separated`, asserting that the\ndomain is a quasi-separated scheme. -/\ndef QuasiSeparated.affineProperty : AffineTargetMorphismProperty := fun X Y f _ =>\n  QuasiSeparatedSpace X.carrier\n#align algebraic_geometry.quasi_separated.affine_property AlgebraicGeometry.QuasiSeparated.affineProperty\n\ntheorem quasiSeparatedSpace_iff_affine (X : Scheme) :\n    QuasiSeparatedSpace X.carrier \u2194 \u2200 U V : X.affineOpens, IsCompact (U \u2229 V : Set X.carrier) :=\n  by\n  rw [quasiSeparatedSpace_iff]\n  constructor\n  \u00b7 intro H U V\n    exact H U V U.1.2 U.2.IsCompact V.1.2 V.2.IsCompact\n  \u00b7 intro H\n    suffices\n      \u2200 (U : opens X.carrier) (hU : IsCompact U.1) (V : opens X.carrier) (hV : IsCompact V.1),\n        IsCompact (U \u2293 V).1\n      by\n      intro U V hU hU' hV hV'\n      exact this \u27e8U, hU\u27e9 hU' \u27e8V, hV\u27e9 hV'\n    intro U hU V hV\n    apply compact_open_induction_on V hV\n    \u00b7 simp\n    \u00b7 intro S hS V hV\n      change IsCompact (U.1 \u2229 (S.1 \u222a V.1))\n      rw [Set.inter_union_distrib_left]\n      apply hV.union\n      clear hV\n      apply compact_open_induction_on U hU\n      \u00b7 simp\n      \u00b7 intro S hS W hW\n        change IsCompact ((S.1 \u222a W.1) \u2229 V.1)\n        rw [Set.union_inter_distrib_right]\n        apply hW.union\n        apply H\n#align algebraic_geometry.quasi_separated_space_iff_affine AlgebraicGeometry.quasiSeparatedSpace_iff_affine\n\ntheorem quasi_compact_affineProperty_iff_quasiSeparatedSpace {X Y : Scheme} [IsAffine Y]\n    (f : X \u27f6 Y) : QuasiCompact.affineProperty.diagonal f \u2194 QuasiSeparatedSpace X.carrier :=\n  by\n  delta affine_target_morphism_property.diagonal\n  rw [quasi_separated_space_iff_affine]\n  constructor\n  \u00b7 intro H U V\n    haveI : is_affine _ := U.2\n    haveI : is_affine _ := V.2\n    let g : pullback (X.of_restrict U.1.OpenEmbedding) (X.of_restrict V.1.OpenEmbedding) \u27f6 X :=\n      pullback.fst \u226b X.of_restrict _\n    have : is_open_immersion g := inferInstance\n    have e := Homeomorph.ofEmbedding _ this.base_open.to_embedding\n    rw [is_open_immersion.range_pullback_to_base_of_left] at e\n    erw [Subtype.range_coe, Subtype.range_coe] at e\n    rw [isCompact_iff_compactSpace]\n    exact @Homeomorph.compactSpace _ _ (H _ _) e\n  \u00b7 introv H h\u2081 h\u2082\n    skip\n    let g : pullback f\u2081 f\u2082 \u27f6 X := pullback.fst \u226b f\u2081\n    have : is_open_immersion g := inferInstance\n    have e := Homeomorph.ofEmbedding _ this.base_open.to_embedding\n    rw [is_open_immersion.range_pullback_to_base_of_left] at e\n    simp_rw [isCompact_iff_compactSpace] at H\n    exact\n      @Homeomorph.compactSpace _ _\n        (H \u27e8\u27e8_, h\u2081.base_open.open_range\u27e9, range_is_affine_open_of_open_immersion _\u27e9\n          \u27e8\u27e8_, h\u2082.base_open.open_range\u27e9, range_is_affine_open_of_open_immersion _\u27e9)\n        e.symm\n#align algebraic_geometry.quasi_compact_affine_property_iff_quasi_separated_space AlgebraicGeometry.quasi_compact_affineProperty_iff_quasiSeparatedSpace\n\ntheorem quasiSeparated_eq_diagonal_is_quasiCompact :\n    @QuasiSeparated = MorphismProperty.diagonal @QuasiCompact :=\n  by\n  ext\n  exact quasi_separated_iff _\n#align algebraic_geometry.quasi_separated_eq_diagonal_is_quasi_compact AlgebraicGeometry.quasiSeparated_eq_diagonal_is_quasiCompact\n\ntheorem quasi_compact_affineProperty_diagonal_eq :\n    QuasiCompact.affineProperty.diagonal = QuasiSeparated.affineProperty :=\n  by\n  ext\n  rw [quasi_compact_affine_property_iff_quasi_separated_space]\n  rfl\n#align algebraic_geometry.quasi_compact_affine_property_diagonal_eq AlgebraicGeometry.quasi_compact_affineProperty_diagonal_eq\n\ntheorem quasiSeparated_eq_affineProperty_diagonal :\n    @QuasiSeparated = targetAffineLocally QuasiCompact.affineProperty.diagonal :=\n  by\n  rw [quasi_separated_eq_diagonal_is_quasi_compact, quasi_compact_eq_affine_property]\n  exact\n    diagonal_target_affine_locally_eq_target_affine_locally _ quasi_compact.affine_property_is_local\n#align algebraic_geometry.quasi_separated_eq_affine_property_diagonal AlgebraicGeometry.quasiSeparated_eq_affineProperty_diagonal\n\ntheorem quasiSeparated_eq_affineProperty :\n    @QuasiSeparated = targetAffineLocally QuasiSeparated.affineProperty := by\n  rw [quasi_separated_eq_affine_property_diagonal, quasi_compact_affine_property_diagonal_eq]\n#align algebraic_geometry.quasi_separated_eq_affine_property AlgebraicGeometry.quasiSeparated_eq_affineProperty\n\ntheorem QuasiSeparated.affinePropertyIsLocal : QuasiSeparated.affineProperty.IsLocal :=\n  quasi_compact_affineProperty_diagonal_eq \u25b8 QuasiCompact.affinePropertyIsLocal.diagonal\n#align algebraic_geometry.quasi_separated.affine_property_is_local AlgebraicGeometry.QuasiSeparated.affinePropertyIsLocal\n\ninstance (priority := 900) quasiSeparatedOfMono {X Y : Scheme} (f : X \u27f6 Y) [Mono f] :\n    QuasiSeparated f :=\n  \u27e8inferInstance\u27e9\n#align algebraic_geometry.quasi_separated_of_mono AlgebraicGeometry.quasiSeparatedOfMono\n\ntheorem quasiSeparated_stableUnderComposition :\n    MorphismProperty.StableUnderComposition @QuasiSeparated :=\n  quasiSeparated_eq_diagonal_is_quasiCompact.symm \u25b8\n    quasiCompact_stableUnderComposition.diagonal quasiCompact_respectsIso\n      quasiCompact_stableUnderBaseChange\n#align algebraic_geometry.quasi_separated_stable_under_composition AlgebraicGeometry.quasiSeparated_stableUnderComposition\n\ntheorem quasiSeparated_stableUnderBaseChange :\n    MorphismProperty.StableUnderBaseChange @QuasiSeparated :=\n  quasiSeparated_eq_diagonal_is_quasiCompact.symm \u25b8\n    quasiCompact_stableUnderBaseChange.diagonal quasiCompact_respectsIso\n#align algebraic_geometry.quasi_separated_stable_under_base_change AlgebraicGeometry.quasiSeparated_stableUnderBaseChange\n\ninstance quasiSeparatedComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [QuasiSeparated f]\n    [QuasiSeparated g] : QuasiSeparated (f \u226b g) :=\n  quasiSeparated_stableUnderComposition f g inferInstance inferInstance\n#align algebraic_geometry.quasi_separated_comp AlgebraicGeometry.quasiSeparatedComp\n\ntheorem quasiSeparated_respectsIso : MorphismProperty.RespectsIso @QuasiSeparated :=\n  quasiSeparated_eq_diagonal_is_quasiCompact.symm \u25b8 quasiCompact_respectsIso.diagonal\n#align algebraic_geometry.quasi_separated_respects_iso AlgebraicGeometry.quasiSeparated_respectsIso\n\ntheorem QuasiSeparated.affine_openCover_tFAE {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    TFAE\n      [QuasiSeparated f,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y)(_ : \u2200 i, IsAffine (\ud835\udcb0.obj i)),\n          \u2200 i : \ud835\udcb0.J, QuasiSeparatedSpace (pullback f (\ud835\udcb0.map i)).carrier,\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (i : \ud835\udcb0.J),\n          QuasiSeparatedSpace (pullback f (\ud835\udcb0.map i)).carrier,\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsAffine U] [IsOpenImmersion g],\n          QuasiSeparatedSpace (pullback f g).carrier,\n        \u2203 (\ud835\udcb0 : Scheme.OpenCover.{u} Y)(_ : \u2200 i, IsAffine (\ud835\udcb0.obj i))(\ud835\udcb0' :\n          \u2200 i : \ud835\udcb0.J, Scheme.OpenCover.{u} (pullback f (\ud835\udcb0.map i)))(_ :\n          \u2200 i j, IsAffine ((\ud835\udcb0' i).obj j)),\n          \u2200 (i : \ud835\udcb0.J) (j k : (\ud835\udcb0' i).J),\n            CompactSpace (pullback ((\ud835\udcb0' i).map j) ((\ud835\udcb0' i).map k)).carrier] :=\n  by\n  have := quasi_compact.affine_property_is_local.diagonal_affine_open_cover_tfae f\n  simp_rw [\u2190 quasi_compact_eq_affine_property, \u2190 quasi_separated_eq_diagonal_is_quasi_compact,\n    quasi_compact_affine_property_diagonal_eq] at this\n  exact this\n#align algebraic_geometry.quasi_separated.affine_open_cover_tfae AlgebraicGeometry.QuasiSeparated.affine_openCover_tFAE\n\ntheorem QuasiSeparated.isLocalAtTarget : PropertyIsLocalAtTarget @QuasiSeparated :=\n  quasiSeparated_eq_affineProperty_diagonal.symm \u25b8\n    QuasiCompact.affinePropertyIsLocal.diagonal.targetAffineLocallyIsLocal\n#align algebraic_geometry.quasi_separated.is_local_at_target AlgebraicGeometry.QuasiSeparated.isLocalAtTarget\n\ntheorem QuasiSeparated.openCover_tFAE {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n    TFAE\n      [QuasiSeparated f,\n        \u2203 \ud835\udcb0 : Scheme.OpenCover.{u} Y,\n          \u2200 i : \ud835\udcb0.J, QuasiSeparated (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (i : \ud835\udcb0.J),\n          QuasiSeparated (pullback.snd : (\ud835\udcb0.pullbackCover f).obj i \u27f6 \ud835\udcb0.obj i),\n        \u2200 U : Opens Y.carrier, QuasiSeparated (f \u2223_ U),\n        \u2200 {U : Scheme} (g : U \u27f6 Y) [IsOpenImmersion g],\n          QuasiSeparated (pullback.snd : pullback f g \u27f6 _),\n        \u2203 (\u03b9 : Type u)(U : \u03b9 \u2192 Opens Y.carrier)(hU : sup\u1d62 U = \u22a4), \u2200 i, QuasiSeparated (f \u2223_ U i)] :=\n  QuasiSeparated.isLocalAtTarget.openCover_tFAE f\n#align algebraic_geometry.quasi_separated.open_cover_tfae AlgebraicGeometry.QuasiSeparated.openCover_tFAE\n\ntheorem quasiSeparated_over_affine_iff {X Y : Scheme} (f : X \u27f6 Y) [IsAffine Y] :\n    QuasiSeparated f \u2194 QuasiSeparatedSpace X.carrier := by\n  rw [quasi_separated_eq_affine_property,\n    quasi_separated.affine_property_is_local.affine_target_iff f, quasi_separated.affine_property]\n#align algebraic_geometry.quasi_separated_over_affine_iff AlgebraicGeometry.quasiSeparated_over_affine_iff\n\ntheorem quasiSeparatedSpace_iff_quasiSeparated (X : Scheme) :\n    QuasiSeparatedSpace X.carrier \u2194 QuasiSeparated (terminal.from X) :=\n  (quasiSeparated_over_affine_iff _).symm\n#align algebraic_geometry.quasi_separated_space_iff_quasi_separated AlgebraicGeometry.quasiSeparatedSpace_iff_quasiSeparated\n\ntheorem QuasiSeparated.affine_openCover_iff {X Y : Scheme.{u}} (\ud835\udcb0 : Scheme.OpenCover.{u} Y)\n    [\u2200 i, IsAffine (\ud835\udcb0.obj i)] (f : X \u27f6 Y) :\n    QuasiSeparated f \u2194 \u2200 i, QuasiSeparatedSpace (pullback f (\ud835\udcb0.map i)).carrier :=\n  by\n  rw [quasi_separated_eq_affine_property,\n    quasi_separated.affine_property_is_local.affine_open_cover_iff f \ud835\udcb0]\n  rfl\n#align algebraic_geometry.quasi_separated.affine_open_cover_iff AlgebraicGeometry.QuasiSeparated.affine_openCover_iff\n\ntheorem QuasiSeparated.openCover_iff {X Y : Scheme.{u}} (\ud835\udcb0 : Scheme.OpenCover.{u} Y) (f : X \u27f6 Y) :\n    QuasiSeparated f \u2194 \u2200 i, QuasiSeparated (pullback.snd : pullback f (\ud835\udcb0.map i) \u27f6 _) :=\n  QuasiSeparated.isLocalAtTarget.openCover_iff f \ud835\udcb0\n#align algebraic_geometry.quasi_separated.open_cover_iff AlgebraicGeometry.QuasiSeparated.openCover_iff\n\ninstance {X Y S : Scheme} (f : X \u27f6 S) (g : Y \u27f6 S) [QuasiSeparated g] :\n    QuasiSeparated (pullback.fst : pullback f g \u27f6 X) :=\n  quasiSeparated_stableUnderBaseChange.fst f g inferInstance\n\ninstance {X Y S : Scheme} (f : X \u27f6 S) (g : Y \u27f6 S) [QuasiSeparated f] :\n    QuasiSeparated (pullback.snd : pullback f g \u27f6 Y) :=\n  quasiSeparated_stableUnderBaseChange.snd f g inferInstance\n\ninstance {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [QuasiSeparated f] [QuasiSeparated g] :\n    QuasiSeparated (f \u226b g) :=\n  quasiSeparated_stableUnderComposition f g inferInstance inferInstance\n\ntheorem quasiSeparatedSpace_of_quasiSeparated {X Y : Scheme} (f : X \u27f6 Y)\n    [hY : QuasiSeparatedSpace Y.carrier] [QuasiSeparated f] : QuasiSeparatedSpace X.carrier :=\n  by\n  rw [quasi_separated_space_iff_quasi_separated] at hY\u22a2\n  have : f \u226b terminal.from Y = terminal.from X := terminal_is_terminal.hom_ext _ _\n  rw [\u2190 this]\n  skip; infer_instance\n#align algebraic_geometry.quasi_separated_space_of_quasi_separated AlgebraicGeometry.quasiSeparatedSpace_of_quasiSeparated\n\ninstance quasiSeparatedSpace_of_isAffine (X : Scheme) [IsAffine X] :\n    QuasiSeparatedSpace X.carrier := by\n  constructor\n  intro U V hU hU' hV hV'\n  obtain \u27e8s, hs, e\u27e9 := (is_compact_open_iff_eq_basic_open_union _).mp \u27e8hU', hU\u27e9\n  obtain \u27e8s', hs', e'\u27e9 := (is_compact_open_iff_eq_basic_open_union _).mp \u27e8hV', hV\u27e9\n  rw [e, e', Set.union\u1d62\u2082_inter]\n  simp_rw [Set.inter_union\u1d62\u2082]\n  apply hs.is_compact_bUnion\n  \u00b7 intro i hi\n    apply hs'.is_compact_bUnion\n    intro i' hi'\n    change IsCompact (X.basic_open i \u2293 X.basic_open i').1\n    rw [\u2190 Scheme.basic_open_mul]\n    exact ((top_is_affine_open _).basicOpen_is_affine _).IsCompact\n#align algebraic_geometry.quasi_separated_space_of_is_affine AlgebraicGeometry.quasiSeparatedSpace_of_isAffine\n\ntheorem IsAffineOpen.isQuasiSeparated {X : Scheme} {U : Opens X.carrier} (hU : IsAffineOpen U) :\n    IsQuasiSeparated (U : Set X.carrier) :=\n  by\n  rw [isQuasiSeparated_iff_quasiSeparatedSpace]\n  exacts[@AlgebraicGeometry.quasiSeparatedSpace_of_isAffine _ hU, U.is_open]\n#align algebraic_geometry.is_affine_open.is_quasi_separated AlgebraicGeometry.IsAffineOpen.isQuasiSeparated\n\ntheorem quasiSeparatedOfComp {X Y Z : Scheme} (f : X \u27f6 Y) (g : Y \u27f6 Z) [H : QuasiSeparated (f \u226b g)] :\n    QuasiSeparated f :=\n  by\n  rw [(quasi_separated.affine_open_cover_tfae f).out 0 1]\n  rw [(quasi_separated.affine_open_cover_tfae (f \u226b g)).out 0 2] at H\n  use (Z.affine_cover.pullback_cover g).bind fun x => Scheme.affine_cover _\n  constructor;\n  \u00b7 intro i\n    dsimp\n    infer_instance\n  rintro \u27e8i, j\u27e9; dsimp at *\n  specialize H _ i\n  refine' @quasi_separated_space_of_quasi_separated _ H _\n  \u00b7\n    exact\n      pullback.map _ _ _ _ (\ud835\udfd9 _) _ _ (by simp) (category.comp_id _) \u226b\n        (pullback_right_pullback_fst_iso g (Z.affine_cover.map i) f).Hom\n  \u00b7 apply AlgebraicGeometry.quasiSeparatedOfMono\n#align algebraic_geometry.quasi_separated_of_comp AlgebraicGeometry.quasiSeparatedOfComp\n\ntheorem exists_eq_pow_mul_of_isAffineOpen (X : Scheme) (U : Opens X.carrier) (hU : IsAffineOpen U)\n    (f : X.Presheaf.obj (op U)) (x : X.Presheaf.obj (op <| X.basicOpen f)) :\n    \u2203 (n : \u2115)(y : X.Presheaf.obj (op U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x :=\n  by\n  have := (is_localization_basic_open hU f).2\n  obtain \u27e8\u27e8y, _, n, rfl\u27e9, d\u27e9 := this x\n  use n, y\n  delta TopCat.Presheaf.restrictOpen TopCat.Presheaf.restrict\n  simpa [mul_comm x] using d.symm\n#align algebraic_geometry.exists_eq_pow_mul_of_is_affine_open AlgebraicGeometry.exists_eq_pow_mul_of_isAffineOpen\n\ntheorem exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux (X : Scheme)\n    (S : X.affineOpens) (U\u2081 U\u2082 : Opens X.carrier) {n\u2081 n\u2082 : \u2115} {y\u2081 : X.Presheaf.obj (op U\u2081)}\n    {y\u2082 : X.Presheaf.obj (op U\u2082)} {f : X.Presheaf.obj (op <| U\u2081 \u2294 U\u2082)}\n    {x : X.Presheaf.obj (op <| X.basicOpen f)} (h\u2081 : S.1 \u2264 U\u2081) (h\u2082 : S.1 \u2264 U\u2082)\n    (e\u2081 :\n      X.Presheaf.map\n          (homOfLE <| X.basicOpen_le (X.Presheaf.map (homOfLE le_sup_left).op f) : _ \u27f6 U\u2081).op y\u2081 =\n        X.Presheaf.map\n              (homOfLE\n                  (by\n                    erw [X.basic_open_res]\n                    exact inf_le_left)).op\n              (X.Presheaf.map (homOfLE le_sup_left).op f) ^\n            n\u2081 *\n          (X.Presheaf.map\n              (homOfLE\n                  (by\n                    erw [X.basic_open_res]\n                    exact inf_le_right)).op)\n            x)\n    (e\u2082 :\n      X.Presheaf.map\n          (homOfLE <| X.basicOpen_le (X.Presheaf.map (homOfLE le_sup_right).op f) : _ \u27f6 U\u2082).op y\u2082 =\n        X.Presheaf.map\n              (homOfLE\n                  (by\n                    rw [X.basic_open_res]\n                    exact inf_le_left)).op\n              (X.Presheaf.map (homOfLE le_sup_right).op f) ^\n            n\u2082 *\n          (X.Presheaf.map\n              (homOfLE\n                  (by\n                    rw [X.basic_open_res]\n                    exact inf_le_right)).op)\n            x) :\n    \u2203 n : \u2115,\n      X.Presheaf.map (homOfLE <| h\u2081).op\n          (X.Presheaf.map (homOfLE le_sup_left).op f ^ (n + n\u2082) * y\u2081) =\n        X.Presheaf.map (homOfLE <| h\u2082).op\n          (X.Presheaf.map (homOfLE le_sup_right).op f ^ (n + n\u2081) * y\u2082) :=\n  by\n  have :=\n    is_localization_basic_open S.2 (X.presheaf.map (hom_of_le <| le_trans h\u2081 le_sup_left).op f)\n  obtain \u27e8\u27e8_, n, rfl\u27e9, e\u27e9 :=\n    (@IsLocalization.eq_iff_exists _ _ _ _ _ _ this\n          (X.presheaf.map (hom_of_le <| h\u2081).op\n            (X.presheaf.map (hom_of_le le_sup_left).op f ^ n\u2082 * y\u2081))\n          (X.presheaf.map (hom_of_le <| h\u2082).op\n            (X.presheaf.map (hom_of_le le_sup_right).op f ^ n\u2081 * y\u2082))).mp\n      _\n  swap\n  \u00b7 simp only [map_pow, RingHom.algebraMap_toAlgebra, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190\n      op_comp, hom_of_le_comp]\n    have h\u2083 : X.basic_open ((X.presheaf.map (hom_of_le (h\u2081.trans le_sup_left)).op) f) \u2264 S.val := by\n      simpa only [X.basic_open_res] using inf_le_left\n    trans\n      X.presheaf.map (hom_of_le <| h\u2083.trans <| h\u2081.trans le_sup_left).op f ^ (n\u2082 + n\u2081) *\n        X.presheaf.map (hom_of_le <| (X.basic_open_res f _).trans_le inf_le_right).op x\n    \u00b7 rw [pow_add, mul_assoc]\n      congr 1\n      convert congr_arg (X.presheaf.map (hom_of_le _).op) e\u2081\n      \u00b7 simp only [map_pow, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190 op_comp]\n        congr\n      \u00b7 simp only [map_pow, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190 op_comp]\n        congr\n      \u00b7 rw [X.basic_open_res, X.basic_open_res]\n        rintro x \u27e8H\u2081, H\u2082\u27e9\n        exact \u27e8h\u2081 H\u2081, H\u2082\u27e9\n    \u00b7 rw [add_comm, pow_add, mul_assoc]\n      congr 1\n      convert congr_arg (X.presheaf.map (hom_of_le _).op) e\u2082.symm\n      \u00b7 simp only [map_pow, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190 op_comp]\n        congr\n      \u00b7 simp only [map_pow, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190 op_comp]\n        congr\n      \u00b7 simp only [X.basic_open_res]\n        rintro x \u27e8H\u2081, H\u2082\u27e9\n        exact \u27e8h\u2082 H\u2081, H\u2082\u27e9\n  use n\n  simp only [pow_add, map_pow, map_mul, \u2190 comp_apply, \u2190 mul_assoc, \u2190 functor.map_comp,\n    Subtype.coe_mk] at e\u22a2\n  exact e\n#align algebraic_geometry.exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux AlgebraicGeometry.exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux\n\ntheorem exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated (X : Scheme) (U : Opens X.carrier)\n    (hU : IsCompact U.1) (hU' : IsQuasiSeparated U.1) (f : X.Presheaf.obj (op U))\n    (x : X.Presheaf.obj (op <| X.basicOpen f)) :\n    \u2203 (n : \u2115)(y : X.Presheaf.obj (op U)), y |_ X.basicOpen f = (f |_ X.basicOpen f) ^ n * x :=\n  by\n  delta TopCat.Presheaf.restrictOpen TopCat.Presheaf.restrict\n  revert hU' f x\n  apply compact_open_induction_on U hU\n  \u00b7 intro hU' f x\n    use 0, f\n    refine'\n      @Subsingleton.elim\n        (CommRingCat.subsingleton_of_isTerminal (X.sheaf.is_terminal_of_eq_empty _)) _ _\n    erw [eq_bot_iff]\n    exact X.basic_open_le f\n  \u00b7 -- Given `f : \ud835\udcaa(S \u222a U), x : \ud835\udcaa(X_f)`, we need to show that `f ^ n * x` is the restriction of\n    -- some `y : \ud835\udcaa(S \u222a U)` for some `n : \u2115`.\n    intro S hS U hU hSU f x\n    -- We know that such `y\u2081, n\u2081` exists on `S` by the induction hypothesis.\n    obtain \u27e8n\u2081, y\u2081, hy\u2081\u27e9 :=\n      hU (hSU.of_subset <| Set.subset_union_left _ _) (X.presheaf.map (hom_of_le le_sup_left).op f)\n        (X.presheaf.map (hom_of_le _).op x)\n    swap\n    \u00b7 rw [X.basic_open_res]\n      exact inf_le_right\n    -- We know that such `y\u2082, n\u2082` exists on `U` since `U` is affine.\n    obtain \u27e8n\u2082, y\u2082, hy\u2082\u27e9 :=\n      exists_eq_pow_mul_of_is_affine_open X _ U.2 (X.presheaf.map (hom_of_le le_sup_right).op f)\n        (X.presheaf.map (hom_of_le _).op x)\n    delta TopCat.Presheaf.restrictOpen TopCat.Presheaf.restrict at hy\u2082\n    swap\n    \u00b7 rw [X.basic_open_res]\n      exact inf_le_right\n    -- Since `S \u222a U` is quasi-separated, `S \u2229 U` can be covered by finite affine opens.\n    obtain \u27e8s, hs', hs\u27e9 :=\n      (is_compact_open_iff_eq_finset_affine_union _).mp\n        \u27e8hSU _ _ (Set.subset_union_left _ _) S.2 hS (Set.subset_union_right _ _) U.1.2\n            U.2.IsCompact,\n          (S \u2293 U.1).2\u27e9\n    haveI := hs'.to_subtype\n    cases nonempty_fintype s\n    replace hs : S \u2293 U.1 = sup\u1d62 fun i : s => (i : opens X.carrier) :=\n      by\n      ext1\n      simpa using hs\n    have hs\u2081 : \u2200 i : s, i.1.1 \u2264 S := by\n      intro i\n      change (i : opens X.carrier) \u2264 S\n      refine' le_trans _ inf_le_left\n      use U.1\n      erw [hs]\n      exact le_sup\u1d62 _ _\n    have hs\u2082 : \u2200 i : s, i.1.1 \u2264 U.1 := by\n      intro i\n      change (i : opens X.carrier) \u2264 U\n      refine' le_trans _ inf_le_right\n      use S\n      erw [hs]\n      exact le_sup\u1d62 _ _\n    -- On each affine open in the intersection, we have `f ^ (n + n\u2082) * y\u2081 = f ^ (n + n\u2081) * y\u2082`\n    -- for some `n` since `f ^ n\u2082 * y\u2081 = f ^ (n\u2081 + n\u2082) * x = f ^ n\u2081 * y\u2082` on `X_f`.\n    have :\n      \u2200 i : s,\n        \u2203 n : \u2115,\n          X.presheaf.map (hom_of_le <| hs\u2081 i).op\n              (X.presheaf.map (hom_of_le le_sup_left).op f ^ (n + n\u2082) * y\u2081) =\n            X.presheaf.map (hom_of_le <| hs\u2082 i).op\n              (X.presheaf.map (hom_of_le le_sup_right).op f ^ (n + n\u2081) * y\u2082) :=\n      by\n      intro i\n      exact\n        exists_eq_pow_mul_of_is_compact_of_quasi_separated_space_aux X i.1 S U (hs\u2081 i) (hs\u2082 i) hy\u2081\n          hy\u2082\n    choose n hn using this\n    -- We can thus choose a big enough `n` such that `f ^ (n + n\u2082) * y\u2081 = f ^ (n + n\u2081) * y\u2082`\n    -- on `S \u2229 U`.\n    have :\n      X.presheaf.map (hom_of_le <| inf_le_left).op\n          (X.presheaf.map (hom_of_le le_sup_left).op f ^ (finset.univ.sup n + n\u2082) * y\u2081) =\n        X.presheaf.map (hom_of_le <| inf_le_right).op\n          (X.presheaf.map (hom_of_le le_sup_right).op f ^ (finset.univ.sup n + n\u2081) * y\u2082) :=\n      by\n      fapply X.sheaf.eq_of_locally_eq' fun i : s => i.1.1\n      \u00b7 refine' fun i => hom_of_le _\n        erw [hs]\n        exact le_sup\u1d62 _ _\n      \u00b7 exact le_of_eq hs\n      \u00b7 intro i\n        replace hn :=\n          congr_arg\n            (fun x =>\n              X.presheaf.map (hom_of_le (le_trans (hs\u2081 i) le_sup_left)).op f ^\n                  (finset.univ.sup n - n i) *\n                x)\n            (hn i)\n        dsimp only at hn\n        delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [\u2190 map_pow, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190 op_comp, \u2190 mul_assoc] at\n          hn\u22a2\n        erw [\u2190 map_mul, \u2190 map_mul] at hn\n        rw [\u2190 pow_add, \u2190 pow_add, \u2190 add_assoc, \u2190 add_assoc, tsub_add_cancel_of_le] at hn\n        convert hn\n        exact Finset.le_sup (Finset.mem_univ _)\n    use finset.univ.sup n + n\u2081 + n\u2082\n    -- By the sheaf condition, since `f ^ (n + n\u2082) * y\u2081 = f ^ (n + n\u2081) * y\u2082`, it can be glued into\n    -- the desired section on `S \u222a U`.\n    use (X.sheaf.obj_sup_iso_prod_eq_locus S U.1).inv \u27e8\u27e8_ * _, _ * _\u27e9, this\u27e9\n    refine'\n      X.sheaf.eq_of_locally_eq\u2082\n        (hom_of_le (_ : X.basic_open (X.presheaf.map (hom_of_le le_sup_left).op f) \u2264 _))\n        (hom_of_le (_ : X.basic_open (X.presheaf.map (hom_of_le le_sup_right).op f) \u2264 _)) _ _ _ _ _\n    \u00b7 rw [X.basic_open_res]\n      exact inf_le_right\n    \u00b7 rw [X.basic_open_res]\n      exact inf_le_right\n    \u00b7 rw [X.basic_open_res, X.basic_open_res]\n      erw [\u2190 inf_sup_right]\n      refine' le_inf_iff.mpr \u27e8X.basic_open_le f, le_of_eq rfl\u27e9\n    \u00b7 convert congr_arg (X.presheaf.map (hom_of_le _).op)\n          (X.sheaf.obj_sup_iso_prod_eq_locus_inv_fst S U.1 \u27e8\u27e8_ * _, _ * _\u27e9, this\u27e9) using 1\n      \u00b7 delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [\u2190 comp_apply (X.presheaf.map _) (X.presheaf.map _), \u2190 functor.map_comp, \u2190\n          op_comp]\n        congr\n      \u00b7 delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [map_pow, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190 op_comp, mul_assoc,\n          pow_add]\n        erw [hy\u2081]\n        congr 1\n        rw [\u2190 mul_assoc, \u2190 mul_assoc]\n        congr 1\n        rw [mul_comm, \u2190 comp_apply, \u2190 functor.map_comp]\n        congr\n    \u00b7 convert congr_arg (X.presheaf.map (hom_of_le _).op)\n          (X.sheaf.obj_sup_iso_prod_eq_locus_inv_snd S U.1 \u27e8\u27e8_ * _, _ * _\u27e9, this\u27e9) using 1\n      \u00b7 delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [\u2190 comp_apply (X.presheaf.map _) (X.presheaf.map _), \u2190 functor.map_comp, \u2190\n          op_comp]\n        congr\n      \u00b7 delta Scheme.sheaf SheafedSpace.sheaf\n        simp only [map_pow, map_mul, \u2190 comp_apply, \u2190 functor.map_comp, \u2190 op_comp, mul_assoc,\n          pow_add]\n        erw [hy\u2082]\n        rw [\u2190 comp_apply, \u2190 functor.map_comp]\n        congr\n#align algebraic_geometry.exists_eq_pow_mul_of_is_compact_of_is_quasi_separated AlgebraicGeometry.exists_eq_pow_mul_of_isCompact_of_isQuasiSeparated\n\n/-- If `U` is qcqs, then `\u0393(X, D(f)) \u2243 \u0393(X, U)_f` for every `f : \u0393(X, U)`.\nThis is known as the **Qcqs lemma** in [R. Vakil, *The rising sea*][RisingSea]. -/\ntheorem is_localization_basicOpen_of_qcqs {X : Scheme} {U : Opens X.carrier} (hU : IsCompact U.1)\n    (hU' : IsQuasiSeparated U.1) (f : X.Presheaf.obj (op U)) :\n    IsLocalization.Away f (X.Presheaf.obj (op <| X.basicOpen f)) :=\n  by\n  constructor\n  \u00b7 rintro \u27e8_, n, rfl\u27e9\n    simp only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra]\n    exact IsUnit.pow _ (RingedSpace.is_unit_res_basic_open _ f)\n  \u00b7 intro z\n    obtain \u27e8n, y, e\u27e9 := exists_eq_pow_mul_of_is_compact_of_is_quasi_separated X U hU hU' f z\n    refine' \u27e8\u27e8y, _, n, rfl\u27e9, _\u27e9\n    simpa only [map_pow, Subtype.coe_mk, RingHom.algebraMap_toAlgebra, mul_comm z] using e.symm\n  \u00b7 intro x y\n    rw [\u2190 sub_eq_zero, \u2190 map_sub, RingHom.algebraMap_toAlgebra]\n    simp_rw [\u2190 @sub_eq_zero _ _ (_ * x) (_ * y), \u2190 mul_sub]\n    generalize x - y = z\n    constructor\n    \u00b7 intro H\n      obtain \u27e8n, e\u27e9 := exists_pow_mul_eq_zero_of_res_basic_open_eq_zero_of_is_compact X hU _ _ H\n      refine' \u27e8\u27e8_, n, rfl\u27e9, _\u27e9\n      simpa [mul_comm z] using e\n    \u00b7 rintro \u27e8\u27e8_, n, rfl\u27e9, e : f ^ n * z = 0\u27e9\n      rw [\u2190 ((RingedSpace.is_unit_res_basic_open _ f).pow n).mul_right_inj, MulZeroClass.mul_zero, \u2190\n        map_pow, \u2190 map_mul, e, map_zero]\n#align algebraic_geometry.is_localization_basic_open_of_qcqs AlgebraicGeometry.is_localization_basicOpen_of_qcqs\n\nend AlgebraicGeometry\n\n"}
{"text": "/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n\n! This file was ported from Lean 3 source module analysis.normed_space.star.spectrum\n! leanprover-community/mathlib commit 1e3201306d4d9eb1fd54c60d7c4510ad5126f6f9\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Analysis.NormedSpace.Star.Basic\nimport Mathbin.Analysis.NormedSpace.Spectrum\nimport Mathbin.Analysis.NormedSpace.Star.Exponential\nimport Mathbin.Analysis.SpecialFunctions.Exponential\nimport Mathbin.Algebra.Star.StarAlgHom\n\n/-! # Spectral properties in C\u22c6-algebras\nIn this file, we establish various properties related to the spectrum of elements in C\u22c6-algebras.\n-/\n\n\n-- mathport name: \u00abexpr \u22c6\u00bb\nlocal postfix:max \"\u22c6\" => star\n\nsection\n\nopen Topology ENNReal\n\nopen Filter ENNReal spectrum CstarRing\n\nsection UnitarySpectrum\n\nvariable {\ud835\udd5c : Type _} [NormedField \ud835\udd5c] {E : Type _} [NormedRing E] [StarRing E] [CstarRing E]\n  [NormedAlgebra \ud835\udd5c E] [CompleteSpace E]\n\ntheorem unitary.spectrum_subset_circle (u : unitary E) : spectrum \ud835\udd5c (u : E) \u2286 Metric.sphere 0 1 :=\n  by\n  nontriviality E\n  refine' fun k hk => mem_sphere_zero_iff_norm.mpr (le_antisymm _ _)\n  \u00b7 simpa only [CstarRing.norm_coe_unitary u] using norm_le_norm_of_mem hk\n  \u00b7 rw [\u2190 unitary.coe_toUnits_apply u] at hk\n    have hnk := ne_zero_of_mem_of_unit hk\n    rw [\u2190 inv_inv (unitary.toUnits u), \u2190 spectrum.map_inv, Set.mem_inv] at hk\n    have : \u2016k\u2016\u207b\u00b9 \u2264 \u2016\u2191(unitary.toUnits u)\u207b\u00b9\u2016\n    simpa only [norm_inv] using norm_le_norm_of_mem hk\n    simpa using inv_le_of_inv_le (norm_pos_iff.mpr hnk) this\n#align unitary.spectrum_subset_circle unitary.spectrum_subset_circle\n\ntheorem spectrum.subset_circle_of_unitary {u : E} (h : u \u2208 unitary E) :\n    spectrum \ud835\udd5c u \u2286 Metric.sphere 0 1 :=\n  unitary.spectrum_subset_circle \u27e8u, h\u27e9\n#align spectrum.subset_circle_of_unitary spectrum.subset_circle_of_unitary\n\nend UnitarySpectrum\n\nsection ComplexScalars\n\nopen Complex\n\nvariable {A : Type _} [NormedRing A] [NormedAlgebra \u2102 A] [CompleteSpace A] [StarRing A]\n  [CstarRing A]\n\n-- mathport name: \u00abexpr\u2191\u2090\u00bb\nlocal notation \"\u2191\u2090\" => algebraMap \u2102 A\n\ntheorem IsSelfAdjoint.spectralRadius_eq_nnnorm {a : A} (ha : IsSelfAdjoint a) :\n    spectralRadius \u2102 a = \u2016a\u2016\u208a :=\n  by\n  have hconst : tendsto (fun n : \u2115 => (\u2016a\u2016\u208a : \u211d\u22650\u221e)) at_top _ := tendsto_const_nhds\n  refine' tendsto_nhds_unique _ hconst\n  convert(spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius (a : A)).comp\n      (Nat.tendsto_pow_atTop_atTop_of_one_lt one_lt_two)\n  refine' funext fun n => _\n  rw [Function.comp_apply, ha.nnnorm_pow_two_pow, ENNReal.coe_pow, \u2190 rpow_nat_cast, \u2190 rpow_mul]\n  simp\n#align is_self_adjoint.spectral_radius_eq_nnnorm IsSelfAdjoint.spectralRadius_eq_nnnorm\n\ntheorem IsStarNormal.spectralRadius_eq_nnnorm (a : A) [IsStarNormal a] :\n    spectralRadius \u2102 a = \u2016a\u2016\u208a :=\n  by\n  refine' (ENNReal.pow_strictMono two_ne_zero).Injective _\n  have heq :\n    (fun n : \u2115 => (\u2016(a\u22c6 * a) ^ n\u2016\u208a ^ (1 / n : \u211d) : \u211d\u22650\u221e)) =\n      (fun x => x ^ 2) \u2218 fun n : \u2115 => (\u2016a ^ n\u2016\u208a ^ (1 / n : \u211d) : \u211d\u22650\u221e) :=\n    by\n    funext\n    rw [Function.comp_apply, \u2190 rpow_nat_cast, \u2190 rpow_mul, mul_comm, rpow_mul, rpow_nat_cast, \u2190\n      coe_pow, sq, \u2190 nnnorm_star_mul_self, Commute.mul_pow (star_comm_self' a), star_pow]\n  have h\u2082 :=\n    ((ENNReal.continuous_pow 2).Tendsto (spectralRadius \u2102 a)).comp\n      (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectralRadius a)\n  rw [\u2190 HEq] at h\u2082\n  convert tendsto_nhds_unique h\u2082 (pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius (a\u22c6 * a))\n  rw [(IsSelfAdjoint.star_mul_self a).spectralRadius_eq_nnnorm, sq, nnnorm_star_mul_self, coe_mul]\n#align is_star_normal.spectral_radius_eq_nnnorm IsStarNormal.spectralRadius_eq_nnnorm\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem IsSelfAdjoint.mem_spectrum_eq_re [StarModule \u2102 A] {a : A} (ha : IsSelfAdjoint a) {z : \u2102}\n    (hz : z \u2208 spectrum \u2102 a) : z = z.re :=\n  by\n  have hu := exp_mem_unitary_of_mem_skewAdjoint \u2102 (ha.smul_mem_skew_adjoint conj_I)\n  let Iu := Units.mk0 I I_ne_zero\n  have : exp \u2102 (I \u2022 z) \u2208 spectrum \u2102 (exp \u2102 (I \u2022 a)) := by\n    simpa only [Units.smul_def, Units.val_mk0] using\n      spectrum.exp_mem_exp (Iu \u2022 a) (smul_mem_smul_iff.mpr hz)\n  exact\n    Complex.ext (of_real_re _)\n      (by\n        simpa only [\u2190 Complex.exp_eq_exp_\u2102, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,\n          Real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero] using\n          spectrum.subset_circle_of_unitary hu this)\n#align is_self_adjoint.mem_spectrum_eq_re IsSelfAdjoint.mem_spectrum_eq_re\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem selfAdjoint.mem_spectrum_eq_re [StarModule \u2102 A] (a : selfAdjoint A) {z : \u2102}\n    (hz : z \u2208 spectrum \u2102 (a : A)) : z = z.re :=\n  a.Prop.mem_spectrum_eq_re hz\n#align self_adjoint.mem_spectrum_eq_re selfAdjoint.mem_spectrum_eq_re\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem IsSelfAdjoint.coe_re_map_spectrum [StarModule \u2102 A] {a : A} (ha : IsSelfAdjoint a) :\n    spectrum \u2102 a = (coe \u2218 re '' spectrum \u2102 a : Set \u2102) :=\n  le_antisymm (fun z hz => \u27e8z, hz, (ha.mem_spectrum_eq_re hz).symm\u27e9) fun z =>\n    by\n    rintro \u27e8z, hz, rfl\u27e9\n    simpa only [(ha.mem_spectrum_eq_re hz).symm, Function.comp_apply] using hz\n#align is_self_adjoint.coe_re_map_spectrum IsSelfAdjoint.coe_re_map_spectrum\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem selfAdjoint.coe_re_map_spectrum [StarModule \u2102 A] (a : selfAdjoint A) :\n    spectrum \u2102 (a : A) = (coe \u2218 re '' spectrum \u2102 (a : A) : Set \u2102) :=\n  a.property.coe_re_map_spectrum\n#align self_adjoint.coe_re_map_spectrum selfAdjoint.coe_re_map_spectrum\n\nend ComplexScalars\n\nnamespace StarAlgHom\n\nvariable {F A B : Type _} [NormedRing A] [NormedAlgebra \u2102 A] [CompleteSpace A] [StarRing A]\n  [CstarRing A] [NormedRing B] [NormedAlgebra \u2102 B] [CompleteSpace B] [StarRing B] [CstarRing B]\n  [hF : StarAlgHomClass F \u2102 A B] (\u03c6 : F)\n\ninclude hF\n\n/-- A star algebra homomorphism of complex C\u22c6-algebras is norm contractive. -/\ntheorem nnnorm_apply_le (a : A) : \u2016(\u03c6 a : B)\u2016\u208a \u2264 \u2016a\u2016\u208a :=\n  by\n  suffices \u2200 s : A, IsSelfAdjoint s \u2192 \u2016\u03c6 s\u2016\u208a \u2264 \u2016s\u2016\u208a by\n    exact\n      nonneg_le_nonneg_of_sq_le_sq zero_le'\n        (by\n          simpa only [nnnorm_star_mul_self, map_star, map_mul] using\n            this _ (IsSelfAdjoint.star_mul_self a))\n  \u00b7 intro s hs\n    simpa only [hs.spectral_radius_eq_nnnorm, (hs.star_hom_apply \u03c6).spectralRadius_eq_nnnorm,\n      coe_le_coe] using\n      show spectralRadius \u2102 (\u03c6 s) \u2264 spectralRadius \u2102 s from\n        sup\u1d62_le_sup\u1d62_of_subset (AlgHom.spectrum_apply_subset \u03c6 s)\n#align star_alg_hom.nnnorm_apply_le StarAlgHom.nnnorm_apply_le\n\n/-- A star algebra homomorphism of complex C\u22c6-algebras is norm contractive. -/\ntheorem norm_apply_le (a : A) : \u2016(\u03c6 a : B)\u2016 \u2264 \u2016a\u2016 :=\n  nnnorm_apply_le \u03c6 a\n#align star_alg_hom.norm_apply_le StarAlgHom.norm_apply_le\n\n/-- Star algebra homomorphisms between C\u22c6-algebras are continuous linear maps.\nSee note [lower instance priority] -/\nnoncomputable instance (priority := 100) : ContinuousLinearMapClass F \u2102 A B :=\n  { AlgHomClass.linearMapClass with\n    map_continuous := fun \u03c6 =>\n      AddMonoidHomClass.continuous_of_bound \u03c6 1 (by simpa only [one_mul] using nnnorm_apply_le \u03c6) }\n\nend StarAlgHom\n\nend\n\nnamespace WeakDual\n\nopen ContinuousMap Complex\n\nopen ComplexStarModule\n\nvariable {F A : Type _} [NormedRing A] [NormedAlgebra \u2102 A] [CompleteSpace A] [StarRing A]\n  [CstarRing A] [StarModule \u2102 A] [hF : AlgHomClass F \u2102 A \u2102]\n\ninclude hF\n\n/-- This instance is provided instead of `star_alg_hom_class` to avoid type class inference loops.\nSee note [lower instance priority] -/\nnoncomputable instance (priority := 100) : StarHomClass F A \u2102\n    where\n  coe \u03c6 := \u03c6\n  coe_injective' := FunLike.coe_injective'\n  map_star \u03c6 a := by\n    suffices hsa : \u2200 s : selfAdjoint A, (\u03c6 s)\u22c6 = \u03c6 s\n    \u00b7 rw [\u2190 realPart_add_i_smul_imaginaryPart a]\n      simp only [map_add, map_smul, star_add, star_smul, hsa, selfAdjoint.star_val_eq]\n    \u00b7 intro s\n      have := AlgHom.apply_mem_spectrum \u03c6 (s : A)\n      rw [selfAdjoint.coe_re_map_spectrum s] at this\n      rcases this with \u27e8\u27e8_, _\u27e9, _, heq\u27e9\n      rw [\u2190 HEq, IsROrC.star_def, IsROrC.conj_of_real]\n\n/-- This is not an instance to avoid type class inference loops. See\n`weak_dual.complex.star_hom_class`. -/\nnoncomputable def AlgHomClass.starAlgHomClass : StarAlgHomClass F \u2102 A \u2102 :=\n  { WeakDual.Complex.starHomClass, hF with coe := fun f => f }\n#align alg_hom_class.star_alg_hom_class AlgHomClass.starAlgHomClass\n\nomit hF\n\nnamespace CharacterSpace\n\nnoncomputable instance : StarAlgHomClass (characterSpace \u2102 A) \u2102 A \u2102 :=\n  { AlgHomClass.starAlgHomClass with coe := fun f => f }\n\nend CharacterSpace\n\nend WeakDual\n\n"}
{"text": "{-# OPTIONS --without-K --safe --no-universe-polymorphism --sized-types\n            --no-guardedness --no-subtyping #-}\n\nmodule Agda.Builtin.Size where\n\n{-# BUILTIN SIZEUNIV SizeUniv #-}\n{-# BUILTIN SIZE     Size     #-}\n{-# BUILTIN SIZELT   Size<_   #-}\n{-# BUILTIN SIZESUC  \u2191_       #-}\n{-# BUILTIN SIZEINF  \u221e        #-}\n{-# BUILTIN SIZEMAX  _\u2294\u02e2_     #-}\n\n{-# FOREIGN GHC\n  type SizeLT i = ()\n  #-}\n\n{-# COMPILE GHC Size   = type ()     #-}\n{-# COMPILE GHC Size<_ = type SizeLT #-}\n{-# COMPILE GHC \u2191_     = \\_ -> ()    #-}\n{-# COMPILE GHC \u221e      = ()          #-}\n{-# COMPILE GHC _\u2294\u02e2_   = \\_ _ -> ()  #-}\n"}
{"text": "\n\ndef f (x : Nat) (y : Nat := 1) (w : Nat := 2) (z : Nat) :=\nx + y + w - z\n\ntheorem ex1 (x z : Nat) : f (z := z) x = x + 1 + 2 - z :=\nrfl\n\ntheorem ex2 (x z : Nat) : f x (z := z) = x + 1 + 2 - z :=\nrfl\n\ntheorem ex3 (x y : Nat) : f x y = fun z => x + y + 2 - z :=\nrfl\n\ntheorem ex4 : f = (fun x z => x + 1 + 2 - z) :=\nrfl\n\ntheorem ex5 (x : Nat) : f x = fun z => x + 1 + 2 - z :=\nrfl\n\ntheorem ex6 (y : Nat) : f (y := 5) = fun x z => x + 5 + 2 - z :=\nrfl\n\ndef g {\u03b1} [Add \u03b1] (a : \u03b1) (b? : Option \u03b1 := none) (c : \u03b1) : \u03b1 :=\nmatch b? with\n| none   => a + c\n| some b => a + b + c\n\nvariable {\u03b1} [Add \u03b1]\n\ntheorem ex7 : g = fun (a c : \u03b1) => a + c :=\nrfl\n\ntheorem ex8 (x : \u03b1) : g (c := x) = fun (a : \u03b1) => a + x :=\nrfl\n\ntheorem ex9 (x : \u03b1) : g (b? := some x) = fun (a c : \u03b1) => a + x + c :=\nrfl\n\ntheorem ex10 (x : \u03b1) : g x = fun (c : \u03b1) => x + c :=\nrfl\n\ntheorem ex11 (x y : \u03b1) : g x y = fun (c : \u03b1) => x + y + c :=\nrfl\n"}
{"text": "lemma completion_upper: assumes A: \"A \\<in> sets (completion M)\" obtains A' where \"A \\<subseteq> A'\" \"A' \\<in> sets M\" \"A' - A \\<in> null_sets (completion M)\" \"emeasure (completion M) A = emeasure M A'\""}
{"text": "theorem ex1 (x : Nat) (y : { v // v > x }) (z : Nat) : Nat :=\nby {\n  clear y x;\n  exact z\n}\n\ntheorem ex2 (x : Nat) (y : { v // v > x }) (z : Nat) : Nat :=\nby {\n  clear x y;\n  exact z\n}\n\ntheorem ex3 (x y z : Nat) (h\u2081 : x = y) (h\u2082 : z = y) : x = z :=\nby {\n  have : y = z := h\u2082.symm;\n  apply Eq.trans;\n  exact h\u2081;\n  assumption\n}\n\ntheorem ex4 (x y z : Nat) (h\u2081 : x = y) (h\u2082 : z = y) : x = z :=\nby {\n  let h\u2083 : y = z := h\u2082.symm;\n  apply Eq.trans;\n  exact h\u2081;\n  exact h\u2083\n}\n\ntheorem ex5 (x y z : Nat) (h\u2081 : x = y) (h\u2082 : z = y) : x = z :=\nby {\n  have h\u2083 : y = z := h\u2082.symm;\n  apply Eq.trans;\n  exact h\u2081;\n  exact h\u2083\n}\n\ntheorem ex6 (x y z : Nat) (h\u2081 : x = y) (h\u2082 : z = y) : id (x + 0 = z) :=\nby {\n  show x = z;\n  have h\u2083 : y = z := h\u2082.symm;\n  apply Eq.trans;\n  exact h\u2081;\n  exact h\u2083\n}\n\ntheorem ex7 (x y z : Nat) (h\u2081 : x = y) (h\u2082 : z = y) : x = z := by\nhave : y = z := by apply Eq.symm; assumption\napply Eq.trans\nexact h\u2081\nassumption\n\ntheorem ex8 (x y z : Nat) (h\u2081 : x = y) (h\u2082 : z = y) : x = z :=\nby apply Eq.trans h\u2081;\n   have : y = z := by\n     apply Eq.symm;\n     assumption;\n   exact this\n"}
{"text": "/-\nCopyright (c) 2021 Ashvni Narayanan. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Ashvni Narayanan\n-/\nimport norm_properties\nimport nat_properties\nimport misc\nimport number_theory.bernoulli_polynomials\n/-!\n# Theorems regarding sums of even characters\nThis file describes theorems of convergence properties of certain sums twisted \nby even Dirichlet characters. These are proved separately over `zmod (d * p^n)` \nand `(zmod (d * p^n))\u02e3`, for `d` coprime to the prime `p`. \n\n## Main theorems\n * `sum_even_character_tendsto_zero`\n * `sum_even_character_tendsto_zero_of_units`\n\n## References\nIntroduction to Cyclotomic Fields, Washington (Chapter 7, Lemma 7.11)\n\n## Tags\np-adic, L-function, Dirichlet character\n-/\n-- `mul_eval_coprime` replaced with `mul_eval_of_coprime`\n-- `lev_mul_dvd` replaced with `lev_mul_dvd_lcm`\n-- `mul_eval_coprime'` replaced with `mul_eval_neg_one`\n-- `teichmuller_character_mod_p_change_level_pow` replaced with `dirichlet_character.pow_apply`\n-- `teichmuller_character_mod_p_eval_neg_one` replaced with `teichmuller_character.eval_neg_one`\n-- removed `asso_dc`\n\nopen dirichlet_character zmod\nvariables {p d m : nat} [fact (nat.prime p)] [fact (0 < d)] {R : Type*} [normed_comm_ring R]\n  {\u03c7 : dirichlet_character R (d * p^m)}\nopen_locale big_operators\n--set_option pp.proofs true\nopen dirichlet_character teichmuller_character\n\n-- choosing `teichmuller_character_mod_p_change_level'` as easiest to work with?\nlemma sum_eq_neg_sum_add_dvd (h\u03c7 : \u03c7.is_even) [algebra \u211a_[p] R] [nontrivial R]\n  [no_zero_divisors R] [fact (0 < m)] (hp : 2 < p) {k : \u2115} (hk : 1 \u2264 k) {x : \u2115} (hx : m \u2264 x) :\n  \u2211 (i : \u2115) in finset.range (d * p ^ x).succ, (asso_dirichlet_character (\u03c7.mul\n  (teichmuller_character_mod_p' p R ^ k))) \u2191i * \u2191i ^ (k - 1) = -1 *\n  \u2211 (y : \u2115) in finset.range (d * p ^ x + 1),\n  (asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191y * \u2191y ^ (k - 1) +\n  \u2191(d * p ^ x) * \u2211 (y : \u2115) in finset.range (d * p ^ x + 1),\n  (asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) (-1) *\n  ((asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191y *\n  \u2211 (x_1 : \u2115) in finset.range (k - 1), \u2191(d * p ^ x) ^ x_1 * ((-1) * \u2191y) ^ (k - 1 - (x_1 + 1)) *\n  \u2191((k - 1).choose (x_1 + 1))) :=\nbegin\n  have lev_mul_dvd : lev (\u03c7.mul (teichmuller_character_mod_p' p R ^ k)) \u2223 d * p^m,\n  { apply dvd_trans (lev_mul_dvd_lcm _ _) _,\n    rw helper_4, },\n  rw \u2190finset.sum_flip,\n  conv_lhs { apply_congr, skip, rw [nat.cast_sub (finset.mem_range_succ_iff.1 H),\n    dirichlet_character.asso_dirichlet_character.eval_mul_sub' _ (dvd_trans lev_mul_dvd\n    (mul_dvd_mul dvd_rfl (pow_dvd_pow _ hx)))],\n    conv { congr, skip, rw [nat.cast_sub (finset.mem_range_succ_iff.1 H), sub_eq_add_neg,\n      add_pow, finset.sum_range_succ', add_comm, pow_zero, one_mul, nat.sub_zero,\n      nat.choose_zero_right, nat.cast_one, mul_one, neg_eq_neg_one_mul, mul_pow],\n    congr, skip, apply_congr, skip, rw [pow_succ, mul_assoc \u2191(d * p^x) _, mul_assoc \u2191(d * p^x) _], },\n    rw [\u2190finset.mul_sum, mul_add, mul_mul_mul_comm, mul_mul_mul_comm _ _ \u2191(d * p^x) _,\n      mul_comm _ \u2191(d * p^x), mul_assoc \u2191(d * p^x) _ _], },\n  rw [finset.sum_add_distrib, \u2190finset.mul_sum, \u2190finset.mul_sum],\n  refine congr_arg2 _ (congr_arg2 _ _ _) rfl,\n  { rw [\u2190int.cast_one, \u2190int.cast_neg, mul_eval_neg_one, asso_even_dirichlet_character_eval_neg_one\n      _ h\u03c7, one_mul, asso_dirichlet_character_eq_char' _ (is_unit.neg (is_unit_one)),\n      change_level_pow_eval_neg_one' k hp, units.coe_pow, units.coe_neg_one, \u2190pow_add,\n      nat.add_sub_pred, odd.neg_one_pow _],\n    { rw [nat.odd_iff, nat.two_mul_sub_one_mod_two_eq_one hk], },\n    any_goals { apply_instance, }, },\n  { rw \u2190finset.sum_flip, },\nend\n\n-- `sum_odd_char` replaced with `helper_11`\nlemma helper_11 [nontrivial R] [no_zero_divisors R] [normed_algebra \u211a_[p] R]  [norm_one_class R]\n (na : \u2200 (n : \u2115) (f : \u2115 \u2192 R), \u2225 \u2211 (i : \u2115) in finset.range n, f i\u2225 \u2264 \u2a06 (i : zmod n), \u2225f i.val\u2225)\n [fact (0 < m)] {k : \u2115} (hk : 1 < k) (h\u03c7 : \u03c7.is_even) (hp : 2 < p) {x : \u2115} (hx : m \u2264 x) :\n \u2203 y, (2 : R) * \u2211 i in finset.range (d * p^x), ((asso_dirichlet_character (\u03c7.mul\n  (teichmuller_character_mod_p' p R ^ k))) i * i^(k - 1)) = \u2191(d * p^x) * y \u2227 \u2225y\u2225 \u2264 ((\u03c7.mul\n  (teichmuller_character_mod_p' p R ^ k)).bound * (\u2191k - 1)) + \u2225(((d * p ^ x : \u2115) : R) ^ (k - 2)) *\n  (1 + 1)\u2225 * (\u03c7.mul (teichmuller_character_mod_p' p R ^ k)).bound :=\nbegin\n  have f1 : \u2211 (i : \u2115) in finset.range (d * p ^ x), (asso_dirichlet_character (\u03c7.mul\n    (teichmuller_character_mod_p' p R ^ k))) \u2191i * \u2191i ^ (k - 1) =\n    \u2211 (i : \u2115) in finset.range (d * p ^ x).succ, (asso_dirichlet_character\n    (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191i * \u2191i ^ (k - 1)\n   - ((asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191(d * p^x) *\n   \u2191(d * p^x) ^ (k - 1)),\n  { rw [finset.sum_range_succ, add_sub_cancel], },\n  rw [f1, mul_sub, mul_comm _ (\u2191(d * p ^ x) ^ (k - 1)), \u2190mul_assoc _ (\u2191(d * p ^ x) ^ (k - 1)) _,\n    mul_comm _ (\u2191(d * p ^ x) ^ (k - 1)), mul_assoc _ (2 : R) _, \u2190nat.cast_pow],\n  clear f1,\n  conv { congr, funext, rw [sub_eq_iff_eq_add, @helper_5 p _ d _ k hk,\n    nat.cast_mul (d * p^x) _, mul_assoc \u2191(d * p^x) _ _],\n    conv { congr, rw \u2190mul_add \u2191(d * p^x) _ _, }, },\n  have two_eq_one_add_one : (2 : R) = (1 : R) + (1 : R) := rfl,\n  rw [two_eq_one_add_one, add_mul, one_mul],\n  conv { congr, funext, conv { congr, to_lhs, congr, skip,\n    rw sum_eq_neg_sum_add_dvd h\u03c7 hp (le_of_lt hk) hx, }, },\n  rw [\u2190neg_eq_neg_one_mul, \u2190add_assoc, \u2190sub_eq_add_neg],\n  conv { congr, funext, rw [sub_self _, zero_add], },\n  refine \u27e8\u2211 (y : \u2115) in finset.range (d * p ^ x + 1),\n    (asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) (-1) *\n    ((asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191y *\n    \u2211 (x_1 : \u2115) in finset.range (k - 1),\n    \u2191(d * p ^ x) ^ x_1 * ((-1) * \u2191y) ^ (k - 1 - (x_1 + 1)) * \u2191((k - 1).choose (x_1 + 1))) -\n    \u2191((d * p ^ x) ^ (k - 2)) * ((1 + 1) * (asso_dirichlet_character (\u03c7.mul\n    (teichmuller_character_mod_p' p R ^ k))) \u2191(d * p ^ x)), _, _\u27e9,\n  { rw sub_add_cancel, },\n  { apply le_trans (norm_sub_le _ _) _,\n    conv { congr, congr, congr, apply_congr, skip, rw [\u2190mul_assoc, \u2190monoid_hom.map_mul], },\n    apply le_trans (add_le_add (norm_sum_le_smul hk na) (le_refl _)) _,\n    rw \u2190 mul_assoc,\n    refine le_trans (add_le_add (le_refl _) (norm_mul_le _ _)) (le_trans (add_le_add (le_refl _)\n      ((mul_le_mul_left _).2 (le_of_lt (dirichlet_character.lt_bound _ _)))) _),\n    { haveI : algebra \u211a_[p] R, apply_instance, -- needed for char_zero\n      haveI : char_zero R := char_zero_of_nontrivial_of_normed_algebra p R,\n      refine lt_iff_le_and_ne.2 \u27e8norm_nonneg _, \u03bb h, _\u27e9,\n      rw [eq_comm, norm_eq_zero, mul_eq_zero] at h,\n      cases h,\n      { refine pow_ne_zero _ (ne_zero_of_lt (nat.mul_prime_pow_pos _)) (nat.cast_eq_zero.1 h), },\n      { apply zero_ne_one ((self_eq_neg R R).1 (eq_neg_iff_add_eq_zero.2 h)).symm, }, },\n    { rw nat.cast_pow, }, },\nend\n\n-- `sum_even_character` replaced with `sum_even_character_tendsto_zero`\nlemma sum_even_character_tendsto_zero [nontrivial R] [no_zero_divisors R] [normed_algebra \u211a_[p] R]\n  [norm_one_class R] [fact (0 < m)] {k : \u2115} (hk : 1 < k) (h\u03c7 : \u03c7.is_even) (hp : 2 < p)\n  (na : \u2200 (n : \u2115) (f : \u2115 \u2192 R), \u2225 \u2211 (i : \u2115) in finset.range n, f i\u2225 \u2264 \u2a06 (i : zmod n), \u2225f i.val\u2225) :\n  filter.tendsto (\u03bb n : nat, \u2211 i in finset.range (d * p^n), ((asso_dirichlet_character\n  (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) i * i^(k - 1)) ) filter.at_top (nhds 0) :=\nbegin\n  -- better way to do this with filters\n  refine metric.tendsto_at_top.2 (\u03bb \u03b5 h\u03b5, _),\n  obtain \u27e8z, hz\u27e9 := helper_10 \u03c7 hk hp h\u03b5,\n  refine \u27e8max z m, \u03bb x hx, _\u27e9,\n  cases helper_11 na hk h\u03c7 hp (max_le_iff.1 hx).2,\n  rw [dist_eq_norm, sub_zero, helper_6 p h.1, norm_smul],\n  apply lt_of_le_of_lt (mul_le_mul le_rfl (norm_mul_le _ _)\n    (norm_nonneg (\u2191(d * p ^ x) * w)) (norm_nonneg _)) _,\n  rw \u2190 mul_assoc,\n  apply lt_of_le_of_lt (mul_le_mul le_rfl h.2 (norm_nonneg _) (mul_nonneg (norm_nonneg _)\n    (norm_nonneg _))) _,\n  rw [mul_comm _ (k - 1 : \u211d), \u2190add_mul, mul_mul_mul_comm],\n  apply lt_of_le_of_lt (mul_le_mul (mul_le_mul le_rfl (add_le_add le_rfl _) (helper_8 hk _)\n    (norm_nonneg _)) (mul_le_mul (norm_mul_prime_pow_le_of_ge p R (le_trans (le_max_left _ _) hx))\n    le_rfl (le_of_lt (dirichlet_character.bound_pos _)) (norm_nonneg _)) (mul_nonneg (norm_nonneg _)\n    (le_of_lt (dirichlet_character.bound_pos _))) (mul_nonneg (norm_nonneg _) (helper_8 hk _))) hz,\n-- refine is so much more powerful than apply, it captures instances of explicit vars very well, but not implicit\n  have : ((2 : \u2115) : R) = 1 + 1,\n  { simp only [nat.cast_bit0, nat.cast_one], refl, },\n  simp_rw [\u2190this, \u2190nat.cast_pow, norm_mul_nat_eq_mul_norm p R], -- better than repeat\n  apply mul_le_mul _ le_rfl (norm_nonneg _) (norm_nonneg _),\n  simp_rw [nat.cast_pow, norm_pow_nat_eq_pow_norm p R],\n  refine pow_le_pow_of_le_left (norm_nonneg _) (norm_mul_prime_pow_le_of_ge p R (le_trans (le_max_left _ _) hx)) _,\nend\n-- btw, this still works without the na condition, since in the end, we divide by d*p^x\n\nopen filter dirichlet_character ring_hom\n\nvariables (p d R)\nlemma helper_12 [algebra \u211a R] {k : \u2115} (hk : 1 < k) (x y : \u2115) :\n  (algebra_map \u211a R) (((d * p ^ x : \u2115) : \u211a) ^ k) * (algebra_map \u211a R)\n  (polynomial.eval (\u2191(y.succ) / \u2191(d * p ^ x : \u2115)) (polynomial.bernoulli k)) =\n  ((y + 1 : \u2115) : R)^k + ((algebra_map \u211a R) (bernoulli 1 * (k : \u211a))) * ((d * p^x : \u2115) : R) *\n  ((y + 1 : \u2115) : R)^k.pred + (d * p^x : \u2115) * (\u2211 (x_1 : \u2115) in finset.range k.pred,\n  (algebra_map \u211a R) (bernoulli (k.pred.succ - x_1) * \u2191(k.pred.succ.choose x_1) *\n  (((y + 1 : \u2115) : \u211a) ^ x_1 / \u2191(d * p ^ x) ^ x_1) * \u2191(d * p ^ x) ^ k.pred)) :=\nbegin\n  rw [\u2190(algebra_map \u211a R).map_mul, polynomial.bernoulli_def, polynomial.eval_finset_sum,\n    finset.mul_sum],\n  simp only [polynomial.eval_monomial, div_pow, nat.cast_succ],\n  simp_rw [mul_comm (((d * p ^ x : \u2115) : \u211a) ^ k) _, mul_assoc],\n  rw [finset.sum_range_succ_comm, div_mul_cancel _],\n  { rw (algebra_map \u211a R).map_add,\n    conv_lhs { congr, skip, rw \u2190 nat.succ_pred_eq_of_pos (pos_of_gt hk),\n      rw finset.sum_range_succ_comm, },\n    rw [div_mul_comm, (algebra_map \u211a R).map_add, add_assoc],\n    congr,\n    { simp only [nat.choose_self, map_nat_cast, one_mul, map_add, nat.sub_self, bernoulli_zero,\n        map_pow, map_one, nat.cast_one], },\n    { rw [nat.choose_succ_self_right, \u2190nat.succ_eq_add_one, nat.succ_pred_eq_of_pos (pos_of_gt hk),\n        nat.pred_eq_sub_one, div_eq_mul_inv,\n        \u2190pow_sub\u2080 ((d * p^x : \u2115) : \u211a) (nat.cast_ne_zero.2 (nat.ne_zero_of_lt' 0)) (nat.sub_le k 1)],\n      rw [nat.sub_sub_self (le_of_lt hk), pow_one, \u2190mul_assoc, (algebra_map \u211a R).map_mul],\n      simp only [map_nat_cast, map_add, map_pow, map_one, map_mul], },\n    { rw [map_sum, pow_succ'],\n      conv_lhs { apply_congr, skip, rw [\u2190mul_assoc, \u2190mul_assoc, \u2190mul_assoc,\n        (algebra_map \u211a R).map_mul], },\n      rw [\u2190finset.sum_mul, mul_comm, map_nat_cast],\n      conv_rhs { congr, skip, apply_congr, skip, rw [\u2190mul_assoc, \u2190mul_assoc], }, }, },\n  { norm_cast,\n    refine pow_ne_zero _ (nat.ne_zero_of_lt' 0), },\nend\n\nvariables {p d R}\nvariables {p d R}\nlemma helper_15 [nontrivial R] [algebra \u211a R] [normed_algebra \u211a_[p] R] [norm_one_class R]\n  (na : \u2200 (n : \u2115) (f : \u2115 \u2192 R), \u2225 \u2211 (i : \u2115) in finset.range n, f i\u2225 \u2264 \u2a06 (i : zmod n), \u2225f i.val\u2225)\n  {k : \u2115} (hk : 1 < k) (x y : \u2115) : \u2225(\u2211 (x_1 : \u2115) in finset.range k.pred,\n  (algebra_map \u211a R) (bernoulli (k.pred.succ - x_1) * \u2191(k.pred.succ.choose x_1) *\n  (((y + 1 : \u2115) : \u211a) ^ x_1 / \u2191(d * p ^ x) ^ x_1) * \u2191(d * p ^ x) ^ k.pred))\u2225 \u2264\n  \u2225((d * p^x : \u2115) : R)\u2225 * (\u2a06 (x_1 : zmod k.pred), (\u2225(algebra_map \u211a R) (bernoulli (k.pred.succ - x_1.val) *\n  \u2191(k.pred.succ.choose x_1.val) )\u2225)) :=\nbegin\n  have le : k.pred = k.pred - 1 + 1,\n  { rw [nat.sub_add_cancel _, nat.pred_eq_sub_one], apply nat.le_pred_of_lt hk, },\n  haveI : fact (0 < k.pred) := fact_iff.2 (nat.lt_pred_iff.2 hk),\n  refine le_trans (na _ _) (csupr_le (\u03bb z, _)),\n  conv { congr, congr, find (\u2191(d * p ^ x) ^ k.pred) { rw [le, pow_add, pow_one], },\n    rw [\u2190mul_assoc, (algebra_map \u211a R).map_mul, mul_assoc _ _ (\u2191(d * p ^ x) ^ (k.pred - 1)),\n      div_mul_comm], },\n  rw mul_comm,\n  apply le_trans (norm_mul_le _ _) _,\n  rw [\u2190mul_one_div, \u2190inv_eq_one_div, \u2190pow_sub\u2080 ((d * p^x : \u2115) : \u211a)\n    (nat.cast_ne_zero.2 (nat.ne_zero_of_lt' 0)) (nat.le_pred_of_lt (zmod.val_lt z)),\n    ring_hom.map_mul, \u2190nat.cast_pow, \u2190nat.cast_pow, \u2190nat.cast_mul, map_nat_cast,\n    mul_le_mul_left (norm_mul_pow_pos p d R x), map_nat_cast],\n  refine le_trans (norm_mul_le _ _) (le_trans (mul_le_mul le_rfl (norm_le_one p _)\n    (norm_nonneg _) (norm_nonneg _)) _),\n  rw mul_one,\n  refine le_cSup (set.finite.bdd_above (set.finite_range _)) \u27e8z, _\u27e9,\n  simp only,\nend\n\n--`helper_W_3` replaced with `helper_16`\nlemma helper_16 [normed_algebra \u211a_[p] R] [fact (0 < m)] (k : \u2115) {x : \u2115} (hx : m \u2264 x) :\n  \u2211 (i : (zmod (d * p ^ x))\u02e3), (asso_dirichlet_character (\u03c7.mul\n    (teichmuller_character_mod_p' p R ^ k))) \u2191i * \u2191i ^ (k - 1) =\n  \u2211 (i : (zmod (d * p ^ x))\u02e3), (asso_dirichlet_character (\u03c7.mul\n    (teichmuller_character_mod_p' p R ^ k))) \u2191(d * p ^ x - (i : zmod (d * p^x)).val) *\n    \u2191(d * p ^ x - (i : zmod (d * p^x)).val) ^ (k - 1) :=\nbegin\n  symmetry,\n  apply finset.sum_bij,\n  swap 5, { intros a ha, apply zmod.unit_of_coprime (d * p^x - (a : zmod (d * p^x)).val),\n    apply nat.coprime_sub (coprime_of_is_unit _).symm (le_of_lt (zmod.val_lt _)),\n    { rw zmod.nat_cast_val, rw zmod.cast_id,\n      apply units.is_unit _, },\n    { apply_instance, }, },\n  { intros a ha, apply finset.mem_univ _, },\n  { intros a ha,\n    simp only,\n    have lev_mul_dvd : lev (\u03c7.mul (teichmuller_character_mod_p' p R ^ k)) \u2223 d * p^m,\n    { --apply dvd_trans _ (mul_dvd_mul_left d (pow_dvd_pow p hk)),\n      apply dvd_trans (conductor.dvd_lev _) _, --(dvd_trans (conductor_dvd _) _),\n      rw helper_4, },\n    have lev_mul_dvd' : lev (\u03c7.mul (teichmuller_character_mod_p' p R ^ k)) \u2223 d * p^x,\n    { apply dvd_trans lev_mul_dvd _,\n      --convert dvd_trans (dirichlet_character.lev_mul_dvd _ _) _, rw [lcm_eq_nat_lcm, nat.lcm_self],\n      apply mul_dvd_mul_left d, apply pow_dvd_pow p hx, },\n    symmetry,\n    rw _root_.coe_coe, rw _root_.coe_coe, rw zmod.coe_unit_of_coprime,\n    rw zmod.cast_nat_cast lev_mul_dvd' (d * p ^ x - (a : zmod (d * p^x)).val),\n    swap 2, { delta lev, refine zmod.char_p _, }, congr' 2,\n    rw \u2190 zmod.nat_cast_val (d * p ^ x - (a : zmod (d * p^x)).val : \u2115), congr,\n    apply zmod.val_cast_of_lt, apply nat.sub_lt _ _,\n    { refine fact_iff.1 _, apply_instance, },\n    { apply lt_of_le_of_ne,\n      { apply nat.zero_le _, },\n      { apply ne.symm, simp only [ne.def, zmod.val_eq_zero],\n        apply is_unit.ne_zero (units.is_unit _),\n        apply zmod.nontrivial _,\n        apply fact_iff.2 _, apply nat.one_lt_mul_pow_of_ne_one, intro h,\n        rw nat.mul_eq_one_iff at h,\n        rw pow_eq_one_iff (ne_zero_of_lt (lt_of_le_of_lt' hx (fact.out _))) at h,\n        apply nat.prime.ne_one (fact.out _) h.2,\n        swap 3, { exact 0, },\n        any_goals { apply_instance, }, }, },\n    { apply_instance, }, },\n  { intros a b ha hb, simp only, intro h,\n    rw units.ext_iff at h, rw zmod.coe_unit_of_coprime at h, rw zmod.coe_unit_of_coprime at h,\n    rw nat.cast_sub (le_of_lt (@zmod.val_lt (d * p^x) _ _)) at h,\n    rw nat.cast_sub (le_of_lt (@zmod.val_lt (d * p^x) _ _)) at h,\n    rw zmod.nat_cast_self at h, rw zero_sub at h, rw zero_sub at h, rw eq_neg_iff_eq_neg at h,\n    rw neg_neg at h, rw zmod.nat_cast_val at h, rw zmod.cast_id at h,\n    rw zmod.nat_cast_val at h, rw zmod.cast_id at h, rw \u2190 units.ext_iff at h,\n    rw h, },\n  { intros b hb,\n    refine \u27e8_, finset.mem_univ _, _\u27e9,\n    { apply zmod.unit_of_coprime (d * p^x - (b : zmod (d * p^x)).val),\n      apply nat.coprime_sub (coprime_of_is_unit _).symm (le_of_lt (zmod.val_lt _)),\n      { rw zmod.nat_cast_val, rw zmod.cast_id,\n        apply units.is_unit _, },\n      { apply_instance, }, },\n    simp only, rw units.ext_iff, rw zmod.coe_unit_of_coprime, rw zmod.coe_unit_of_coprime,\n    rw nat.cast_sub (le_of_lt (@zmod.val_lt (d * p^x) _ _)),\n    rw nat.cast_sub (le_of_lt (@zmod.val_lt (d * p^x) _ _)),\n    rw zmod.nat_cast_val, rw zmod.cast_id, rw zmod.nat_cast_val, rw zmod.cast_id,\n    rw sub_sub_cancel, },\nend\n\n--`sum_eq_neg_sum_add_dvd'` replaced with `sum_eq_neg_sum_add_dvd_of_units`\nlemma sum_eq_neg_sum_add_dvd_of_units (h\u03c7 : \u03c7.is_even) [normed_algebra \u211a_[p] R] [nontrivial R]\n  [no_zero_divisors R] [fact (0 < m)] (hp : 2 < p) (k : \u2115) (hk : 1 \u2264 k) {x : \u2115} (hx : m \u2264 x) :\n  \u2211 (i : (zmod (d * p ^ x))\u02e3), (asso_dirichlet_character (\u03c7.mul\n  (teichmuller_character_mod_p' p R ^ k))) \u2191i * \u2191i ^ (k - 1) =\n  -1 * \u2211 (y : (zmod (d * p ^ x))\u02e3),\n  (asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191y *\n  \u2191y ^ (k - 1) + \u2191(d * p ^ x) * \u2211 (y : (zmod (d * p ^ x))\u02e3),\n  (asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) (-1) *\n  ((asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191y *\n  \u2211 (x_1 : \u2115) in finset.range (k - 1), \u2191(d * p ^ x) ^ x_1 * ((-1) * \u2191y) ^ (k - 1 - (x_1 + 1)) *\n  \u2191((k - 1).choose (x_1 + 1))) :=\nbegin\n  have lev_mul_dvd : lev (\u03c7.mul (teichmuller_character_mod_p' p R ^ k)) \u2223 d * p^m,\n  { --apply dvd_trans _ (mul_dvd_mul_left d (pow_dvd_pow p hk)),\n    apply dvd_trans (conductor.dvd_lev _) _, --(dvd_trans (conductor_dvd _) _),\n    rw helper_4, },\n  refine eq.trans (helper_16 k hx) _,\n  conv_lhs { apply_congr, skip, rw nat.cast_sub (le_of_lt (@zmod.val_lt (d * p^x) _ _)),\n    rw asso_dirichlet_character.eval_mul_sub' _ (dvd_trans lev_mul_dvd\n      (mul_dvd_mul dvd_rfl (pow_dvd_pow _ hx))),\n    conv { congr, skip, rw [nat.cast_sub (le_of_lt (@zmod.val_lt (d * p^x) _ _)), sub_eq_add_neg,\n    add_pow, finset.sum_range_succ', add_comm, pow_zero, one_mul, nat.sub_zero,\n    nat.choose_zero_right, nat.cast_one, mul_one, neg_eq_neg_one_mul, mul_pow],\n    congr, skip, apply_congr, skip, rw pow_succ, rw mul_assoc \u2191(d * p^x) _,\n    rw mul_assoc \u2191(d * p^x) _, },\n    rw [\u2190finset.mul_sum, mul_add, mul_mul_mul_comm, mul_mul_mul_comm _ _ \u2191(d * p^x) _,\n      mul_comm _ \u2191(d * p^x), mul_assoc \u2191(d * p^x) _ _], },\n  rw finset.sum_add_distrib, rw \u2190finset.mul_sum, rw \u2190finset.mul_sum,\n  simp_rw [\u2190 zmod.cast_nat_cast lev_mul_dvd, zmod.nat_cast_val, \u2190 _root_.coe_coe],\n  apply congr_arg2 _ (congr_arg2 _ _ rfl) rfl,\n--  apply congr_arg2 _ (congr_arg2 _ _ rfl) rfl,\n  rw \u2190int.cast_one, rw \u2190int.cast_neg,\n  --rw \u2190zmod.neg_one_eq_sub _,\n  rw mul_eval_neg_one _ _,\n--  rw zmod.neg_one_eq_sub _,\n  --rw int.cast_neg, rw int.cast_one,\n  rw asso_even_dirichlet_character_eval_neg_one _ h\u03c7, rw one_mul,\n  rw asso_dirichlet_character_eq_char' _ (is_unit.neg (is_unit_one)),\n  convert_to (-1 : R)^k * (-1)^(k -1) = -1,\n  { apply congr_arg2 _ _ rfl,\n    rw change_level_pow_eval_neg_one' k hp,\n    simp only [units.coe_neg_one, units.coe_pow],\n    any_goals { apply_instance, }, },\n  { rw \u2190pow_add, rw nat.add_sub_pred, rw odd.neg_one_pow _, rw nat.odd_iff,\n    rw nat.two_mul_sub_one_mod_two_eq_one hk, },\n  { apply_instance, },\n  { apply fact_iff.2 (nat.prime.pos _), refine fact_iff.1 _, apply_instance, },\nend\n\n--`sum_even_character'` replaced with `sum_even_character_tendsto_zero_of_units`\nlemma sum_even_character_tendsto_zero_of_units [nontrivial R] [no_zero_divisors R] [normed_algebra \u211a_[p] R]  [norm_one_class R]\n --(n : \u2115) --[fact (0 < n)]\n  (na' : \u2200 (n : \u2115) (f : (zmod n)\u02e3 \u2192 R), \u2225\u2211 i : (zmod n)\u02e3, f i\u2225 \u2264 \u2a06 (i : (zmod n)\u02e3), \u2225f i\u2225)\n  [fact (0 < m)] {k : \u2115} (hk : 1 < k) (h\u03c7 : \u03c7.is_even) (hp : 2 < p) :\n  filter.tendsto (\u03bb n, \u2211 (i : (zmod (d * p^n))\u02e3), ((asso_dirichlet_character\n  (dirichlet_character.mul \u03c7 (teichmuller_character_mod_p' p R^k)))\n  i * i^(k - 1)) ) (@filter.at_top \u2115 _) (nhds 0) :=\nbegin\n  suffices : filter.tendsto (\u03bb n, (2 : R) * \u2211 (i : (zmod (d * p^n))\u02e3), ((asso_dirichlet_character\n    (dirichlet_character.mul \u03c7 (teichmuller_character_mod_p' p R^k)))\n    i * i^(k - 1)) ) (@filter.at_top \u2115 _) (nhds 0),\n  { have h1 : (2 : \u211a_[p]) \u2260 0, { norm_num, },\n    apply tendsto_zero_of_tendsto_const_smul_zero h1,\n    have h2 : (2 : R) = ((2 : \u2115) : R), { rw nat.cast_two, },\n    conv at this { congr, funext, rw [h2, \u2190map_nat_cast (algebra_map \u211a_[p] R) 2, \u2190smul_eq_mul,\n      algebra_map_smul, nat.cast_two], },\n    apply this, },\n  { apply (tendsto_congr' _).2,\n    swap 2, { refine \u03bb x : \u2115, \u2191(d * p ^ x) * \u2211 (y : (zmod (d * p ^ x))\u02e3),\n      (asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) (-1) *\n      ((asso_dirichlet_character (\u03c7.mul (teichmuller_character_mod_p' p R ^ k))) \u2191y *\n      \u2211 (x_1 : \u2115) in finset.range (k - 1), \u2191(d * p ^ x) ^ x_1 * ((-1) * \u2191y) ^ (k - 1 - (x_1 + 1)) *\n      \u2191((k - 1).choose (x_1 + 1))) },\n    { conv { congr, funext, rw finset.mul_sum, },\n      rw metric.tendsto_at_top,\n      intros \u03b5 h\u03b5,\n      have h4 : 0 < \u03b5 / 2 / (\u03c7.mul (teichmuller_character_mod_p' p R ^ k)).bound,\n      { apply div_pos (half_pos h\u03b5) (bound_pos _), },\n      obtain \u27e8z, hz\u27e9 := padic_int.exists_pow_neg_lt p h4,\n      refine \u27e8max z 1, \u03bb x hx, _\u27e9,\n      rw dist_zero_right,\n      apply lt_of_le_of_lt (na' _ _),\n      have h2 : \u03b5 / 2 < \u03b5, linarith,\n      apply lt_of_le_of_lt _ h2,\n      apply cSup_le _ _,\n      { exact set.range_nonempty (\u03bb (i : (zmod (d * p ^ x))\u02e3), \u2225\u2191(d * p ^ x) *\n          ((asso_dirichlet_character (mul \u03c7 (teichmuller_character_mod_p' p R ^ k)))\n          (-1) * ((asso_dirichlet_character (mul \u03c7\n          (teichmuller_character_mod_p' p R ^ k))) \u2191i * \u2211 (x_1 : \u2115) in\n          finset.range (k - 1), \u2191(d * p ^ x) ^ x_1 * ((-1) * \u2191i) ^ (k - 1 - (x_1 + 1)) *\n          \u2191((k - 1).choose (x_1 + 1))))\u2225), },\n      { intros b hb,\n        cases hb with y hy,\n        rw \u2190 hy, simp only, clear hy,\n        conv { congr, congr, congr, skip, rw \u2190 mul_assoc, rw \u2190monoid_hom.map_mul, rw mul_comm, },\n        rw \u2190 mul_assoc,\n        apply le_trans (norm_mul_le _ _) _,\n        apply le_trans (mul_le_mul le_rfl (le_of_lt (lt_bound _ _)) _ (norm_nonneg _)) _,\n        { apply norm_nonneg _, },\n        rw _root_.coe_coe, rw \u2190 zmod.nat_cast_val,\n        --rw nat.mul_comm d (p^x),\n        rw nat.cast_mul, rw mul_comm \u2191d _, rw mul_assoc,\n        apply le_trans (mul_le_mul (norm_mul_le _ _) le_rfl (le_of_lt (bound_pos _)) _) _,\n        { apply mul_nonneg (norm_nonneg _) (norm_nonneg _), },\n        refine le_trans (mul_le_mul (mul_le_mul le_rfl (helper_17 y) (norm_nonneg _)\n          (norm_nonneg _)) le_rfl (le_of_lt (bound_pos _)) _) _,\n        { rw mul_one, apply norm_nonneg _, },\n        rw mul_one,\n        rw \u2190 map_nat_cast (algebra_map \u211a_[p] R), rw norm_algebra_map',\n        rw nat.cast_pow, rw norm_pow,\n        rw padic_norm_e.norm_p,\n        apply le_trans (mul_le_mul (le_trans _ (le_of_lt hz)) le_rfl (le_of_lt (bound_pos _))\n          (le_of_lt h4)) _,\n        { rw inv_pow,\n          rw \u2190 zpow_neg_coe_of_pos _,\n          apply zpow_le_of_le _ _,\n          { norm_cast, apply le_of_lt (nat.prime.one_lt _), apply fact_iff.1, apply_instance, },\n          { apply neg_le_neg, norm_cast, apply (max_le_iff.1 hx).1, },\n          { apply nat.succ_le_iff.1 (max_le_iff.1 hx).2, }, },\n        { rw div_mul_cancel _ _,\n          intro h,\n          have := bound_pos (mul \u03c7 (teichmuller_character_mod_p' p R ^ k)),\n          rw h at this, simp only [lt_self_iff_false] at this, apply this, }, }, },\n    { simp_rw two_mul,\n      rw eventually_eq,\n      rw eventually_at_top,\n      refine \u27e8m, \u03bb x hx, _\u27e9,\n      conv { congr, --skip, funext,\n        conv { congr, skip, rw sum_eq_neg_sum_add_dvd_of_units h\u03c7 hp _ (le_of_lt hk) hx, }, },\n      rw neg_one_mul, rw \u2190 add_assoc, ring, }, },\nend"}
{"text": "lemma contrapositive2 (P Q : Prop) : (\u00ac Q \u2192 \u00ac P) \u2192 (P \u2192 Q) :=\nbegin\n    \nend"}
{"text": "informal statement Prove that the intersection of an arbitrary nonempty collection of normal subgroups of a group is a normal subgroup (do not assume the collection is countable).formal statement theorem exercise_3_2_11 {G : Type*} [group G] {H K : subgroup G}\n  (hHK : H \u2264 K) : \n  H.index = K.index * H.relindex K :="}
{"text": "** Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.\n** See https://llvm.org/LICENSE.txt for license information.\n** SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception\n\n*   END DO statement (VMS).\n\n      program hb30\n      parameter (N = 7)\n      integer*2 i\n      integer j\n      integer rslts(N), expect(N)\n\n      do 10 i = 1, 10, 100\n          rslts(1) = i\n          data expect(1) /1/\n10    enddo\n\n      rslts(2) = 0\n      do i = -10, -11, -1\n          rslts(2) = rslts(2) + i\n      END DO\n      data expect(2) / -21 /\n\n      do while (0 .gt. 1)\n      enddo\n\n      rslts(3) = 3\n      do while ( rslts(3) .lt. 10 )\n          if (rslts(3) .eq. -1)  goto 30\n              rslts(3) = rslts(3) * rslts(3)\n30    end do\n      data expect(3) / 81 /\n\n      j = 1\n      do 40 while (j .ne. 3)\n          j = j + 1\n          do i = j, j+1\n              rslts(i+j) = i + j\n 40   END\n     +DO\n      data (expect(j), j = 4, 7) / 4, 5, 6, 7 /\n\n      call check(rslts, expect, N)\n      end\n"}
{"text": "[STATEMENT]\nlemma inversion_infty [simp]:\n  shows \"inversion \\<infinity>\\<^sub>h = 0\\<^sub>h\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. inversion \\<infinity>\\<^sub>h = 0\\<^sub>h\n[PROOF STEP]\nby (simp add: inversion_def)"}
{"text": "_ : (@0 Set \u2192 Set) \u2192 (@\u03c9 Set \u2192 Set)\n_ = \u03bb f \u2192 f\n"}
{"text": "import tidy.forwards_reasoning\n\nlemma G (n : \u2115) : list \u2115 := [n]\nlemma F : \u2115 := 0\n\nsection\n\nlocal attribute [forward] G\n\nexample : 1 = 1 :=\nbegin\n  success_if_fail { forwards_library_reasoning },\n  refl\nend\n\nlocal attribute [forward] F\n\nexample : 1 = 1 :=\nbegin\n  forwards_library_reasoning,\n  forwards_library_reasoning,\n  success_if_fail { forwards_library_reasoning },\n  refl\nend\n\nexample : 1 = 1 :=\nbegin\n  have p := [0],\n  forwards_library_reasoning,\n  success_if_fail { forwards_library_reasoning },\n  refl\nend\nend\n\nsection\ninductive T (n : \u2115)\n| t : \u2115 \u2192 T\n\n@[forward] lemma H.H {n : \u2115} (v : T n) : string := \"hello\"\n\nexample : 1 = 1 :=\nbegin\n  success_if_fail { forwards_library_reasoning },\n  have p : T 3 := T.t 3 5,\n  forwards_library_reasoning,\n  guard_hyp H_p := string, -- check that we drop namespaces\n  refl\nend\n\nexample (P Q : Prop) (p : P) (h : P \u2192 Q): Q :=\nbegin\n  forwards_reasoning,\n  success_if_fail { forwards_reasoning },\n  exact h_p\nend\n\n\nend\n"}
{"text": "import Smt\n\ntheorem exists' : \u2203 x : Nat, x = 1 := by\n  smt\n  exact \u27e81, rfl\u27e9\n"}
{"text": "informal statement If $x$ and $g$ are elements of the group $G$, prove that $|x|=\\left|g^{-1} x g\\right|$.formal statement theorem exercise_1_1_25 {G : Type*} [group G] \n  (h : \u2200 x : G, x ^ 2 = 1) : \u2200 a b : G, a*b = b*a :="}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_342\n  (a d: \u211d)\n  (h\u2080 : \u2211 k in (finset.range 5), (a + k * d) = 70)\n  (h\u2081 : \u2211 k in (finset.range 10), (a + k * d) = 210) :\n  a = 42/5 :=\nbegin\n  revert h\u2080 h\u2081,\n  simp [finset.sum_range_succ, mul_comm d],\n  intros,\n  linarith,\nend"}
{"text": "{-# OPTIONS -Werror -WnoEmptyRewritePragma #-}\n\n{-# REWRITE #-}\n"}
{"text": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport ring_theory.int.basic\nimport data.nat.factorization.prime_pow\nimport algebra.squarefree\n\n/-!\n# Lemmas about squarefreeness of natural numbers\nA number is squarefree when it is not divisible by any squares except the squares of units.\n\n## Main Results\n - `nat.squarefree_iff_nodup_factors`: A positive natural number `x` is squarefree iff\n  the list `factors x` has no duplicate factors.\n\n## Tags\nsquarefree, multiplicity\n\n-/\n\nnamespace nat\n\nlemma squarefree_iff_nodup_factors {n : \u2115} (h0 : n \u2260 0) :\n  squarefree n \u2194 n.factors.nodup :=\nbegin\n  rw [unique_factorization_monoid.squarefree_iff_nodup_normalized_factors h0, nat.factors_eq],\n  simp,\nend\n\ntheorem squarefree_iff_prime_squarefree {n : \u2115} : squarefree n \u2194 \u2200 x, prime x \u2192 \u00ac x * x \u2223 n :=\nsquarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible \u27e8_, prime_two\u27e9\n\nlemma squarefree.factorization_le_one {n : \u2115} (p : \u2115) (hn : squarefree n) :\n  n.factorization p \u2264 1 :=\nbegin\n  rcases eq_or_ne n 0 with rfl | hn',\n  { simp },\n  rw [multiplicity.squarefree_iff_multiplicity_le_one] at hn,\n  by_cases hp : p.prime,\n  { have := hn p,\n    simp only [multiplicity_eq_factorization hp hn', nat.is_unit_iff, hp.ne_one, or_false] at this,\n    exact_mod_cast this },\n  { rw factorization_eq_zero_of_non_prime _ hp,\n    exact zero_le_one }\nend\n\nlemma squarefree_of_factorization_le_one {n : \u2115} (hn : n \u2260 0) (hn' : \u2200 p, n.factorization p \u2264 1) :\n  squarefree n :=\nbegin\n  rw [squarefree_iff_nodup_factors hn, list.nodup_iff_count_le_one],\n  intro a,\n  rw factors_count_eq,\n  apply hn',\nend\n\nlemma squarefree_iff_factorization_le_one {n : \u2115} (hn : n \u2260 0) :\n  squarefree n \u2194 \u2200 p, n.factorization p \u2264 1 :=\n\u27e8\u03bb p hn, squarefree.factorization_le_one hn p, squarefree_of_factorization_le_one hn\u27e9\n\n\n\nlemma squarefree_pow_iff {n k : \u2115} (hn : n \u2260 1) (hk : k \u2260 0) :\n  squarefree (n ^ k) \u2194 squarefree n \u2227 k = 1 :=\nbegin\n  refine \u27e8\u03bb h, _, by { rintro \u27e8hn, rfl\u27e9, simpa }\u27e9,\n  rcases eq_or_ne n 0 with rfl | hn\u2080,\n  { simpa [zero_pow hk.bot_lt] using h },\n  refine \u27e8squarefree_of_dvd_of_squarefree (dvd_pow_self _ hk) h, by_contradiction $ \u03bb h\u2081, _\u27e9,\n  have : 2 \u2264 k := k.two_le_iff.mpr \u27e8hk, h\u2081\u27e9,\n  apply hn (nat.is_unit_iff.1 (h _ _)),\n  rw \u2190sq,\n  exact pow_dvd_pow _ this\nend\n\nlemma squarefree_and_prime_pow_iff_prime {n : \u2115} :\n  squarefree n \u2227 is_prime_pow n \u2194 prime n :=\nbegin\n  refine iff.symm \u27e8\u03bb hn, \u27e8hn.squarefree, hn.is_prime_pow\u27e9, _\u27e9,\n  rw is_prime_pow_nat_iff,\n  rintro \u27e8h, p, k, hp, hk, rfl\u27e9,\n  rw squarefree_pow_iff hp.ne_one hk.ne' at h,\n  rwa [h.2, pow_one],\nend\n\n/-- Assuming that `n` has no factors less than `k`, returns the smallest prime `p` such that\n  `p^2 \u2223 n`. -/\ndef min_sq_fac_aux : \u2115 \u2192 \u2115 \u2192 option \u2115\n| n k :=\n  if h : n < k * k then none else\n  have nat.sqrt n + 2 - (k + 2) < nat.sqrt n + 2 - k,\n    by { rw nat.add_sub_add_right, exact nat.min_fac_lemma n k h },\n  if k \u2223 n then\n    let n' := n / k in\n    have nat.sqrt n' + 2 - (k + 2) < nat.sqrt n + 2 - k, from\n      lt_of_le_of_lt (nat.sub_le_sub_right\n        (nat.add_le_add_right (nat.sqrt_le_sqrt $ nat.div_le_self _ _) _) _) this,\n    if k \u2223 n' then some k else min_sq_fac_aux n' (k + 2)\n  else min_sq_fac_aux n (k + 2)\nusing_well_founded {rel_tac :=\n  \u03bb _ _, `[exact \u27e8_, measure_wf (\u03bb \u27e8n, k\u27e9, nat.sqrt n + 2 - k)\u27e9]}\n\n/-- Returns the smallest prime factor `p` of `n` such that `p^2 \u2223 n`, or `none` if there is no\n  such `p` (that is, `n` is squarefree). See also `squarefree_iff_min_sq_fac`. -/\ndef min_sq_fac (n : \u2115) : option \u2115 :=\nif 2 \u2223 n then\n  let n' := n / 2 in\n  if 2 \u2223 n' then some 2 else min_sq_fac_aux n' 3\nelse min_sq_fac_aux n 3\n\n/-- The correctness property of the return value of `min_sq_fac`.\n  * If `none`, then `n` is squarefree;\n  * If `some d`, then `d` is a minimal square factor of `n` -/\ndef min_sq_fac_prop (n : \u2115) : option \u2115 \u2192 Prop\n| none := squarefree n\n| (some d) := prime d \u2227 d * d \u2223 n \u2227 \u2200 p, prime p \u2192 p * p \u2223 n \u2192 d \u2264 p\n\ntheorem min_sq_fac_prop_div (n) {k} (pk : prime k) (dk : k \u2223 n) (dkk : \u00ac k * k \u2223 n)\n  {o} (H : min_sq_fac_prop (n / k) o) : min_sq_fac_prop n o :=\nbegin\n  have : \u2200 p, prime p \u2192 p*p \u2223 n \u2192 k*(p*p) \u2223 n := \u03bb p pp dp,\n    have _ := (coprime_primes pk pp).2 (\u03bb e, by { subst e, contradiction }),\n    (coprime_mul_iff_right.2 \u27e8this, this\u27e9).mul_dvd_of_dvd_of_dvd dk dp,\n  cases o with d,\n  { rw [min_sq_fac_prop, squarefree_iff_prime_squarefree] at H \u22a2,\n    exact \u03bb p pp dp, H p pp ((dvd_div_iff dk).2 (this _ pp dp)) },\n  { obtain \u27e8H1, H2, H3\u27e9 := H,\n    simp only [dvd_div_iff dk] at H2 H3,\n    exact \u27e8H1, dvd_trans (dvd_mul_left _ _) H2, \u03bb p pp dp, H3 _ pp (this _ pp dp)\u27e9 }\nend\n\ntheorem min_sq_fac_aux_has_prop : \u2200 {n : \u2115} k, 0 < n \u2192 \u2200 i, k = 2*i+3 \u2192\n  (\u2200 m, prime m \u2192 m \u2223 n \u2192 k \u2264 m) \u2192 min_sq_fac_prop n (min_sq_fac_aux n k)\n| n k := \u03bb n0 i e ih, begin\n  rw min_sq_fac_aux,\n  by_cases h : n < k*k; simp [h],\n  { refine squarefree_iff_prime_squarefree.2 (\u03bb p pp d, _),\n    have := ih p pp (dvd_trans \u27e8_, rfl\u27e9 d),\n    have := nat.mul_le_mul this this,\n    exact not_le_of_lt h (le_trans this (le_of_dvd n0 d)) },\n  have k2 : 2 \u2264 k, { subst e, exact dec_trivial },\n  have k0 : 0 < k := lt_of_lt_of_le dec_trivial k2,\n  have IH : \u2200 n', n' \u2223 n \u2192 \u00ac k \u2223 n' \u2192 min_sq_fac_prop n' (n'.min_sq_fac_aux (k + 2)),\n  { intros n' nd' nk,\n    have hn' := le_of_dvd n0 nd',\n    refine\n      have nat.sqrt n' - k < nat.sqrt n + 2 - k, from\n        lt_of_le_of_lt (nat.sub_le_sub_right (nat.sqrt_le_sqrt hn') _) (nat.min_fac_lemma n k h),\n      @min_sq_fac_aux_has_prop n' (k+2) (pos_of_dvd_of_pos nd' n0)\n        (i+1) (by simp [e, left_distrib]) (\u03bb m m2 d, _),\n    cases nat.eq_or_lt_of_le (ih m m2 (dvd_trans d nd')) with me ml,\n    { subst me, contradiction },\n    apply (nat.eq_or_lt_of_le ml).resolve_left, intro me,\n    rw [\u2190 me, e] at d, change 2 * (i + 2) \u2223 n' at d,\n    have := ih _ prime_two (dvd_trans (dvd_of_mul_right_dvd d) nd'),\n    rw e at this, exact absurd this dec_trivial },\n  have pk : k \u2223 n \u2192 prime k,\n  { refine \u03bb dk, prime_def_min_fac.2 \u27e8k2, le_antisymm (min_fac_le k0) _\u27e9,\n    exact ih _ (min_fac_prime (ne_of_gt k2)) (dvd_trans (min_fac_dvd _) dk) },\n  split_ifs with dk dkk,\n  { exact \u27e8pk dk, (nat.dvd_div_iff dk).1 dkk, \u03bb p pp d, ih p pp (dvd_trans \u27e8_, rfl\u27e9 d)\u27e9 },\n  { specialize IH (n/k) (div_dvd_of_dvd dk) dkk,\n    exact min_sq_fac_prop_div _ (pk dk) dk (mt (nat.dvd_div_iff dk).2 dkk) IH },\n  { exact IH n (dvd_refl _) dk }\nend\nusing_well_founded {rel_tac :=\n  \u03bb _ _, `[exact \u27e8_, measure_wf (\u03bb \u27e8n, k\u27e9, nat.sqrt n + 2 - k)\u27e9]}\n\ntheorem min_sq_fac_has_prop (n : \u2115) : min_sq_fac_prop n (min_sq_fac n) :=\nbegin\n  dunfold min_sq_fac, split_ifs with d2 d4,\n  { exact \u27e8prime_two, (dvd_div_iff d2).1 d4, \u03bb p pp _, pp.two_le\u27e9 },\n  { cases nat.eq_zero_or_pos n with n0 n0, { subst n0, cases d4 dec_trivial },\n    refine min_sq_fac_prop_div _ prime_two d2 (mt (dvd_div_iff d2).2 d4) _,\n    refine min_sq_fac_aux_has_prop 3 (nat.div_pos (le_of_dvd n0 d2) dec_trivial) 0 rfl _,\n    refine \u03bb p pp dp, succ_le_of_lt (lt_of_le_of_ne pp.two_le _),\n    rintro rfl, contradiction },\n  { cases nat.eq_zero_or_pos n with n0 n0, { subst n0, cases d2 dec_trivial },\n    refine min_sq_fac_aux_has_prop _ n0 0 rfl _,\n    refine \u03bb p pp dp, succ_le_of_lt (lt_of_le_of_ne pp.two_le _),\n    rintro rfl, contradiction },\nend\n\ntheorem min_sq_fac_prime {n d : \u2115} (h : n.min_sq_fac = some d) : prime d :=\nby { have := min_sq_fac_has_prop n, rw h at this, exact this.1 }\n\ntheorem min_sq_fac_dvd {n d : \u2115} (h : n.min_sq_fac = some d) : d * d \u2223 n :=\nby { have := min_sq_fac_has_prop n, rw h at this, exact this.2.1 }\n\ntheorem min_sq_fac_le_of_dvd {n d : \u2115} (h : n.min_sq_fac = some d)\n  {m} (m2 : 2 \u2264 m) (md : m * m \u2223 n) : d \u2264 m :=\nbegin\n  have := min_sq_fac_has_prop n, rw h at this,\n  have fd := min_fac_dvd m,\n  exact le_trans\n    (this.2.2 _ (min_fac_prime $ ne_of_gt m2) (dvd_trans (mul_dvd_mul fd fd) md))\n    (min_fac_le $ lt_of_lt_of_le dec_trivial m2),\nend\n\nlemma squarefree_iff_min_sq_fac {n : \u2115} :\n  squarefree n \u2194 n.min_sq_fac = none :=\nbegin\n  have := min_sq_fac_has_prop n,\n  split; intro H,\n  { cases n.min_sq_fac with d, {refl},\n    cases squarefree_iff_prime_squarefree.1 H _ this.1 this.2.1 },\n  { rwa H at this }\nend\n\ninstance : decidable_pred (squarefree : \u2115 \u2192 Prop) :=\n\u03bb n, decidable_of_iff' _ squarefree_iff_min_sq_fac\n\ntheorem squarefree_two : squarefree 2 := by rw squarefree_iff_nodup_factors; norm_num\n\nopen unique_factorization_monoid\n\nlemma divisors_filter_squarefree {n : \u2115} (h0 : n \u2260 0) :\n  (n.divisors.filter squarefree).val =\n    (unique_factorization_monoid.normalized_factors n).to_finset.powerset.val.map\n      (\u03bb x, x.val.prod) :=\nbegin\n  rw (finset.nodup _).ext ((finset.nodup _).map_on _),\n  { intro a,\n    simp only [multiset.mem_filter, id.def, multiset.mem_map, finset.filter_val, \u2190 finset.mem_def,\n      mem_divisors],\n    split,\n    { rintro \u27e8\u27e8an, h0\u27e9, hsq\u27e9,\n      use (unique_factorization_monoid.normalized_factors a).to_finset,\n      simp only [id.def, finset.mem_powerset],\n      rcases an with \u27e8b, rfl\u27e9,\n      rw mul_ne_zero_iff at h0,\n      rw unique_factorization_monoid.squarefree_iff_nodup_normalized_factors h0.1 at hsq,\n      rw [multiset.to_finset_subset, multiset.to_finset_val, hsq.dedup, \u2190 associated_iff_eq,\n        normalized_factors_mul h0.1 h0.2],\n      exact \u27e8multiset.subset_of_le (multiset.le_add_right _ _), normalized_factors_prod h0.1\u27e9 },\n    { rintro \u27e8s, hs, rfl\u27e9,\n      rw [finset.mem_powerset, \u2190 finset.val_le_iff, multiset.to_finset_val] at hs,\n      have hs0 : s.val.prod \u2260 0,\n      { rw [ne.def, multiset.prod_eq_zero_iff],\n        simp only [exists_prop, id.def, exists_eq_right],\n        intro con,\n        apply not_irreducible_zero (irreducible_of_normalized_factor 0\n            (multiset.mem_dedup.1 (multiset.mem_of_le hs con))) },\n      rw (normalized_factors_prod h0).symm.dvd_iff_dvd_right,\n      refine \u27e8\u27e8multiset.prod_dvd_prod_of_le (le_trans hs (multiset.dedup_le _)), h0\u27e9, _\u27e9,\n      have h := unique_factorization_monoid.factors_unique irreducible_of_normalized_factor\n        (\u03bb x hx, irreducible_of_normalized_factor x (multiset.mem_of_le\n          (le_trans hs (multiset.dedup_le _)) hx)) (normalized_factors_prod hs0),\n      rw [associated_eq_eq, multiset.rel_eq] at h,\n      rw [unique_factorization_monoid.squarefree_iff_nodup_normalized_factors hs0, h],\n      apply s.nodup } },\n  { intros x hx y hy h,\n    rw [\u2190 finset.val_inj, \u2190 multiset.rel_eq, \u2190 associated_eq_eq],\n    rw [\u2190 finset.mem_def, finset.mem_powerset] at hx hy,\n    apply unique_factorization_monoid.factors_unique _ _ (associated_iff_eq.2 h),\n    { intros z hz,\n      apply irreducible_of_normalized_factor z,\n      rw \u2190 multiset.mem_to_finset,\n      apply hx hz },\n    { intros z hz,\n      apply irreducible_of_normalized_factor z,\n      rw \u2190 multiset.mem_to_finset,\n      apply hy hz } }\nend\n\nopen_locale big_operators\n\nlemma sum_divisors_filter_squarefree {n : \u2115} (h0 : n \u2260 0)\n  {\u03b1 : Type*} [add_comm_monoid \u03b1] {f : \u2115 \u2192 \u03b1} :\n  \u2211 i in (n.divisors.filter squarefree), f i =\n    \u2211 i in (unique_factorization_monoid.normalized_factors n).to_finset.powerset, f (i.val.prod) :=\nby rw [finset.sum_eq_multiset_sum, divisors_filter_squarefree h0, multiset.map_map,\n    finset.sum_eq_multiset_sum]\n\nlemma sq_mul_squarefree_of_pos {n : \u2115} (hn : 0 < n) :\n  \u2203 a b : \u2115, 0 < a \u2227 0 < b \u2227 b ^ 2 * a = n \u2227 squarefree a :=\nbegin\n  let S := {s \u2208 finset.range (n + 1) | s \u2223 n \u2227 \u2203 x, s = x ^ 2},\n  have hSne : S.nonempty,\n  { use 1,\n    have h1 : 0 < n \u2227 \u2203 (x : \u2115), 1 = x ^ 2 := \u27e8hn, \u27e81, (one_pow 2).symm\u27e9\u27e9,\n    simpa [S] },\n  let s := finset.max' S hSne,\n  have hs : s \u2208 S := finset.max'_mem S hSne,\n  simp only [finset.sep_def, S, finset.mem_filter, finset.mem_range] at hs,\n  obtain \u27e8hsn1, \u27e8a, hsa\u27e9, \u27e8b, hsb\u27e9\u27e9 := hs,\n  rw hsa at hn,\n  obtain \u27e8hlts, hlta\u27e9 := canonically_ordered_comm_semiring.mul_pos.mp hn,\n  rw hsb at hsa hn hlts,\n  refine \u27e8a, b, hlta, (pow_pos_iff zero_lt_two).mp hlts, hsa.symm, _\u27e9,\n  rintro x \u27e8y, hy\u27e9,\n  rw nat.is_unit_iff,\n  by_contra hx,\n  refine lt_le_antisymm _ (finset.le_max' S ((b * x) ^ 2) _),\n  { simp_rw [S, hsa, finset.sep_def, finset.mem_filter, finset.mem_range],\n    refine \u27e8lt_succ_iff.mpr (le_of_dvd hn _), _, \u27e8b * x, rfl\u27e9\u27e9; use y; rw hy; ring },\n  { convert lt_mul_of_one_lt_right hlts\n      (one_lt_pow 2 x zero_lt_two (one_lt_iff_ne_zero_and_ne_one.mpr \u27e8\u03bb h, by simp * at *, hx\u27e9)),\n    rw mul_pow },\nend\n\nlemma sq_mul_squarefree_of_pos' {n : \u2115} (h : 0 < n) :\n  \u2203 a b : \u2115, (b + 1) ^ 2 * (a + 1) = n \u2227 squarefree (a + 1) :=\nbegin\n  obtain \u27e8a\u2081, b\u2081, ha\u2081, hb\u2081, hab\u2081, hab\u2082\u27e9 := sq_mul_squarefree_of_pos h,\n  refine \u27e8a\u2081.pred, b\u2081.pred, _, _\u27e9;\n  simpa only [add_one, succ_pred_eq_of_pos, ha\u2081, hb\u2081],\nend\n\nlemma sq_mul_squarefree (n : \u2115) : \u2203 a b : \u2115, b ^ 2 * a = n \u2227 squarefree a :=\nbegin\n  cases n,\n  { exact \u27e81, 0, (by simp), squarefree_one\u27e9 },\n  { obtain \u27e8a, b, -, -, h\u2081, h\u2082\u27e9 := sq_mul_squarefree_of_pos (succ_pos n),\n    exact \u27e8a, b, h\u2081, h\u2082\u27e9 },\nend\n\n/-- `squarefree` is multiplicative. Note that the \u2192 direction does not require `hmn`\nand generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and\n`squarefree.of_mul_right` above for auxiliary lemmas. -/\nlemma squarefree_mul {m n : \u2115} (hmn : m.coprime n) :\n  squarefree (m * n) \u2194 squarefree m \u2227 squarefree n :=\nbegin\n  simp only [squarefree_iff_prime_squarefree, \u2190sq, \u2190forall_and_distrib],\n  refine ball_congr (\u03bb p hp, _),\n  simp only [hmn.is_prime_pow_dvd_mul (hp.is_prime_pow.pow two_ne_zero), not_or_distrib],\nend\n\nend nat\n\n/-! ### Square-free prover -/\n\nopen norm_num\n\nnamespace tactic\nnamespace norm_num\n\n/-- A predicate representing partial progress in a proof of `squarefree`. -/\ndef squarefree_helper (n k : \u2115) : Prop :=\n0 < k \u2192 (\u2200 m, nat.prime m \u2192 m \u2223 bit1 n \u2192 bit1 k \u2264 m) \u2192 squarefree (bit1 n)\n\nlemma squarefree_bit10 (n : \u2115) (h : squarefree_helper n 1) :\n  squarefree (bit0 (bit1 n)) :=\nbegin\n  refine @nat.min_sq_fac_prop_div _ _ nat.prime_two two_dvd_bit0 _ none _,\n  { rw [bit0_eq_two_mul (bit1 n), mul_dvd_mul_iff_left (@two_ne_zero \u2115 _ _)],\n    exact nat.not_two_dvd_bit1 _ },\n  { rw [bit0_eq_two_mul, nat.mul_div_right _ (dec_trivial:0<2)],\n    refine h dec_trivial (\u03bb p pp dp, nat.succ_le_of_lt (lt_of_le_of_ne pp.two_le _)),\n    rintro rfl, exact nat.not_two_dvd_bit1 _ dp }\nend\n\nlemma squarefree_bit1 (n : \u2115) (h : squarefree_helper n 1) :\n  squarefree (bit1 n) :=\nbegin\n  refine h dec_trivial (\u03bb p pp dp, nat.succ_le_of_lt (lt_of_le_of_ne pp.two_le _)),\n  rintro rfl, exact nat.not_two_dvd_bit1 _ dp\nend\n\nlemma squarefree_helper_0 {k} (k0 : 0 < k)\n  {p : \u2115} (pp : nat.prime p) (h : bit1 k \u2264 p) : bit1 (k + 1) \u2264 p \u2228 bit1 k = p :=\nbegin\n  rcases lt_or_eq_of_le h with (hp:_+1\u2264_) | hp,\n  { rw [bit1, bit0_eq_two_mul] at hp, change 2*(_+1) \u2264 _ at hp,\n    rw [bit1, bit0_eq_two_mul],\n    refine or.inl (lt_of_le_of_ne hp _), unfreezingI { rintro rfl },\n    exact nat.not_prime_mul dec_trivial (lt_add_of_pos_left _ k0) pp },\n  { exact or.inr hp }\nend\n\nlemma squarefree_helper_1 (n k k' : \u2115) (e : k + 1 = k')\n  (hk : nat.prime (bit1 k) \u2192 \u00ac bit1 k \u2223 bit1 n)\n  (H : squarefree_helper n k') : squarefree_helper n k :=\n\u03bb k0 ih, begin\n  subst e,\n  refine H (nat.succ_pos _) (\u03bb p pp dp, _),\n  refine (squarefree_helper_0 k0 pp (ih p pp dp)).resolve_right (\u03bb hp, _),\n  subst hp, cases hk pp dp\nend\n\nlemma squarefree_helper_2 (n k k' c : \u2115) (e : k + 1 = k')\n  (hc : bit1 n % bit1 k = c) (c0 : 0 < c)\n  (h : squarefree_helper n k') : squarefree_helper n k :=\nbegin\n  refine squarefree_helper_1 _ _ _ e (\u03bb _, _) h,\n  refine mt _ (ne_of_gt c0), intro e\u2081,\n  rwa [\u2190 hc, \u2190 nat.dvd_iff_mod_eq_zero],\nend\n\nlemma squarefree_helper_3 (n n' k k' c : \u2115) (e : k + 1 = k')\n  (hn' : bit1 n' * bit1 k = bit1 n)\n  (hc : bit1 n' % bit1 k = c) (c0 : 0 < c)\n  (H : squarefree_helper n' k') : squarefree_helper n k :=\n\u03bb k0 ih, begin\n  subst e,\n  have k0' : 0 < bit1 k := bit1_pos (nat.zero_le _),\n  have dn' : bit1 n' \u2223 bit1 n := \u27e8_, hn'.symm\u27e9,\n  have dk : bit1 k \u2223 bit1 n := \u27e8_, ((mul_comm _ _).trans hn').symm\u27e9,\n  have : bit1 n / bit1 k = bit1 n',\n  { rw [\u2190 hn', nat.mul_div_cancel _ k0'] },\n  have k2 : 2 \u2264 bit1 k := nat.succ_le_succ (bit0_pos k0),\n  have pk : (bit1 k).prime,\n  { refine nat.prime_def_min_fac.2 \u27e8k2, le_antisymm (nat.min_fac_le k0') _\u27e9,\n    exact ih _ (nat.min_fac_prime (ne_of_gt k2)) (dvd_trans (nat.min_fac_dvd _) dk) },\n  have dkk' : \u00ac bit1 k \u2223 bit1 n', {rw [nat.dvd_iff_mod_eq_zero, hc], exact ne_of_gt c0},\n  have dkk : \u00ac bit1 k * bit1 k \u2223 bit1 n, {rwa [\u2190 nat.dvd_div_iff dk, this]},\n  refine @nat.min_sq_fac_prop_div _ _ pk dk dkk none _,\n  rw this, refine H (nat.succ_pos _) (\u03bb p pp dp, _),\n  refine (squarefree_helper_0 k0 pp (ih p pp $ dvd_trans dp dn')).resolve_right (\u03bb e, _),\n  subst e, contradiction\nend\n\nlemma squarefree_helper_4 (n k k' : \u2115) (e : bit1 k * bit1 k = k')\n  (hd : bit1 n < k') : squarefree_helper n k :=\nbegin\n  cases nat.eq_zero_or_pos n with h h,\n  { subst n, exact \u03bb _ _, squarefree_one },\n  subst e,\n  refine \u03bb k0 ih, irreducible.squarefree (nat.prime_def_le_sqrt.2 \u27e8bit1_lt_bit1.2 h, _\u27e9),\n  intros m m2 hm md,\n  obtain \u27e8p, pp, hp\u27e9 := nat.exists_prime_and_dvd (ne_of_gt m2),\n  have := (ih p pp (dvd_trans hp md)).trans\n    (le_trans (nat.le_of_dvd (lt_of_lt_of_le dec_trivial m2) hp) hm),\n  rw nat.le_sqrt at this,\n  exact not_le_of_lt hd this\nend\n\nlemma not_squarefree_mul (a aa b n : \u2115) (ha : a * a = aa) (hb : aa * b = n)\n  (h\u2081 : 1 < a) : \u00ac squarefree n :=\nby { rw [\u2190 hb, \u2190 ha], exact \u03bb H, ne_of_gt h\u2081 (nat.is_unit_iff.1 $ H _ \u27e8_, rfl\u27e9) }\n\n/-- Given `e` a natural numeral and `a : nat` with `a^2 \u2223 n`, return `\u22a2 \u00ac squarefree e`. -/\nmeta def prove_non_squarefree (e : expr) (n a : \u2115) : tactic expr := do\n  let ea := reflect a,\n  let eaa := reflect (a*a),\n  c \u2190 mk_instance_cache `(nat),\n  (c, p\u2081) \u2190 prove_lt_nat c `(1) ea,\n  let b := n / (a*a), let eb := reflect b,\n  (c, eaa, pa) \u2190 prove_mul_nat c ea ea,\n  (c, e', pb) \u2190 prove_mul_nat c eaa eb,\n  guard (e' =\u2090 e),\n  return $ `(@not_squarefree_mul).mk_app [ea, eaa, eb, e, pa, pb, p\u2081]\n\n/-- Given `en`,`en1 := bit1 en`, `n1` the value of `en1`, `ek`,\n  returns `\u22a2 squarefree_helper en ek`. -/\nmeta def prove_squarefree_aux : \u2200 (ic : instance_cache) (en en1 : expr) (n1 : \u2115)\n  (ek : expr) (k : \u2115), tactic expr\n| ic en en1 n1 ek k := do\n  let k1 := bit1 k,\n  let ek1 := `(bit1:\u2115\u2192\u2115).mk_app [ek],\n  if n1 < k1*k1 then do\n    (ic, ek', p\u2081) \u2190 prove_mul_nat ic ek1 ek1,\n    (ic, p\u2082) \u2190 prove_lt_nat ic en1 ek',\n    pure $ `(squarefree_helper_4).mk_app [en, ek, ek', p\u2081, p\u2082]\n  else do\n    let c := n1 % k1,\n    let k' := k+1, let ek' := reflect k',\n    (ic, p\u2081) \u2190 prove_succ ic ek ek',\n    if c = 0 then do\n      let n1' := n1 / k1,\n      let n' := n1' / 2, let en' := reflect n',\n      let en1' := `(bit1:\u2115\u2192\u2115).mk_app [en'],\n      (ic, _, pn') \u2190 prove_mul_nat ic en1' ek1,\n      let c := n1' % k1,\n      guard (c \u2260 0),\n      (ic, ec, pc) \u2190 prove_div_mod ic en1' ek1 tt,\n      (ic, p\u2080) \u2190 prove_pos ic ec,\n      p\u2082 \u2190 prove_squarefree_aux ic en' en1' n1' ek' k',\n      pure $ `(squarefree_helper_3).mk_app [en, en', ek, ek', ec, p\u2081, pn', pc, p\u2080, p\u2082]\n    else do\n      (ic, ec, pc) \u2190 prove_div_mod ic en1 ek1 tt,\n      (ic, p\u2080) \u2190 prove_pos ic ec,\n      p\u2082 \u2190 prove_squarefree_aux ic en en1 n1 ek' k',\n      pure $ `(squarefree_helper_2).mk_app [en, ek, ek', ec, p\u2081, pc, p\u2080, p\u2082]\n\n/-- Given `n > 0` a squarefree natural numeral, returns `\u22a2 squarefree n`. -/\nmeta def prove_squarefree (en : expr) (n : \u2115) : tactic expr :=\nmatch match_numeral en with\n| match_numeral_result.one := pure `(@squarefree_one \u2115 _)\n| match_numeral_result.bit0 en1 := match match_numeral en1 with\n  | match_numeral_result.one := pure `(nat.squarefree_two)\n  | match_numeral_result.bit1 en := do\n    ic \u2190 mk_instance_cache `(\u2115),\n    p \u2190 prove_squarefree_aux ic en en1 (n / 2) `(1:\u2115) 1,\n    pure $ `(squarefree_bit10).mk_app [en, p]\n  | _ := failed\n  end\n| match_numeral_result.bit1 en' := do\n  ic \u2190 mk_instance_cache `(\u2115),\n  p \u2190 prove_squarefree_aux ic en' en n `(1:\u2115) 1,\n  pure $ `(squarefree_bit1).mk_app [en', p]\n| _ := failed\nend\n\n/-- Evaluates the `prime` and `min_fac` functions. -/\n@[norm_num] meta def eval_squarefree : expr \u2192 tactic (expr \u00d7 expr)\n| `(squarefree (%%e : \u2115)) := do\n  n \u2190 e.to_nat,\n  match n with\n  | 0 := false_intro `(@not_squarefree_zero \u2115 _ _)\n  | 1 := true_intro `(@squarefree_one \u2115 _)\n  | _ := match n.min_sq_fac with\n    | some d := prove_non_squarefree e n d >>= false_intro\n    | none := prove_squarefree e n >>= true_intro\n    end\n  end\n| _ := failed\n\nend norm_num\nend tactic\n"}
{"text": "module PatternSyn where\n\ndata \u22a4\n  : Set\n  where\n\n  tt\n    : \u22a4\n\ndata D\n  (A : Set)\n  : Set\n  where\n\n  d\n    : A\n    \u2192 A\n    \u2192 D A\n\npattern p\n  = tt\n\npattern q\n  = tt\n\npattern _,_ x y\n  = d x y\n\nf\n  : \u22a4\n  \u2192 \u22a4\nf p\n  = tt\n\ng\n  : {A : Set}\n  \u2192 D A\n  \u2192 A\ng (x , _)\n  = x\n\n"}
{"text": "lemma bounded_empty [simp]: \"bounded {}\""}
{"text": "State Before: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\n\u22a2 Finset.sum A (Nat.pow 2) < 2 ^ k State After: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < 2 ^ k Tactic: apply lt_of_le_of_lt (sum_le_sum_of_subset fun t => mem_range.2 \u2218 h\u2081) State Before: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < 2 ^ k State After: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\nz : (\u2211 i in range k, (1 + 1) ^ i) * 1 + 1 = (1 + 1) ^ k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < 2 ^ k Tactic: have z := geom_sum_mul_add 1 k State Before: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\nz : (\u2211 i in range k, (1 + 1) ^ i) * 1 + 1 = (1 + 1) ^ k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < 2 ^ k State After: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\nz : \u2211 i in range k, 2 ^ i + 1 = 2 ^ k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < 2 ^ k Tactic: rw [mul_one, one_add_one_eq_two] at z State Before: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\nz : \u2211 i in range k, 2 ^ i + 1 = 2 ^ k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < 2 ^ k State After: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\nz : \u2211 i in range k, 2 ^ i + 1 = 2 ^ k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < \u2211 i in range k, 2 ^ i + 1 Tactic: rw [\u2190 z] State Before: \u03b1 : Type ?u.638\nk : \u2115\nA : Finset \u2115\nh\u2081 : \u2200 {x : \u2115}, x \u2208 A \u2192 x < k\nz : \u2211 i in range k, 2 ^ i + 1 = 2 ^ k\n\u22a2 \u2211 x in range k, Nat.pow 2 x < \u2211 i in range k, 2 ^ i + 1 State After: no goals Tactic: apply Nat.lt_succ_self"}
{"text": "lemma interior_hyperplane [simp]: assumes \"a \\<noteq> 0\" shows \"interior {x. a \\<bullet> x = b} = {}\""}
{"text": "import GMLInit.Meta.Prelude\n\ntheorem eqRec_eq_cast {\u03b1} {a b : \u03b1} {motive : (b : \u03b1) \u2192 a = b \u2192 Sort _} (t : motive a rfl) (h : a = b) : Eq.rec t h = cast (show motive a rfl = motive b h by cases h; rfl) t := by cases h; rfl\n\ntheorem eqNdrec_eq_cast {\u03b1} {a b : \u03b1} {motive : \u03b1 \u2192 Sort _} (t : motive a) (h : a = b) : Eq.ndrec t h = cast (h \u25b8 rfl) t := by cases h; rfl\n\ntheorem eqNdrec_symm {\u03b1} {motive : \u03b1 \u2192 Sort _} {a b : \u03b1} (h : a = b) (x : motive a) (y : motive b) : Eq.ndrec x h = y \u2194 x = Eq.ndrec y h.symm := by cases h; exact Iff.rfl\n\n@[elim_casts] theorem cast_irrel {\u03b1 \u03b2} (h\u2081 h\u2082 : \u03b1 = \u03b2) (a : \u03b1) : cast h\u2081 a = cast h\u2082 a := rfl\n\n@[elim_casts] theorem cast_refl {\u03b1} (a : \u03b1) : cast rfl a = a := rfl\n\n@[elim_casts] theorem cast_trans {\u03b1 \u03b2 \u03b3} (h\u2081 : \u03b1 = \u03b2) (h\u2082 : \u03b2 = \u03b3) (a : \u03b1) : cast h\u2082 (cast h\u2081 a) = cast (Eq.trans h\u2081 h\u2082) a := by cases h\u2081; cases h\u2082; rfl\n\n@[elim_casts] theorem cast_symm {\u03b1 \u03b2} (h : \u03b1 = \u03b2) (a : \u03b1) (b : \u03b2) : cast h a = b \u2194 a = cast h.symm b := by cases h; exact Iff.rfl\n"}
{"text": "import VISD.Binary\n\ntest : Syntax d Nat => d (Nat, Nat) Nat\ntest = (val 1) <*> item\n   <|> (val 2) <*> (val 3)\n\ntest2 : Syntax d Bool => d (Nat, Bool) Bool\ntest2 = (nat BE 4) <*> (val True)\n    <|> (nat BE 2) <*> (val False)\n\npartial test3 : Syntax d Bool => d (Bool, List Nat) Bool\ntest3 = (val True) <*> ((ignore False <$> item) *> (many $ nat BE 4))\n    <|> (val False) <*> ((ignore True <$> item) *> (many $ nat LE 3))\n\ntest4 : Syntax d Bool => d (Vect 2 Nat, Bool) Bool\ntest4 = rep 2 (nat LE 4) <*> val True\n    <|> rep 2 (nat BE 3) <*> val False\n\n\nmain : IO ()\nmain = do\n  putStrLn $ show $ parse test4 [False, False, True, False, True, False, False] >>= compose test4\n"}
{"text": "-- Copyright \u00a9 2019 Fran\u00e7ois G. Dorais. All rights reserved.\n-- Released under Apache 2.0 license as described in the file LICENSE.\n\n\ntheorem not_exists_of_forall_not {\u03b1 : Sort*} {p : \u03b1 \u2192 Prop} :\n(\u2200 x, \u00ac p x) \u2192 \u00ac (\u2203 x, p x) := \u03bb h \u27e8x, hx\u27e9, h x hx\n\ntheorem not_exists_iff_forall_not {\u03b1 : Sort*} (p : \u03b1 \u2192 Prop) :\n\u00ac (\u2203 x, p x) \u2194 (\u2200 x, \u00ac p x) := \u27e8forall_not_of_not_exists, not_exists_of_forall_not\u27e9\n"}
{"text": "import number_theory.sum_four_squares\n\nlemma t019 : \u2200 n : \u2115, \u2203 a b c d : \u2115, a^2 + b^2 + c^2 + d^2 = n\n:= nat.sum_four_squares\n"}
{"text": "## takes in\n## * data\n## * filename\n\nsave( data, file = filename )\n"}
{"text": "State Before: a : Code \u00d7 \u2115\n\u22a2 (rfindOpt fun b =>\n      evaln (((a, b).snd, (a, b).fst.fst), (a, b).fst.snd).fst.fst\n        (((a, b).snd, (a, b).fst.fst), (a, b).fst.snd).fst.snd (((a, b).snd, (a, b).fst.fst), (a, b).fst.snd).snd) =\n    eval a.fst a.snd State After: no goals Tactic: simp [eval_eq_rfindOpt]"}
{"text": "import category_theory.category\nimport category_theory.functor\nimport help_functions\nimport set_category.colimits.Coequalizer\nimport coalgebra.Coalgebra\nimport coalgebra.colimits.coalgebra_sum\nimport coalgebra.colimits.coalgebra_coequalizer\nimport set_category.colimits.Pushout\nimport set_category.colimits.Sum\nimport set_category.category_set\n\n\nimport tactic.tidy\n\nuniverses u\n\n\n\nnamespace coalgebra_pushout\n\nopen category_theory \n     set \n     sum\n     Sum\n     classical\n     function\n     help_functions\n     Coequalizer\n     coalgebra\n     coalgebra_sum\n     coalgebra_coequalizer\n     Pushout\n     category_set\n     \n\n\nlocal notation f ` \u229a `:80 g:80 := category_struct.comp g f\n\nvariables   {F : Type u \u2964 Type u}\n            {\ud835\udd38 \u0392\u2081 \u0392\u2082: Coalgebra F} \n            (\u03d5 : \ud835\udd38 \u27f6 \u0392\u2081)\n            (\u03c8 : \ud835\udd38 \u27f6 \u0392\u2082)\n\n\ntheorem pushout_is_coalgebra :\n    let S := \u0392\u2081 \u229e \u0392\u2082  in\n    let \u0392_\u0398 := @theta \ud835\udd38 S (inl \u2218 \u03d5) (inr \u2218 \u03c8) in\n    let \u03c0_\u0398 := @coequalizer \ud835\udd38 S (inl \u2218 \u03d5) (inr \u2218 \u03c8) in\n    \u2203! \u03b1 : \u0392_\u0398 \u2192 F.obj \u0392_\u0398,  \n    let P : Coalgebra F := \u27e8\u0392_\u0398, \u03b1\u27e9 in \n    @is_coalgebra_homomorphism F \u0392\u2081 P (\u03c0_\u0398 \u2218 inl) \u2227 \n    @is_coalgebra_homomorphism F \u0392\u2082 P (\u03c0_\u0398 \u2218 inr)  := \n    begin\n        assume S \u0392_\u0398 \u03c0_\u0398,\n\n        have po1 : \u03c0_\u0398 \u2218 inl \u2218 \u03d5 = \u03c0_\u0398 \u2218 inr \u2218 \u03c8\n                   := (coequalizer_sum_is_pushout \u03d5 \u03c8).1,\n\n        let p\u2081 : \ud835\udd38 \u2192 S := (inl \u2218 \u03d5),\n        let p\u2082 : \ud835\udd38 \u2192 S := (inr \u2218 \u03c8),\n\n        have hom_p\u2081 : is_coalgebra_homomorphism p\u2081 := \n            @comp_is_hom F \ud835\udd38 \u0392\u2081 S \u03d5 \u27e8inl, inl_is_homomorphism \u0392\u2081 \u0392\u2082\u27e9,\n\n        have hom_p\u2082 : is_coalgebra_homomorphism p\u2082 := \n            @comp_is_hom F \ud835\udd38 \u0392\u2082 S \u03c8 \u27e8inr, inr_is_homomorphism \u0392\u2081 \u0392\u2082\u27e9,\n\n        have co : _ := coequalizer_is_homomorphism \n                        \u27e8p\u2081, hom_p\u2081\u27e9 \u27e8p\u2082,  hom_p\u2082\u27e9,\n        let \u03b1 := some co,\n        have hom_\u03c0 : @is_coalgebra_homomorphism F S \u27e8\u0392_\u0398 , \u03b1\u27e9 \u03c0_\u0398\n                := (some_spec co).1,\n        let P : Coalgebra F := \u27e8\u0392_\u0398, \u03b1\u27e9,\n\n        have hom_\u03c0_inl : \u03b1 \u2218 (\u03c0_\u0398 \u2218 inl) = (F.map (\u03c0_\u0398 \u2218 inl)) \u2218 \u0392\u2081.\u03b1\n                    := @comp_is_hom F \u0392\u2081 S P \n                        \u27e8inl, inl_is_homomorphism \u0392\u2081 \u0392\u2082\u27e9\n                        \u27e8\u03c0_\u0398, hom_\u03c0\u27e9,\n\n        have hom_\u03c0_inr : \u03b1 \u2218 (\u03c0_\u0398 \u2218 inr) = (F.map (\u03c0_\u0398 \u2218 inr)) \u2218 \u0392\u2082.\u03b1\n                    := @comp_is_hom F \u0392\u2082 S P \n                        \u27e8inr, inr_is_homomorphism \u0392\u2081 \u0392\u2082\u27e9\n                        \u27e8\u03c0_\u0398, hom_\u03c0\u27e9,\n\n        use \u03b1,\n        split,\n        exact \u27e8hom_\u03c0_inl , hom_\u03c0_inr\u27e9 ,\n\n        intros \u03b1\u2081 hom,\n\n        have hom1 : \u03b1\u2081 \u2218 (\u03c0_\u0398 \u2218 inl) = (F.map (\u03c0_\u0398 \u2218 inl)) \u2218 \u0392\u2081.\u03b1 := hom.1,\n\n        have hom2 : \u03b1\u2081 \u2218 (\u03c0_\u0398 \u2218 inr) = (F.map (\u03c0_\u0398 \u2218 inr)) \u2218 \u0392\u2082.\u03b1 := hom.2,\n\n        have \u03b1_\u03b1\u2081_l : \u03b1\u2081 \u2218 \u03c0_\u0398 \u2218 inl = \u03b1 \u2218 \u03c0_\u0398 \u2218 inl := \n                by simp [hom_\u03c0_inl, hom1],\n\n        have \u03b1_\u03b1\u2081_r : \u03b1\u2081 \u2218 \u03c0_\u0398 \u2218 inr = \u03b1 \u2218 \u03c0_\u0398 \u2218 inr := \n                by simp [hom_\u03c0_inr, hom2],\n\n        have \u03b1_\u03b1\u2081_\u03c0 : \u03b1\u2081 \u2218 \u03c0_\u0398 = \u03b1 \u2218 \u03c0_\u0398 := \n            jointly_epi (\u03b1 \u2218 \u03c0_\u0398) (\u03b1\u2081 \u2218 \u03c0_\u0398) \u03b1_\u03b1\u2081_l \u03b1_\u03b1\u2081_r,\n\n        let mor_\u03c0 : (\u0392\u2081 \u2295 \u0392\u2082) \u27f6 \u0392_\u0398 := \u03c0_\u0398,\n        haveI ep : epi mor_\u03c0 := \n            (epi_iff_surjective mor_\u03c0).2 \n            (quot_is_surjective (inl \u2218 \u03d5) (inr \u2218 \u03c8)),\n\n        exact right_cancel mor_\u03c0 \u03b1_\u03b1\u2081_\u03c0,\n    end\n\n\nend coalgebra_pushout"}
{"text": "(*\nSous emacs, pour avoir les symboles il faut avoir une font adequat (par exemple: \"Mono\")\nPour taper les symboles utf8, il faut faire:\n\n M-x set-input-method TeX\n\nensuite il suffit de taper la commande latex correspondante.\n\n\u2295  \\oplus\n\u2297 \\otimes\n\u22b8 \\multimap\n\u22a4 \\top\n\u22a2 \\vdash\n*)\nRequire Import multiset_spec.\nRequire Import ILL_spec.\nRequire Import OrderedType.\nRequire Import Utf8_core.\nRequire Import vars.\n\nRequire Import ILL.\n(** Les preuves de epsrc_case_for_support.pdf. *)\n(* Module MakePaperProofs(Vars : OrderedType)(M : ILL_sig(Vars)).\n  Import M.\n  Import FormulaMultiSet.\n  Module Import Tactics := ILL_tactics(Vars)(M).\n  (** Figure 1 de epsrc_case_for_support. *)\n  Section figure_1.\n    Parameters vD vP vR vS : Vars.t.\n    Local Notation \"'D'\" := (Proposition vD).\n    Local Notation \"'P'\" := (Proposition vP).\n    Local Notation \"'R'\":= (Proposition vR).\n    Local Notation \"'S'\" := (Proposition vS).\n\n    Hypothesis D_neq_P : not (Vars.eq vD vP).\n    Hypothesis D_neq_R : not (Vars.eq vD vR).\n    Hypothesis D_neq_S : not (Vars.eq vD vS).\n    Hypothesis P_neq_R : not (Vars.eq vP vR).\n    Hypothesis P_neq_S : not (Vars.eq vP vS).\n    Hypothesis R_neq_S : not (Vars.eq vR vS).\n\n\n    Lemma Proof_from_figure_1:  {D, P & 1, R & 1, D \u22b8 (((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D)} \u22a2 ((S \u2297 D) \u2295 D).\n    Proof with (try complete (try constructor; prove_multiset_eq)).\n      impl_l ({D}) ({(P&1) , (R&1) })\n        (D) ((((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D))...\n    (* search_one_goal ({D, (P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S))), P & 1, R & 1} \u22a2 (S \u2297 D) \u2295 D). *)\n      times_l ((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) D.\n      oplus_l (P \u22b8 S) (R \u22b8 (1 \u2295 (P \u22b8 S))).\n    (* search_one_goal    ({P, P \u22b8 S, D, R & 1} \u22a2 (S \u2297 D) \u2295 D). *)\n      and_l_1 P 1.\n    (* search_one_goal ({1, P, P \u22b8 S, D} \u22a2 (S \u2297 D) \u2295 D). *)\n      and_l_2 R 1.\n    (* search_one_goal ({P, P \u22b8 S, D} \u22a2 (S \u2297 D) \u2295 D). *)\n      one_l.\n      apply Oplus_R_1.\n      times_r ({P, (P \u22b8 S) }) ({D})...\n      impl_l  ({P}) (\u2205) (P) (S)...\n      and_l_1 R 1.\n      impl_l({R}) ({D, P & 1 }) (R) ((1 \u2295 (P \u22b8 S)))...\n      oplus_l 1 (P \u22b8 S).\n      one_l.\n      and_l_2 P 1.\n      one_l.\n      apply Oplus_R_2...\n      and_l_1 (P) 1.\n      apply Oplus_R_1.\n      times_r ({ P , P \u22b8 S}) ({D})...\n      impl_l ({P}) (\u2205) (P) (S)...\n    Qed.\n\n    (* Same proof as above but with some more automation *)\n    Lemma Copy_Proof_from_figure_1_with_weak_search:\n    {D, P & 1, R & 1, D \u22b8 (((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D)} \u22a2 ((S \u2297 D) \u2295 D).\n    Proof with (try complete (try constructor; prove_multiset_eq)).\n      impl_l  ({D}) ({(P&1) , (R&1) }) (D) ((((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D))...\n      search_one_goal ({D, (P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S))), P & 1, R & 1} \u22a2 (S \u2297 D) \u2295 D).\n      oplus_l (P \u22b8 S) (R \u22b8 (1 \u2295 (P \u22b8 S))).\n      search_one_goal ({P, P \u22b8 S, D} \u22a2 (S \u2297 D) \u2295 D).\n      apply Oplus_R_1.\n      times_r ({P, (P \u22b8 S) }) ({D})...\n      impl_l ({P}) (\u2205) (P) (S)...\n      search_one_goal ({R, R \u22b8 (1 \u2295 (P \u22b8 S)), D, P & 1} \u22a2 (S \u2297 D) \u2295 D).\n      impl_l ({R}) ({D, P & 1 }) (R) ((1 \u2295 (P \u22b8 S)))...\n      oplus_l 1 (P \u22b8 S).\n      search_one_goal ({D} \u22a2 (S \u2297 D) \u2295 D).\n      apply Oplus_R_2...\n      search_one_goal ( {P \u22b8 S, D, P} \u22a2 (S \u2297 D) \u2295 D).\n      apply Oplus_R_1.\n      times_r ({ P , P \u22b8 S}) ({D})...\n      impl_l ({P}) (\u2205) (P) (S)...\n    Qed.\n\n\n    Lemma Copy_Proof_from_figure_1_with_stronger_search:\n    {D, P & 1, R & 1, D \u22b8 (((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D)} \u22a2 ((S \u2297 D) \u2295 D).\n    Proof with try complete (finish_proof_strong || prove_multiset_eq).\n      search_one_goal_strong ({D, (P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S))), P & 1, R & 1} \u22a2 (S \u2297 D) \u2295 D).\n      oplus_l (P \u22b8 S) (R \u22b8 (1 \u2295 (P \u22b8 S))).\n\n      search_one_goal_strong ({P, P \u22b8 S, D} \u22a2 (S \u2297 D)).\n      times_r ({P, (P \u22b8 S) }) ({D})...\n\n      search_one_goal_strong ({1 \u2295 (P \u22b8 S), D, P & 1} \u22a2 (S \u2297 D) \u2295 D).\n      oplus_l 1 (P \u22b8 S)...\n      search_one_goal_strong ( {P \u22b8 S, D, P} \u22a2 (S \u2297 D)).\n      times_r  ({ P , P \u22b8 S}) ({D})...\n    Qed.\n  End figure_1.\n\n  (** Figure 5 de epsrc_case_for_support. *)\n  Section figure_5.\n    Parameters vD' vD0' vD1' vD2' vH' vF' vG' vM' vL' : Vars.t.\n    Local Notation \"'D'\" := (Proposition vD').\n    Local Notation \"'D\u2081'\" := (Proposition vD1').\n    Local Notation \"'D\u2080'\" := (Proposition vD0').\n    Local Notation \"'D\u2082'\" := (Proposition vD2').\n    Local Notation \"'H'\" := (Proposition vH').\n    Local Notation \"'F'\":= (Proposition vF').\n    Local Notation \"'G'\" := (Proposition vG').\n    Local Notation \"'M'\" := (Proposition vM').\n    Local Notation \"'L'\" := (Proposition vL').\n\n\n    Local Notation \"'\u03c1'\" := { H,F,L,D\u2082, G\u22b8(!(H\u22b8(H\u2297M))) }.\n    Local Notation \"'\u03bc'\" := { !((D\u2081\u2297M)\u22b8D\u2080),!((D\u2082\u2297M)\u22b8D\u2081)}.\n    Local Notation \"'\u03bb'\" := { !((L\u2297D\u2080)\u22b8(L\u2297D\u2081)),!((L\u2297D\u2081)\u22b8(L\u2297D\u2082))}.\n\n\n  Ltac bang_c  p'   := \n    match goal with \n      |- ILL_proof ?env _ =>\n        match env with\n          | context C [(!p'::?env')] =>\n            let e := context C [ env' ] in  \n              with_multiset (!p'::e) ltac:(apply Bang_C)\n        end\n    end.\n\n  Ltac bang_d  p'   := \n    match goal with \n      |- ILL_proof ?env _ =>\n        match env with\n          | context C [(!p'::?env')] =>\n            let e := context C [ env' ] in  \n              with_multiset (!p'::e) ltac:(apply Bang_D)\n        end\n    end.\n\n    Lemma figure_5 : \n      {H,L,G,D\u2082,G\u22b8!(H\u22b8(H\u2297M)),(L\u2297(D\u2082\u2297H))\u22b8(L\u2297(D\u2080\u2297((L\u2297D\u2082)\u22b8D)))}\u222a\u03bb\u222a\u03bc\u22a2D.\n    Proof with try complete (finish_proof_strong || prove_multiset_eq).\n      search_one_goal_strong ({H,L,D\u2082,!(H\u22b8(H\u2297M)),(L\u2297(D\u2082\u2297H))\u22b8(L\u2297(D\u2080\u2297((L\u2297D\u2082)\u22b8D)))}\u222a\u03bb\u222a\u03bc\u22a2D).\n      bang_c (H\u22b8(H\u2297M)).\n      bang_d ((H\u22b8(H\u2297M))).\n      search_one_goal_strong ((H \u2297 M)\n        :: {L, D\u2082, !(H \u22b8 (H \u2297 M)),\n          (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \n        \u03bb \u222a \u03bc\u22a2D).\n      search_one_goal_strong ( {H ,M,L, D\u2082, !(H \u22b8 (H \u2297 M)),\n        (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \n      \u03bb \u222a \u03bc\u22a2D).\n      bang_c ((D\u2082\u2297M)\u22b8D\u2081).\n      bang_d ((D\u2082\u2297M)\u22b8D\u2081).\n      impl_l {M,D\u2082} ({H, L,  !(H \u22b8 (H \u2297 M)), (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \u03bb \u222a \u03bc) (D\u2082\u2297M) (D\u2081).\n      times_r ({ D\u2082}) ({M})...\n      search_one_goal_strong ({D\u2081,H, L,  (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \u03bb \u22a2 D).\n      bang_c ((L\u2297D\u2081)\u22b8(L\u2297D\u2082))...\n      bang_d ((L\u2297D\u2081)\u22b8(L\u2297D\u2082))...\n      impl_l ({L,D\u2081}) ({H, (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))}\u222a\u03bb) (L\u2297D\u2081) (L\u2297D\u2082)...\n      times_r  ({L}) ({D\u2081})...\n      search_one_goal_strong ({L,D\u2082,H, (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \u03bb \u22a2 D).\n      impl_l ({L,D\u2082,H}) ({ !((L\u2297D\u2080)\u22b8(L\u2297D\u2081)),!((L\u2297D\u2081)\u22b8(L\u2297D\u2082))}) (L\u2297(D\u2082\u2297H)) ((L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D))))...\n      times_r ({L}) ({D\u2082,H})...\n      times_r ({D\u2082}) ({H})...\n      search_one_goal_strong ({L,D\u2080,((L \u2297 D\u2082) \u22b8 D)}\u222a\u03bb\u22a2D).\n      bang_c ((L\u2297D\u2080)\u22b8(L\u2297D\u2081))...\n      bang_d ((L\u2297D\u2080)\u22b8(L\u2297D\u2081))...\n      impl_l \n        ({L,D\u2080})\n        ({!((L \u2297 D\u2080) \u22b8 (L \u2297 D\u2081)), (L \u2297 D\u2082) \u22b8 D, !((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082))})\n        (L\u2297D\u2080)\n        (L\u2297D\u2081)...\n      times_r ({L}) ({D\u2080})...\n      search_one_goal_strong (   {L \u2297 D\u2081, (L \u2297 D\u2082) \u22b8 D, !((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082))} \u22a2 D).\n      bang_c \n      (((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082)))...\n      bang_d \n        (((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082)))...\n    Qed.  \n\n  End figure_5.\nEnd MakePaperProofs.\n*)\nRequire Import String.\nRequire Import Setoid.\n\n\nModule PaperProofsString.\n  Module M := ILL_Make(VarsString).\n  Import M.\n  Import FormulaMultiSet.\n  Include ILL_tactics_refl(VarsString)(M).\n\n  (** Figure 1 de epsrc_case_for_support. *)\n  Section figure_1.\n\n  Local Notation \"'D'\" := (Proposition \"D\"%string).\n  Local Notation \"'P'\" := (Proposition \"P\"%string).\n  Local Notation \"'R'\":= (Proposition \"R\"%string).\n  Local Notation \"'S'\" := (Proposition \"S\"%string).\n\n  Lemma Copy_Proof_from_figure_1:\n  {D, P & 1, R & 1, D \u22b8 (((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D)} \u22a2 ((S \u2297 D) \u2295 D).\n  Proof with (try now (try constructor; prove_multiset_eq)).\n      impl_l ({D}) ({(P&1) , (R&1) })\n        (D) ((((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D))...\n    (* search_one_goal ({D, (P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S))), P & 1, R & 1} \u22a2 (S \u2297 D) \u2295 D). *)\n      times_l ((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) D.\n      oplus_l (P \u22b8 S) (R \u22b8 (1 \u2295 (P \u22b8 S))).\n    (* search_one_goal    ({P, P \u22b8 S, D, R & 1} \u22a2 (S \u2297 D) \u2295 D). *)\n      and_l_1 P 1.\n    (* search_one_goal ({1, P, P \u22b8 S, D} \u22a2 (S \u2297 D) \u2295 D). *)\n      and_l_2 R 1.\n    (* search_one_goal ({P, P \u22b8 S, D} \u22a2 (S \u2297 D) \u2295 D). *)\n      one_l.\n      apply Oplus_R_1.\n      times_r ({P, (P \u22b8 S) }) ({D})...\n      impl_l  ({P}) (\u2205) (P) (S)...\n      and_l_1 R 1.\n      impl_l({R}) ({D, P & 1 }) (R) ((1 \u2295 (P \u22b8 S)))...\n      oplus_l 1 (P \u22b8 S).\n      one_l.\n      and_l_2 P 1.\n      one_l.\n      apply Oplus_R_2...\n      and_l_1 (P) 1.\n      apply Oplus_R_1.\n      times_r ({ P , P \u22b8 S}) ({D})...\n      impl_l ({P}) (\u2205) (P) (S)...\n    Qed.\n\n  (* Same proof as above but with some more automation *)\n  Lemma Copy_Proof_from_figure_1_with_weak_search:\n  {D, P & 1, R & 1, D \u22b8 (((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D)} \u22a2 ((S \u2297 D) \u2295 D).\n  Proof with (try now (try constructor; prove_multiset_eq)).\n    impl_l  ({D}) ({(P&1) , (R&1) }) (D) ((((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D))...\n    search_one_goal ({D, (P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S))), P & 1, R & 1} \u22a2 (S \u2297 D) \u2295 D).\n    oplus_l (P \u22b8 S) (R \u22b8 (1 \u2295 (P \u22b8 S))).\n    search_one_goal ({P, P \u22b8 S, D} \u22a2 (S \u2297 D) \u2295 D).\n    apply Oplus_R_1.\n    times_r ({P, (P \u22b8 S) }) ({D})...\n    impl_l ({P}) (\u2205) (P) (S)...\n    search_one_goal ({R, R \u22b8 (1 \u2295 (P \u22b8 S)), D, P & 1} \u22a2 (S \u2297 D) \u2295 D).\n    impl_l ({R}) ({D, P & 1 }) (R) ((1 \u2295 (P \u22b8 S)))...\n    oplus_l 1 (P \u22b8 S).\n    search_one_goal ({D} \u22a2 (S \u2297 D) \u2295 D).\n    apply Oplus_R_2...\n    search_one_goal ( {P \u22b8 S, D, P} \u22a2 (S \u2297 D) \u2295 D).\n    apply Oplus_R_1.\n    times_r ({ P , P \u22b8 S}) ({D})...\n    impl_l ({P}) (\u2205) (P) (S)...\n  Qed.\n\n  Lemma Copy_Proof_from_figure_1_with_stronger_search:\n    {D, P & 1, R & 1, D \u22b8 (((P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S)))) \u2297 D)} \u22a2 ((S \u2297 D) \u2295 D).\n  Proof with try now (finish_proof_strong || prove_multiset_eq).\n    search_one_goal_strong ({D, (P \u22b8 S) \u2295 (R \u22b8 (1 \u2295 (P \u22b8 S))), P & 1, R & 1} \u22a2 (S \u2297 D) \u2295 D).\n    oplus_l (P \u22b8 S) (R \u22b8 (1 \u2295 (P \u22b8 S))).\n\n    search_one_goal_strong ({P, P \u22b8 S, D} \u22a2 (S \u2297 D)).\n    times_r ({P, (P \u22b8 S) }) ({D})...\n\n    search_one_goal_strong ({1 \u2295 (P \u22b8 S), D, P & 1} \u22a2 (S \u2297 D) \u2295 D).\n    oplus_l 1 (P \u22b8 S)...\n    search_one_goal_strong ( {P \u22b8 S, D, P} \u22a2 (S \u2297 D)).\n    times_r  ({ P , P \u22b8 S}) ({D})...\n  Qed.\nEnd figure_1.\n\n(** Figure 5 de epsrc_case_for_support. *)\nSection figure_5.\n  Local Notation \"'D'\" := (Proposition \"vD'\"%string).\n  Local Notation \"'D\u2081'\" := (Proposition \"vD1'\"%string).\n  Local Notation \"'D\u2080'\" := (Proposition \"vD0'\"%string).\n  Local Notation \"'D\u2082'\" := (Proposition \"vD2'\"%string).\n  Local Notation \"'H'\" := (Proposition \"vH'\"%string).\n  Local Notation \"'F'\":= (Proposition \"vF'\"%string).\n  Local Notation \"'G'\" := (Proposition \"vG'\"%string).\n  Local Notation \"'M'\" := (Proposition \"vM'\"%string).\n  Local Notation \"'L'\" := (Proposition \"vL'\"%string).\n\n\n  Local Notation \"'\u03c1'\" := ({ H,F,L,D\u2082, G\u22b8(!(H\u22b8(H\u2297M))) }).\n  Local Notation \"'\u03bc'\" := ({ !((D\u2081\u2297M)\u22b8D\u2080),!((D\u2082\u2297M)\u22b8D\u2081)}).\n  Local Notation \"'\u03bb'\" := ({ !((L\u2297D\u2080)\u22b8(L\u2297D\u2081)),!((L\u2297D\u2081)\u22b8(L\u2297D\u2082))}).\n\n  (* Ltac bang_c  p'   :=  *)\n  (*   match goal with  *)\n  (*     |- ILL_proof ?env _ => *)\n  (*       match env with *)\n  (*         | context C [(!p'::?env')] => *)\n  (*           let e := context C [ env' ] in   *)\n  (*             with_multiset (!p'::e) ltac:(apply Bang_C) *)\n  (*       end *)\n  (*   end. *)\n\n  (* Ltac bang_d  p'   :=  *)\n  (*   match goal with  *)\n  (*     |- ILL_proof ?env _ => *)\n  (*       match env with *)\n  (*         | context C [(!p'::?env')] => *)\n  (*           let e := context C [ env' ] in   *)\n  (*             with_multiset (!p'::e) ltac:(apply Bang_D) *)\n  (*       end *)\n  (*   end. *)\n\n  Lemma figure_5 : \n    {H,L,G,D\u2082,G\u22b8!(H\u22b8(H\u2297M)),(L\u2297(D\u2082\u2297H))\u22b8(L\u2297(D\u2080\u2297((L\u2297D\u2082)\u22b8D)))}\u222a\u03bb\u222a\u03bc\u22a2D.\n  Proof with try now (finish_proof_strong || prove_multiset_eq).\n      search_one_goal_strong ({H,L,D\u2082,!(H\u22b8(H\u2297M)),(L\u2297(D\u2082\u2297H))\u22b8(L\u2297(D\u2080\u2297((L\u2297D\u2082)\u22b8D)))}\u222a\u03bb\u222a\u03bc\u22a2D).\n      bang_c (H\u22b8(H\u2297M)).\n      bang_d ((H\u22b8(H\u2297M))).\n      search_one_goal_strong ((H \u2297 M)\n        :: {L, D\u2082, !(H \u22b8 (H \u2297 M)),\n          (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \n        \u03bb \u222a \u03bc\u22a2D).\n      search_one_goal_strong ( {H ,M,L, D\u2082, !(H \u22b8 (H \u2297 M)),\n        (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \n      \u03bb \u222a \u03bc\u22a2D).\n      bang_c ((D\u2082\u2297M)\u22b8D\u2081).\n      bang_d ((D\u2082\u2297M)\u22b8D\u2081).\n      impl_l ({M,D\u2082}) ({H, L,  !(H \u22b8 (H \u2297 M)), (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \u03bb \u222a \u03bc) (D\u2082\u2297M) (D\u2081).\n      times_r ({ D\u2082}) ({M})...\n      search_one_goal_strong ({D\u2081,H, L,  (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \u03bb \u22a2 D).\n      bang_c ((L\u2297D\u2081)\u22b8(L\u2297D\u2082))...\n      bang_d ((L\u2297D\u2081)\u22b8(L\u2297D\u2082))...\n      impl_l ({L,D\u2081}) ({H, (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))}\u222a\u03bb) (L\u2297D\u2081) (L\u2297D\u2082)...\n      times_r  ({L}) ({D\u2081})...\n      search_one_goal_strong ({L,D\u2082,H, (L \u2297 (D\u2082 \u2297 H)) \u22b8 (L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D)))} \u222a \u03bb \u22a2 D).\n      impl_l ({L,D\u2082,H}) ({ !((L\u2297D\u2080)\u22b8(L\u2297D\u2081)),!((L\u2297D\u2081)\u22b8(L\u2297D\u2082))}) (L\u2297(D\u2082\u2297H)) ((L \u2297 (D\u2080 \u2297 ((L \u2297 D\u2082) \u22b8 D))))...\n      times_r ({L}) ({D\u2082,H})...\n      times_r ({D\u2082}) ({H})...\n      search_one_goal_strong ({L,D\u2080,((L \u2297 D\u2082) \u22b8 D)}\u222a\u03bb\u22a2D).\n      bang_c ((L\u2297D\u2080)\u22b8(L\u2297D\u2081))...\n      bang_d ((L\u2297D\u2080)\u22b8(L\u2297D\u2081))...\n      impl_l \n        ({L,D\u2080})\n        ({!((L \u2297 D\u2080) \u22b8 (L \u2297 D\u2081)), (L \u2297 D\u2082) \u22b8 D, !((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082))})\n        (L\u2297D\u2080)\n        (L\u2297D\u2081)...\n      times_r ({L}) ({D\u2080})...\n      search_one_goal_strong (   {L \u2297 D\u2081, (L \u2297 D\u2082) \u22b8 D, !((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082))} \u22a2 D).\n      bang_c \n      (((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082)))...\n      bang_d \n        (((L \u2297 D\u2081) \u22b8 (L \u2297 D\u2082)))...\nQed.\n\nEnd figure_5.\nEnd PaperProofsString.\n"}
{"text": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\n\nimport number_theory.arithmetic_function\nimport number_theory.lucas_lehmer\nimport algebra.geom_sum\nimport ring_theory.multiplicity\n\n/-!\n# Perfect Numbers\n\nThis file proves Theorem 70 from the [100 Theorems List](https://www.cs.ru.nl/~freek/100/).\n\nThe theorem characterizes even perfect numbers.\n\nEuclid proved that if `2 ^ (k + 1) - 1` is prime (these primes are known as Mersenne primes),\n  then `2 ^ k * 2 ^ (k + 1) - 1` is perfect.\n\nEuler proved the converse, that if `n` is even and perfect, then there exists `k` such that\n  `n = 2 ^ k * 2 ^ (k + 1) - 1` and `2 ^ (k + 1) - 1` is prime.\n\n## References\nhttps://en.wikipedia.org/wiki/Euclid%E2%80%93Euler_theorem\n-/\n\nlemma odd_mersenne_succ (k : \u2115) : \u00ac 2 \u2223 mersenne (k + 1) :=\nby simp [\u2190 even_iff_two_dvd, \u2190 nat.even_add_one] with parity_simps\n\nnamespace nat\nopen arithmetic_function finset\nopen_locale arithmetic_function\n\nlemma sigma_two_pow_eq_mersenne_succ (k : \u2115) : \u03c3 1 (2 ^ k) = mersenne (k + 1) :=\nby simp [sigma_one_apply, mersenne, prime_two, \u2190 geom_sum_mul_add 1 (k+1)]\n\n/-- Euclid's theorem that Mersenne primes induce perfect numbers -/\ntheorem perfect_two_pow_mul_mersenne_of_prime (k : \u2115) (pr : (mersenne (k + 1)).prime) :\n  perfect ((2 ^ k) * mersenne (k + 1)) :=\nbegin\n  rw [perfect_iff_sum_divisors_eq_two_mul, \u2190 mul_assoc, \u2190 pow_succ, \u2190 sigma_one_apply, mul_comm,\n    is_multiplicative_sigma.map_mul_of_coprime\n        (nat.prime_two.coprime_pow_of_not_dvd (odd_mersenne_succ _)),\n    sigma_two_pow_eq_mersenne_succ],\n  { simp [pr, nat.prime_two, sigma_one_apply] },\n  { apply mul_pos (pow_pos _ k) (mersenne_pos (nat.succ_pos k)),\n    norm_num }\nend\n\nlemma ne_zero_of_prime_mersenne (k : \u2115) (pr : (mersenne (k + 1)).prime) :\n  k \u2260 0 :=\nbegin\n  intro H,\n  simpa [H, mersenne, not_prime_one] using pr,\nend\n\ntheorem even_two_pow_mul_mersenne_of_prime (k : \u2115) (pr : (mersenne (k + 1)).prime) :\n  even ((2 ^ k) * mersenne (k + 1)) :=\nby simp [ne_zero_of_prime_mersenne k pr] with parity_simps\n\nlemma eq_two_pow_mul_odd {n : \u2115} (hpos : 0 < n) :\n  \u2203 (k m : \u2115), n = 2 ^ k * m \u2227 \u00ac even m :=\nbegin\n  have h := (multiplicity.finite_nat_iff.2 \u27e8nat.prime_two.ne_one, hpos\u27e9),\n  cases multiplicity.pow_multiplicity_dvd h with m hm,\n  use [(multiplicity 2 n).get h, m],\n  refine \u27e8hm, _\u27e9,\n  rw even_iff_two_dvd,\n  have hg := multiplicity.is_greatest' h (nat.lt_succ_self _),\n  contrapose! hg,\n  rcases hg with \u27e8k, rfl\u27e9,\n  apply dvd.intro k,\n  rw [pow_succ', mul_assoc, \u2190 hm],\nend\n\n/-- **Perfect Number Theorem**: Euler's theorem that even perfect numbers can be factored as a\n  power of two times a Mersenne prime. -/\ntheorem eq_two_pow_mul_prime_mersenne_of_even_perfect {n : \u2115} (ev : even n) (perf : perfect n) :\n  \u2203 (k : \u2115), prime (mersenne (k + 1)) \u2227 n = 2 ^ k * mersenne (k + 1) :=\nbegin\n  have hpos := perf.2,\n  rcases eq_two_pow_mul_odd hpos with \u27e8k, m, rfl, hm\u27e9,\n  use k,\n  rw even_iff_two_dvd at hm,\n  rw [perfect_iff_sum_divisors_eq_two_mul hpos, \u2190 sigma_one_apply,\n    is_multiplicative_sigma.map_mul_of_coprime (nat.prime_two.coprime_pow_of_not_dvd hm).symm,\n    sigma_two_pow_eq_mersenne_succ, \u2190 mul_assoc, \u2190 pow_succ] at perf,\n  rcases nat.coprime.dvd_of_dvd_mul_left\n    (nat.prime_two.coprime_pow_of_not_dvd (odd_mersenne_succ _)) (dvd.intro _ perf) with \u27e8j, rfl\u27e9,\n  rw [\u2190 mul_assoc, mul_comm _ (mersenne _), mul_assoc] at perf,\n  have h := mul_left_cancel\u2080 (ne_of_gt (mersenne_pos (nat.succ_pos _))) perf,\n  rw [sigma_one_apply, sum_divisors_eq_sum_proper_divisors_add_self, \u2190 succ_mersenne, add_mul,\n    one_mul, add_comm] at h,\n  have hj := add_left_cancel h,\n  cases sum_proper_divisors_dvd (by { rw hj, apply dvd.intro_left (mersenne (k + 1)) rfl }),\n  { have j1 : j = 1 := eq.trans hj.symm h_1,\n    rw [j1, mul_one, sum_proper_divisors_eq_one_iff_prime] at h_1,\n    simp [h_1, j1] },\n  { have jcon := eq.trans hj.symm h_1,\n    rw [\u2190 one_mul j, \u2190 mul_assoc, mul_one] at jcon,\n    have jcon2 := mul_right_cancel\u2080 _ jcon,\n    { exfalso,\n      cases k,\n      { apply hm,\n        rw [\u2190 jcon2, pow_zero, one_mul, one_mul] at ev,\n        rw [\u2190 jcon2, one_mul],\n        exact even_iff_two_dvd.mp ev },\n      apply ne_of_lt _ jcon2,\n      rw [mersenne, \u2190 nat.pred_eq_sub_one, lt_pred_iff, \u2190 pow_one (nat.succ 1)],\n      apply pow_lt_pow (nat.lt_succ_self 1) (nat.succ_lt_succ (nat.succ_pos k)) },\n    contrapose! hm,\n    simp [hm] }\nend\n\n/-- The Euclid-Euler theorem characterizing even perfect numbers -/\ntheorem even_and_perfect_iff {n : \u2115} :\n  (even n \u2227 perfect n) \u2194 \u2203 (k : \u2115), prime (mersenne (k + 1)) \u2227 n = 2 ^ k * mersenne (k + 1) :=\nbegin\n  split,\n  { rintro \u27e8ev, perf\u27e9,\n    exact eq_two_pow_mul_prime_mersenne_of_even_perfect ev perf },\n  { rintro \u27e8k, pr, rfl\u27e9,\n    exact \u27e8even_two_pow_mul_mersenne_of_prime k pr, perfect_two_pow_mul_mersenne_of_prime k pr\u27e9 }\nend\n\nend nat\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_188\n  (\u03c3 : equiv \u211d \u211d)\n  (h : \u03c3.1 2 = \u03c3.2 2) :\n  \u03c3.1 (\u03c3.1 2) = 2 :=\nbegin\n  simp [h]\nend"}
{"text": "section transport\nuniverses u v\ndef eq.transport {A : Type u} (B : A \u2192 Type v) {a a' : A}\n  : a = a' \u2192 B a \u2192 B a' := by { intros, cases a_1, assumption, }\nlemma heq_transport {A : Type u} (B : A \u2192 Type v) {a b : A} (p : a = b)\n  : \u2200 b : B a, b == eq.transport B p b := by { intros, cases p, refl }\nend transport\nsection transport_inj\nuniverses u v w\n\nlemma inj_implies_transport_inj {A : Type u} (B : A \u2192 Type v)\n                                (C : A \u2192 Type w) {a a' : A}\n                                (p : a = a')\n  : \u2200 f : B a \u2192 C a,\n    function.injective f\n    \u2192 function.injective (eq.transport (\u03bb x, B x \u2192 C x) p f) :=\nby { cases p, simp [eq.transport], intro, exact id }\n\nlemma heq.funext1 {A : Type u} (B : Type v)\n                               (C : A \u2192 Type w) {a a' : A}\n                               (p : a = a')\n  : \u2200 (f : B \u2192 C a) (g : B \u2192 C a'), (\u2200 x, f x == g x) \u2192 f == g :=\nby { cases p, intros, apply heq_of_eq, funext, apply eq_of_heq (a_1 x) }\n\nlemma dep_fn_eq_of_heq\n  {A : Type u} (B : A \u2192 Type v)\n  (C : Type w) (f : \u03a0 x : A, B x \u2192 C)\n  {a a' : A} {b : B a} {b' : B a'}\n  : a = a' \u2192 b == b' \u2192 f a b = f a' b' :=\nby { intro p, cases p, intro p', cases eq_of_heq p', refl }\n\nlemma fin.funext (C : Type w) {n k : nat}\n                 (p : n = k)\n  : \u2200 (f : fin n \u2192 C) (g : fin k \u2192 C),\n      (\u2200 x : fin n, f x = g \u27e8x.val, p \u25b8 x.is_lt\u27e9) \u2192 f == g :=\nby { cases p, intros, apply heq_of_eq, funext, rw a x, congr, apply fin.eq_of_veq, refl }\n\nlemma heq.funext {A : Type u} (B : A \u2192 Type v)\n                              (C : Type w) {a a' : A}\n                              (p : a = a')\n  : (B a \u2192 false) \u2192 \u2200 (f : B a \u2192 C) (g : B a' \u2192 C), f == g :=\nby { cases p, intros,\n     rw (_ : f = (\u03bb b, false.elim (a_1 b))),\n     rw (_ : g = (\u03bb b, false.elim (a_1 b))),\n     all_goals { funext, exfalso, exact a_1 x }, }\n\nlemma sigma_eq_of_heq {A : Type u} (B : A \u2192 Type v)\n                    : \u2200 (a a' : A) (p : a = a')\n                        (b : B a) (b' : B a'),\n                      b == b' \u2192 sigma.mk a b = sigma.mk a' b' :=\nby { intros, congr; assumption }\nend transport_inj"}
{"text": "informal statement Let $X$ be a topological space and let $Y$ be a metric space. Let $f_{n}: X \\rightarrow Y$ be a sequence of continuous functions. Let $x_{n}$ be a sequence of points of $X$ converging to $x$. Show that if the sequence $\\left(f_{n}\\right)$ converges uniformly to $f$, then $\\left(f_{n}\\left(x_{n}\\right)\\right)$ converges to $f(x)$.formal statement theorem exercise_21_8\n  {X : Type*} [topological_space X] {Y : Type*} [metric_space Y]\n  {f : \u2115 \u2192 X \u2192 Y} {x : \u2115 \u2192 X}\n  (hf : \u2200 n, continuous (f n))\n  (x\u2080 : X)\n  (hx : tendsto x at_top (\ud835\udcdd x\u2080))\n  (f\u2080 : X \u2192 Y)\n  (hh : tendsto_uniformly f f\u2080 at_top) :\n  tendsto (\u03bb n, f n (x n)) at_top (\ud835\udcdd (f\u2080 x\u2080)) :="}
{"text": "/-\nCopyright (c) 2021 Kalle Kyt\u00f6l\u00e4. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kalle Kyt\u00f6l\u00e4, Moritz Doll\n\n! This file was ported from Lean 3 source module topology.algebra.module.weak_dual\n! leanprover-community/mathlib commit f2ce6086713c78a7f880485f7917ea547a215982\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Topology.Algebra.Module.Basic\nimport Mathbin.LinearAlgebra.BilinearMap\n\n/-!\n# Weak dual topology\n\nThis file defines the weak topology given two vector spaces `E` and `F` over a commutative semiring\n`\ud835\udd5c` and a bilinear form `B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c`. The weak topology on `E` is the coarsest topology\nsuch that for all `y : F` every map `\u03bb x, B x y` is continuous.\n\nIn the case that `F = E \u2192L[\ud835\udd5c] \ud835\udd5c` and `B` being the canonical pairing, we obtain the weak-* topology,\n`weak_dual \ud835\udd5c E := (E \u2192L[\ud835\udd5c] \ud835\udd5c)`. Interchanging the arguments in the bilinear form yields the\nweak topology `weak_space \ud835\udd5c E := E`.\n\n## Main definitions\n\nThe main definitions are the types `weak_bilin B` for the general case and the two special cases\n`weak_dual \ud835\udd5c E` and `weak_space \ud835\udd5c E` with the respective topology instances on it.\n\n* Given `B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c`, the type `weak_bilin B` is a type synonym for `E`.\n* The instance `weak_bilin.topological_space` is the weak topology induced by the bilinear form `B`.\n* `weak_dual \ud835\udd5c E` is a type synonym for `dual \ud835\udd5c E` (when the latter is defined): both are equal to\n  the type `E \u2192L[\ud835\udd5c] \ud835\udd5c` of continuous linear maps from a module `E` over `\ud835\udd5c` to the ring `\ud835\udd5c`.\n* The instance `weak_dual.topological_space` is the weak-* topology on `weak_dual \ud835\udd5c E`, i.e., the\n  coarsest topology making the evaluation maps at all `z : E` continuous.\n* `weak_space \ud835\udd5c E` is a type synonym for `E` (when the latter is defined).\n* The instance `weak_dual.topological_space` is the weak topology on `E`, i.e., the\n  coarsest topology such that all `v : dual \ud835\udd5c E` remain continuous.\n\n## Main results\n\nWe establish that `weak_bilin B` has the following structure:\n* `weak_bilin.has_continuous_add`: The addition in `weak_bilin B` is continuous.\n* `weak_bilin.has_continuous_smul`: The scalar multiplication in `weak_bilin B` is continuous.\n\nWe prove the following results characterizing the weak topology:\n* `eval_continuous`: For any `y : F`, the evaluation mapping `\u03bb x, B x y` is continuous.\n* `continuous_of_continuous_eval`: For a mapping to `weak_bilin B` to be continuous,\n  it suffices that its compositions with pairing with `B` at all points `y : F` is continuous.\n* `tendsto_iff_forall_eval_tendsto`: Convergence in `weak_bilin B` can be characterized\n  in terms of convergence of the evaluations at all points `y : F`.\n\n## Notations\n\nNo new notation is introduced.\n\n## References\n\n* [H. H. Schaefer, *Topological Vector Spaces*][schaefer1966]\n\n## Tags\n\nweak-star, weak dual, duality\n\n-/\n\n\nnoncomputable section\n\nopen Filter\n\nopen Topology\n\nvariable {\u03b1 \ud835\udd5c \ud835\udd5d R E F M : Type _}\n\nsection WeakTopology\n\n/- ./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] \ud835\udd5c -/\n/-- The space `E` equipped with the weak topology induced by the bilinear form `B`. -/\n@[nolint has_nonempty_instance unused_arguments]\ndef WeakBilin [CommSemiring \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [AddCommMonoid F] [Module \ud835\udd5c F]\n    (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) :=\n  E deriving AddCommMonoid,\n  \u00ab./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] \ud835\udd5c\u00bb\n#align weak_bilin WeakBilin\n\nnamespace WeakBilin\n\ninstance [CommSemiring \ud835\udd5c] [a : AddCommGroup E] [Module \ud835\udd5c E] [AddCommMonoid F] [Module \ud835\udd5c F]\n    (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) : AddCommGroup (WeakBilin B) :=\n  a\n\ninstance (priority := 100) module' [CommSemiring \ud835\udd5c] [CommSemiring \ud835\udd5d] [AddCommGroup E] [Module \ud835\udd5c E]\n    [AddCommGroup F] [Module \ud835\udd5c F] [m : Module \ud835\udd5d E] (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) :\n    Module \ud835\udd5d (WeakBilin B) :=\n  m\n#align weak_bilin.module' WeakBilin.module'\n\ninstance [CommSemiring \ud835\udd5c] [CommSemiring \ud835\udd5d] [AddCommGroup E] [Module \ud835\udd5c E] [AddCommGroup F]\n    [Module \ud835\udd5c F] [SMul \ud835\udd5d \ud835\udd5c] [Module \ud835\udd5d E] [s : IsScalarTower \ud835\udd5d \ud835\udd5c E] (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c) :\n    IsScalarTower \ud835\udd5d \ud835\udd5c (WeakBilin B) :=\n  s\n\nsection Semiring\n\nvariable [TopologicalSpace \ud835\udd5c] [CommSemiring \ud835\udd5c]\n\nvariable [AddCommMonoid E] [Module \ud835\udd5c E]\n\nvariable [AddCommMonoid F] [Module \ud835\udd5c F]\n\nvariable (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c)\n\ninstance : TopologicalSpace (WeakBilin B) :=\n  TopologicalSpace.induced (fun x y => B x y) Pi.topologicalSpace\n\n/-- The coercion `(\u03bb x y, B x y) : E \u2192 (F \u2192 \ud835\udd5c)` is continuous. -/\ntheorem coeFn_continuous : Continuous fun (x : WeakBilin B) y => B x y :=\n  continuous_induced_dom\n#align weak_bilin.coe_fn_continuous WeakBilin.coeFn_continuous\n\ntheorem eval_continuous (y : F) : Continuous fun x : WeakBilin B => B x y :=\n  (continuous_pi_iff.mp (coeFn_continuous B)) y\n#align weak_bilin.eval_continuous WeakBilin.eval_continuous\n\ntheorem continuous_of_continuous_eval [TopologicalSpace \u03b1] {g : \u03b1 \u2192 WeakBilin B}\n    (h : \u2200 y, Continuous fun a => B (g a) y) : Continuous g :=\n  continuous_induced_rng.2 (continuous_pi_iff.mpr h)\n#align weak_bilin.continuous_of_continuous_eval WeakBilin.continuous_of_continuous_eval\n\n/-- The coercion `(\u03bb x y, B x y) : E \u2192 (F \u2192 \ud835\udd5c)` is an embedding. -/\ntheorem embedding {B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c} (hB : Function.Injective B) :\n    Embedding fun (x : WeakBilin B) y => B x y :=\n  Function.Injective.embedding_induced <| LinearMap.coe_injective.comp hB\n#align weak_bilin.embedding WeakBilin.embedding\n\ntheorem tendsto_iff_forall_eval_tendsto {l : Filter \u03b1} {f : \u03b1 \u2192 WeakBilin B} {x : WeakBilin B}\n    (hB : Function.Injective B) :\n    Tendsto f l (\ud835\udcdd x) \u2194 \u2200 y, Tendsto (fun i => B (f i) y) l (\ud835\udcdd (B x y)) := by\n  rw [\u2190 tendsto_pi_nhds, Embedding.tendsto_nhds_iff (Embedding hB)]\n#align weak_bilin.tendsto_iff_forall_eval_tendsto WeakBilin.tendsto_iff_forall_eval_tendsto\n\n/-- Addition in `weak_space B` is continuous. -/\ninstance [ContinuousAdd \ud835\udd5c] : ContinuousAdd (WeakBilin B) :=\n  by\n  refine' \u27e8continuous_induced_rng.2 _\u27e9\n  refine'\n    cast (congr_arg _ _)\n      (((coe_fn_continuous B).comp continuous_fst).add ((coe_fn_continuous B).comp continuous_snd))\n  ext\n  simp only [Function.comp_apply, Pi.add_apply, map_add, LinearMap.add_apply]\n\n/-- Scalar multiplication by `\ud835\udd5c` on `weak_bilin B` is continuous. -/\ninstance [ContinuousSMul \ud835\udd5c \ud835\udd5c] : ContinuousSMul \ud835\udd5c (WeakBilin B) :=\n  by\n  refine' \u27e8continuous_induced_rng.2 _\u27e9\n  refine' cast (congr_arg _ _) (continuous_fst.smul ((coe_fn_continuous B).comp continuous_snd))\n  ext\n  simp only [Function.comp_apply, Pi.smul_apply, LinearMap.map_smul\u209b\u2097, RingHom.id_apply,\n    LinearMap.smul_apply]\n\nend Semiring\n\nsection Ring\n\nvariable [TopologicalSpace \ud835\udd5c] [CommRing \ud835\udd5c]\n\nvariable [AddCommGroup E] [Module \ud835\udd5c E]\n\nvariable [AddCommGroup F] [Module \ud835\udd5c F]\n\nvariable (B : E \u2192\u2097[\ud835\udd5c] F \u2192\u2097[\ud835\udd5c] \ud835\udd5c)\n\n/-- `weak_space B` is a `topological_add_group`, meaning that addition and negation are\ncontinuous. -/\ninstance [ContinuousAdd \ud835\udd5c] : TopologicalAddGroup (WeakBilin B)\n    where\n  to_continuousAdd := by infer_instance\n  continuous_neg :=\n    by\n    refine' continuous_induced_rng.2 (continuous_pi_iff.mpr fun y => _)\n    refine' cast (congr_arg _ _) (eval_continuous B (-y))\n    ext\n    simp only [map_neg, Function.comp_apply, LinearMap.neg_apply]\n\nend Ring\n\nend WeakBilin\n\nend WeakTopology\n\nsection WeakStarTopology\n\n/-- The canonical pairing of a vector space and its topological dual. -/\ndef topDualPairing (\ud835\udd5c E) [CommSemiring \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousAdd \ud835\udd5c] [AddCommMonoid E]\n    [Module \ud835\udd5c E] [TopologicalSpace E] [ContinuousConstSMul \ud835\udd5c \ud835\udd5c] : (E \u2192L[\ud835\udd5c] \ud835\udd5c) \u2192\u2097[\ud835\udd5c] E \u2192\u2097[\ud835\udd5c] \ud835\udd5c :=\n  ContinuousLinearMap.coeLm \ud835\udd5c\n#align top_dual_pairing topDualPairing\n\nvariable [CommSemiring \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousAdd \ud835\udd5c]\n\nvariable [ContinuousConstSMul \ud835\udd5c \ud835\udd5c]\n\nvariable [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E]\n\ntheorem dual_pairing_apply (v : E \u2192L[\ud835\udd5c] \ud835\udd5c) (x : E) : topDualPairing \ud835\udd5c E v x = v x :=\n  rfl\n#align dual_pairing_apply dual_pairing_apply\n\n/- ./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] \ud835\udd5c -/\n/-- The weak star topology is the topology coarsest topology on `E \u2192L[\ud835\udd5c] \ud835\udd5c` such that all\nfunctionals `\u03bb v, top_dual_pairing \ud835\udd5c E v x` are continuous. -/\ndef WeakDual (\ud835\udd5c E) [CommSemiring \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousAdd \ud835\udd5c] [ContinuousConstSMul \ud835\udd5c \ud835\udd5c]\n    [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] :=\n  WeakBilin (topDualPairing \ud835\udd5c E)deriving AddCommMonoid,\n  \u00ab./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] \ud835\udd5c\u00bb,\n  TopologicalSpace, ContinuousAdd\n#align weak_dual WeakDual\n\nnamespace WeakDual\n\ninstance : Inhabited (WeakDual \ud835\udd5c E) :=\n  ContinuousLinearMap.inhabited\n\ninstance WeakDual.continuousLinearMapClass : ContinuousLinearMapClass (WeakDual \ud835\udd5c E) \ud835\udd5c E \ud835\udd5c :=\n  ContinuousLinearMap.continuousSemilinearMapClass\n#align weak_dual.weak_dual.continuous_linear_map_class WeakDual.WeakDual.continuousLinearMapClass\n\n/-- Helper instance for when there's too many metavariables to apply `fun_like.has_coe_to_fun`\ndirectly. -/\ninstance : CoeFun (WeakDual \ud835\udd5c E) fun _ => E \u2192 \ud835\udd5c :=\n  FunLike.hasCoeToFun\n\n/-- If a monoid `M` distributively continuously acts on `\ud835\udd5c` and this action commutes with\nmultiplication on `\ud835\udd5c`, then it acts on `weak_dual \ud835\udd5c E`. -/\ninstance (M) [Monoid M] [DistribMulAction M \ud835\udd5c] [SMulCommClass \ud835\udd5c M \ud835\udd5c] [ContinuousConstSMul M \ud835\udd5c] :\n    MulAction M (WeakDual \ud835\udd5c E) :=\n  ContinuousLinearMap.mulAction\n\n/-- If a monoid `M` distributively continuously acts on `\ud835\udd5c` and this action commutes with\nmultiplication on `\ud835\udd5c`, then it acts distributively on `weak_dual \ud835\udd5c E`. -/\ninstance (M) [Monoid M] [DistribMulAction M \ud835\udd5c] [SMulCommClass \ud835\udd5c M \ud835\udd5c] [ContinuousConstSMul M \ud835\udd5c] :\n    DistribMulAction M (WeakDual \ud835\udd5c E) :=\n  ContinuousLinearMap.distribMulAction\n\n/-- If `\ud835\udd5c` is a topological module over a semiring `R` and scalar multiplication commutes with the\nmultiplication on `\ud835\udd5c`, then `weak_dual \ud835\udd5c E` is a module over `R`. -/\ninstance module' (R) [Semiring R] [Module R \ud835\udd5c] [SMulCommClass \ud835\udd5c R \ud835\udd5c] [ContinuousConstSMul R \ud835\udd5c] :\n    Module R (WeakDual \ud835\udd5c E) :=\n  ContinuousLinearMap.module\n#align weak_dual.module' WeakDual.module'\n\ninstance (M) [Monoid M] [DistribMulAction M \ud835\udd5c] [SMulCommClass \ud835\udd5c M \ud835\udd5c] [ContinuousConstSMul M \ud835\udd5c] :\n    ContinuousConstSMul M (WeakDual \ud835\udd5c E) :=\n  \u27e8fun m =>\n    continuous_induced_rng.2 <| (WeakBilin.coeFn_continuous (topDualPairing \ud835\udd5c E)).const_smul m\u27e9\n\n/-- If a monoid `M` distributively continuously acts on `\ud835\udd5c` and this action commutes with\nmultiplication on `\ud835\udd5c`, then it continuously acts on `weak_dual \ud835\udd5c E`. -/\ninstance (M) [Monoid M] [DistribMulAction M \ud835\udd5c] [SMulCommClass \ud835\udd5c M \ud835\udd5c] [TopologicalSpace M]\n    [ContinuousSMul M \ud835\udd5c] : ContinuousSMul M (WeakDual \ud835\udd5c E) :=\n  \u27e8continuous_induced_rng.2 <|\n      continuous_fst.smul ((WeakBilin.coeFn_continuous (topDualPairing \ud835\udd5c E)).comp continuous_snd)\u27e9\n\ntheorem coeFn_continuous : Continuous fun (x : WeakDual \ud835\udd5c E) y => x y :=\n  continuous_induced_dom\n#align weak_dual.coe_fn_continuous WeakDual.coeFn_continuous\n\ntheorem eval_continuous (y : E) : Continuous fun x : WeakDual \ud835\udd5c E => x y :=\n  continuous_pi_iff.mp coeFn_continuous y\n#align weak_dual.eval_continuous WeakDual.eval_continuous\n\ntheorem continuous_of_continuous_eval [TopologicalSpace \u03b1] {g : \u03b1 \u2192 WeakDual \ud835\udd5c E}\n    (h : \u2200 y, Continuous fun a => (g a) y) : Continuous g :=\n  continuous_induced_rng.2 (continuous_pi_iff.mpr h)\n#align weak_dual.continuous_of_continuous_eval WeakDual.continuous_of_continuous_eval\n\ninstance [T2Space \ud835\udd5c] : T2Space (WeakDual \ud835\udd5c E) :=\n  Embedding.t2Space <|\n    WeakBilin.embedding <|\n      show Function.Injective (topDualPairing \ud835\udd5c E) from ContinuousLinearMap.coe_injective\n\nend WeakDual\n\n/- ./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] \ud835\udd5c -/\n/-- The weak topology is the topology coarsest topology on `E` such that all\nfunctionals `\u03bb x, top_dual_pairing \ud835\udd5c E v x` are continuous. -/\n@[nolint has_nonempty_instance]\ndef WeakSpace (\ud835\udd5c E) [CommSemiring \ud835\udd5c] [TopologicalSpace \ud835\udd5c] [ContinuousAdd \ud835\udd5c]\n    [ContinuousConstSMul \ud835\udd5c \ud835\udd5c] [AddCommMonoid E] [Module \ud835\udd5c E] [TopologicalSpace E] :=\n  WeakBilin (topDualPairing \ud835\udd5c E).flip deriving AddCommMonoid,\n  \u00ab./././Mathport/Syntax/Translate/Command.lean:42:9: unsupported derive handler module[module] \ud835\udd5c\u00bb,\n  TopologicalSpace, ContinuousAdd\n#align weak_space WeakSpace\n\nnamespace WeakSpace\n\nvariable {\ud835\udd5c E F} [AddCommMonoid F] [Module \ud835\udd5c F] [TopologicalSpace F]\n\n/-- A continuous linear map from `E` to `F` is still continuous when `E` and `F` are equipped with\ntheir weak topologies. -/\ndef map (f : E \u2192L[\ud835\udd5c] F) : WeakSpace \ud835\udd5c E \u2192L[\ud835\udd5c] WeakSpace \ud835\udd5c F :=\n  { f with\n    cont :=\n      WeakBilin.continuous_of_continuous_eval _ fun l => WeakBilin.eval_continuous _ (l \u2218L f) }\n#align weak_space.map WeakSpace.map\n\ntheorem map_apply (f : E \u2192L[\ud835\udd5c] F) (x : E) : WeakSpace.map f x = f x :=\n  rfl\n#align weak_space.map_apply WeakSpace.map_apply\n\n@[simp]\ntheorem coe_map (f : E \u2192L[\ud835\udd5c] F) : (WeakSpace.map f : E \u2192 F) = f :=\n  rfl\n#align weak_space.coe_map WeakSpace.coe_map\n\nend WeakSpace\n\ntheorem tendsto_iff_forall_eval_tendsto_topDualPairing {l : Filter \u03b1} {f : \u03b1 \u2192 WeakDual \ud835\udd5c E}\n    {x : WeakDual \ud835\udd5c E} :\n    Tendsto f l (\ud835\udcdd x) \u2194\n      \u2200 y, Tendsto (fun i => topDualPairing \ud835\udd5c E (f i) y) l (\ud835\udcdd (topDualPairing \ud835\udd5c E x y)) :=\n  WeakBilin.tendsto_iff_forall_eval_tendsto _ ContinuousLinearMap.coe_injective\n#align tendsto_iff_forall_eval_tendsto_top_dual_pairing tendsto_iff_forall_eval_tendsto_topDualPairing\n\nend WeakStarTopology\n\n"}
{"text": "[STATEMENT]\nlemma pred_intros_finite[measurable (raw)]:\n  \"finite I \\<Longrightarrow> (\\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> N x i)) \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> (\\<Inter>i\\<in>I. N x i))\"\n  \"finite I \\<Longrightarrow> (\\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> N x i)) \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> (\\<Union>i\\<in>I. N x i))\"\n  \"finite I \\<Longrightarrow> (\\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. P x i)) \\<Longrightarrow> pred M (\\<lambda>x. \\<forall>i\\<in>I. P x i)\"\n  \"finite I \\<Longrightarrow> (\\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. P x i)) \\<Longrightarrow> pred M (\\<lambda>x. \\<exists>i\\<in>I. P x i)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. ((\\<lbrakk>finite I; \\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> N x i)\\<rbrakk> \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> \\<Inter> (N x ` I))) &&& (\\<lbrakk>finite I; \\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> N x i)\\<rbrakk> \\<Longrightarrow> pred M (\\<lambda>x. x \\<in> \\<Union> (N x ` I)))) &&& (\\<lbrakk>finite I; \\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. P x i)\\<rbrakk> \\<Longrightarrow> pred M (\\<lambda>x. \\<forall>i\\<in>I. P x i)) &&& (\\<lbrakk>finite I; \\<And>i. i \\<in> I \\<Longrightarrow> pred M (\\<lambda>x. P x i)\\<rbrakk> \\<Longrightarrow> pred M (\\<lambda>x. \\<exists>i\\<in>I. P x i))\n[PROOF STEP]\nby (auto intro!: sets.sets_Collect_finite_Ex sets.sets_Collect_finite_All simp: iff_conv_conj_imp pred_def)"}
{"text": "[STATEMENT]\ntheorem subst_lemma [simp]:\n  \\<open>eval e f g (subst a t i) = eval (e\\<langle>i:evalt e f t\\<rangle>) f g a\\<close>\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. eval e f g (a[t/i]) = eval (e\\<langle>i:evalt e f t\\<rangle>) f g a\n[PROOF STEP]\nby (induct a arbitrary: e i t) simp_all"}
{"text": "Require Export Basics.\n\nFixpoint ble_nat (n m : nat) : bool :=\n  match n with\n  | O => true\n  | S n' =>\n      match m with\n      | O => false\n      | S m' => ble_nat n' m'\n      end\n  end.\n\nFixpoint minus (n m:nat) : nat :=\n  match n, m with\n  | O   , _    => O\n  | S _ , O    => n\n  | S n', S m' => minus n' m'\n  end.\n\nTheorem minus_help : forall (x y : nat),\n  ble_nat x y = true -> x + (minus y x) = y.\nProof.\n  intros x y. intros H.\n  induction x as [ | x'].\n  simpl. admit.\n  simpl. admit.\n\nTheorem ble_nat1 : forall (x y : nat),\n  ble_nat (S x) y = true -> ble_nat x y = true.\nProof.\n  intros x y. intros H.\n  induction y as [ | y'].\n  inversion H.\n\nTheorem ble_nat2 : forall (x : nat),\n  ble_nat x (S x).\n\n\nTheorem ble_nat_alt : forall (x y : nat),\n  ble_nat x y = true -> exists (z : nat), x + z = y.\nProof.\n  intros x y.\n  intros H.\n  assert (Lemma1 : x + (minus y x) = y).\n  \n"}
{"text": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n\n! This file was ported from Lean 3 source module ring_theory.ideal.minimal_prime\n! leanprover-community/mathlib commit 70fd9563a21e7b963887c9360bd29b2393e6225a\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.RingTheory.Localization.AtPrime\nimport Mathbin.Order.Minimal\n\n/-!\n\n# Minimal primes\n\nWe provide various results concerning the minimal primes above an ideal\n\n## Main results\n- `ideal.minimal_primes`: `I.minimal_primes` is the set of ideals that are minimal primes over `I`.\n- `minimal_primes`: `minimal_primes R` is the set of minimal primes of `R`.\n- `ideal.exists_minimal_primes_le`: Every prime ideal over `I` contains a minimal prime over `I`.\n- `ideal.radical_minimal_primes`: The minimal primes over `I.radical` are precisely\n  the minimal primes over `I`.\n- `ideal.Inf_minimal_primes`: The intersection of minimal primes over `I` is `I.radical`.\n- `ideal.exists_minimal_primes_comap_eq` If `p` is a minimal prime over `f \u207b\u00b9 I`, then it is the\n  preimage of some minimal prime over `I`.\n- `ideal.minimal_primes_eq_comap`: The minimal primes over `I` are precisely the preimages of\n  minimal primes of `R \u29f8 I`.\n\n\n-/\n\n\nsection\n\nvariable {R S : Type _} [CommRing R] [CommRing S] (I J : Ideal R)\n\n/-- `I.minimal_primes` is the set of ideals that are minimal primes over `I`. -/\ndef Ideal.minimalPrimes : Set (Ideal R) :=\n  minimals (\u00b7 \u2264 \u00b7) { p | p.IsPrime \u2227 I \u2264 p }\n#align ideal.minimal_primes Ideal.minimalPrimes\n\n/-- `minimal_primes R` is the set of minimal primes of `R`.\nThis is defined as `ideal.minimal_primes \u22a5`. -/\ndef minimalPrimes (R : Type _) [CommRing R] : Set (Ideal R) :=\n  Ideal.minimalPrimes \u22a5\n#align minimal_primes minimalPrimes\n\nvariable {I J}\n\ntheorem Ideal.exists_minimalPrimes_le [J.IsPrime] (e : I \u2264 J) : \u2203 p \u2208 I.minimalPrimes, p \u2264 J :=\n  by\n  suffices\n    \u2203 m \u2208 { p : (Ideal R)\u1d52\u1d48 | Ideal.IsPrime p \u2227 I \u2264 OrderDual.ofDual p },\n      OrderDual.toDual J \u2264 m \u2227 \u2200 z \u2208 { p : (Ideal R)\u1d52\u1d48 | Ideal.IsPrime p \u2227 I \u2264 p }, m \u2264 z \u2192 z = m\n    by\n    obtain \u27e8p, h\u2081, h\u2082, h\u2083\u27e9 := this\n    simp_rw [\u2190 @eq_comm _ p] at h\u2083\n    exact \u27e8p, \u27e8h\u2081, fun a b c => (h\u2083 a b c).le\u27e9, h\u2082\u27e9\n  apply zorn_nonempty_partialOrder\u2080\n  swap\n  \u00b7 refine' \u27e8show J.is_prime by infer_instance, e\u27e9\n  rintro (c : Set (Ideal R)) hc hc' J' hJ'\n  refine'\n    \u27e8OrderDual.toDual (Inf c),\n      \u27e8Ideal.inf\u209b_isPrime_of_isChain \u27e8J', hJ'\u27e9 hc'.symm fun x hx => (hc hx).1, _\u27e9, _\u27e9\n  \u00b7 rw [OrderDual.ofDual_toDual]\n    convert le_inf\u209b _\n    intro x hx\n    exact (hc hx).2\n  \u00b7 rintro z hz\n    rw [OrderDual.le_toDual]\n    exact inf\u209b_le hz\n#align ideal.exists_minimal_primes_le Ideal.exists_minimalPrimes_le\n\n@[simp]\ntheorem Ideal.radical_minimalPrimes : I.radical.minimalPrimes = I.minimalPrimes :=\n  by\n  rw [Ideal.minimalPrimes, Ideal.minimalPrimes]\n  congr\n  ext p\n  exact \u27e8fun \u27e8a, b\u27e9 => \u27e8a, ideal.le_radical.trans b\u27e9, fun \u27e8a, b\u27e9 => \u27e8a, a.radical_le_iff.mpr b\u27e9\u27e9\n#align ideal.radical_minimal_primes Ideal.radical_minimalPrimes\n\n@[simp]\ntheorem Ideal.inf\u209b_minimalPrimes : inf\u209b I.minimalPrimes = I.radical :=\n  by\n  rw [I.radical_eq_Inf]\n  apply le_antisymm\n  \u00b7 intro x hx\n    rw [Ideal.mem_inf\u209b] at hx\u22a2\n    rintro J \u27e8e, hJ\u27e9\n    skip\n    obtain \u27e8p, hp, hp'\u27e9 := Ideal.exists_minimalPrimes_le e\n    exact hp' (hx hp)\n  \u00b7 apply inf\u209b_le_inf\u209b _\n    intro I hI\n    exact hI.1.symm\n#align ideal.Inf_minimal_primes Ideal.inf\u209b_minimalPrimes\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (p \u00abexpr \u2208 \u00bb minimal_primes[minimal_primes] R) -/\ntheorem Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective {f : R \u2192+* S}\n    (hf : Function.Injective f) (p) (_ : p \u2208 minimalPrimes R) :\n    \u2203 p' : Ideal S, p'.IsPrime \u2227 p'.comap f = p :=\n  by\n  haveI := H.1.1\n  have : Nontrivial (Localization (Submonoid.map f p.prime_compl)) :=\n    by\n    refine' \u27e8\u27e81, 0, _\u27e9\u27e9\n    convert(IsLocalization.map_injective_of_injective p.prime_compl (Localization.AtPrime p)\n            (Localization <| p.prime_compl.map f) hf).Ne\n        one_ne_zero\n    \u00b7 rw [map_one]\n    \u00b7 rw [map_zero]\n  obtain \u27e8M, hM\u27e9 := Ideal.exists_maximal (Localization (Submonoid.map f p.prime_compl))\n  skip\n  refine' \u27e8M.comap (algebraMap S <| Localization (Submonoid.map f p.prime_compl)), inferInstance, _\u27e9\n  rw [Ideal.comap_comap, \u2190\n    @IsLocalization.map_comp _ _ _ _ Localization.isLocalization _ p.prime_compl.le_comap_map _\n      Localization.isLocalization,\n    \u2190 Ideal.comap_comap]\n  suffices _ \u2264 p by exact this.antisymm (H.2 \u27e8inferInstance, bot_le\u27e9 this)\n  intro x hx\n  by_contra h\n  apply hM.ne_top\n  apply M.eq_top_of_is_unit_mem hx\n  apply IsUnit.map\n  apply IsLocalization.map_units _ (show p.prime_compl from \u27e8x, h\u27e9)\n  infer_instance\n#align ideal.exists_comap_eq_of_mem_minimal_primes_of_injective Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (p \u00abexpr \u2208 \u00bb (I.comap f).minimal_primes) -/\ntheorem Ideal.exists_comap_eq_of_mem_minimalPrimes {I : Ideal S} (f : R \u2192+* S) (p)\n    (_ : p \u2208 (I.comap f).minimalPrimes) : \u2203 p' : Ideal S, p'.IsPrime \u2227 I \u2264 p' \u2227 p'.comap f = p :=\n  by\n  haveI := H.1.1\n  let f' := I.Quotient.mk.comp f\n  have e : (I.Quotient.mk.comp f).ker = I.comap f :=\n    by\n    ext1\n    exact Submodule.Quotient.mk_eq_zero _\n  have : (I.Quotient.mk.comp f).ker.Quotient.mk.ker \u2264 p :=\n    by\n    rw [Ideal.mk_ker, e]\n    exact H.1.2\n  obtain \u27e8p', hp\u2081, hp\u2082\u27e9 :=\n    Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective\n      (I.Quotient.mk.comp f).ker_lift_injective (p.map (I.Quotient.mk.comp f).ker.Quotient.mk) _\n  \u00b7 skip\n    refine' \u27e8p'.comap I.Quotient.mk, Ideal.IsPrime.comap _, _, _\u27e9\n    \u00b7 exact ideal.mk_ker.symm.trans_le (Ideal.comap_mono bot_le)\n    convert congr_arg (Ideal.comap (I.Quotient.mk.comp f).ker.Quotient.mk) hp\u2082\n    rwa [Ideal.comap_map_of_surjective (I.Quotient.mk.comp f).ker.Quotient.mk\n        Ideal.Quotient.mk_surjective,\n      eq_comm, sup_eq_left]\n  refine' \u27e8\u27e8_, bot_le\u27e9, _\u27e9\n  \u00b7 apply Ideal.map_isPrime_of_surjective _ this\n    exact Ideal.Quotient.mk_surjective\n  \u00b7 rintro q \u27e8hq, -\u27e9 hq'\n    rw [\u2190\n      Ideal.map_comap_of_surjective (I.Quotient.mk.comp f).ker.Quotient.mk\n        Ideal.Quotient.mk_surjective q]\n    apply Ideal.map_mono\n    skip\n    apply H.2\n    \u00b7 refine' \u27e8inferInstance, (ideal.mk_ker.trans e).symm.trans_le (Ideal.comap_mono bot_le)\u27e9\n    \u00b7 refine' (Ideal.comap_mono hq').trans _\n      rw [Ideal.comap_map_of_surjective]\n      exacts[sup_le rfl.le this, Ideal.Quotient.mk_surjective]\n#align ideal.exists_comap_eq_of_mem_minimal_primes Ideal.exists_comap_eq_of_mem_minimalPrimes\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (p \u00abexpr \u2208 \u00bb (I.comap f).minimal_primes) -/\ntheorem Ideal.exists_minimalPrimes_comap_eq {I : Ideal S} (f : R \u2192+* S) (p)\n    (_ : p \u2208 (I.comap f).minimalPrimes) : \u2203 p' \u2208 I.minimalPrimes, Ideal.comap f p' = p :=\n  by\n  obtain \u27e8p', h\u2081, h\u2082, h\u2083\u27e9 := Ideal.exists_comap_eq_of_mem_minimalPrimes f p H\n  skip\n  obtain \u27e8q, hq, hq'\u27e9 := Ideal.exists_minimalPrimes_le h\u2082\n  refine' \u27e8q, hq, Eq.symm _\u27e9\n  haveI := hq.1.1\n  have := (Ideal.comap_mono hq').trans_eq h\u2083\n  exact (H.2 \u27e8inferInstance, Ideal.comap_mono hq.1.2\u27e9 this).antisymm this\n#align ideal.exists_minimal_primes_comap_eq Ideal.exists_minimalPrimes_comap_eq\n\ntheorem Ideal.mimimal_primes_comap_of_surjective {f : R \u2192+* S} (hf : Function.Surjective f)\n    {I J : Ideal S} (h : J \u2208 I.minimalPrimes) : J.comap f \u2208 (I.comap f).minimalPrimes :=\n  by\n  haveI := h.1.1\n  refine' \u27e8\u27e8inferInstance, Ideal.comap_mono h.1.2\u27e9, _\u27e9\n  rintro K \u27e8hK, e\u2081\u27e9 e\u2082\n  have : f.ker \u2264 K := (Ideal.comap_mono bot_le).trans e\u2081\n  rw [\u2190 sup_eq_left.mpr this, RingHom.ker_eq_comap_bot, \u2190 Ideal.comap_map_of_surjective f hf]\n  apply Ideal.comap_mono _\n  apply h.2 _ _\n  \u00b7 exact \u27e8Ideal.map_isPrime_of_surjective hf this, Ideal.le_map_of_comap_le_of_surjective f hf e\u2081\u27e9\n  \u00b7 exact Ideal.map_le_of_le_comap e\u2082\n#align ideal.mimimal_primes_comap_of_surjective Ideal.mimimal_primes_comap_of_surjective\n\ntheorem Ideal.comap_minimalPrimes_eq_of_surjective {f : R \u2192+* S} (hf : Function.Surjective f)\n    (I : Ideal S) : (I.comap f).minimalPrimes = Ideal.comap f '' I.minimalPrimes :=\n  by\n  ext J\n  constructor\n  \u00b7 intro H\n    obtain \u27e8p, h, rfl\u27e9 := Ideal.exists_minimalPrimes_comap_eq f J H\n    exact \u27e8p, h, rfl\u27e9\n  \u00b7 rintro \u27e8J, hJ, rfl\u27e9\n    exact Ideal.mimimal_primes_comap_of_surjective hf hJ\n#align ideal.comap_minimal_primes_eq_of_surjective Ideal.comap_minimalPrimes_eq_of_surjective\n\ntheorem Ideal.minimalPrimes_eq_comap :\n    I.minimalPrimes = Ideal.comap I.Quotient.mk '' minimalPrimes (R \u29f8 I) := by\n  rw [minimalPrimes, \u2190 Ideal.comap_minimalPrimes_eq_of_surjective Ideal.Quotient.mk_surjective, \u2190\n    RingHom.ker_eq_comap_bot, Ideal.mk_ker]\n#align ideal.minimal_primes_eq_comap Ideal.minimalPrimes_eq_comap\n\ntheorem Ideal.minimalPrimes_eq_subsingleton (hI : I.IsPrimary) : I.minimalPrimes = {I.radical} :=\n  by\n  ext J\n  constructor\n  \u00b7\n    exact fun H =>\n      let e := H.1.1.radical_le_iff.mpr H.1.2\n      (H.2 \u27e8Ideal.isPrime_radical hI, Ideal.le_radical\u27e9 e).antisymm e\n  \u00b7 rintro (rfl : J = I.radical)\n    exact \u27e8\u27e8Ideal.isPrime_radical hI, Ideal.le_radical\u27e9, fun _ H _ => H.1.radical_le_iff.mpr H.2\u27e9\n#align ideal.minimal_primes_eq_subsingleton Ideal.minimalPrimes_eq_subsingleton\n\ntheorem Ideal.minimalPrimes_eq_subsingleton_self [I.IsPrime] : I.minimalPrimes = {I} :=\n  by\n  ext J\n  constructor\n  \u00b7 exact fun H => (H.2 \u27e8inferInstance, rfl.le\u27e9 H.1.2).antisymm H.1.2\n  \u00b7 rintro (rfl : J = I)\n    refine' \u27e8\u27e8inferInstance, rfl.le\u27e9, fun _ h _ => h.2\u27e9\n#align ideal.minimal_primes_eq_subsingleton_self Ideal.minimalPrimes_eq_subsingleton_self\n\nend\n\n"}
{"text": "import seminormed_rings\nimport ring_theory.adjoin.basic\n--import field_theory.normal\n\nopen_locale nnreal\n\nvariables {R S : Type*} [comm_ring R] [comm_ring S] [algebra R S]\n\nlemma is_pow_mult.restriction (A : subalgebra R S) {f : S \u2192 \u211d\u22650} (hf_pm : is_pow_mult f) :\n  is_pow_mult (\u03bb x : A, (f x.val)) :=\n\u03bb x n hn, by simpa [subtype.val_eq_coe,subsemiring_class.coe_pow] using (hf_pm \u2191x hn)\n\nlemma is_algebra_norm.restriction (A : subalgebra R S) {g : R \u2192 \u211d\u22650} (hg : is_norm g)\n  {f : S \u2192 \u211d\u22650} (hf_an : is_algebra_norm hg f) : is_algebra_norm hg (\u03bb x : A, (f x.val)) :=\n\u27e8\u27e8\u27e8hf_an.to_is_norm.to_is_seminorm.zero, \u03bb x y, hf_an.to_is_norm.to_is_seminorm.add _ _,\n    \u03bb x y, hf_an.to_is_norm.to_is_seminorm.mul _ _\u27e9, \u03bb x hx, (by {rw [ne.def, \n      \u2190 add_submonoid_class.coe_eq_zero] at hx, exact hf_an.to_is_norm.ne_zero _ hx})\u27e9,\n     \u03bb r x, hf_an.smul _ _\u27e9\n\n-- Proposition 3.1.5/1\nlemma eq_of_pow_mult_faithful {g : R \u2192 \u211d\u22650} (hg : is_mul_norm g) {f\u2081 : S \u2192 \u211d\u22650}\n  (hf\u2081_pm : is_pow_mult f\u2081) (hf\u2081_an : is_algebra_norm (hg.to_is_norm) f\u2081) {f\u2082 : S \u2192 \u211d\u22650}\n  (hf\u2082_pm : is_pow_mult f\u2082) (hf\u2082_an : is_algebra_norm (hg.to_is_norm) f\u2082)\n  (h_eq : \u2200 (y : S), \u2203 (C\u2081 C\u2082 : \u211d\u22650) (hC\u2081 : 0 < C\u2081) (hC\u2082 : 0 < C\u2082), \u2200 (x : (algebra.adjoin R {y})), \n    f\u2081 x.val \u2264 C\u2081 * (f\u2082 x.val) \u2227 f\u2082 x.val \u2264 C\u2082 * (f\u2081 x.val) ) : \n  f\u2081 = f\u2082 := \nbegin\n  ext x,\n  rw nnreal.coe_eq,\n  set g\u2081 : algebra.adjoin R ({x} : set S) \u2192 \u211d\u22650 := \u03bb y, f\u2081 y.val with hg\u2081,\n  set g\u2082 : algebra.adjoin R ({x} : set S) \u2192 \u211d\u22650 := \u03bb y, f\u2082 y.val with hg\u2082,\n  have hg\u2081_s : is_seminorm g\u2081 :=\n  (is_algebra_norm.restriction _ hg.to_is_norm hf\u2081_an).to_is_norm.to_is_seminorm,\n  have hg\u2081_pm : is_pow_mult g\u2081 := is_pow_mult.restriction _ hf\u2081_pm,\n  have hg\u2082_s : is_seminorm g\u2082 :=\n  (is_algebra_norm.restriction _ hg.to_is_norm hf\u2082_an).to_is_norm.to_is_seminorm,\n  have hg\u2082_pm : is_pow_mult g\u2082 := is_pow_mult.restriction _ hf\u2082_pm,\n  let y : algebra.adjoin R ({x} : set S) := \u27e8x, algebra.self_mem_adjoin_singleton R x\u27e9,\n  have hy : x = y.val := rfl,\n  have h1 : f\u2081 y.val = g\u2081 y := rfl,\n  have h2 : f\u2082 y.val = g\u2082 y := rfl,\n  obtain \u27e8C\u2081, C\u2082, hC\u2081_pos, hC\u2082_pos, hC\u27e9 := h_eq x,\n  obtain \u27e8hC\u2081, hC\u2082\u27e9 := forall_and_distrib.mp hC,\n  rw [hy, h1, h2, eq_seminorms hg\u2081_s hg\u2081_pm hg\u2082_s hg\u2082_pm \u27e8C\u2081, hC\u2081_pos, hC\u2081\u27e9 \u27e8C\u2082, hC\u2082_pos, hC\u2082\u27e9],\nend"}
{"text": "lemmas bounded_linear_const_scaleR = bounded_linear_scaleR_right[THEN bounded_linear_compose]"}
{"text": "example (x : \u2115) : x = x :=\nbegin\n  revert x,\n  intro y,\n  reflexivity\nend\n"}
{"text": "/-\nCopyright (c) 2019 Amelia Livingston. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Amelia Livingston, Bryan Gin-ge Chen, Patrick Massot\n\n! This file was ported from Lean 3 source module data.setoid.partition\n! leanprover-community/mathlib commit 50832daea47b195a48b5b33b1c8b2162c48c3afc\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Data.Fintype.Basic\nimport Mathbin.Data.Set.Finite\nimport Mathbin.Data.Setoid.Basic\nimport Mathbin.Order.Partition.Finpartition\n\n/-!\n# Equivalence relations: partitions\n\n> THIS FILE IS SYNCHRONIZED WITH MATHLIB4.\n> Any changes to this file require a corresponding PR to mathlib4.\n\nThis file comprises properties of equivalence relations viewed as partitions.\nThere are two implementations of partitions here:\n* A collection `c : set (set \u03b1)` of sets is a partition of `\u03b1` if `\u2205 \u2209 c` and each element `a : \u03b1`\n  belongs to a unique set `b \u2208 c`. This is expressed as `is_partition c`\n* An indexed partition is a map `s : \u03b9 \u2192 \u03b1` whose image is a partition. This is\n  expressed as `indexed_partition s`.\n\nOf course both implementations are related to `quotient` and `setoid`.\n\n`setoid.is_partition.partition` and `finpartition.is_partition_parts` furnish\na link between `setoid.is_partition` and `finpartition`.\n\n## TODO\n\nCould the design of `finpartition` inform the one of `setoid.is_partition`? Maybe bundling it and\nchanging it from `set (set \u03b1)` to `set \u03b1` where `[lattice \u03b1] [order_bot \u03b1]` would make it more\nusable.\n\n## Tags\n\nsetoid, equivalence, iseqv, relation, equivalence relation, partition, equivalence class\n-/\n\n\nnamespace Setoid\n\nvariable {\u03b1 : Type _}\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n#print Setoid.eq_of_mem_eqv_class /-\n/-- If x \u2208 \u03b1 is in 2 elements of a set of sets partitioning \u03b1, those 2 sets are equal. -/\ntheorem eq_of_mem_eqv_class {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _)(_ : b \u2208 c), a \u2208 b) {x b b'}\n    (hc : b \u2208 c) (hb : x \u2208 b) (hc' : b' \u2208 c) (hb' : x \u2208 b') : b = b' :=\n  (H x).unique\u2082 hc hb hc' hb'\n#align setoid.eq_of_mem_eqv_class Setoid.eq_of_mem_eqv_class\n-/\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n#print Setoid.mkClasses /-\n/-- Makes an equivalence relation from a set of sets partitioning \u03b1. -/\ndef mkClasses (c : Set (Set \u03b1)) (H : \u2200 a, \u2203! (b : _)(_ : b \u2208 c), a \u2208 b) : Setoid \u03b1 :=\n  \u27e8fun x y => \u2200 s \u2208 c, x \u2208 s \u2192 y \u2208 s,\n    \u27e8fun _ _ _ hx => hx, fun x y h s hs hy =>\n      (H x).elim\u2082 fun t ht hx _ =>\n        have : s = t := eq_of_mem_eqv_class H hs hy ht (h t ht hx)\n        this.symm \u25b8 hx,\n      fun x y z h1 h2 s hs hx =>\n      (H y).elim\u2082 fun t ht hy _ =>\n        (H z).elim\u2082 fun t' ht' hz _ =>\n          have hst : s = t := eq_of_mem_eqv_class H hs (h1 _ hs hx) ht hy\n          have htt' : t = t' := eq_of_mem_eqv_class H ht (h2 _ ht hy) ht' hz\n          (hst.trans htt').symm \u25b8 hz\u27e9\u27e9\n#align setoid.mk_classes Setoid.mkClasses\n-/\n\n#print Setoid.classes /-\n/-- Makes the equivalence classes of an equivalence relation. -/\ndef classes (r : Setoid \u03b1) : Set (Set \u03b1) :=\n  { s | \u2203 y, s = { x | r.Rel x y } }\n#align setoid.classes Setoid.classes\n-/\n\n#print Setoid.mem_classes /-\ntheorem mem_classes (r : Setoid \u03b1) (y) : { x | r.Rel x y } \u2208 r.classes :=\n  \u27e8y, rfl\u27e9\n#align setoid.mem_classes Setoid.mem_classes\n-/\n\n#print Setoid.classes_ker_subset_fiber_set /-\ntheorem classes_ker_subset_fiber_set {\u03b2 : Type _} (f : \u03b1 \u2192 \u03b2) :\n    (Setoid.ker f).classes \u2286 Set.range fun y => { x | f x = y } :=\n  by\n  rintro s \u27e8x, rfl\u27e9\n  rw [Set.mem_range]\n  exact \u27e8f x, rfl\u27e9\n#align setoid.classes_ker_subset_fiber_set Setoid.classes_ker_subset_fiber_set\n-/\n\n/- warning: setoid.finite_classes_ker -> Setoid.finite_classes_ker is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} {\u03b2 : Type.{u2}} [_inst_1 : Finite.{succ u2} \u03b2] (f : \u03b1 -> \u03b2), Set.Finite.{u1} (Set.{u1} \u03b1) (Setoid.classes.{u1} \u03b1 (Setoid.ker.{u1, u2} \u03b1 \u03b2 f))\nbut is expected to have type\n  forall {\u03b1 : Type.{u2}} {\u03b2 : Type.{u1}} [_inst_1 : Finite.{succ u1} \u03b2] (f : \u03b1 -> \u03b2), Set.Finite.{u2} (Set.{u2} \u03b1) (Setoid.classes.{u2} \u03b1 (Setoid.ker.{u2, u1} \u03b1 \u03b2 f))\nCase conversion may be inaccurate. Consider using '#align setoid.finite_classes_ker Setoid.finite_classes_ker\u2093'. -/\ntheorem finite_classes_ker {\u03b1 \u03b2 : Type _} [Finite \u03b2] (f : \u03b1 \u2192 \u03b2) : (Setoid.ker f).classes.Finite :=\n  (Set.finite_range _).Subset <| classes_ker_subset_fiber_set f\n#align setoid.finite_classes_ker Setoid.finite_classes_ker\n\n/- warning: setoid.card_classes_ker_le -> Setoid.card_classes_ker_le is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} {\u03b2 : Type.{u2}} [_inst_1 : Fintype.{u2} \u03b2] (f : \u03b1 -> \u03b2) [_inst_2 : Fintype.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} \u03b1)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} \u03b1)) (Setoid.classes.{u1} \u03b1 (Setoid.ker.{u1, u2} \u03b1 \u03b2 f)))], LE.le.{0} Nat Nat.hasLe (Fintype.card.{u1} (coeSort.{succ u1, succ (succ u1)} (Set.{u1} (Set.{u1} \u03b1)) Type.{u1} (Set.hasCoeToSort.{u1} (Set.{u1} \u03b1)) (Setoid.classes.{u1} \u03b1 (Setoid.ker.{u1, u2} \u03b1 \u03b2 f))) _inst_2) (Fintype.card.{u2} \u03b2 _inst_1)\nbut is expected to have type\n  forall {\u03b1 : Type.{u2}} {\u03b2 : Type.{u1}} [_inst_1 : Fintype.{u1} \u03b2] (f : \u03b1 -> \u03b2) [_inst_2 : Fintype.{u2} (Set.Elem.{u2} (Set.{u2} \u03b1) (Setoid.classes.{u2} \u03b1 (Setoid.ker.{u2, u1} \u03b1 \u03b2 f)))], LE.le.{0} Nat instLENat (Fintype.card.{u2} (Set.Elem.{u2} (Set.{u2} \u03b1) (Setoid.classes.{u2} \u03b1 (Setoid.ker.{u2, u1} \u03b1 \u03b2 f))) _inst_2) (Fintype.card.{u1} \u03b2 _inst_1)\nCase conversion may be inaccurate. Consider using '#align setoid.card_classes_ker_le Setoid.card_classes_ker_le\u2093'. -/\ntheorem card_classes_ker_le {\u03b1 \u03b2 : Type _} [Fintype \u03b2] (f : \u03b1 \u2192 \u03b2)\n    [Fintype (Setoid.ker f).classes] : Fintype.card (Setoid.ker f).classes \u2264 Fintype.card \u03b2 := by\n  classical exact\n      le_trans (Set.card_le_of_subset (classes_ker_subset_fiber_set f)) (Fintype.card_range_le _)\n#align setoid.card_classes_ker_le Setoid.card_classes_ker_le\n\n#print Setoid.eq_iff_classes_eq /-\n/-- Two equivalence relations are equal iff all their equivalence classes are equal. -/\ntheorem eq_iff_classes_eq {r\u2081 r\u2082 : Setoid \u03b1} :\n    r\u2081 = r\u2082 \u2194 \u2200 x, { y | r\u2081.Rel x y } = { y | r\u2082.Rel x y } :=\n  \u27e8fun h x => h \u25b8 rfl, fun h => ext' fun x => Set.ext_iff.1 <| h x\u27e9\n#align setoid.eq_iff_classes_eq Setoid.eq_iff_classes_eq\n-/\n\n/- warning: setoid.rel_iff_exists_classes -> Setoid.rel_iff_exists_classes is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} (r : Setoid.{succ u1} \u03b1) {x : \u03b1} {y : \u03b1}, Iff (Setoid.Rel.{u1} \u03b1 r x y) (Exists.{succ u1} (Set.{u1} \u03b1) (fun (c : Set.{u1} \u03b1) => Exists.{0} (Membership.Mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.hasMem.{u1} (Set.{u1} \u03b1)) c (Setoid.classes.{u1} \u03b1 r)) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.hasMem.{u1} (Set.{u1} \u03b1)) c (Setoid.classes.{u1} \u03b1 r)) => And (Membership.Mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.hasMem.{u1} \u03b1) x c) (Membership.Mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.hasMem.{u1} \u03b1) y c))))\nbut is expected to have type\n  forall {\u03b1 : Type.{u1}} (r : Setoid.{succ u1} \u03b1) {x : \u03b1} {y : \u03b1}, Iff (Setoid.Rel.{u1} \u03b1 r x y) (Exists.{succ u1} (Set.{u1} \u03b1) (fun (c : Set.{u1} \u03b1) => And (Membership.mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.instMembershipSet.{u1} (Set.{u1} \u03b1)) c (Setoid.classes.{u1} \u03b1 r)) (And (Membership.mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.instMembershipSet.{u1} \u03b1) x c) (Membership.mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.instMembershipSet.{u1} \u03b1) y c))))\nCase conversion may be inaccurate. Consider using '#align setoid.rel_iff_exists_classes Setoid.rel_iff_exists_classes\u2093'. -/\ntheorem rel_iff_exists_classes (r : Setoid \u03b1) {x y} : r.Rel x y \u2194 \u2203 c \u2208 r.classes, x \u2208 c \u2227 y \u2208 c :=\n  \u27e8fun h => \u27e8_, r.mem_classes y, h, r.refl' y\u27e9, fun \u27e8c, \u27e8z, hz\u27e9, hx, hy\u27e9 =>\n    by\n    subst c\n    exact r.trans' hx (r.symm' hy)\u27e9\n#align setoid.rel_iff_exists_classes Setoid.rel_iff_exists_classes\n\n#print Setoid.classes_inj /-\n/-- Two equivalence relations are equal iff their equivalence classes are equal. -/\ntheorem classes_inj {r\u2081 r\u2082 : Setoid \u03b1} : r\u2081 = r\u2082 \u2194 r\u2081.classes = r\u2082.classes :=\n  \u27e8fun h => h \u25b8 rfl, fun h => ext' fun a b => by simp only [rel_iff_exists_classes, exists_prop, h]\u27e9\n#align setoid.classes_inj Setoid.classes_inj\n-/\n\n#print Setoid.empty_not_mem_classes /-\n/-- The empty set is not an equivalence class. -/\ntheorem empty_not_mem_classes {r : Setoid \u03b1} : \u2205 \u2209 r.classes := fun \u27e8y, hy\u27e9 =>\n  Set.not_mem_empty y <| hy.symm \u25b8 r.refl' y\n#align setoid.empty_not_mem_classes Setoid.empty_not_mem_classes\n-/\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb r.classes) -/\n#print Setoid.classes_eqv_classes /-\n/-- Equivalence classes partition the type. -/\ntheorem classes_eqv_classes {r : Setoid \u03b1} (a) : \u2203! (b : _)(_ : b \u2208 r.classes), a \u2208 b :=\n  ExistsUnique.intro\u2082 { x | r.Rel x a } (r.mem_classes a) (r.refl' _) <|\n    by\n    rintro _ \u27e8y, rfl\u27e9 ha\n    ext x\n    exact \u27e8fun hx => r.trans' hx (r.symm' ha), fun hx => r.trans' hx ha\u27e9\n#align setoid.classes_eqv_classes Setoid.classes_eqv_classes\n-/\n\n#print Setoid.eq_of_mem_classes /-\n/-- If x \u2208 \u03b1 is in 2 equivalence classes, the equivalence classes are equal. -/\ntheorem eq_of_mem_classes {r : Setoid \u03b1} {x b} (hc : b \u2208 r.classes) (hb : x \u2208 b) {b'}\n    (hc' : b' \u2208 r.classes) (hb' : x \u2208 b') : b = b' :=\n  eq_of_mem_eqv_class classes_eqv_classes hc hb hc' hb'\n#align setoid.eq_of_mem_classes Setoid.eq_of_mem_classes\n-/\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n#print Setoid.eq_eqv_class_of_mem /-\n/-- The elements of a set of sets partitioning \u03b1 are the equivalence classes of the\n    equivalence relation defined by the set of sets. -/\ntheorem eq_eqv_class_of_mem {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _)(_ : b \u2208 c), a \u2208 b) {s y}\n    (hs : s \u2208 c) (hy : y \u2208 s) : s = { x | (mkClasses c H).Rel x y } :=\n  Set.ext fun x =>\n    \u27e8fun hs' => symm' (mkClasses c H) fun b' hb' h' => eq_of_mem_eqv_class H hs hy hb' h' \u25b8 hs',\n      fun hx =>\n      (H x).elim\u2082 fun b' hc' hb' h' =>\n        (eq_of_mem_eqv_class H hs hy hc' <| hx b' hc' hb').symm \u25b8 hb'\u27e9\n#align setoid.eq_eqv_class_of_mem Setoid.eq_eqv_class_of_mem\n-/\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n#print Setoid.eqv_class_mem /-\n/-- The equivalence classes of the equivalence relation defined by a set of sets\n    partitioning \u03b1 are elements of the set of sets. -/\ntheorem eqv_class_mem {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _)(_ : b \u2208 c), a \u2208 b) {y} :\n    { x | (mkClasses c H).Rel x y } \u2208 c :=\n  (H y).elim\u2082 fun b hc hy hb => eq_eqv_class_of_mem H hc hy \u25b8 hc\n#align setoid.eqv_class_mem Setoid.eqv_class_mem\n-/\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n#print Setoid.eqv_class_mem' /-\ntheorem eqv_class_mem' {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _)(_ : b \u2208 c), a \u2208 b) {x} :\n    { y : \u03b1 | (mkClasses c H).Rel x y } \u2208 c :=\n  by\n  convert Setoid.eqv_class_mem H\n  ext\n  rw [Setoid.comm']\n#align setoid.eqv_class_mem' Setoid.eqv_class_mem'\n-/\n\n/- warning: setoid.eqv_classes_disjoint -> Setoid.eqv_classes_disjoint is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (forall (a : \u03b1), ExistsUnique.{succ u1} (Set.{u1} \u03b1) (fun (b : Set.{u1} \u03b1) => ExistsUnique.{0} (Membership.Mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.hasMem.{u1} (Set.{u1} \u03b1)) b c) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.hasMem.{u1} (Set.{u1} \u03b1)) b c) => Membership.Mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.hasMem.{u1} \u03b1) a b))) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.completeBooleanAlgebra.{u1} \u03b1)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} \u03b1) (Set.booleanAlgebra.{u1} \u03b1))) c (id.{succ u1} (Set.{u1} \u03b1)))\nbut is expected to have type\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (forall (a : \u03b1), ExistsUnique.{succ u1} (Set.{u1} \u03b1) (fun (b : Set.{u1} \u03b1) => ExistsUnique.{0} (Membership.mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.instMembershipSet.{u1} (Set.{u1} \u03b1)) b c) (fun (H : Membership.mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.instMembershipSet.{u1} (Set.{u1} \u03b1)) b c) => Membership.mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.instMembershipSet.{u1} \u03b1) a b))) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) c (id.{succ u1} (Set.{u1} \u03b1)))\nCase conversion may be inaccurate. Consider using '#align setoid.eqv_classes_disjoint Setoid.eqv_classes_disjoint\u2093'. -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n/-- Distinct elements of a set of sets partitioning \u03b1 are disjoint. -/\ntheorem eqv_classes_disjoint {c : Set (Set \u03b1)} (H : \u2200 a, \u2203! (b : _)(_ : b \u2208 c), a \u2208 b) :\n    c.PairwiseDisjoint id := fun b\u2081 h\u2081 b\u2082 h\u2082 h =>\n  Set.disjoint_left.2 fun x hx1 hx2 =>\n    (H x).elim\u2082 fun b hc hx hb => h <| eq_of_mem_eqv_class H h\u2081 hx1 h\u2082 hx2\n#align setoid.eqv_classes_disjoint Setoid.eqv_classes_disjoint\n\n/- warning: setoid.eqv_classes_of_disjoint_union -> Setoid.eqv_classes_of_disjoint_union is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (Eq.{succ u1} (Set.{u1} \u03b1) (Set.union\u209b.{u1} \u03b1 c) (Set.univ.{u1} \u03b1)) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.completeBooleanAlgebra.{u1} \u03b1)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} \u03b1) (Set.booleanAlgebra.{u1} \u03b1))) c (id.{succ u1} (Set.{u1} \u03b1))) -> (forall (a : \u03b1), ExistsUnique.{succ u1} (Set.{u1} \u03b1) (fun (b : Set.{u1} \u03b1) => ExistsUnique.{0} (Membership.Mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.hasMem.{u1} (Set.{u1} \u03b1)) b c) (fun (H : Membership.Mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.hasMem.{u1} (Set.{u1} \u03b1)) b c) => Membership.Mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.hasMem.{u1} \u03b1) a b)))\nbut is expected to have type\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (Eq.{succ u1} (Set.{u1} \u03b1) (Set.union\u209b.{u1} \u03b1 c) (Set.univ.{u1} \u03b1)) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) c (id.{succ u1} (Set.{u1} \u03b1))) -> (forall (a : \u03b1), ExistsUnique.{succ u1} (Set.{u1} \u03b1) (fun (b : Set.{u1} \u03b1) => ExistsUnique.{0} (Membership.mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.instMembershipSet.{u1} (Set.{u1} \u03b1)) b c) (fun (H : Membership.mem.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} (Set.{u1} \u03b1)) (Set.instMembershipSet.{u1} (Set.{u1} \u03b1)) b c) => Membership.mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.instMembershipSet.{u1} \u03b1) a b)))\nCase conversion may be inaccurate. Consider using '#align setoid.eqv_classes_of_disjoint_union Setoid.eqv_classes_of_disjoint_union\u2093'. -/\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n/-- A set of disjoint sets covering \u03b1 partition \u03b1 (classical). -/\ntheorem eqv_classes_of_disjoint_union {c : Set (Set \u03b1)} (hu : Set.union\u209b c = @Set.univ \u03b1)\n    (H : c.PairwiseDisjoint id) (a) : \u2203! (b : _)(_ : b \u2208 c), a \u2208 b :=\n  let \u27e8b, hc, ha\u27e9 := Set.mem_union\u209b.1 <| show a \u2208 _ by rw [hu] <;> exact Set.mem_univ a\n  ExistsUnique.intro\u2082 b hc ha fun b' hc' ha' => H.elim_set hc' hc a ha' ha\n#align setoid.eqv_classes_of_disjoint_union Setoid.eqv_classes_of_disjoint_union\n\n/- warning: setoid.setoid_of_disjoint_union -> Setoid.setoidOfDisjointUnion is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (Eq.{succ u1} (Set.{u1} \u03b1) (Set.union\u209b.{u1} \u03b1 c) (Set.univ.{u1} \u03b1)) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.completeBooleanAlgebra.{u1} \u03b1)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} \u03b1) (Set.booleanAlgebra.{u1} \u03b1))) c (id.{succ u1} (Set.{u1} \u03b1))) -> (Setoid.{succ u1} \u03b1)\nbut is expected to have type\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (Eq.{succ u1} (Set.{u1} \u03b1) (Set.union\u209b.{u1} \u03b1 c) (Set.univ.{u1} \u03b1)) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) c (id.{succ u1} (Set.{u1} \u03b1))) -> (Setoid.{succ u1} \u03b1)\nCase conversion may be inaccurate. Consider using '#align setoid.setoid_of_disjoint_union Setoid.setoidOfDisjointUnion\u2093'. -/\n/-- Makes an equivalence relation from a set of disjoints sets covering \u03b1. -/\ndef setoidOfDisjointUnion {c : Set (Set \u03b1)} (hu : Set.union\u209b c = @Set.univ \u03b1)\n    (H : c.PairwiseDisjoint id) : Setoid \u03b1 :=\n  Setoid.mkClasses c <| eqv_classes_of_disjoint_union hu H\n#align setoid.setoid_of_disjoint_union Setoid.setoidOfDisjointUnion\n\n#print Setoid.mkClasses_classes /-\n/-- The equivalence relation made from the equivalence classes of an equivalence\n    relation r equals r. -/\ntheorem mkClasses_classes (r : Setoid \u03b1) : mkClasses r.classes classes_eqv_classes = r :=\n  ext' fun x y =>\n    \u27e8fun h => r.symm' (h { z | r.Rel z x } (r.mem_classes x) <| r.refl' x), fun h b hb hx =>\n      eq_of_mem_classes (r.mem_classes x) (r.refl' x) hb hx \u25b8 r.symm' h\u27e9\n#align setoid.mk_classes_classes Setoid.mkClasses_classes\n-/\n\n#print Setoid.union\u209b_classes /-\n@[simp]\ntheorem union\u209b_classes (r : Setoid \u03b1) : \u22c3\u2080 r.classes = Set.univ :=\n  Set.eq_univ_of_forall fun x => Set.mem_union\u209b.2 \u27e8{ y | r.Rel y x }, \u27e8x, rfl\u27e9, Setoid.refl _\u27e9\n#align setoid.sUnion_classes Setoid.union\u209b_classes\n-/\n\nsection Partition\n\n/- ./././Mathport/Syntax/Translate/Basic.lean:635:2: warning: expanding binder collection (b \u00abexpr \u2208 \u00bb c) -/\n#print Setoid.IsPartition /-\n/-- A collection `c : set (set \u03b1)` of sets is a partition of `\u03b1` into pairwise\ndisjoint sets if `\u2205 \u2209 c` and each element `a : \u03b1` belongs to a unique set `b \u2208 c`. -/\ndef IsPartition (c : Set (Set \u03b1)) :=\n  \u2205 \u2209 c \u2227 \u2200 a, \u2203! (b : _)(_ : b \u2208 c), a \u2208 b\n#align setoid.is_partition Setoid.IsPartition\n-/\n\n#print Setoid.nonempty_of_mem_partition /-\n/-- A partition of `\u03b1` does not contain the empty set. -/\ntheorem nonempty_of_mem_partition {c : Set (Set \u03b1)} (hc : IsPartition c) {s} (h : s \u2208 c) :\n    s.Nonempty :=\n  Set.nonempty_iff_ne_empty.2 fun hs0 => hc.1 <| hs0 \u25b8 h\n#align setoid.nonempty_of_mem_partition Setoid.nonempty_of_mem_partition\n-/\n\n#print Setoid.isPartition_classes /-\ntheorem isPartition_classes (r : Setoid \u03b1) : IsPartition r.classes :=\n  \u27e8empty_not_mem_classes, classes_eqv_classes\u27e9\n#align setoid.is_partition_classes Setoid.isPartition_classes\n-/\n\n/- warning: setoid.is_partition.pairwise_disjoint -> Setoid.IsPartition.pairwiseDisjoint is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (Setoid.IsPartition.{u1} \u03b1 c) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.completeBooleanAlgebra.{u1} \u03b1)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} \u03b1) (Set.booleanAlgebra.{u1} \u03b1))) c (id.{succ u1} (Set.{u1} \u03b1)))\nbut is expected to have type\n  forall {\u03b1 : Type.{u1}} {c : Set.{u1} (Set.{u1} \u03b1)}, (Setoid.IsPartition.{u1} \u03b1 c) -> (Set.PairwiseDisjoint.{u1, u1} (Set.{u1} \u03b1) (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) c (id.{succ u1} (Set.{u1} \u03b1)))\nCase conversion may be inaccurate. Consider using '#align setoid.is_partition.pairwise_disjoint Setoid.IsPartition.pairwiseDisjoint\u2093'. -/\ntheorem IsPartition.pairwiseDisjoint {c : Set (Set \u03b1)} (hc : IsPartition c) :\n    c.PairwiseDisjoint id :=\n  eqv_classes_disjoint hc.2\n#align setoid.is_partition.pairwise_disjoint Setoid.IsPartition.pairwiseDisjoint\n\n#print Setoid.IsPartition.union\u209b_eq_univ /-\ntheorem IsPartition.union\u209b_eq_univ {c : Set (Set \u03b1)} (hc : IsPartition c) : \u22c3\u2080 c = Set.univ :=\n  Set.eq_univ_of_forall fun x =>\n    Set.mem_union\u209b.2 <|\n      let \u27e8t, ht\u27e9 := hc.2 x\n      \u27e8t, by\n        simp only [exists_unique_iff_exists] at ht\n        tauto\u27e9\n#align setoid.is_partition.sUnion_eq_univ Setoid.IsPartition.union\u209b_eq_univ\n-/\n\n#print Setoid.exists_of_mem_partition /-\n/-- All elements of a partition of \u03b1 are the equivalence class of some y \u2208 \u03b1. -/\ntheorem exists_of_mem_partition {c : Set (Set \u03b1)} (hc : IsPartition c) {s} (hs : s \u2208 c) :\n    \u2203 y, s = { x | (mkClasses c hc.2).Rel x y } :=\n  let \u27e8y, hy\u27e9 := nonempty_of_mem_partition hc hs\n  \u27e8y, eq_eqv_class_of_mem hc.2 hs hy\u27e9\n#align setoid.exists_of_mem_partition Setoid.exists_of_mem_partition\n-/\n\n#print Setoid.classes_mkClasses /-\n/-- The equivalence classes of the equivalence relation defined by a partition of \u03b1 equal\n    the original partition. -/\ntheorem classes_mkClasses (c : Set (Set \u03b1)) (hc : IsPartition c) : (mkClasses c hc.2).classes = c :=\n  Set.ext fun s =>\n    \u27e8fun \u27e8y, hs\u27e9 =>\n      (hc.2 y).elim\u2082 fun b hm hb hy => by\n        rwa [show s = b from\n            hs.symm \u25b8\n              Set.ext fun x =>\n                \u27e8fun hx => symm' (mk_classes c hc.2) hx b hm hb, fun hx b' hc' hx' =>\n                  eq_of_mem_eqv_class hc.2 hm hx hc' hx' \u25b8 hb\u27e9],\n      exists_of_mem_partition hc\u27e9\n#align setoid.classes_mk_classes Setoid.classes_mkClasses\n-/\n\n#print Setoid.Partition.le /-\n/-- Defining `\u2264` on partitions as the `\u2264` defined on their induced equivalence relations. -/\ninstance Partition.le : LE (Subtype (@IsPartition \u03b1)) :=\n  \u27e8fun x y => mkClasses x.1 x.2.2 \u2264 mkClasses y.1 y.2.2\u27e9\n#align setoid.partition.le Setoid.Partition.le\n-/\n\n#print Setoid.Partition.partialOrder /-\n/-- Defining a partial order on partitions as the partial order on their induced\n    equivalence relations. -/\ninstance Partition.partialOrder : PartialOrder (Subtype (@IsPartition \u03b1))\n    where\n  le := (\u00b7 \u2264 \u00b7)\n  lt x y := x \u2264 y \u2227 \u00acy \u2264 x\n  le_refl _ := @le_refl (Setoid \u03b1) _ _\n  le_trans _ _ _ := @le_trans (Setoid \u03b1) _ _ _ _\n  lt_iff_le_not_le _ _ := Iff.rfl\n  le_antisymm x y hx hy := by\n    let h := @le_antisymm (Setoid \u03b1) _ _ _ hx hy\n    rw [Subtype.ext_iff_val, \u2190 classes_mk_classes x.1 x.2, \u2190 classes_mk_classes y.1 y.2, h]\n#align setoid.partition.partial_order Setoid.Partition.partialOrder\n-/\n\nvariable (\u03b1)\n\n#print Setoid.Partition.orderIso /-\n/-- The order-preserving bijection between equivalence relations on a type `\u03b1`, and\n  partitions of `\u03b1` into subsets. -/\nprotected def Partition.orderIso : Setoid \u03b1 \u2243o { C : Set (Set \u03b1) // IsPartition C }\n    where\n  toFun r := \u27e8r.classes, empty_not_mem_classes, classes_eqv_classes\u27e9\n  invFun C := mkClasses C.1 C.2.2\n  left_inv := mkClasses_classes\n  right_inv C := by rw [Subtype.ext_iff_val, \u2190 classes_mk_classes C.1 C.2]\n  map_rel_iff' r s :=\n    by\n    conv_rhs => rw [\u2190 mk_classes_classes r, \u2190 mk_classes_classes s]\n    rfl\n#align setoid.partition.order_iso Setoid.Partition.orderIso\n-/\n\nvariable {\u03b1}\n\n#print Setoid.Partition.completeLattice /-\n/-- A complete lattice instance for partitions; there is more infrastructure for the\n    equivalent complete lattice on equivalence relations. -/\ninstance Partition.completeLattice : CompleteLattice (Subtype (@IsPartition \u03b1)) :=\n  GaloisInsertion.liftCompleteLattice <|\n    @OrderIso.toGaloisInsertion _ (Subtype (@IsPartition \u03b1)) _ (PartialOrder.toPreorder _) <|\n      Partition.orderIso \u03b1\n#align setoid.partition.complete_lattice Setoid.Partition.completeLattice\n-/\n\nend Partition\n\n/- warning: setoid.is_partition.finpartition -> Setoid.IsPartition.finpartition is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} {c : Finset.{u1} (Set.{u1} \u03b1)}, (Setoid.IsPartition.{u1} \u03b1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Set.{u1} \u03b1)) (Set.{u1} (Set.{u1} \u03b1)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Set.{u1} \u03b1)) (Set.{u1} (Set.{u1} \u03b1)) (CoeTC\u2093.coe.{succ u1, succ u1} (Finset.{u1} (Set.{u1} \u03b1)) (Set.{u1} (Set.{u1} \u03b1)) (Finset.Set.hasCoeT.{u1} (Set.{u1} \u03b1)))) c)) -> (Finpartition.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.completeBooleanAlgebra.{u1} \u03b1))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} \u03b1) (Set.booleanAlgebra.{u1} \u03b1))) (Set.univ.{u1} \u03b1))\nbut is expected to have type\n  forall {\u03b1 : Type.{u1}} {c : Finset.{u1} (Set.{u1} \u03b1)}, (Setoid.IsPartition.{u1} \u03b1 (Finset.toSet.{u1} (Set.{u1} \u03b1) c)) -> (Finpartition.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (SemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (Lattice.toSemilatticeInf.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1))))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (Set.univ.{u1} \u03b1))\nCase conversion may be inaccurate. Consider using '#align setoid.is_partition.finpartition Setoid.IsPartition.finpartition\u2093'. -/\n/-- A finite setoid partition furnishes a finpartition -/\n@[simps]\ndef IsPartition.finpartition {c : Finset (Set \u03b1)} (hc : Setoid.IsPartition (c : Set (Set \u03b1))) :\n    Finpartition (Set.univ : Set \u03b1) where\n  parts := c\n  SupIndep := Finset.supIndep_iff_pairwiseDisjoint.mpr <| eqv_classes_disjoint hc.2\n  supParts := c.sup_id_set_eq_union\u209b.trans hc.union\u209b_eq_univ\n  not_bot_mem := hc.left\n#align setoid.is_partition.finpartition Setoid.IsPartition.finpartition\n\nend Setoid\n\n/- warning: finpartition.is_partition_parts -> Finpartition.isPartition_parts is a dubious translation:\nlean 3 declaration is\n  forall {\u03b1 : Type.{u1}} (f : Finpartition.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.completeBooleanAlgebra.{u1} \u03b1))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} \u03b1) (Set.booleanAlgebra.{u1} \u03b1))) (Set.univ.{u1} \u03b1)), Setoid.IsPartition.{u1} \u03b1 ((fun (a : Type.{u1}) (b : Type.{u1}) [self : HasLiftT.{succ u1, succ u1} a b] => self.0) (Finset.{u1} (Set.{u1} \u03b1)) (Set.{u1} (Set.{u1} \u03b1)) (HasLiftT.mk.{succ u1, succ u1} (Finset.{u1} (Set.{u1} \u03b1)) (Set.{u1} (Set.{u1} \u03b1)) (CoeTC\u2093.coe.{succ u1, succ u1} (Finset.{u1} (Set.{u1} \u03b1)) (Set.{u1} (Set.{u1} \u03b1)) (Finset.Set.hasCoeT.{u1} (Set.{u1} \u03b1)))) (Finpartition.parts.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.completeBooleanAlgebra.{u1} \u03b1))))) (GeneralizedBooleanAlgebra.toOrderBot.{u1} (Set.{u1} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u1} (Set.{u1} \u03b1) (Set.booleanAlgebra.{u1} \u03b1))) (Set.univ.{u1} \u03b1) f))\nbut is expected to have type\n  forall {\u03b1 : Type.{u1}} (f : Finpartition.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (SemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (Lattice.toSemilatticeInf.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1))))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (Set.univ.{u1} \u03b1)), Setoid.IsPartition.{u1} \u03b1 (Finset.toSet.{u1} (Set.{u1} \u03b1) (Finpartition.parts.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (SemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (Lattice.toSemilatticeInf.{u1} (Set.{u1} \u03b1) (CompleteLattice.toLattice.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1))))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (Set.univ.{u1} \u03b1) f))\nCase conversion may be inaccurate. Consider using '#align finpartition.is_partition_parts Finpartition.isPartition_parts\u2093'. -/\n/-- A finpartition gives rise to a setoid partition -/\ntheorem Finpartition.isPartition_parts {\u03b1} (f : Finpartition (Set.univ : Set \u03b1)) :\n    Setoid.IsPartition (f.parts : Set (Set \u03b1)) :=\n  \u27e8f.not_bot_mem,\n    Setoid.eqv_classes_of_disjoint_union (f.parts.sup_id_set_eq_union\u209b.symm.trans f.supParts)\n      f.SupIndep.PairwiseDisjoint\u27e9\n#align finpartition.is_partition_parts Finpartition.isPartition_parts\n\n#print IndexedPartition /-\n/-- Constructive information associated with a partition of a type `\u03b1` indexed by another type `\u03b9`,\n`s : \u03b9 \u2192 set \u03b1`.\n\n`indexed_partition.index` sends an element to its index, while `indexed_partition.some` sends\nan index to an element of the corresponding set.\n\nThis type is primarily useful for definitional control of `s` - if this is not needed, then\n`setoid.ker index` by itself may be sufficient. -/\nstructure IndexedPartition {\u03b9 \u03b1 : Type _} (s : \u03b9 \u2192 Set \u03b1) where\n  eq_of_mem : \u2200 {x i j}, x \u2208 s i \u2192 x \u2208 s j \u2192 i = j\n  some : \u03b9 \u2192 \u03b1\n  some_mem : \u2200 i, some i \u2208 s i\n  index : \u03b1 \u2192 \u03b9\n  mem_index : \u2200 x, x \u2208 s (index x)\n#align indexed_partition IndexedPartition\n-/\n\n/- warning: indexed_partition.mk' -> IndexedPartition.mk' is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} (s : \u03b9 -> (Set.{u2} \u03b1)), (forall (i : \u03b9) (j : \u03b9), (Ne.{succ u1} \u03b9 i j) -> (Disjoint.{u2} (Set.{u2} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} \u03b1) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} \u03b1) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} \u03b1) (Set.completeBooleanAlgebra.{u2} \u03b1)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u2} (Set.{u2} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} (Set.{u2} \u03b1) (Set.booleanAlgebra.{u2} \u03b1))) (s i) (s j))) -> (forall (i : \u03b9), Set.Nonempty.{u2} \u03b1 (s i)) -> (forall (x : \u03b1), Exists.{succ u1} \u03b9 (fun (i : \u03b9) => Membership.Mem.{u2, u2} \u03b1 (Set.{u2} \u03b1) (Set.hasMem.{u2} \u03b1) x (s i))) -> (IndexedPartition.{u1, u2} \u03b9 \u03b1 s)\nbut is expected to have type\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} (s : \u03b9 -> (Set.{u2} \u03b1)), (forall (i : \u03b9) (j : \u03b9), (Ne.{succ u1} \u03b9 i j) -> (Disjoint.{u2} (Set.{u2} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} \u03b1) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} \u03b1) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u2} \u03b1)))))) (BoundedOrder.toOrderBot.{u2} (Set.{u2} \u03b1) (Preorder.toLE.{u2} (Set.{u2} \u03b1) (PartialOrder.toPreorder.{u2} (Set.{u2} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} \u03b1) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} \u03b1) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u2} \u03b1)))))))) (CompleteLattice.toBoundedOrder.{u2} (Set.{u2} \u03b1) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} \u03b1) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u2} \u03b1)))))) (s i) (s j))) -> (forall (i : \u03b9), Set.Nonempty.{u2} \u03b1 (s i)) -> (forall (x : \u03b1), Exists.{succ u1} \u03b9 (fun (i : \u03b9) => Membership.mem.{u2, u2} \u03b1 (Set.{u2} \u03b1) (Set.instMembershipSet.{u2} \u03b1) x (s i))) -> (IndexedPartition.{u1, u2} \u03b9 \u03b1 s)\nCase conversion may be inaccurate. Consider using '#align indexed_partition.mk' IndexedPartition.mk'\u2093'. -/\n/-- The non-constructive constructor for `indexed_partition`. -/\nnoncomputable def IndexedPartition.mk' {\u03b9 \u03b1 : Type _} (s : \u03b9 \u2192 Set \u03b1)\n    (dis : \u2200 i j, i \u2260 j \u2192 Disjoint (s i) (s j)) (nonempty : \u2200 i, (s i).Nonempty)\n    (ex : \u2200 x, \u2203 i, x \u2208 s i) : IndexedPartition s\n    where\n  eq_of_mem x i j hxi hxj := by_contradiction fun h => (dis _ _ h).le_bot \u27e8hxi, hxj\u27e9\n  some i := (Nonempty i).some\n  some_mem i := (Nonempty i).choose_spec\n  index x := (ex x).some\n  mem_index x := (ex x).choose_spec\n#align indexed_partition.mk' IndexedPartition.mk'\n\nnamespace IndexedPartition\n\nopen Set\n\nvariable {\u03b9 \u03b1 : Type _} {s : \u03b9 \u2192 Set \u03b1} (hs : IndexedPartition s)\n\n/-- On a unique index set there is the obvious trivial partition -/\ninstance [Unique \u03b9] [Inhabited \u03b1] : Inhabited (IndexedPartition fun i : \u03b9 => (Set.univ : Set \u03b1)) :=\n  \u27e8{  eq_of_mem := fun x i j hi hj => Subsingleton.elim _ _\n      some := default\n      some_mem := Set.mem_univ\n      index := default\n      mem_index := Set.mem_univ }\u27e9\n\nattribute [simp] some_mem mem_index\n\ninclude hs\n\n/- warning: indexed_partition.exists_mem -> IndexedPartition.exists_mem is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} {s : \u03b9 -> (Set.{u2} \u03b1)}, (IndexedPartition.{u1, u2} \u03b9 \u03b1 s) -> (forall (x : \u03b1), Exists.{succ u1} \u03b9 (fun (i : \u03b9) => Membership.Mem.{u2, u2} \u03b1 (Set.{u2} \u03b1) (Set.hasMem.{u2} \u03b1) x (s i)))\nbut is expected to have type\n  forall {\u03b9 : Type.{u2}} {\u03b1 : Type.{u1}} {s : \u03b9 -> (Set.{u1} \u03b1)}, (IndexedPartition.{u2, u1} \u03b9 \u03b1 s) -> (forall (x : \u03b1), Exists.{succ u2} \u03b9 (fun (i : \u03b9) => Membership.mem.{u1, u1} \u03b1 (Set.{u1} \u03b1) (Set.instMembershipSet.{u1} \u03b1) x (s i)))\nCase conversion may be inaccurate. Consider using '#align indexed_partition.exists_mem IndexedPartition.exists_mem\u2093'. -/\ntheorem exists_mem (x : \u03b1) : \u2203 i, x \u2208 s i :=\n  \u27e8hs.index x, hs.mem_index x\u27e9\n#align indexed_partition.exists_mem IndexedPartition.exists_mem\n\n#print IndexedPartition.union\u1d62 /-\ntheorem union\u1d62 : (\u22c3 i, s i) = univ := by\n  ext x\n  simp [hs.exists_mem x]\n#align indexed_partition.Union IndexedPartition.union\u1d62\n-/\n\n/- warning: indexed_partition.disjoint -> IndexedPartition.disjoint is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} {s : \u03b9 -> (Set.{u2} \u03b1)}, (IndexedPartition.{u1, u2} \u03b9 \u03b1 s) -> (forall {i : \u03b9} {j : \u03b9}, (Ne.{succ u1} \u03b9 i j) -> (Disjoint.{u2} (Set.{u2} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u2} (Set.{u2} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u2} (Set.{u2} \u03b1) (Order.Coframe.toCompleteLattice.{u2} (Set.{u2} \u03b1) (CompleteDistribLattice.toCoframe.{u2} (Set.{u2} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u2} (Set.{u2} \u03b1) (Set.completeBooleanAlgebra.{u2} \u03b1)))))) (GeneralizedBooleanAlgebra.toOrderBot.{u2} (Set.{u2} \u03b1) (BooleanAlgebra.toGeneralizedBooleanAlgebra.{u2} (Set.{u2} \u03b1) (Set.booleanAlgebra.{u2} \u03b1))) (s i) (s j)))\nbut is expected to have type\n  forall {\u03b9 : Type.{u2}} {\u03b1 : Type.{u1}} {s : \u03b9 -> (Set.{u1} \u03b1)}, (IndexedPartition.{u2, u1} \u03b9 \u03b1 s) -> (forall {i : \u03b9} {j : \u03b9}, (Ne.{succ u2} \u03b9 i j) -> (Disjoint.{u1} (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (BoundedOrder.toOrderBot.{u1} (Set.{u1} \u03b1) (Preorder.toLE.{u1} (Set.{u1} \u03b1) (PartialOrder.toPreorder.{u1} (Set.{u1} \u03b1) (CompleteSemilatticeInf.toPartialOrder.{u1} (Set.{u1} \u03b1) (CompleteLattice.toCompleteSemilatticeInf.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))))) (CompleteLattice.toBoundedOrder.{u1} (Set.{u1} \u03b1) (Order.Coframe.toCompleteLattice.{u1} (Set.{u1} \u03b1) (CompleteDistribLattice.toCoframe.{u1} (Set.{u1} \u03b1) (CompleteBooleanAlgebra.toCompleteDistribLattice.{u1} (Set.{u1} \u03b1) (Set.instCompleteBooleanAlgebraSet.{u1} \u03b1)))))) (s i) (s j)))\nCase conversion may be inaccurate. Consider using '#align indexed_partition.disjoint IndexedPartition.disjoint\u2093'. -/\ntheorem disjoint : \u2200 {i j}, i \u2260 j \u2192 Disjoint (s i) (s j) := fun i j h =>\n  disjoint_left.mpr fun x hxi hxj => h (hs.eq_of_mem hxi hxj)\n#align indexed_partition.disjoint IndexedPartition.disjoint\n\n#print IndexedPartition.mem_iff_index_eq /-\ntheorem mem_iff_index_eq {x i} : x \u2208 s i \u2194 hs.index x = i :=\n  \u27e8fun hxi => (hs.eq_of_mem hxi (hs.mem_index x)).symm, fun h => h \u25b8 hs.mem_index _\u27e9\n#align indexed_partition.mem_iff_index_eq IndexedPartition.mem_iff_index_eq\n-/\n\n#print IndexedPartition.eq /-\ntheorem eq (i) : s i = { x | hs.index x = i } :=\n  Set.ext fun _ => hs.mem_iff_index_eq\n#align indexed_partition.eq IndexedPartition.eq\n-/\n\n#print IndexedPartition.setoid /-\n/-- The equivalence relation associated to an indexed partition. Two\nelements are equivalent if they belong to the same set of the partition. -/\nprotected abbrev setoid (hs : IndexedPartition s) : Setoid \u03b1 :=\n  Setoid.ker hs.index\n#align indexed_partition.setoid IndexedPartition.setoid\n-/\n\n/- warning: indexed_partition.index_some -> IndexedPartition.index_some is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} {s : \u03b9 -> (Set.{u2} \u03b1)} (hs : IndexedPartition.{u1, u2} \u03b9 \u03b1 s) (i : \u03b9), Eq.{succ u1} \u03b9 (IndexedPartition.index.{u1, u2} \u03b9 \u03b1 s hs (IndexedPartition.some.{u1, u2} \u03b9 \u03b1 s hs i)) i\nbut is expected to have type\n  forall {\u03b9 : Type.{u2}} {\u03b1 : Type.{u1}} {s : \u03b9 -> (Set.{u1} \u03b1)} (hs : IndexedPartition.{u2, u1} \u03b9 \u03b1 s) (i : \u03b9), Eq.{succ u2} \u03b9 (IndexedPartition.index.{u2, u1} \u03b9 \u03b1 s hs (IndexedPartition.some.{u2, u1} \u03b9 \u03b1 s hs i)) i\nCase conversion may be inaccurate. Consider using '#align indexed_partition.index_some IndexedPartition.index_some\u2093'. -/\n@[simp]\ntheorem index_some (i : \u03b9) : hs.index (hs.some i) = i :=\n  (mem_iff_index_eq _).1 <| hs.some_mem i\n#align indexed_partition.index_some IndexedPartition.index_some\n\n#print IndexedPartition.some_index /-\ntheorem some_index (x : \u03b1) : hs.Setoid.Rel (hs.some (hs.index x)) x :=\n  hs.index_some (hs.index x)\n#align indexed_partition.some_index IndexedPartition.some_index\n-/\n\n#print IndexedPartition.Quotient /-\n/-- The quotient associated to an indexed partition. -/\nprotected def Quotient :=\n  Quotient hs.Setoid\n#align indexed_partition.quotient IndexedPartition.Quotient\n-/\n\n#print IndexedPartition.proj /-\n/-- The projection onto the quotient associated to an indexed partition. -/\ndef proj : \u03b1 \u2192 hs.Quotient :=\n  Quotient.mk''\n#align indexed_partition.proj IndexedPartition.proj\n-/\n\ninstance [Inhabited \u03b1] : Inhabited hs.Quotient :=\n  \u27e8hs.proj default\u27e9\n\n#print IndexedPartition.proj_eq_iff /-\ntheorem proj_eq_iff {x y : \u03b1} : hs.proj x = hs.proj y \u2194 hs.index x = hs.index y :=\n  Quotient.eq_rel\n#align indexed_partition.proj_eq_iff IndexedPartition.proj_eq_iff\n-/\n\n#print IndexedPartition.proj_some_index /-\n@[simp]\ntheorem proj_some_index (x : \u03b1) : hs.proj (hs.some (hs.index x)) = hs.proj x :=\n  Quotient.eq''.2 (hs.some_index x)\n#align indexed_partition.proj_some_index IndexedPartition.proj_some_index\n-/\n\n#print IndexedPartition.equivQuotient /-\n/-- The obvious equivalence between the quotient associated to an indexed partition and\nthe indexing type. -/\ndef equivQuotient : \u03b9 \u2243 hs.Quotient :=\n  (Setoid.quotientKerEquivOfRightInverse hs.index hs.some <| hs.index_some).symm\n#align indexed_partition.equiv_quotient IndexedPartition.equivQuotient\n-/\n\n#print IndexedPartition.equivQuotient_index_apply /-\n@[simp]\ntheorem equivQuotient_index_apply (x : \u03b1) : hs.equivQuotient (hs.index x) = hs.proj x :=\n  hs.proj_eq_iff.mpr (some_index hs x)\n#align indexed_partition.equiv_quotient_index_apply IndexedPartition.equivQuotient_index_apply\n-/\n\n/- warning: indexed_partition.equiv_quotient_symm_proj_apply -> IndexedPartition.equivQuotient_symm_proj_apply is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} {s : \u03b9 -> (Set.{u2} \u03b1)} (hs : IndexedPartition.{u1, u2} \u03b9 \u03b1 s) (x : \u03b1), Eq.{succ u1} \u03b9 (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b9) (fun (_x : Equiv.{succ u2, succ u1} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b9) => (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) -> \u03b9) (Equiv.hasCoeToFun.{succ u2, succ u1} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b9) (Equiv.symm.{succ u1, succ u2} \u03b9 (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) (IndexedPartition.equivQuotient.{u1, u2} \u03b9 \u03b1 s hs)) (IndexedPartition.proj.{u1, u2} \u03b9 \u03b1 s hs x)) (IndexedPartition.index.{u1, u2} \u03b9 \u03b1 s hs x)\nbut is expected to have type\n  forall {\u03b9 : Type.{u2}} {\u03b1 : Type.{u1}} {s : \u03b9 -> (Set.{u1} \u03b1)} (hs : IndexedPartition.{u2, u1} \u03b9 \u03b1 s) (x : \u03b1), Eq.{succ u2} ((fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => \u03b9) (IndexedPartition.proj.{u2, u1} \u03b9 \u03b1 s hs x)) (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b9) (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (fun (_x : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => \u03b9) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u2} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b9) (Equiv.symm.{succ u2, succ u1} \u03b9 (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (IndexedPartition.equivQuotient.{u2, u1} \u03b9 \u03b1 s hs)) (IndexedPartition.proj.{u2, u1} \u03b9 \u03b1 s hs x)) (IndexedPartition.index.{u2, u1} \u03b9 \u03b1 s hs x)\nCase conversion may be inaccurate. Consider using '#align indexed_partition.equiv_quotient_symm_proj_apply IndexedPartition.equivQuotient_symm_proj_apply\u2093'. -/\n@[simp]\ntheorem equivQuotient_symm_proj_apply (x : \u03b1) : hs.equivQuotient.symm (hs.proj x) = hs.index x :=\n  rfl\n#align indexed_partition.equiv_quotient_symm_proj_apply IndexedPartition.equivQuotient_symm_proj_apply\n\n#print IndexedPartition.equivQuotient_index /-\ntheorem equivQuotient_index : hs.equivQuotient \u2218 hs.index = hs.proj :=\n  funext hs.equivQuotient_index_apply\n#align indexed_partition.equiv_quotient_index IndexedPartition.equivQuotient_index\n-/\n\n#print IndexedPartition.out /-\n/-- A map choosing a representative for each element of the quotient associated to an indexed\npartition. This is a computable version of `quotient.out'` using `indexed_partition.some`. -/\ndef out : hs.Quotient \u21aa \u03b1 :=\n  hs.equivQuotient.symm.toEmbedding.trans \u27e8hs.some, Function.LeftInverse.injective hs.index_some\u27e9\n#align indexed_partition.out IndexedPartition.out\n-/\n\n#print IndexedPartition.out_proj /-\n/-- This lemma is analogous to `quotient.mk_out'`. -/\n@[simp]\ntheorem out_proj (x : \u03b1) : hs.out (hs.proj x) = hs.some (hs.index x) :=\n  rfl\n#align indexed_partition.out_proj IndexedPartition.out_proj\n-/\n\n/- warning: indexed_partition.index_out' -> IndexedPartition.index_out' is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} {s : \u03b9 -> (Set.{u2} \u03b1)} (hs : IndexedPartition.{u1, u2} \u03b9 \u03b1 s) (x : IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs), Eq.{succ u1} \u03b9 (IndexedPartition.index.{u1, u2} \u03b9 \u03b1 s hs (Quotient.out'.{succ u2} \u03b1 (IndexedPartition.setoid.{u1, u2} \u03b9 \u03b1 s hs) x)) (IndexedPartition.index.{u1, u2} \u03b9 \u03b1 s hs (coeFn.{succ u2, succ u2} (Function.Embedding.{succ u2, succ u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b1) (fun (_x : Function.Embedding.{succ u2, succ u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b1) => (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) -> \u03b1) (Function.Embedding.hasCoeToFun.{succ u2, succ u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b1) (IndexedPartition.out.{u1, u2} \u03b9 \u03b1 s hs) x))\nbut is expected to have type\n  forall {\u03b9 : Type.{u2}} {\u03b1 : Type.{u1}} {s : \u03b9 -> (Set.{u1} \u03b1)} (hs : IndexedPartition.{u2, u1} \u03b9 \u03b1 s) (x : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs), Eq.{succ u2} \u03b9 (IndexedPartition.index.{u2, u1} \u03b9 \u03b1 s hs (Quotient.out'.{succ u1} \u03b1 (IndexedPartition.setoid.{u2, u1} \u03b9 \u03b1 s hs) x)) (IndexedPartition.index.{u2, u1} \u03b9 \u03b1 s hs (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1) (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (fun (_x : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => \u03b1) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1) (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1 (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1)) (IndexedPartition.out.{u2, u1} \u03b9 \u03b1 s hs) x))\nCase conversion may be inaccurate. Consider using '#align indexed_partition.index_out' IndexedPartition.index_out'\u2093'. -/\n/-- The indices of `quotient.out'` and `indexed_partition.out` are equal. -/\ntheorem index_out' (x : hs.Quotient) : hs.index x.out' = hs.index (hs.out x) :=\n  Quotient.inductionOn' x fun x => (Setoid.ker_apply_mk_out' x).trans (hs.index_some _).symm\n#align indexed_partition.index_out' IndexedPartition.index_out'\n\n/- warning: indexed_partition.proj_out -> IndexedPartition.proj_out is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} {s : \u03b9 -> (Set.{u2} \u03b1)} (hs : IndexedPartition.{u1, u2} \u03b9 \u03b1 s) (x : IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs), Eq.{succ u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) (IndexedPartition.proj.{u1, u2} \u03b9 \u03b1 s hs (coeFn.{succ u2, succ u2} (Function.Embedding.{succ u2, succ u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b1) (fun (_x : Function.Embedding.{succ u2, succ u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b1) => (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) -> \u03b1) (Function.Embedding.hasCoeToFun.{succ u2, succ u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b1) (IndexedPartition.out.{u1, u2} \u03b9 \u03b1 s hs) x)) x\nbut is expected to have type\n  forall {\u03b9 : Type.{u2}} {\u03b1 : Type.{u1}} {s : \u03b9 -> (Set.{u1} \u03b1)} (hs : IndexedPartition.{u2, u1} \u03b9 \u03b1 s) (x : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs), Eq.{succ u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (IndexedPartition.proj.{u2, u1} \u03b9 \u03b1 s hs (FunLike.coe.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1) (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (fun (_x : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => (fun (x._@.Mathlib.Data.FunLike.Embedding._hyg.19 : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => \u03b1) _x) (EmbeddingLike.toFunLike.{succ u1, succ u1, succ u1} (Function.Embedding.{succ u1, succ u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1) (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1 (Function.instEmbeddingLikeEmbedding.{succ u1, succ u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b1)) (IndexedPartition.out.{u2, u1} \u03b9 \u03b1 s hs) x)) x\nCase conversion may be inaccurate. Consider using '#align indexed_partition.proj_out IndexedPartition.proj_out\u2093'. -/\n/-- This lemma is analogous to `quotient.out_eq'`. -/\n@[simp]\ntheorem proj_out (x : hs.Quotient) : hs.proj (hs.out x) = x :=\n  Quotient.inductionOn' x fun x => Quotient.sound' <| hs.some_index x\n#align indexed_partition.proj_out IndexedPartition.proj_out\n\n#print IndexedPartition.class_of /-\ntheorem class_of {x : \u03b1} : setOf (hs.Setoid.Rel x) = s (hs.index x) :=\n  Set.ext fun y => eq_comm.trans hs.mem_iff_index_eq.symm\n#align indexed_partition.class_of IndexedPartition.class_of\n-/\n\n/- warning: indexed_partition.proj_fiber -> IndexedPartition.proj_fiber is a dubious translation:\nlean 3 declaration is\n  forall {\u03b9 : Type.{u1}} {\u03b1 : Type.{u2}} {s : \u03b9 -> (Set.{u2} \u03b1)} (hs : IndexedPartition.{u1, u2} \u03b9 \u03b1 s) (x : IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs), Eq.{succ u2} (Set.{u2} \u03b1) (Set.preimage.{u2, u2} \u03b1 (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) (IndexedPartition.proj.{u1, u2} \u03b9 \u03b1 s hs) (Singleton.singleton.{u2, u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) (Set.{u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs)) (Set.hasSingleton.{u2} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs)) x)) (s (coeFn.{max 1 (max (succ u2) (succ u1)) (succ u1) (succ u2), max (succ u2) (succ u1)} (Equiv.{succ u2, succ u1} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b9) (fun (_x : Equiv.{succ u2, succ u1} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b9) => (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) -> \u03b9) (Equiv.hasCoeToFun.{succ u2, succ u1} (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) \u03b9) (Equiv.symm.{succ u1, succ u2} \u03b9 (IndexedPartition.Quotient.{u1, u2} \u03b9 \u03b1 s hs) (IndexedPartition.equivQuotient.{u1, u2} \u03b9 \u03b1 s hs)) x))\nbut is expected to have type\n  forall {\u03b9 : Type.{u2}} {\u03b1 : Type.{u1}} {s : \u03b9 -> (Set.{u1} \u03b1)} (hs : IndexedPartition.{u2, u1} \u03b9 \u03b1 s) (x : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs), Eq.{succ u1} (Set.{u1} \u03b1) (Set.preimage.{u1, u1} \u03b1 (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (IndexedPartition.proj.{u2, u1} \u03b9 \u03b1 s hs) (Singleton.singleton.{u1, u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (Set.{u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs)) (Set.instSingletonSet.{u1} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs)) x)) (s (FunLike.coe.{max (succ u2) (succ u1), succ u1, succ u2} (Equiv.{succ u1, succ u2} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b9) (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (fun (_x : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => (fun (x._@.Mathlib.Logic.Equiv.Defs._hyg.808 : IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) => \u03b9) _x) (Equiv.instFunLikeEquiv.{succ u1, succ u2} (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) \u03b9) (Equiv.symm.{succ u2, succ u1} \u03b9 (IndexedPartition.Quotient.{u2, u1} \u03b9 \u03b1 s hs) (IndexedPartition.equivQuotient.{u2, u1} \u03b9 \u03b1 s hs)) x))\nCase conversion may be inaccurate. Consider using '#align indexed_partition.proj_fiber IndexedPartition.proj_fiber\u2093'. -/\ntheorem proj_fiber (x : hs.Quotient) : hs.proj \u207b\u00b9' {x} = s (hs.equivQuotient.symm x) :=\n  Quotient.inductionOn' x fun x => by\n    ext y\n    simp only [Set.mem_preimage, Set.mem_singleton_iff, hs.mem_iff_index_eq]\n    exact Quotient.eq''\n#align indexed_partition.proj_fiber IndexedPartition.proj_fiber\n\nend IndexedPartition\n\n"}
{"text": "[STATEMENT]\ntheorem THEOREM1: \"\\<lfloor>\\<^bold>\\<forall>\\<Phi>. \\<P>(\\<Phi>) \\<^bold>\\<rightarrow> \\<^bold>\\<diamond>(\\<^bold>\\<exists>x. \\<Phi>(x))\\<rfloor>\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<lfloor>\\<lambda>w. \\<forall>x. (\\<P> x \\<^bold>\\<rightarrow> \\<^bold>\\<diamond>q4 x) w\\<rfloor>\n[PROOF STEP]\nusing CORO1 CORO2 T'\n[PROOF STATE]\nproof (prove)\nusing this:\n\\<lfloor>\\<^bold>\\<not>\\<P> (\\<lambda>x. x\\<^bold>\\<noteq>x)\\<rfloor>\n\\<lfloor>\\<lambda>w. \\<forall>x xa. \\<P> x w \\<and> (\\<forall>xb. (x xb \\<^bold>\\<rightarrow> xa xb) w) \\<longrightarrow> \\<P> xa w\\<rfloor>\n\\<lfloor>\\<lambda>w. \\<forall>x. (x \\<^bold>\\<rightarrow> \\<^bold>\\<diamond>x) w\\<rfloor>\n\ngoal (1 subgoal):\n 1. \\<lfloor>\\<lambda>w. \\<forall>x. (\\<P> x \\<^bold>\\<rightarrow> \\<^bold>\\<diamond>q4 x) w\\<rfloor>\n[PROOF STEP]\nby metis"}
{"text": "lemmas bounded_linear_scaleR_const = bounded_linear_scaleR_left[THEN bounded_linear_compose]"}
{"text": "lemma of_real_power_int [simp]: \"of_real (power_int x n) = power_int (of_real x :: 'a :: {real_div_algebra,division_ring}) n\""}
{"text": "open import Relation.Binary.Core\n\nmodule InsertSort.Impl2.Correctness.Order {A : Set}\n                  (_\u2264_ : A \u2192 A \u2192 Set)\n                  (tot\u2264 : Total _\u2264_)  where\n\nopen import Data.List\nopen import Function using (_\u2218_)\nopen import InsertSort.Impl2 _\u2264_ tot\u2264\nopen import List.Sorted _\u2264_\nopen import OList _\u2264_\nopen import OList.Properties _\u2264_\n\ntheorem-insertSort-sorted : (xs : List A) \u2192 Sorted (forget (insertSort xs))\ntheorem-insertSort-sorted = lemma-olist-sorted \u2218 insertSort\n\n\n"}
{"text": "[STATEMENT]\nlemma fields_Ext [simp]: \n  \"fields (tprg, Ext)  = [((vee, Ext ), PrimT Integer)] @ fields (tprg, Base)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. fields (tprg, Ext) = [((vee, Ext), PrimT Integer)] @ fields (tprg, Base)\n[PROOF STEP]\napply (rule trans)\n[PROOF STATE]\nproof (prove)\ngoal (2 subgoals):\n 1. fields (tprg, Ext) = ?s\n 2. ?s = [((vee, Ext), PrimT Integer)] @ fields (tprg, Base)\n[PROOF STEP]\napply  (rule fields_rec')\n[PROOF STATE]\nproof (prove)\ngoal (2 subgoals):\n 1. class tprg Ext = Some (?D3, ?fs3, ?ms3)\n 2. map (\\<lambda>(fn, ft). ((fn, Ext), ft)) ?fs3 @ (if Ext = Object then [] else fields (tprg, ?D3)) = [((vee, Ext), PrimT Integer)] @ fields (tprg, Base)\n[PROOF STEP]\napply   auto\n[PROOF STATE]\nproof (prove)\ngoal:\nNo subgoals!\n[PROOF STEP]\ndone"}
{"text": "[STATEMENT]\nlemma uniqueness_of_types_expr [rule_format (no_asm)]: \"\n  (\\<forall>E T1 T2. E\\<turnstile>e :: T1 \\<longrightarrow> E\\<turnstile>e :: T2 \\<longrightarrow> T1 = T2)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<forall>E T1 T2. E \\<turnstile> e :: T1 \\<longrightarrow> E \\<turnstile> e :: T2 \\<longrightarrow> T1 = T2\n[PROOF STEP]\nby (rule uniqueness_of_types [THEN conjunct1])"}
{"text": "import data.mv_polynomial ring_theory.noetherian finsupp finset\n\nopen finsupp\nnamespace mv_polynomial\nvariables {\u03c3 : Type*} {\u03b1 : Type*} [decidable_eq \u03c3] [decidable_eq \u03b1] \n\n/-section discrete_field\nvariables [discrete_field \u03b1] \n\ntheorem HBT : is_noetherian (mv_polynomial \u03c3 \u03b1) (mv_polynomial \u03c3 \u03b1) := sorry\n\nlemma ideal_wf : well_founded ((>) : ideal (mv_polynomial \u03c3 \u03b1) \u2192 ideal (mv_polynomial \u03c3 \u03b1) \u2192 Prop) := is_noetherian_iff_well_founded.1 HBT\n\nend discrete_field-/\n\nsection basic\nvariables [comm_semiring \u03b1]\n\ninstance : has_coe_to_fun (mv_polynomial \u03c3 \u03b1) := \u27e8\u03bb _, (\u03c3 \u2192\u2080 \u2115) \u2192 \u03b1, finsupp.to_fun\u27e9\n@[simp] lemma support_zero : (0 : mv_polynomial \u03c3 \u03b1).support = \u2205 := finsupp.support_zero\n@[simp] lemma zero_apply {a} : (0 : mv_polynomial \u03c3 \u03b1) a = 0 := rfl\n@[simp] lemma support_eq_empty {p : mv_polynomial \u03c3 \u03b1} : p.support = \u2205 \u2194 p = 0 := finsupp.support_eq_empty\nlemma support_ne_empty (p : mv_polynomial \u03c3 \u03b1) : p.support \u2260 \u2205 \u2194 p \u2260 0 := by finish\n@[simp] lemma eq_zero_lem : \u2200 {f : (\u03c3 \u2192\u2080 \u2115) \u2192 \u03b1} {l}, ({support := \u2205, to_fun := f, mem_support_to_fun := l} : mv_polynomial \u03c3 \u03b1) = (0 : mv_polynomial \u03c3 \u03b1) := by apply finsupp.eq_zero_lem \nlemma eq_zero_apply (p : mv_polynomial \u03c3 \u03b1) : (\u2200 a, p a = 0) \u2194 p = 0 := eq_zero_apply p\n\n@[simp] lemma zero_monomial {a : \u03c3 \u2192\u2080 \u2115} : ((monomial a 0) : mv_polynomial \u03c3 \u03b1) = 0 := by simp [monomial]; refl\nlemma monomial_eq_zero_iff {a : \u03c3 \u2192\u2080 \u2115} {b : \u03b1} : monomial a b = 0 \u2194 b = 0 := by simp [monomial]; apply single_eq_zero_iff\n\nlemma monomial_add_monomial {a : \u03c3 \u2192\u2080 \u2115} {b\u2081 b\u2082 : \u03b1} :\n    monomial a (b\u2081 + b\u2082) = monomial a b\u2081 + monomial a b\u2082 := by simp [monomial]\nlemma monomial_mul_monomial {a\u2081 a\u2082 : \u03c3 \u2192\u2080 \u2115} {b\u2081 b\u2082 : \u03b1} :\n  monomial a\u2081 b\u2081 * monomial a\u2082 b\u2082 = monomial (a\u2081 + a\u2082) (b\u2081 * b\u2082) := by simp [monomial]; apply single_mul_single\n\nlemma monomial_apply {a a' : \u03c3 \u2192\u2080 \u2115} {b : \u03b1} : ((monomial a b) : mv_polynomial \u03c3 \u03b1) a' = if a = a' then b else 0 := rfl\n\nlemma support_monomial_eq {a : \u03c3 \u2192\u2080 \u2115} {b : \u03b1} (hb : b \u2260 0) : (monomial a b).support = {a} :=\n    by simp [monomial, single, hb]\n\nlemma not_mem_disjoint {p : mv_polynomial \u03c3 \u03b1} {a : \u03c3 \u2192\u2080 \u2115} (ha : a \u2209 p.support) \n{b : \u03b1} (hb : b \u2260 0) : disjoint (monomial a b).support p.support :=\nby simpa [support_monomial_eq hb, finset.disjoint_singleton] using ha\n\n@[simp] lemma add_zero {p : mv_polynomial \u03c3 \u03b1} : p + 0 = p := by simp\n\nlemma add_monomial_nez {p : mv_polynomial \u03c3 \u03b1} {a} (ha : a \u2209 p.support) {b : \u03b1} (hb : b \u2260 0) : monomial a b + p \u2260 0 := \n\u03bb h, hb begin\n    rw \u2190eq_zero_apply (monomial a b + p) at h,\n    simpa [monomial_apply, not_mem_support_iff.1 ha] using h a,\nend\n\n@[simp] lemma nez_of_mem_support {p : mv_polynomial \u03c3 \u03b1} {a} (ha : a \u2208 p.support) : p \u2260 0 :=\n\u03bb h', by finish\n\n@[elab_as_eliminator]\ntheorem induction_f {C : (mv_polynomial \u03c3 \u03b1) \u2192 Prop} (p : mv_polynomial \u03c3 \u03b1)\n  (C0 : C (0 : mv_polynomial \u03c3 \u03b1)) (Ca : \u2200a b (p : mv_polynomial \u03c3 \u03b1), a \u2209 p.support \u2192 b \u2260 0 \u2192 C p \u2192 C (monomial a b + p)) :\n  C p :=\n  begin\n    apply finsupp.induction, assumption,\n    intros a b f haf hb hf,\n    simpa [monomial] using Ca a b f haf hb hf,\n  end\n\nend basic\nend mv_polynomial\n"}
{"text": "State Before: \u03b1 : Type ?u.959671\nn : \u2115\n\u22a2 ofInt' \u2191(n + 1) = -ofInt' -[n+1] State After: no goals Tactic: simp only [ofInt', Num.zneg_toZNumNeg] State Before: \u03b1 : Type ?u.959671\n\u22a2 Num.toZNum (Num.ofNat' 0) = -Num.toZNum (Num.ofNat' 0) State After: \u03b1 : Type ?u.959671\n\u22a2 Num.toZNum 0 = -Num.toZNum 0 Tactic: rw [Num.ofNat'_zero] State Before: \u03b1 : Type ?u.959671\n\u22a2 Num.toZNum 0 = -Num.toZNum 0 State After: no goals Tactic: rfl State Before: \u03b1 : Type ?u.959671\nn : \u2115\n\u22a2 Num.toZNumNeg (Num.ofNat' (Nat.add n 0 + 1)) = -Num.toZNum (Num.ofNat' (n + 1)) State After: no goals Tactic: rw [Num.zneg_toZNum]"}
{"text": "module Specdris.SpecTest\n\nimport Specdris.Spec\nimport Specdris.TestUtil\n\ntestCase : IO ()\ntestCase\n  = do state <- specWithState $ do\n             describe \"context 1\" $ do\n               describe \"context 1.1\" $ do\n                 it \"context 1.1.1\" $ do\n                   1 === 2\n                   1 === 1                  \n        \n               it \"context 1.2\" $ do\n                 \"hello\" `shouldSatisfy` (\\str => (length str) > 5)          \n               it \"context 1.3\" $ do\n                 1 `shouldBe` 2\n               it \"context 1.4\" $ do\n                 pendingWith \"for some reason\"\n       \n       testAndPrint \"spec test\" state (MkState 4 3 1 Nothing) (==)\n\nexport\nspecSuite : IO ()\nspecSuite = do putStrLn \"\\n  spec:\"\n               testCase\n"}
{"text": "informal statement If $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that $f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$).formal statement theorem exercise_4_4a\n  {\u03b1 : Type} [metric_space \u03b1]\n  {\u03b2 : Type} [metric_space \u03b2]\n  (f : \u03b1 \u2192 \u03b2)\n  (s : set \u03b1)\n  (h\u2081 : continuous f)\n  (h\u2082 : dense s)\n  : f '' set.univ \u2286 closure (f '' s) :="}
{"text": "@[simp] theorem one_le_of_lt (h: n < m) : 1 \u2264 m := Nat.lt_of_le_of_lt (Nat.zero_le _) h\n\nexample (h: n < m) : 1 \u2264 m := by\n  simp (disch := assumption) [h]\n"}
{"text": "Formal statement is: lemma of_real_eq_id [simp]: \"of_real = (id :: real \\<Rightarrow> real)\" Informal statement is: The function of_real is the identity function on the reals."}
{"text": "variables (a b c d e : \u2115)\nvariable h1 : a = b\nvariable h2 : b = c + 1\nvariable h3 : c = d\nvariable h4 : e = 1 + d\n\ninclude h1 h2 h3 h4\ntheorem T : a = e :=\n  calc\n    a     = d + 1 : by rw [h1, h2, h3]\n      ... = 1 + d : by rw add_comm\n      ... = e     : by rw h4\n"}
{"text": "import \n  .lemmas.substitution\n  .lemmas.big_step\n\nopen env_big_step\n\nlemma big_subst_sound {E e S r} :\n    big_subst E e \u27f9 r\n  \u2192 (E, compile e, S) \u27f9\u2099\u1d65 (E, r :: S) := \nbegin\n  assume h,\n  induction' e,\n  case EVal {\n    rw compile,\n    rw big_subst_val at h,\n    cases' h,\n    apply ERunPush,\n    apply ERunEmpty\n  },\n  case EVar {\n    rw compile,\n    cases' big_subst_var_implies_bound h with v hbound,\n    apply ERunLookup hbound,\n    rw big_subst_bound_var hbound h,\n    exact ERunEmpty\n  },\n  case EOp {\n    rw compile, simp,\n    rw big_subst_spread_op at h,\n    cases' h,\n    apply from_interm_results' (ih_e_1 h_1),\n    apply from_interm_results' (ih_e h),\n    apply ERunOpInstr,\n    apply ERunEmpty\n  },\n  case EIf {\n    rw compile, simp,\n    rw big_subst_spread_if at h,\n    cases' h,\n    case RunIfT { \n      apply from_interm_results' (ih_e h),\n      apply ERunTBranch,\n      apply from_interm_results' (ih_e_1 h_1),\n      apply ERunJump,\n      exact at_least_refl,\n      rw list.drop_length,\n      apply ERunEmpty\n    },\n    case RunIfF {\n      apply from_interm_results' (ih_e h),\n      apply ERunFBranch,\n      { rw [at_least], simp },\n      rw [nat.add_comm, \n          list.drop_add, \n          list.drop_one,\n          list.drop_append_of_le_length, \n          list.drop_length,\n          list.nil_append, \n          list.tail],\n      exact ih_e_2 h_1,\n      refl\n    }\n  },\n  case ELet {\n    rw compile, simp,\n    rw big_subst_spread_let at h,\n    cases' h,\n    apply from_interm_results' (ih_e h),\n    apply ERunOpenScope,\n    rw [subst_merge, \n      big_subst_remove_append] at h_1,\n    apply from_interm_results' (ih_e_1 h_1),\n    apply ERunCloseScope,\n    apply ERunEmpty\n  }\nend\n\ntheorem compile_sound_nv {e : exp} {v : val} :\n    e \u27f9 v\n  \u2192 ([], compile e, []) \u27f9\u2099\u1d65 ([], [v]) :=\n\u03bb h, big_subst_sound $ eq.subst (big_subst_empty e) h\n\ntheorem compile_sound (e : exp) (v : val) : \n    e \u27f9 v\n  \u2192 ([], compile e, []) \u27f9\u1d65\u2098 [v] :=\nenv_vm_big_step \u2218 compile_sound_nv"}
{"text": "theory Rudin\n  imports Complex_Main (* comment by Angeliki: switched to Complex_Main and imported some Analysis*)\n\"HOL-Analysis.Abstract_Euclidean_Space\"\n\"HOL-Analysis.Derivative\"\n\"HOL-Analysis.Interval_Integral\"\n\"HOL-Analysis.Elementary_Topology\"\n(*\"HOL-Hahn_Banach.Function_Order\"*)\nbegin\n\n(*\nproblem_number:1_1a\nnatural language statement:\nIf $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $r+x$ is irrational.\nlean statement:\ntheorem exercise_1_1a\n  (x : \\<real>) (y : \\<rat>) :\n  ( irrational x ) -> irrational ( x + y ) :=\nbegin\n  apply irrational.add_rat,\nend\n\ncodex statement:\ntheorem irrational_of_add_irrational_rational:\n  fixes r :: real and x::real\n  assumes \"r \\<noteq> 0\" \"irrational x\"\n  shows \"irrational (r + x)\"\n(*Our comment on the codex statement: <wrong: missed one assumption,so what it wants to \nprove is false. Also used the def.\n \"irrational\" which doesn't exist >*)\n*) \ntheorem exercise_1_1a: \n   fixes r :: rat and x::real\n  assumes \"r \\<noteq> 0\" \" x \\<notin> Rats\"\n  shows \" (r + x) \\<notin> Rats \"\n  oops\n\n\n(*\nproblem_number:1_1b\nnatural language statement:\nIf $r$ is rational $(r \\neq 0)$ and $x$ is irrational, prove that $rx$ is irrational.\nlean statement:\ntheorem exercise_1_1b\n(x : \\<real>)\n(y : \\<rat>)\n(h : y \\<noteq> 0)\n: ( irrational x ) -> irrational ( x * y ) :=\nbegin\n  intro g,\n  apply irrational.mul_rat g h,\nend\n\ncodex statement:\ntheorem irrational_of_rational_times_irrational:\n  fixes r::real and x::real\n  assumes \"r \\<noteq> 0\" \"irrational x\" \"rational r\"\n  shows \"irrational (r*x)\"\nOur comment on the codex statement: < the mistake here is that it used the def \"irrational\" which\ndoesn't exist in Isabelle>\n *)\ntheorem exercise_1_1b: \n   fixes r :: rat and x::real\n  assumes \"r \\<noteq> 0\" \" x \\<notin> Rats\"\n  shows \" r*x \\<notin> Rats \"\n  \n  oops\n\n\n(*\nproblem_number:1_2\nnatural language statement:\nProve that there is no rational number whose square is $12$.\nlean statement:\ntheorem exercise_1_2\n: \u00ac \\<exists> (x : \\<rat>), ( x ^ 2 = 12 ) :=\n\ncodex statement:\ntheorem no_rational_square_eq_12:\n  assumes \"\\<exists>x. x^2 = 12\"\n  shows \"False\"\nOur comment on the codex statement: <it didn't include the rationality assumption; \nthe formalisation is wrong, plus the claim it presents is not true.>\n *)\ntheorem exercise_1_2: assumes \"\\<exists> x \\<in> Rats. x^2 = 12\"\n  shows False oops\n\n\n(*\nproblem_number:1_4\nnatural language statement:\nLet $E$ be a nonempty subset of an ordered set; suppose $\\alpha$ is a lower bound of $E$ and \n$\\beta$ is an upper bound of $E$. Prove that $\\alpha \\leq \\beta$.\nlean statement:\ntheorem exercise_1_4\n(\\<alpha> : Type* ) [partial_order \\<alpha>]\n(s : set \\<alpha>)\n(x y : \\<alpha>)\n(h\u2080 : set.nonempty s)\n(h_1 : x \\<in> lower_bounds s)\n(h_2 : y \\<in> upper_bounds s)\n: x \\<le> y :=\nbegin\n  have h : \\<exists> z, z \\<in> s := h\u2080,\n  cases h with z,\n  have xlez : x \\<le> z :=\n  begin\n  apply h_1,\n  assumption,\n  end,\n  have zley : z \\<le> y :=\n  begin\n  apply h_2,\n  assumption,\n  end,\n  exact xlez.trans zley,\nend\n\ncodex statement:\ntheorem lower_bound_leq_upper_bound:\n  fixes E::\"'a::linorder set\"\n  assumes \"E \\<noteq> {}\" \"\\<forall>x\\<in>E. \\<alpha> \\<le> x\" \"\\<forall>x\\<in>E. x \\<le> \u03b2\"\n  shows \"\\<alpha> \\<le> \u03b2\"\n  \nOur comment on the codex statement: <correct formalisation! I copy-paste it below.>\n *)\n\ntheorem exercise_1_4: fixes E::\"'a::linorder set\"\n  assumes \"E \\<noteq> {}\" \"\\<forall>x\\<in>E. \\<alpha> \\<le> x\" \"\\<forall>x\\<in>E. x \\<le> \\<beta>\"\n  shows \"\\<alpha> \\<le> \\<beta>\"\n  oops\n\n(*\n\nproblem_number:1_5\nnatural language statement:\nLet $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all \nnumbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$.\nlean statement:\ntheorem exercise_1_5\n  (A minus_A : set \\<real>) (hA : A.nonempty) (hA_bdd_below : bdd_below A)\n  (hminus_A : minus_A = {x | -x \\<in> A}) :\n  Inf A = Sup minus_A :=\n\ncodex statement:\ntheorem inf_of_neg_sup_of_neg:\n  fixes A::\"real set\"\n  assumes \"bdd_below A\" \"A \\<noteq> {}\"\n  shows \"Inf A = - Sup (-A)\"\nOur comment on the codex statement: <  chosen notation is wrong: -A denotes\nthe complement of A  >\n*) \n\ntheorem exercise_1_5:  fixes A::\"real set\" and minusA::\"real set\" \n  assumes \"bdd_below A\" \"A \\<noteq> {}\" and \" minusA = {x. -x \\<in> A}\"\n  shows \"Inf A = - Sup (minusA)\"\n\n\n  oops\n\n\n(*\nproblem_number:1_8\nnatural language statement:\nProve that no order can be defined in the complex field that turns it into an ordered field. \nHint: $-1$ is a square.\nlean statement:\ntheorem exercise_1_8\n  : \u00ac \\<exists> (r : \\<complex> \\<rightarrow> \\<complex> \\<rightarrow> Prop), is_linear_order \\<complex> r :=\n\ncodex statement:\ntheorem no_order_in_complex_field:\n  fixes z::complex\n  assumes \"\\<forall>x y. x \\<le> y \\<longrightarrow> x + z \\<le> y + z\" \n\"\\<forall>x y. x \\<le> y \\<longrightarrow> x * z \\<le> y * z\" \"\\<forall>x. x \\<le> x\" \n\"\\<forall>x y. x \\<le> y \\<longrightarrow> y \\<le> x \\<longrightarrow> x = y\" \n\"\\<forall>x y z. x \\<le> y \\<longrightarrow> x + z \\<le> y + z\" \"\\<forall>x y. x \\<le> y \\<longrightarrow> x * y \\<le> y * x\" \n\"\\<forall>x y z. x \\<le> y \\<longrightarrow> x * (y + z) \\<le> x * y + x * z\" \"\\<exists>x. x < x\"\n  shows False\nOur comment on the codex statement: < overall wrong>\n\n*)\n\ntheorem exercise_1_8:\n  fixes C:: \"complex set\"\n  shows \"\\<not> (\\<exists> r. linear_order_on C r)\" \n \n  oops\n\n\n(*\nproblem_number:1_17\nnatural language statement:\nProve that $|\\mathbf{x}+\\mathbf{y}|^{2}+|\\mathbf{x}-\\mathbf{y}|^{2}=2|\\mathbf{x}|^{2}+2|\\mathbf{y}|^{2}$ \nif $\\mathbf{x} \\in R^{k}$ and $\\mathbf{y} \\in R^{k}$.\nlean statement:\nexercise_1_17\n(n : \u2115)\n(x y : euclidean_space \u211d (fin n)) -- R^n\n: \u2225x + y\u2225^2 + \u2225x - y\u2225^2 = 2*\u2225x\u2225^2 + 2*\u2225y\u2225^2 :\ncodex statement:\ntheorem sum_add_square_sub_square_eq_sum_square:\n  fixes x y::\"'a::euclidean_space\" \n  shows \"norm (x+y)^2 + norm (x - y) ^ 2 = 2 * (norm x)^2 + 2* (norm y)^2\"\n\n\nOur comment on the codex statement: < correct,I copy-paste it below >\n *)\n\ntheorem exercise_1_17:\n  fixes x y::\"'a::euclidean_space\"\n  shows \"norm (x+y)^2 + norm (x - y) ^ 2 = 2 * (norm x)^2 + 2* (norm y)^2\"\n\n  oops\n(*\nproblem_number:1_14\nnatural language statement:\nIf $z$ is a complex number such that $|z|=1$, that is, such that $z \\bar{z}=1$, compute $|1+z|^{2}+|1-z|^{2}$.\nlean statement:\ntheorem exercise_1_14\n  (z : \\<complex>) (h : abs z = 1)\n  : (abs (1 + z)) ^ 2 + (abs (1 - z)) ^ 2 = 4 :=\n\ncodex statement:\ntheorem sum_square_of_sum_sub_of_abs_eq_one:\n  fixes z::complex\n  assumes \"norm z = 1\"\n  shows \"norm (1 + z)^2 + norm (1 - z)^2 = 4\"\nOur comment on the codex statement: <Unsure how to compare: the natural language version says\n\"compute\" without giving the answer, both the formalised and codex-autoformalised versions\ngive the answer and ask for proving what it is. The extra hint \"that is, such that $z \\bar{z}=1$\" did not need to\nbe formalised and wasn't autoformalised either. The autoformalisation is correct, I copy-paste it below. >\n *)\ntheorem exercise_1_14: \n fixes z::complex\n  assumes \"norm z = 1\"\n  shows \"norm (1 + z)^2 + norm (1 - z)^2 = 4\"  \n  oops\n\n\n(*\nproblem_number:1_18a\nnatural language statement:\nIf $k \\geq 2$ and $\\mathbf{x} \\in R^{k}$, prove that \nthere exists $\\mathbf{y} \\in R^{k}$ such that $\\mathbf{y} \\neq 0$ but $\\mathbf{x} \\cdot \\mathbf{y}=0$\nlean statement:\ntheorem exercise_1_18a\n  (n : \\<nat>)\n  (h : n > 1)\n  (x : euclidean_space \\<real> (fin n)) -- R^n\n  : \\<exists> (y : euclidean_space \\<real> (fin n)), y \\<noteq> 0 \\<and> (inner x y) = (0 : \\<real>) :=\n\ncodex statement:\ntheorem exists_nonzero_orthogonal_vector:\n  fixes x::\"'a::euclidean_space\"\n  assumes \"k\\<ge>2\"\n  shows \"\\<exists>y. y \\<noteq> 0 \\<and> x \u22c5 y = 0\"\nOur comment on the codex statement: <  missed the assumption that k is the dimension\nand had wrong inner product symbol>\n *)                        \ntheorem exercise_1_18a:\n  fixes x::\"'a::euclidean_space\"\n  assumes \" DIM('a::euclidean_space) \\<ge> 2\"\n  shows \"\\<exists>y. y \\<noteq> 0 \\<and> inner  x  y = 0\" \n  \n  oops\n\n\n(*\nproblem_number:1_25\nnatural language statement:\n25: Prove that every compact metric space $K$ has a countable base.\nlean statement:\nMISSING\ncodex statement:\n\ntheorem compact_metric_space_has_countable_base:\n  fixes K::\"'a::metric_space set\"\n  assumes \"compact K\"\n  shows \"countable (UNIV::'a set)\"\n\n\nOur comment on the codex statement: <wrong conclusion>\n\n*)\ntheorem exercise_1_25:\n \n  fixes K::\"'a::metric_space set\"\n  assumes \"compact K\" \n  shows \n \"\\<exists> B. (countable B) \\<and> (topological_basis B)\n \\<and> (\\<forall> b\\<in> B. b \\<subseteq> K)\"\n  oops\n\n(* TODO CHECK THE ABOVE *)\n\n(*\nproblem_number:1_27a\nnatural language statement:\n27a: Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set \nof condensation points of $E$. Prove that $P$ is perfect.\nlean statement:\n\ncodex statement:\ntheorem perfect_of_uncountable_condensation_points:\n  fixes E::\"'a::euclidean_space set\"\n  assumes \"uncountable E\" \"P = condensation_points E\"\n  shows \"perfect P\"\nOur comment on the codex statement: <makes up definitions that don't exist in Isabelle,\n(perfect which doesn't work for perfect set, condensation_points). >\n*)\n\ntheorem exercise_1_27a:\nundefined \n\n(*shows \" P= {x.  x islimpt P}\"*) \n  oops (* TODO  note the def:  If every neighbourhood of x contains uncountably many points of \nS, then x is a type of limit point called a condensation point of S. *)\n\n(*\nproblem_number:1_27b\nnatural language statement:\n27b: Suppose $E\\subset\\mathbb{R}^k$ is uncountable, and let $P$ be the set of condensation points of $E$. \nProve that at most countably many point of $E$ are not in $P$.\nlean statement:\nMISSING\ncodex statement:\ntheorem countable_of_uncountable_set_of_condensation_points:\n  fixes E::\"'a::euclidean_space set\"\n  assumes \"uncountable E\"\n  shows \"countable {x\\<in>E. x\\<notin>condensation_points E}\"\nOur comment on the codex statement: <  uses nonexistent\nIsabelle definitions (condensation_points) otherwise correct\n>\n *)\ntheorem exercise_1_27b: \n  undefined oops\n\n\n(*\nproblem_number:1_28\nnatural language statement:\nProve that every closed set in a separable metric space is the union of a \n(possibly empty) perfect set and a set which is at most countable.\nlean statement:\nMISSING\ncodex statement:\ntheorem closed_set_union_perfect_set_countable_set:\n  fixes X::\"'a::metric_space set\"\n  assumes \"separable X\" \"closed X\"\n  shows \"\\<exists>P C. perfect P \\<and> countable C \\<and> X = P \u222a C\"\nOur comment on the codex statement: <uses nonexistent Isabelle definitions (perfect which\ndoesn't work for perfect set, separable)> *)\n\ntheorem exercise_1_28:\n\n   fixes X::\"'a::metric_space set\" \n   assumes \"\\<exists> T \u2286 X . countable T \\<and> X \u2286 closure T\"  \"closed S\" and \"S \\<subseteq> X\"\n   shows \"\\<exists> P C. countable C \\<and> P = {x \\<in> P. x islimpt P} \\<and> S = P \u222a C  \"\n\n  oops\n\n\n\n\n\n(*\nproblem_number:1_29\nnatural language statement:\nProve that every open set in $\\mathbb{R}$ is the union of an at most countable collection of disjoint segments.\nlean statement:\nMISSING\ncodex statement:\ntheorem open_set_union_of_countable_disjoint_segments:\n  fixes A::\"real set\"\n  assumes \"open A\"\n\n  shows \"\\<exists>f. countable (f ` (UNIV::nat set)) \\<and> pairwise disjoint (f ` (UNIV::nat set)) \n\\<and> (\\<Union>i\\<in>UNIV. f i) = A\"\nOur comment on the codex statement: <wrong >\n\n *)\ntheorem exercise_1_29: \n  undefined oops\n\n\n(*\nproblem_number:2_19a\nnatural language statement:\nIf $A$ and $B$ are disjoint closed sets in some metric space $X$, prove that they are separated.\nlean statement:\ntheorem exercise_2_19a {X : Type*} [metric_space X]\n  (A B : set X) (hA : is_closed A) (hB : is_closed B) (hAB : disjoint A B) :\n  separated_nhds A B :=\n\ncodex statement:\ntheorem separated_of_disjoint_closed:\n  fixes A B::\"'a::metric_space set\"\n  assumes \"closed A\" \"closed B\" \"A \u2229 B = {}\"\n  shows \"separated A B\"\nOur comment on the codex statement: < Almost correct: used nonexistent Isabelle definition\n(separated)> *)\ntheorem exercise_2_19a:\n  \n   fixes  A B::\"'a::metric_space set\"\n   assumes \"closed A\" \"closed B\" \"A \u2229 B = {}\"  \"A \u2286 topspace X\"\n   \"B \u2286 topspace X\"\n  shows \"separatedin X A B\"\n  \n  oops\n\n\n(*\nproblem_number:2_24\nnatural language statement:\nLet $X$ be a metric space in which every infinite subset has a limit point.\n Prove that $X$ is separable. Hint: Fix $\\delta>0$, and pick $x_{1} \\in X$. \nHaving chosen $x_{1}, \\ldots, x_{J} \\in X$,\nlean statement:\ntheorem exercise_2_24 {X : Type*} [metric_space X]\n  (hX : \\<forall> (A : set X), infinite A \\<rightarrow> \\<exists> (x : X), x \\<in> closure A) :\n  separable_space X :=\n\ncodex statement:\ntheorem separable_of_infinite_subset_has_limit_point:\n  fixes X::\"'a::metric_space set\"\n  assumes \n\"\\<forall>A. infinite A \\<longrightarrow> \n\\<exists>x\\<in>A. \\<forall>\\<epsilon>>0. \\<exists>y\\<in>A. y\\<noteq>x \\<and> dist x y < \\<epsilon>\"\n  shows \"separable X\"\nOur comment on the codex statement: <uses nonexistent Isabelle definition (separable), \nsyntax error due to not including expression in parenthesis, missed  that\nA \\<subseteq> X in assumption, missed the Isabelle limit point definition>\n *)\ntheorem exercise_2_24:\n  \n   fixes X::\"'a::metric_space set\"\n   assumes \"\\<forall>A \\<subseteq> X. infinite A \\<longrightarrow>\n( \\<exists>x\\<in>A. x islimpt A )\"\n   obtains T where \"countable T\" \"T \u2286 X\" \"X \u2286 closure T\"\n  \n  oops\n\n\n(*\nproblem_number:3_1a\nnatural language statement:\nProve that convergence of $\\left\\{s_{n}\\right\\}$ implies convergence of $\\left\\{\\left|s_{n}\\right|\\right\\}$.\nlean statement: \ntheorem exercise_3_1a\n  (f : \\<nat> \\<rightarrow> \\<real>)\n  (h : \\<exists> (a : \\<real>), tendsto (\\<lambda> (n : \\<nat>), f n) at_top (\ud835\udcdd a))\n  : \\<exists> (a : \\<real>), tendsto (\\<lambda> (n : \\<nat>), |f n|) at_top (\ud835\udcdd a) :=\nbegin\n  cases h with a h,\n  use |a|,\n  apply filter.tendsto.abs h,\nend\n\ncodex statement:\ntheorem convergent_of_convergent_abs:\n  fixes s::\"nat \\<Rightarrow> 'a::real_normed_vector\"\n  assumes \"convergent s\"\n  shows \"convergent (\\<lambda>n. norm (s n))\"\nOur comment on the codex statement: < correct, copy-pasted below>\n *)\ntheorem exercise_3_1a:\n  fixes s::\"nat \\<Rightarrow> 'a::real_normed_vector\"\n  assumes \"convergent s\"\n  shows \"convergent (\\<lambda>n. norm (s n))\"\noops\n\n\n(*\nproblem_number:3_3\nnatural language statement:\nIf $s_{1}=\\sqrt{2}$, and $s_{n+1}=\\sqrt{2+\\sqrt{s_{n}}} \\quad(n=1,2,3, \\ldots),$ \nprove that $\\left\\{s_{n}\\right\\}$ converges, and that $s_{n}<2$ for $n=1,2,3, \\ldots$.\nlean statement:\ntheorem exercise_3_3\n  : \\<exists> (x : \\<real>), tendsto f at_top (\ud835\udcdd x) \\<and> \\<forall> n, f n < 2 :=\n\ncodex statement:\ntheorem sqrt_2_lt_2_of_sqrt_2_plus_sqrt_s_n:\n  fixes s::\"nat \\<Rightarrow> real\"\n  assumes \"s 1 = sqrt 2\" \"\\<forall>n. s (n+1) = sqrt (2 + sqrt (s n))\"\n  shows \"\\<forall>n. s n < 2\"\nOur comment on the codex statement: < missed one of the conclusions to be shown, otherwise ok>\n *)\ntheorem exercise_3_3:\n  \n   fixes s::\"nat \\<Rightarrow> real\"\n  assumes \"s 1 = sqrt 2\" \"\\<forall>n. s (n+1) = sqrt (2 + sqrt (s n))\"\n  shows \"convergent s \" and  \"\\<forall>n. s n < 2\"\n  oops\n\n\n(*\nproblem_number:3_5\nnatural language statement:\nFor any two real sequences $\\left\\{a_{n}\\right\\},\\left\\{b_{n}\\right\\}$, \nprove that $\\limsup _{n \\rightarrow \\infty}\\left(a_{n}+b_{n}\\right) \\leq \n\\limsup _{n \\rightarrow \\infty} a_{n}+\\limsup _{n \\rightarrow \\infty} b_{n},$ \nprovided the sum on the right is not of the form $\\infty-\\infty$.\nlean statement:\ntheorem exercise_3_5 -- TODO fix\n  (a b : \\<nat> \\<rightarrow> \\<real>)\n  (h : limsup a + limsup b \\<noteq> 0) :\n  limsup (\\<lambda> n, a n + b n) \\<le> limsup a + limsup b :=\n\ncodex statement:\ntheorem limsup_sum_leq_sum_limsup:\n  fixes a b::\"nat \\<Rightarrow> real\"\n  assumes \"\\<forall>n. a n \\<le> b n\"\n  shows \"limsup (\\<lambda>n. a n + b n) \\<le> limsup a + limsup b\"\nOur comment on the codex statement: < not sure about the natural language statement here \n(* TODO check *)\ncodex is wrong as it's adding nonexistent \\<le> assumption > \n *)\ntheorem exercise_3_5: \n  fixes a b::\"nat \\<Rightarrow> real\"\n  assumes  \"convergent a\" and \"convergent b \"\n  shows \"limsup (\\<lambda>n. \u00a6 a n + b n\u00a6) \\<le> limsup a + limsup b\"  oops \n\n(*\nproblem_number:3_7\nnatural language statement:\nProve that the convergence of $\\Sigma a_{n}$ implies the convergence of $\\sum \\frac{\\sqrt{a_{n}}}{n}$ if $a_n\\geq 0$.\nlean statement:\ntheorem exercise_3_7\n  (a : \\<nat> \\<rightarrow> \\<real>)\n  (h : \\<exists> y, (tendsto (\\<lambda> n, (\\<Sum> i in (finset.range n), a i)) at_top (\ud835\udcdd y))) :\n  \\<exists> y, tendsto (\\<lambda> n, (\\<Sum> i in (finset.range n), sqrt (a i) / n)) at_top (\ud835\udcdd y) :=\n\ncodex statement:\ntheorem sum_sqrt_div_n_converges_of_sum_converges:\n  fixes a::\"nat \\<Rightarrow> real\"\n  assumes \"summable a\" \"\\<forall>n. a n \\<ge> 0\"\n  shows \"summable (\\<lambda>n. sqrt (a n) / n)\"\nOur comment on the codex statement: <correct, I copy-paste it below. Note that the natural\nlanguage statement features both \\Sigma and \\sum.>\n *)\ntheorem exercise_3_7: \n  \n  fixes a::\"nat \\<Rightarrow> real\"\n  assumes \"summable a\" \"\\<forall>n. a n \\<ge> 0\"\n  shows \"summable (\\<lambda>n. sqrt (a n) / n)\" \n  oops\n\n\n(*\nproblem_number:3_8\nnatural language statement:\nIf $\\Sigma a_{n}$ converges, and if $\\left\\{b_{n}\\right\\}$ \nis monotonic and bounded, prove that $\\Sigma a_{n} b_{n}$ converges.\nlean statement:\ntheorem exercise_3_8\n  (a b : \\<nat> \\<rightarrow> \\<real>)\n  (h1 : \\<exists> y, (tendsto (\\<lambda> n, (\\<Sum> i in (finset.range n), a i)) at_top (\ud835\udcdd y)))\n  (h2 : monotone b)\n  (h3 : metric.bounded (set.range b)) :\n  \\<exists> y, tendsto (\\<lambda> n, (\\<Sum> i in (finset.range n), (a i) * (b i))) at_top (\ud835\udcdd y) :=\n\ncodex statement:\ntheorem convergent_of_convergent_and_monotonic_bounded:\n  fixes a::\"nat \\<Rightarrow> real\" and b::\"nat \\<Rightarrow> real\"\n  assumes \"convergent a\" \"bounded (range b)\" \"mono b\"\n  shows \"convergent (\\<lambda>n. a n * b n)\"\nOur comment on the codex statement: < the mistake is that here it is meant summable by \\Sigma, \nso it should not be translated as convergent>\n *)\ntheorem exercise_3_8: \n   fixes a::\"nat \\<Rightarrow> real\" and b::\"nat \\<Rightarrow> real\"\n  assumes \"summable a \" \"bounded (range b)\" \"mono b\"\n  shows \"summable (\\<lambda>n. a n * b n)\"\n  oops\n\n\n(*\nproblem_number:3_13\nnatural language statement:\nProve that the Cauchy product of two absolutely convergent series converges absolutely.\nlean statement: \ntheorem exercise_3_13\n  (a b : \\<nat> \\<rightarrow> \\<real>)\n  (ha : \\<exists> y, (tendsto (\\<lambda> n, (\\<Sum> i in (finset.range n), |a i|)) at_top (\ud835\udcdd y)))\n  (hb : \\<exists> y, (tendsto (\\<lambda> n, (\\<Sum> i in (finset.range n), |b i|)) at_top (\ud835\udcdd y))) :\n  \\<exists> y, (tendsto (\\<lambda> n, (\\<Sum> i in (finset.range n),\n  \\<lambda> i, (\\<Sum> j in finset.range (i + 1), a j * b (i - j)))) at_top (\ud835\udcdd y)) :=\n\ncodex statement:\ntheorem abs_convergent_of_cauchy_product:\n  fixes f g::\"nat \\<Rightarrow> 'a::real_normed_algebra_1\"\n  assumes \"summable (\\<lambda>n. abs (f n))\" \"summable (\\<lambda>n. abs (g n))\"\n  shows \"summable (\\<lambda>n. abs (\\<Sum>i<n. f i * g (n - i)))\"\nOur comment on the codex statement: < mistake in type: should be real instead of real_normed_algebra_1.\nOtherwise impressive> *)\n\ntheorem exercise_3_13:\n   fixes f g::\"nat \\<Rightarrow> real\"\n  assumes \"summable (\\<lambda>n. abs (f n))\" \"summable (\\<lambda>n. abs (g n))\"\n  shows \"summable (\\<lambda>n. abs (\\<Sum>i<n. f i * g (n - i)))\"\n\n  oops\n\n\n(*\nproblem_number:3_20\nnatural language statement:\nSuppose $\\left\\{p_{n}\\right\\}$ is a Cauchy sequence in a metric space $X$, \nand some sequence $\\left\\{p_{n l}\\right\\}$ converges to a point $p \\in X$.\n Prove that the full sequence $\\left\\{p_{n}\\right\\}$ converges to $p$.\nlean statement:\ntheorem exercise_3_20 {X : Type*} [metric_space X]\n  (p : \\<nat> \\<rightarrow> X) (l : \\<nat>) (r : X)\n  (hp : cauchy_seq p)\n  (hpl : tendsto (\\<lambda> n, p (l * n)) at_top (\ud835\udcdd r)) :\n  tendsto p at_top (\ud835\udcdd r) :=\n\ncodex statement:\ntheorem convergent_of_subseq_convergent:\n  fixes X::\"'a::metric_space\" and p::\"'a\" and pn::\"nat \\<Rightarrow> 'a\"\n  assumes \"Cauchy pn\" \"convergent (\\<lambda>n. pn (n l))\" \"\\<forall>n. pn (n l) \\<longrightarrow> p\"\n  shows \"pn \\<longrightarrow> p\"\nOur comment on the codex statement: < close but wrong>\n *)\n\ntheorem exercise_3_20:\n\n  fixes X::\"'a::metric_space\" and p::\"'a\" and pn::\"nat \\<Rightarrow> 'a\"\n  assumes \"Cauchy pn\" and \" ((\u03bbl. pn(n l)) \u290f p) sequentially\"\nshows \" ((\u03bbn. pn(n )) \u290f p) sequentially\"\n  \n  oops\n\n\n(*\nproblem_number:3_21\nnatural language statement:\nIf $\\left\\{E_{n}\\right\\}$ is a sequence of closed nonempty and bounded sets in a complete metric \nspace $X$, if $E_{n} \\supset E_{n+1}$, \nand if $\\lim _{n \\rightarrow \\infty} \\operatorname{diam} E_{n}=0,$ \nthen $\\bigcap_{1}^{\\infty} E_{n}$ consists of exactly one point.\nlean statement:\ntheorem exercise_3_21\n  {X : Type*} [metric_space X] [complete_space X]\n  (E : \\<nat> \\<rightarrow> set X)\n  (hE : \\<forall> n, E n \u2283 E (n + 1))\n  (hE' : tendsto (\\<lambda> n, metric.diam (E n)) at_top (\ud835\udcdd 0)) :\n  \\<exists> a, set.Inter E = {a} :=\n\ncodex statement:\ntheorem singleton_of_closed_nonempty_bounded_diam_zero:\n  fixes X::\"'a::metric_space set\"\n  assumes \"\\<forall>n. closed (E n)\" \"\\<forall>n. E n \\<noteq> {}\" \"\\<forall>n. bounded (E n)\" \n\"\\<forall>n. E n \\<subseteq> E (n+1)\" \"diameter (E n) \\<longrightarrow> 0\"\n  shows \"\\<exists>x. (\u2229n. E n) = {x}\"\nOur comment on the codex statement: <several mistakes: symbols, misses assumptions, uses\nsubset instead of superset>\n *)\ntheorem exercise_3_21:\n\nfixes X::\"'a::metric_space set\" and E:: \" nat \\<Rightarrow> 'a set\"\n\nassumes \"\\<forall>n. closed (E n)\"  \"complete X\" \"\\<forall>n. E n \\<noteq> {}\" \n\"\\<forall>n. bounded (E n)\" \n\"\\<forall>n. E n \\<supset> E (n+1)\" \"((\u03bbn. diameter (E n)) \u290f 0) sequentially\"\nshows\n \" \\<exists> x. ((\\<Inter>n\\<in> \\<nat>. E n) ={x})\"\n \n \n  oops\n\n\n(*\nproblem_number:3_22\nnatural language statement:\nSuppose $X$ is a nonempty complete metric space, \nand $\\left\\{G_{n}\\right\\}$ is a sequence of dense open sets of $X$. \nProve Baire's theorem, namely, that $\\bigcap_{1}^{\\infty} G_{n}$ is not empty.\nlean statement:\ntheorem exercise_3_22 (X : Type* ) [metric_space X] [complete_space X]\n  (G : \\<nat> \\<rightarrow> set X) (hG : \\<forall> n, is_open (G n) \\<and> dense (G n)) :\n  \\<exists> x, \\<forall> n, x \\<in> G n :=\n\ncodex statement:\ntheorem baire_theorem:\n  fixes X::\"'a::metric_space set\" and G::\"'a set set\"\n  assumes \"complete_space X\" \"\\<forall>n. openin (subtopology X UNIV) (G n)\" \"\n\\<forall>n. dense_in (subtopology X UNIV) (G n)\"\n  shows \"\\<exists>x. \\<forall>n. x\\<in>G n\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE >\n *)\n\n\ntheorem exercise_3_22: \n \n   undefined\n  \n  oops\n\n(*\nproblem_number:4_2a\nnatural language statement:\nIf $f$ is a continuous mapping of a metric space $X$ into a metric space $Y$, prove that \n$f(\\overline{E}) \\subset \\overline{f(E)}$ for every set $E \\subset X$. ($\\overline{E}$ denotes the closure of $E$).\nlean statement:\ntheorem exercise_4_2a\n  {\\<alpha> : Type} [metric_space \\<alpha>]\n  {\u03b2 : Type} [metric_space \u03b2]\n  (f : \\<alpha> \\<rightarrow> \u03b2)\n  (h_1 : continuous f)\n  : \\<forall> (x : set \\<alpha>), f '' (closure x) \\<subseteq> closure (f '' x) :=\nbegin\n  intros X x h_2 Y h\u2083,\n  simp at *,\n  cases h\u2083 with h\u2083 h\u2084,\n  cases h_2 with w h\u2085,\n  cases h\u2085 with h\u2085 h\u2086,\n  have h\u2088 : is_closed (f \u207b\u00b9' Y) := is_closed.preimage h_1 h\u2083,\n  have h\u2089 : closure X \\<subseteq> f \u207b\u00b9' Y := closure_minimal h\u2084 h\u2088,\n  rw \u2190h\u2086,\n  exact h\u2089 h\u2085,\nend\n\ncodex statement:\ntheorem closure_of_continuous_image_subset_continuous_image_closure:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and E::\"'a set\"\n  assumes \"continuous_on UNIV f\"\n  shows \"closure (f ` E) \\<subseteq> f ` closure E\"\nOur comment on the codex statement: <shows the opposite (wrong) inclusion >\n *)\ntheorem exercise_4_2a:\n  \n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and E::\"'a set\"\n  assumes \"continuous_on UNIV f\"\n  shows \" f ` ( closure E) \\<subseteq>  closure (f ` E)\"  \n  oops\n\n\n(*\nproblem_number:4_3\nnatural language statement:\nLet $f$ be a continuous real function on a metric space $X$. Let $Z(f)$ (the zero set of $f$ ) \nbe the set of all $p \\in X$ at which $f(p)=0$. Prove that $Z(f)$ is closed.\nlean statement:\ntheorem exercise_4_3\n  {\\<alpha> : Type} [metric_space \\<alpha>]\n  (f : \\<alpha> \\<rightarrow> \\<real>) (h : continuous f) (z : set \\<alpha>) (g : z = inv f' {0})\n  : is_closed z :=\nbegin\n  rw g,\n  apply is_closed.preimage h,\n  exact is_closed_singleton,\nend\n\ncodex statement:\ntheorem zero_set_of_continuous_is_closed:\n  fixes f::\"'a::metric_space \\<Rightarrow> real\"\n  assumes \"continuous_on UNIV f\"\n  shows \"closed {x\\<in>UNIV. f x = 0}\"\nOur comment on the codex statement: <correct, I copy-paste it below>\n *)\ntheorem exercise_4_3:\n  \n  fixes f::\"'a::metric_space \\<Rightarrow> real\"\n  assumes \"continuous_on UNIV f\"\n  shows \"closed {x\\<in>UNIV. f x = 0}\"\n  \n  oops\n\n\n(*\nproblem_number:4_4a\nnatural language statement:\nLet $f$ and $g$ be continuous mappings of a metric space $X$ into a metric space $Y$, \nand let $E$ be a dense subset of $X$. Prove that $f(E)$ is dense in $f(X)$.\nlean statement:\ntheorem exercise_4_4a\n  {\\<alpha> : Type} [metric_space \\<alpha>]\n  {\u03b2 : Type} [metric_space \u03b2]\n  (f : \\<alpha> \\<rightarrow> \u03b2)\n  (s : set \\<alpha>)\n  (h_1 : continuous f)\n  (h_2 : dense s)\n  : f '' set.univ \\<subseteq> closure (f '' s) :=\nbegin\n  simp,\n  exact continuous.range_subset_closure_image_dense h_1 h_2,\nend\n\ncodex statement:\ntheorem dense_of_continuous_dense:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and \ng::\"'a::metric_space \\<Rightarrow> 'b::metric_space\"\n  assumes \"continuous_on UNIV f\" \"continuous_on UNIV g\" \"dense (f ` UNIV)\" \"dense (g ` UNIV)\"\n  shows \"dense ((f \u2218 g) ` UNIV)\"\nOur comment on the codex statement: <wrong: missing assumptions, wrong statement to show,\nuses nonexistent definition>\n *)\ntheorem exercise_4_4a: \n  \n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" \nand g::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and E::\"'a set\"\nassumes \" closure E = UNIV\"\n\"continuous_on UNIV f\" \"continuous_on UNIV g\"\nshows \"closure( f ` E) = ( f ` UNIV)  \"\n  \n  oops\n\n(* TODO In the natural language statement above, why is g introduced? something to check?*)\n\n(*\nproblem_number:4_5a\nnatural language statement:\nIf $f$ is a real continuous function defined on a closed set $E \\subset R^{1}$, \nprove that there exist continuous real functions $g$ on $R^{1}$ such that $g(x)=f(x)$ for all $x \\in E$.\nlean statement:\ntheorem exercise_4_5a\n  (f : \\<real> \\<rightarrow> \\<real>)\n  (E : set \\<real>)\n  (h_1 : is_closed E)\n  (h_2 : continuous_on f E)\n  : \\<exists> (g : \\<real> \\<rightarrow> \\<real>), continuous g \\<and> \\<forall> x \\<in> E, f x = g x :=\n\ncodex statement:\ntheorem exists_continuous_extension:\n  fixes f::\"real \\<Rightarrow> real\" and E::\"real set\"\n  assumes \"continuous_on E f\" \"closed E\"\n  shows \"\\<exists>g. continuous_on UNIV g \\<and> (\\<forall>x\\<in>E. g x = f x)\"\nOur comment on the codex statement: <correct, I copy-paste it below>\n *)\ntheorem exercise_4_5a:\n  fixes f::\"real \\<Rightarrow> real\" and E::\"real set\"\n  assumes \"continuous_on E f\" \"closed E\"\n  shows \"\\<exists>g. continuous_on UNIV g \\<and> (\\<forall>x\\<in>E. g x = f x)\"\n  oops\n\n\n(*\nproblem_number:4_6\nnatural language statement:\nIf $f$ is defined on $E$, the graph of $f$ is the set of points $(x, f(x))$, \nfor $x \\in E$. In particular, if $E$ is a set of real numbers, and $f$ is real-valued, \nthe graph of $f$ is a subset of the plane. Suppose $E$ is compact, and prove that $f$ is \ncontinuous on $E$ if and only if its graph is compact.\nlean statement:\ntheorem exercise_4_6\n  (f : \\<real> \\<rightarrow> \\<real>)\n  (E : set \\<real>)\n  (G : set (\\<real> \\<times> \\<real>))\n  (h_1 : is_compact E)\n  (h_2 : G = {(x, f x) | x \\<in> E})\n  : continuous_on f E \\<longleftrightarrow> is_compact G :=\n\ncodex statement:\ntheorem compact_of_continuous_graph:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and E::\"'a::metric_space set\"\n  assumes \"compact E\" \"continuous_on E f\"\n  shows \"compact {(x, f x) | x. x \\<in> E}\"\nOur comment on the codex statement: < missed the double implication but otherwise correct>\n *)\ntheorem exercise_4_6: fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" \nand E::\"'a::metric_space set\" \nassumes \"compact E\"\nshows \"continuous_on E f \\<longleftrightarrow> compact  {(x, f x) | x. x \\<in> E} \" oops\n\n(*\nproblem_number:4_8a\nnatural language statement:\nLet $f$ be a real uniformly continuous function on the bounded set $E$ in $R^{1}$. \nProve that $f$ is bounded on $E$.\nlean statement:\ntheorem exercise_4_8a\n  (E : set \\<real>) (f : \\<real> \\<rightarrow> \\<real>) (hf : uniform_continuous_on f E)\n  (hE : metric.bounded E) : metric.bounded (set.image f E) :=\n\ncodex statement:\ntheorem bounded_of_uniformly_continuous_on_bounded:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::real_normed_vector\"\n  assumes \"bounded (UNIV::'a set)\" \"uniformly_continuous_on UNIV f\"\n  shows \"bounded (range f)\"\nOur comment on the codex statement: < wrong (didn't refer to set E, wrong types) but quite close >\n *)\ntheorem exercise_4_8a: \n  \n   fixes f::\"real \\<Rightarrow> real\" and E::\" real set\"\n  assumes \"bounded E\" \"uniformly_continuous_on E f\"\n  shows \"bounded (range f)\"\n  \n  oops\n\n\n(*\nproblem_number:4_11a\nnatural language statement:\nSuppose $f$ is a uniformly continuous mapping of a metric \nspace $X$ into a metric space $Y$ and prove that $\\left\\{f\\left(x_{n}\\right)\\right\\}$ \nis a Cauchy sequence in\nlean statement:\ntheorem exercise_4_11a\n  {X : Type*} [metric_space X]\n  {Y : Type*} [metric_space Y]\n  (f : X \\<rightarrow> Y) (hf : uniform_continuous f)\n  (x : \\<nat> \\<rightarrow> X) (hx : cauchy_seq x) :\n  cauchy_seq (\\<lambda> n, f (x n)) :=\n\ncodex statement:\ntheorem cauchy_of_uniform_continuous:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\"\n  assumes \"uniformly_continuous_on UNIV f\" \"cauchy (f \u2218 g)\"\n  shows \"cauchy g\"\nOur comment on the codex statement: <overall wrong, and it's\nstrange that it makes a function g appear out of nowhere. Also uses\ncauchy instead of Cauchy (the former doesn't exist>\n *)\n\n(*TODO something wrong with natural language statement? *)\ntheorem exercise_4_11a: undefined\n  oops\n\n(*\nproblem_number:4_12\nnatural language statement:\nA uniformly continuous function of a uniformly continuous function is uniformly continuous.\nlean statement:\ntheorem exercise_4_12\n  {\\<alpha> \u03b2 \\<nu> : Type*} [uniform_space \\<alpha>] [uniform_space \u03b2] [uniform_space \\<nu>]\n  {f : \\<alpha> \\<rightarrow> \u03b2} {g : \u03b2 \\<rightarrow> \\<nu>}\n  (hf : uniform_continuous f) (hg : uniform_continuous g) :\n  uniform_continuous (g \u2218 f) :=\n\ncodex statement:\ntheorem uniform_continuous_of_uniform_continuous_comp:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and g::\"'b::metric_space \\<Rightarrow> 'c::metric_space\"\n  assumes \"uniformly_continuous_on UNIV f\" \"uniformly_continuous_on UNIV g\"\n  shows \"uniformly_continuous_on UNIV (g \u2218 f)\"\nOur comment on the codex statement: <correct, I copy-paste it below>\n *)\ntheorem exercise_4_12:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and \ng::\"'b::metric_space \\<Rightarrow> 'c::metric_space\"\n  assumes \"uniformly_continuous_on UNIV f\" \"uniformly_continuous_on UNIV g\"\n  shows \"uniformly_continuous_on UNIV (g \u2218 f)\"\n    oops\n\n\n(*\nproblem_number:4_14\nnatural language statement:\nLet $I=[0,1]$ be the closed unit interval. \nSuppose $f$ is a continuous mapping of $I$ into $I$. Prove that $f(x)=x$ for at least one $x \\in I$.\nlean statement:\ntheorem exercise_4_14 [topological_space I]\n  [linear_order I] (f : I \\<rightarrow> I) (hf : continuous f) :\n  \\<exists> (x : I), f x = x :=\n\ncodex statement:\ntheorem exists_fixed_point_of_continuous_on_closed_interval:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on {0..1} f\"\n  shows \"\\<exists>x. x\\<in>{0..1} \\<and> f x = x\"\nOur comment on the codex statement: <almost correct, forgot range>\n *)\ntheorem exercise_4_14: \n   fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on {0..1} f\" and \"range f = {0..1}\"\n  shows \"\\<exists>x. x\\<in>{0..1} \\<and> f x = x\"\n  \n  oops\n\n\n(*\nproblem_number:4_15\nnatural language statement:\nProve that every continuous open mapping of $R^{1}$ into $R^{1}$ is monotonic.\nlean statement:\ntheorem exercise_4_15 {f : \\<real> \\<rightarrow> \\<real>}\n  (hf : continuous f) (hof : is_open_map f) :\n  monotone f :=\n\ncodex statement:\ntheorem monotonic_of_continuous_open_mapping:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on UNIV f\" \"open_mapping f\"\n  shows \"mono f\"\nOur comment on the codex statement: < wrong: used the definition open_mapping which doesn't exist.\nAlso, mono in Isabelle means monotone increasing, while it can either be monotone increasing\nor monotone decreasing>\n *)\ntheorem exercise_4_15:\n   fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on UNIV f\"  \"open (f ` UNIV) \"\n  shows \"mono f \\<or> antimono f \"\n  \n  oops\n\n\n(*\nproblem_number:4_19\nnatural language statement:\nSuppose $f$ is a real function with domain $R^{1}$ which has the intermediate value property. \nIf $f(a)<c<f(b)$, then $f(x)=c$ for some $x$ between $a$ and $b$. Suppose also, for every rational \n$r$, that the set of all $x$ with $f(x)=r$ is closed. Prove that $f$ is continuous.\nlean statement:\ntheorem exercise_4_19\n  {f : \\<real> \\<rightarrow> \\<real>} (hf : \\<forall> a b c, a < b \\<rightarrow> f a < c \\<rightarrow> c < f b \\<rightarrow> \\<exists> x, a < x \\<and> x < b \\<and> f x = c)\n  (hg : \\<forall> r : \\<rat>, is_closed {x | f x = r}) : continuous f :=\n\ncodex statement:\ntheorem continuous_of_intermediate_value_property_and_closed_set_of_rational_value:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>a b c. a < b \\<longrightarrow> f a < c \\<longrightarrow> c < f b \\<longrightarrow> \n\\<exists>x. a < x \\<longrightarrow> x < b \\<longrightarrow> f x = c\"\n    \"\\<forall>r. closed {x | x \\<in> UNIV \\<and> f x = r}\"\n  shows \"continuous_on UNIV f\"\nOur comment on the codex statement: <wrong >\n *)\ntheorem exercise_4_19: \n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \" \\<forall> a b c. ( (f a < c \\<and> c < f b )  \\<longrightarrow>\n(\\<exists> x::real. (f x) =c \\<and> ((x \\<le> a \\<and> x \\<ge> b) \\<or>(x \\<le> b \\<and> x \\<ge> a))   ) )\"\n and  \"\\<forall>r::rat. (closed {x. x \\<in> UNIV \\<and> f x = r})\"\n   shows \"continuous_on UNIV f\"\n  oops\n\n\n(*\nproblem_number:4_21a\nnatural language statement:\nSuppose $K$ and $F$ are disjoint sets in a metric space $X, K$ is compact, $F$ is closed. \nProve that there exists $\\delta>0$ such that $d(p, q)>\\delta$ if $p \\in K, q \\in F$.\nlean statement:\ntheorem exercise_4_21a {X : Type*} [metric_space X]\n  (K F : set X) (hK : is_compact K) (hF : is_closed F) (hKF : disjoint K F) :\n  \\<exists> (\u03b4 : \\<real>), \u03b4 > 0 \\<and> \\<forall> (p q : X), p \\<in> K \\<rightarrow> q \\<in> F \\<rightarrow> dist p q \\<ge> \u03b4 :=\n\ncodex statement:\ntheorem exists_delta_of_disjoint_compact_closed:\n  fixes K F::\"'a::metric_space set\"\n  assumes \"compact K\" \"closed F\" \"K \u2229 F = {}\"\n  shows \"\\<exists>\u03b4>0. \\<forall>p\\<in>K. \\<forall>q\\<in>F. dist p q > \u03b4\"\nOur comment on the codex statement: <correct formalisation, my formulation slightly differs>\n *)\ntheorem exercise_4_21a: \n  \n  fixes X::\"'a::metric_space set\" \n  assumes \"K \\<subseteq> X\"  \"F \\<subseteq> X\" \"compact K\" \"closed F\" \"K \u2229 F = {}\" \n  shows \"\\<exists> \\<delta>>0. \\<forall>p\\<in>K. \\<forall>q\\<in>F. dist p q > \\<delta>\" \n  oops\n\n\n(*\nproblem_number:4_24\nnatural language statement:\nAssume that $f$ is a continuous real function defined in $(a, b)$ \nsuch that $f\\left(\\frac{x+y}{2}\\right) \\leq \\frac{f(x)+f(y)}{2}$ for all $x, y \\in(a, b)$. \nProve that $f$ is convex.\nlean statement:\ntheorem exercise_4_24 {f : \\<real> \\<rightarrow> \\<real>}\n  (hf : continuous f) (a b : \\<real>) (hab : a < b)\n  (h : \\<forall> x y : \\<real>, a < x \\<rightarrow> x < b \\<rightarrow> a < y \\<rightarrow> y < b \\<rightarrow> f ((x + y) / 2) \\<le> (f x + f y) / 2) :\n  convex_on \\<real> (set.Ioo a b) f :=\n\ncodex statement:\ntheorem convex_of_continuous_and_ineq:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on {a<..<b} f\" \"\\<forall>x y. x \\<in> {a<..<b} \\<longrightarrow> y \\<in> {a<..<b} \\<longrightarrow> f ((x + y) / 2) \\<le> (f x + f y) / 2\"\n  shows \"convex_on {a<..<b} f\"\nOur comment on the codex statement: <close but not correct. Missed the absolute value.>\n *)\ntheorem exercise_4_24:\n   fixes f::\"real \\<Rightarrow> real\"\n   assumes\n\n \"continuous_on {a<..<b} f\"\n\"\\<forall>x y. (x  \\<in> {a<..<b} \\<and> y \\<in> {a<..<b} \n\\<longrightarrow>  f (abs((x + y) / 2)) \\<le> (f x + f y) / 2)\"\n  shows \"convex_on {a<..<b} f\"\n  \n  oops\n\n\n(*\nproblem_number:4_26a\nnatural language statement:\nSuppose $X, Y, Z$ are metric spaces, and $Y$ is compact. \nLet $f$ map $X$ into $Y$, let $g$ be a continuous one-to-one mapping of $Y$ into $Z$, \nand put $h(x)=g(f(x))$ for $x \\in X$. \nProve that $f$ is uniformly continuous if $h$ is uniformly continuous.\nlean statement:\n\ncodex statement:\ntheorem uniform_continuous_of_continuous_injective_uniform_continuous_comp:\n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" and g::\"'b::metric_space \\<Rightarrow> 'c::metric_space\"\n  assumes \"compact (UNIV::'b set)\" \"continuous_on UNIV g\" \"inj g\" \"uniformly_continuous_on UNIV (g \u2218 f)\"\n  shows \"uniformly_continuous_on UNIV f\"\nOur comment on the codex statement: <correct, I copy-paste it below>\n *)\ntheorem exercise_4_26a: \n  \n  fixes f::\"'a::metric_space \\<Rightarrow> 'b::metric_space\" \nand g::\"'b::metric_space \\<Rightarrow> 'c::metric_space\"\nassumes \"compact (UNIV::'b set)\" \"continuous_on UNIV g\"  \"inj g\"\n\n\"uniformly_continuous_on UNIV (g \u2218 f)\"\n  shows \"uniformly_continuous_on UNIV f\"\n  \n  oops\n\n\n(*\nproblem_number:5_1\nnatural language statement:\nLet $f$ be defined for all real $x$, and suppose that $|f(x)-f(y)| \n\\leq(x-y)^{2}$for all real $x$ and $y$. Prove that $f$ is constant.\nlean statement:\ntheorem exercise_5_1\n  {f : \\<real> \\<rightarrow> \\<real>} (hf : \\<forall> x y : \\<real>, | (f x - f y) | \\<le> (x - y) ^ 2) :\n  \\<exists> c, f = \\<lambda> x, c :=\n\ncodex statement:\ntheorem constant_of_diff_leq_square_diff:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x y. abs (f x - f y) \\<le> (x - y)^2\"\n  shows \"f constant_on UNIV\"\nOur comment on the codex statement: <correct, I copy-paste it below>\n *)\ntheorem exercise_5_1:\n   fixes f::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x y. abs (f x - f y) \\<le> (x - y)^2\"\n  shows \"f constant_on UNIV\"\n  oops\n\n\n(*\nproblem_number:5_2\nnatural language statement:\nSuppose $f^{\\prime}(x)>0$ in $(a, b)$. Prove that $f$ is strictly \nincreasing in $(a, b)$, and let $g$ be its inverse function. \nProve that $g$ is differentiable, and that$g^{\\prime}(f(x))=\\frac{1}{f^{\\prime}(x)} \\quad(a<x<b)$\nlean statement:\ntheorem exercise_5_2 {a b : \\<real>}\n  {f g : \\<real> \\<rightarrow> \\<real>} (hf : \\<forall> x \\<in> set.Ioo a b, deriv f x > 0)\n  (hg : g = inv f)\n  (hg_diff : differentiable_on \\<real> g (set.Ioo a b)) :\n  differentiable_on \\<real> g (set.Ioo a b) \\<and>\n  \\<forall> x \\<in> set.Ioo a b, deriv g x = 1 / deriv f x :=\n\ncodex statement:\ntheorem derivative_of_inverse_function:\n  fixes f::\"real \\<Rightarrow> real\" and g::\"real \\<Rightarrow> real\"\n  assumes \"a < b\" \"continuous_on {a..b} f\" \"\\<forall>x\\<in>{a..b}. f differentiable (at x)\" \n\"\\<forall>x\\<in>{a..b}. 0 < f' x\"\n  shows \"\\<forall>x\\<in>{a..b}. g differentiable (at x)\" \"\\<forall>x\\<in>{a..b}. g' x = 1 / f' (g x)\"\nOur comment on the codex statement: <quite close but wrong deriv  notation, misses one assumption\nand one concl. >*)\n\ntheorem exercise_5_2: \n   fixes f::\"real \\<Rightarrow> real\"  and g::\"real \\<Rightarrow> real\"\n   assumes \"\\<forall>x\\<in>{a..b}. f differentiable (at x)\" \n\"\\<forall>x\\<in>{a..b}. 0 < deriv f x\"  and \"\\<forall> x\\<in>{a..b} . g x = 1/ f x\"\n\nshows \"mono f\" \"\\<forall>x\\<in>{a..b}. g differentiable (at x)\" \n\"\\<forall>x\\<in>{a..b}. deriv g ( f x) = 1 / deriv f x\"\n  oops\n                                                                                   \n\n(*\nproblem_number:5_3\nnatural language statement:\nSuppose $g$ is a real function on $R^{1}$, with bounded derivative \n(say $\\left|g^{\\prime}\\right| \\leq M$ ). Fix $\\varepsilon>0$, and define $f(x)=x+\\varepsilon g(x)$. \nProve that $f$ is one-to-one if $\\varepsilon$ is small enough.\nlean statement:\ntheorem exercise_5_3 {g : \\<real> \\<rightarrow> \\<real>} (hg : continuous g)\n  (hg' : \\<exists> M : \\<real>, \\<forall> x : \\<real>, | deriv g x | \\<le> M) :\n  \\<exists> N, \\<forall> \\<epsilon> > 0, \\<epsilon> < N \\<rightarrow> \nfunction.injective (\\<lambda> x : \\<real>, x + \\<epsilon> * g x) :=\n\ncodex statement:\ntheorem injective_of_small_epsilon:\n  fixes g::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. abs (g' x) \\<le> M\"\n  shows \"\\<exists>\\<epsilon>>0. \\<forall>x y. abs (x - y) < \\<epsilon> \\<longrightarrow> g x \\<noteq> g y\"\nOur comment on the codex statement: <wrong >\n *)\ntheorem exercise_5_3: \n  fixes g::\"real \\<Rightarrow> real\" and \\<epsilon> K  M:: real and f::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. abs (deriv g x) \\<le> M\" and \" \\<forall> x. f x =x + \\<epsilon> *( g x )\"\n  shows \" \\<epsilon> < K \\<longrightarrow> inj f\"\n\n  oops\n\n\n(*\nproblem_number:5_4\nnatural language statement:\nIf $C_{0}+\\frac{C_{1}}{2}+\\cdots+\\frac{C_{n-1}}{n}+\\frac{C_{n}}{n+1}=0,$ where $C_{0}, \\ldots, \nC_{n}$ are real constants, prove that the equation $C_{0}+C_{1} x+\\cdots+C_{n-1} x^{n-1}+C_{n} x^{n}=0$ \nhas at least one real root between 0 and 1 .\nlean statement:\ntheorem exercise_5_4 {n : \\<nat>}\n  (C : \\<nat> \\<rightarrow> \\<real>)\n  (hC : \\<Sum> i in (finset.range (n + 1)), (C i) / (i + 1) = 0) :\n  \\<exists> x, x \\<in> (set.Icc (0 : \\<real>) 1) \\<and> \\<Sum> i in finset.range (n + 1), (C i) * (x^i) = 0 :=\n\ncodex statement:\ntheorem exists_real_root_of_polynomial_of_sum_eq_zero:\n  fixes C::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>n. C n = 0\" \"\\<Sum>n. C n / (n+1) = 0\"\n  shows \"\\<exists>x. 0 < x \\<and> x < 1 \\<and> (\\<Sum>n. C n * x^n) = 0\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_4: \n  undefined\n  oops\n\n\n(*\nproblem_number:5_5\nnatural language statement:\nSuppose $f$ is defined and differentiable for every $x>0$,\n and $f^{\\prime}(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$. Put $g(x)=f(x+1)-f(x)$. \nProve that $g(x) \\rightarrow 0$ as $x \\rightarrow+\\infty$.\nlean statement:\ntheorem exercise_5_5\n  {f : \\<real> \\<rightarrow> \\<real>}\n  (hfd : differentiable \\<real> f)\n  (hf : tendsto (deriv f) at_top (\ud835\udcdd 0)) :\n  tendsto (\\<lambda> x, f (x + 1) - f x) at_top at_top :=\n\ncodex statement:\ntheorem tendsto_zero_of_tendsto_zero_derivative:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. 0 < x \\<longrightarrow> f differentiable (at x)\" \"((\\<lambda>x. f' x) ---> 0) at_top\"\n  shows \"((\\<lambda>x. f (x + 1) - f x) ---> 0) at_top\"\nOur comment on the codex statement: <several wrong symbols>\n *)\ntheorem exercise_5_5:  \n fixes f::\"real \\<Rightarrow> real\"  and g::\"real \\<Rightarrow> real\"\n assumes \"\\<forall>x >0. f differentiable (at x)\" \"\\<forall> x. g(x)=f(x+1)-f(x)\"\n\"eventually ((\u03bbx. deriv f(x )) \u290f 0) at_top\"\n  shows \"eventually ((\u03bbx. deriv g(x )) \u290f 0) at_top\"\n  oops\n(*\nproblem_number:5_6\nnatural language statement:\nSuppose (a) $f$ is continuous for $x \\geq 0$, \n(b) $f^{\\prime}(x)$ exists for $x>0$, (c) $f(0)=0$, \n(d) $f^{\\prime}$ is monotonically increasing. Put $g(x)=\\frac{f(x)}{x} \\quad(x>0)$ \nand prove that $g$ is monotonically increasing.\nlean statement:\ntheorem exercise_5_6\n  {f : \\<real> \\<rightarrow> \\<real>}\n  (hf1 : continuous f)\n  (hf2 : \\<forall> x, differentiable_at \\<real> f x)\n  (hf3 : f 0 = 0)\n  (hf4 : monotone (deriv f)) :\n  monotone_on (\\<lambda> x, f x / x) (set.Ioi 0) :=\n\ncodex statement:\ntheorem monotone_increasing_of_continuous_derivative_monotone_increasing:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on {0..} f\" \"\\<forall>x>0. (f has_real_derivative f' x) (at x)\" \"f 0 = 0\" \"mono f'\"\n  shows \"mono (\\<lambda>x. f x / x)\"\nOur comment on the codex statement: <correct, copy-pasted with slight change>\n *)\ntheorem exercise_5_6: fixes f::\"real \\<Rightarrow> real\"\n   assumes \"continuous_on {0..} f\" \n\"\\<forall>x>0. (f has_real_derivative f' x) (at x)\" \"f 0 = 0\" \"mono f'\"\n\"\\<forall> x>0. g x = f x / x\"\n  shows \"mono g\"\n  \n  oops\n\n\n(*\nproblem_number:5_7\nnatural language statement:\nSuppose $f^{\\prime}(x), g^{\\prime}(x)$ exist, $g^{\\prime}(x) \\neq 0$, \nand $f(x)=g(x)=0$. Prove that $\\lim _{t \\rightarrow x} \\frac{f(t)}{g(t)}=\\frac{f^{\\prime}(x)}{g^{\\prime}(x)}.$\nlean statement:\ntheorem exercise_5_7\n  {f g : \\<real> \\<rightarrow> \\<real>} {x : \\<real>}\n  (hf' : differentiable_at \\<real> f 0)\n  (hg' : differentiable_at \\<real> g 0)\n  (hg'_ne_0 : deriv g 0 \\<noteq> 0)\n  (f0 : f 0 = 0) (g0 : g 0 = 0) :\n  tendsto (\\<lambda> x, f x / g x) (\ud835\udcdd x) (\ud835\udcdd (deriv f x / deriv g x)) :=\n\ncodex statement:\ntheorem lim_frac_of_derivative_eq_derivative_frac:\n  fixes f g::\"real \\<Rightarrow> real\"\n  assumes \"f differentiable (at x)\" \"g differentiable (at x)\" \"g x \\<noteq> 0\" \"f x = g x = 0\"\n  shows \"(f has_real_derivative (f' x)) (at x)\" \"(g has_real_derivative (g' x)) (at x)\"\nOur comment on the codex statement: <codex gives wrong assumptions and conclusions>\n *)\ntheorem exercise_5_7:\n (*  fixes f g::\"real \\<Rightarrow> real\" assumes\n  \" (f has_real_derivative f' x) (at x)\"\n   \" (g has_real_derivative g' x) (at x)\"\n \"g' x \\<noteq> 0\" \" f x = g x\" \"f x = 0\"\n*)\nundefined oops\n\n(*\nproblem_number:5_15\nnatural language statement:\nSuppose $a \\in R^{1}, f$ is a twice-differentiable real function \non $(a, \\infty)$, and $M_{0}, M_{1}, M_{2}$ are the least upper \nbounds of $|f(x)|,\\left|f^{\\prime}(x)\\right|,\\left|f^{\\prime \\prime}(x)\\right|$, \nrespectively, on $(a, \\infty)$. Prove that $M_{1}^{2} \\leq 4 M_{0} M_{2} .$\nlean statement:\ntheorem exercise_5_15 {f : \\<real> \\<rightarrow> \\<real>} (a M0 M1 M2 : \\<real>)\n  (hf' : differentiable_on \\<real> f (set.Ici a))\n  (hf'' : differentiable_on \\<real> (deriv f) (set.Ici a))\n  (hM0 : M0 = Sup {(| f x | )| x \\<in> (set.Ici a)})\n  (hM1 : M1 = Sup {(| deriv f x | )| x \\<in> (set.Ici a)})\n  (hM2 : M2 = Sup {(| deriv (deriv f) x | )| x \\<in> (set.Ici a)}) :\n  (M1 ^ 2) \\<le> 4 * M0 * M2 :=\n\ncodex statement: (* TODO MISSING*)\n\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_15: undefined oops\n\n\n(*\nproblem_number:5_17\nnatural language statement:\nSuppose $f$ is a real, three times differentiable function on $[-1,1]$, \nsuch that $f(-1)=0, \\quad f(0)=0, \\quad f(1)=1, \\quad f^{\\prime}(0)=0 .$ \nProve that $f^{(3)}(x) \\geq 3$ for some $x \\in(-1,1)$.\nlean statement:\ntheorem exercise_5_17\n  {f : \\<real> \\<rightarrow> \\<real>}\n  (hf' : differentiable_on \\<real> f (set.Icc (-1) 1))\n  (hf'' : differentiable_on \\<real> (deriv f) (set.Icc 1 1))\n  (hf''' : differentiable_on \\<real> (deriv (deriv f)) (set.Icc 1 1))\n  (hf0 : f (-1) = 0)\n  (hf1 : f 0 = 0)\n  (hf2 : f 1 = 1)\n  (hf3 : deriv f 0 = 0) :\n  \\<exists> x, x \\<in> set.Ioo (-1 : \\<real>) 1 \\<and> deriv (deriv (deriv f)) x \\<ge> 3 :=\n\ncodex statement:\ntheorem exists_x_in_interval_of_three_times_differentiable_function:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. f differentiable (at x)\" \"\\<forall>x. f differentiable (at x within {-1..1})\" \"\\<forall>x. f differentiable (at x within {-1..1})\" \"f (-1) = 0\" \"f 0 = 0\" \"f 1 = 1\" \"f' 0 = 0\"\n  shows \"\\<exists>x\\<in>{-1..1}. f''' x \\<ge> 3\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_5_17: undefined oops\n\n\n(*\nproblem_number:6_1\nnatural language statement:\nSuppose $\\alpha$ increases on $[a, b], \na \\leq x_{0} \\leq b, \\alpha$ is continuous at $x_{0}, f\\left(x_{0}\\right)=1$, \nand $f(x)=0$ if $x \\neq x_{0}$. Prove that $f \\in \\mathcal{R}(\\alpha)$ and that $\\int f d \\alpha=0$.\nlean statement:\n\ncodex statement:\ntheorem integral_of_continuous_function_eq_zero:\n  fixes f::\"real \\<Rightarrow> real\" and \\<alpha>::\"real \\<Rightarrow> real\"\n  assumes \"a \\<le> x\u2080\" \"x\u2080 \\<le> b\" \"continuous (at x\u2080) \\<alpha>\" \"f x\u2080 = 1\" \n\"f x = 0\" \"\\<forall>x. a \\<le> x \\<and> x \\<le> b \\<longrightarrow> \\<alpha> x \\<le> \\<alpha> x\u2080\"\n  shows \"f \\<in> borel_measurable \\<alpha>\" \"integral \\<alpha> f = 0\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_1: undefined oops\n(*TODO: note there are different kinds of integration, do we need Riemann here? *)\n\n\n(*\nproblem_number:6_2\nnatural language statement:\nSuppose $f \\geq 0, f$ is continuous on $[a, b]$, and $\\int_{a}^{b} f(x) d x=0$. \nProve that $f(x)=0$ for all $x \\in[a, b]$.\nlean statement:\n\ncodex statement:\ntheorem zero_integral_of_continuous_nonneg_implies_zero_function:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on {a..b} f\" \"f \\<ge> 0\" \"integral {a..b} f = 0\"\n  shows \"\\<forall>x\\<in>{a..b}. f x = 0\"\nOur comment on the codex statement: <almost correct, but syntactical error in one of the assumptions.\n By the way: TODO  it is not \nactually clear which kind of integral is required from the nat lang. statement. >\n *)\ntheorem exercise_6_2: \n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"continuous_on {a..b} f\"  \"\\<forall> x \\<in> UNIV. f x \\<ge> 0\" \"integral {a..b} f = 0\"\n  shows  \"\\<forall>x\\<in>{a..b}. f x = 0\"\n  oops\n\n\n(*\nproblem_number:6_4\nnatural language statement:\nIf $f(x)=0$ for all irrational $x, f(x)=1$ for all rational $x$, \nprove that $f \\notin \\mathcal{R}$ on $[a, b]$ for any $a<b$.\nlean statement:\n\ncodex statement:\ntheorem not_Riemann_integrable_of_zero_for_irrational_one_for_rational:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"\\<forall>x. irrational x \\<longrightarrow> f x = 0\" \"\\<forall>x. rational x \\<longrightarrow> f x = 1\"\n  shows \"\\<forall>a b. a < b \\<longrightarrow> \u00ac (f integrable_on {a..b})\"\nOur comment on the codex statement: <uses nonexistent Isabelle defs like rational, irrational>\n *)\ntheorem exercise_6_4: \n   fixes f::\"real \\<Rightarrow> real\"\n   assumes \"\\<forall>x. x \\<notin> Rats \\<longrightarrow> f x = 0\" \n\"\\<forall>x \\<in> Rats.  f x = 1\"\n  shows \"\\<forall>a b. a < b \\<longrightarrow> \u00ac (f integrable_on {a..b})\"\n  oops\n(*TODO: again note there are different kinds of integration, don't we need Riemann here? *)\n\n(*\nproblem_number:6_6\nnatural language statement:\nLet $P$ be the Cantor set. Let $f$ be a bounded real function on $[0,1]$ \nwhich is continuous at every point outside $P$. Prove that $f \\in \\mathcal{R}$ on $[0,1]$.\nlean statement:\nMISSING\ncodex statement:\ntheorem R_of_bounded_continuous_at_outside_Cantor:\n  fixes f::\"real \\<Rightarrow> real\"\n  assumes \"bounded (range f)\" \"\\<forall>x\\<in>{0..1} - cantor. continuous (at x) f\"\n  shows \"f \\<in> R {0..1}\"\nOur comment on the codex statement: <YOU CAN LEAVE YOUR COMMENT HERE>\n *)\ntheorem exercise_6_6:\n \n undefined oops\n\n\n\n\nend\n"}
{"text": "(*\n   Authors: Asta Halkj\u00e6r From, Agnes Moesg\u00e5rd Eschen & J\u00f8rgen Villadsen, DTU Compute\n*)\n\ntheory System_F1 imports System_L3 begin\n\ntext \\<open>System F from Gottlob Frege: Begriffsschrift (1879)\\<close>\n\ntext \\<open>Derivations are taken from: On Axiom Systems of Propositional Calculi. VII\n                                  by Yoshinari Arai and Kiyoshi Iseki (1965)\\<close>\n\ninductive F (\\<open>\\<FF>\\<close>) where\n  F_MP: \\<open>\\<FF> q\\<close> if \\<open>\\<FF> p\\<close> and \\<open>\\<FF> (p \\<rightarrow> q)\\<close> |\n  F_1:  \\<open>\\<FF> (p \\<rightarrow> (q \\<rightarrow> p))\\<close> |\n  F_2:  \\<open>\\<FF> ((p \\<rightarrow> (q \\<rightarrow> r)) \\<rightarrow> ((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)))\\<close> |\n  F_3:  \\<open>\\<FF> ((p \\<rightarrow> q) \\<rightarrow> ((\\<sim> q) \\<rightarrow> (\\<sim> p)))\\<close> |\n  F_4:  \\<open>\\<FF> ((\\<sim> (\\<sim> p)) \\<rightarrow> p)\\<close> |\n  F_5:  \\<open>\\<FF> (p \\<rightarrow> (\\<sim> (\\<sim> p)))\\<close>\n\nlemma F_6: \\<open>\\<FF> ((q \\<rightarrow> r) \\<rightarrow> ((p \\<rightarrow> (q \\<rightarrow> r)) \\<rightarrow> ((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r))))\\<close>\n  using F_1 F_2 F_MP by metis\n\nlemma F_7: \\<open>\\<FF> ((q \\<rightarrow> r) \\<rightarrow> ((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using F_1 F_2 F_6 F_MP by metis\n\nlemma F_8: \\<open>\\<FF> (((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)) \\<rightarrow> (q \\<rightarrow> (p \\<rightarrow> q)))\\<close>\n  using F_1 F_MP by metis\n\nlemma F_9: \\<open>\\<FF> (((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)) \\<rightarrow> ((q \\<rightarrow> (p \\<rightarrow> q)) \\<rightarrow> (q \\<rightarrow> (p \\<rightarrow> r))))\\<close>\n  using F_7.\n\nlemma F_10: \\<open>\\<FF> (((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)) \\<rightarrow> (q \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using F_2 F_8 F_9 F_MP by metis\n\nlemma F_11: \\<open>\\<FF> ((p \\<rightarrow> (q \\<rightarrow> r)) \\<rightarrow> (q \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using F_2 F_7 F_10 F_MP by metis\n\nlemma F_12: \\<open>\\<FF> ((p \\<rightarrow> q) \\<rightarrow> ((q \\<rightarrow> r) \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using F_7 F_11 F_MP by metis\n\nlemma F_13: \\<open>\\<FF> ((p \\<rightarrow> (\\<sim> q)) \\<rightarrow> ((\\<sim> (\\<sim> q)) \\<rightarrow> (\\<sim> p)))\\<close>\n  using F_3.\n\nlemma F_14: \\<open>\\<FF> (((\\<sim> (\\<sim> q)) \\<rightarrow> (\\<sim> p)) \\<rightarrow> (q \\<rightarrow> (\\<sim> p)))\\<close>\n  using F_5 F_12 F_MP by metis\n\nlemma F_15: \\<open>\\<FF> ((p \\<rightarrow> (\\<sim> q)) \\<rightarrow> (q \\<rightarrow> (\\<sim> p)))\\<close>\n  using F_12 F_13 F_14 F_MP by metis\n\nlemma F_16: \\<open>\\<FF> ((q \\<rightarrow> (\\<sim> (\\<sim> p))) \\<rightarrow> (q \\<rightarrow> p))\\<close>\n  using F_4 F_7 F_MP by metis\n\nlemma F_17: \\<open>\\<FF> (((\\<sim> p) \\<rightarrow> (\\<sim> q)) \\<rightarrow> (q \\<rightarrow> p))\\<close>\n  using F_12 F_15 F_16 F_MP by metis\n\ntheorem F_iff_L3: \\<open>\\<FF> p \\<longleftrightarrow> \\<LL>\\<^sub>3 p\\<close>\nproof\n  have L3_F_3: \\<open>\\<LL>\\<^sub>3 ((p \\<rightarrow> q) \\<rightarrow> ((\\<sim> q) \\<rightarrow> (\\<sim> p)))\\<close> for p q\n    using L3_completeness by simp\n  have L3_F_4: \\<open>\\<LL>\\<^sub>3 ((\\<sim> (\\<sim> p)) \\<rightarrow> p)\\<close> for p\n    using L3_completeness by simp\n  have L3_F_5: \\<open>\\<LL>\\<^sub>3 (p \\<rightarrow> (\\<sim> (\\<sim> p)))\\<close> for p\n    using L3_completeness by simp\n  show \\<open>\\<LL>\\<^sub>3 p\\<close> if \\<open>\\<FF> p\\<close>\n    using that by (induct) (metis L3_MP, metis L3_1, metis L3_2,\n        metis L3_F_3, metis L3_F_4, metis L3_F_5)\n  show \\<open>\\<FF> p\\<close> if \\<open>\\<LL>\\<^sub>3 p\\<close>\n    using that by (induct) (metis F_MP, metis F_1, metis F_2, metis F_17)\nqed\n\ntheorem F_soundness: \\<open>\\<FF> p \\<Longrightarrow> I \\<Turnstile> p\\<close>\n  by (induct rule: F.induct) auto\n\ntheorem F_completeness: \\<open>\\<forall>I. (I \\<Turnstile> p) \\<Longrightarrow> \\<FF> p\\<close>\n  using F_iff_L3 by (simp add: L3_completeness)\n\nsection \\<open>Soundness and Completeness\\<close>\n\ntheorem main: \\<open>valid p = \\<FF> p\\<close>\n  unfolding valid_def using F_soundness F_completeness by blast\n\nlemmas F1 = F.intros main\n\nend\n"}
{"text": "{-# OPTIONS --enable-prop #-}\n\ndata Squash {\u2113} (A : Set \u2113) : Prop \u2113 where\n  squash : A \u2192 Squash A\n\nsquash-elim : \u2200 {\u2113\u2081 \u2113\u2082} (A : Set \u2113\u2081) (P : Prop \u2113\u2082)\n            \u2192 (A \u2192 P) \u2192 Squash A \u2192 P\nsquash-elim A P f (squash x) = f x\n"}
{"text": "{-# OPTIONS --without-K #-}\nmodule GroupoidStructure {a} {A : Set a} where\n\nopen import PathOperations\nopen import Types\n\np\u00b7p\u207b\u00b9 : {a b : A} (p : a \u2261 b) \u2192 p \u00b7 p \u207b\u00b9 \u2261 refl\np\u00b7p\u207b\u00b9 = J (\u03bb _ _ p \u2192 p \u00b7 p \u207b\u00b9 \u2261 refl) (\u03bb _ \u2192 refl) _ _\n\np\u207b\u00b9\u00b7p : {a b : A} (p : a \u2261 b) \u2192 p \u207b\u00b9 \u00b7 p \u2261 refl\np\u207b\u00b9\u00b7p = J (\u03bb _ _ p \u2192 p \u207b\u00b9 \u00b7 p \u2261 refl) (\u03bb _ \u2192 refl) _ _\n\np\u00b7id : {a b : A} (p : a \u2261 b) \u2192 p \u00b7 refl \u2261 p\np\u00b7id = J (\u03bb _ _ p \u2192 p \u00b7 refl \u2261 p) (\u03bb _ \u2192 refl) _ _\n\nid\u00b7p : {a b : A} (p : a \u2261 b) \u2192 refl \u00b7 p \u2261 p\nid\u00b7p _ = refl\n\np\u00b7q\u00b7r : {a b c d : A} (p : a \u2261 b) (q : b \u2261 c) (r : c \u2261 d) \u2192\n  p \u00b7 (q \u00b7 r) \u2261 (p \u00b7 q) \u00b7 r\np\u00b7q\u00b7r {c = c} {d = d} = J\n  (\u03bb _ b p \u2192 (q : b \u2261 c) (r : c \u2261 d) \u2192 p \u00b7 q \u00b7 r \u2261 (p \u00b7 q) \u00b7 r)\n  (\u03bb b \u2192 J\n    (\u03bb _ c q \u2192 (r : c \u2261 d) \u2192 refl \u00b7 q \u00b7 r \u2261 (refl \u00b7 q) \u00b7 r)\n    (\u03bb _ _ \u2192 refl) _ _)\n  _ _\n"}
{"text": "lemma zero_le (a : mynat) : 0 \u2264 a :=\nbegin\nuse a,\nrw zero_add,\nrefl,\nend\n"}
{"text": "theorem ex [Add \u03b1]\n            (assoc : {a b c : \u03b1} \u2192 a + b + c = a + (b + c))\n            (comm  : {a b : \u03b1} \u2192 a + b = b + a)\n            (f : \u03b1 \u2192 \u03b1) (x y z : \u03b1) : f (x + (y + z)) = f (y + (x + z)) := by\n  let leftAssoc {a b c : \u03b1} : a + (b + c) = b + (a + c) := by\n    rw [\u2190 assoc, comm (a := a), assoc]\n  simp [leftAssoc]\n"}
{"text": "theory exercise_2_2\n  imports Main\nbegin\n(*set add function*)\nfun add::\"nat\\<Rightarrow>nat\\<Rightarrow>nat\"\n  where\n\"add m 0  =m\"|\n\"add m  (Suc n)=Suc(add m n)\"\n\n(*set association*)\ntheorem add_assoc:\"add x (add y z) =add (add x y) z\"\n  apply(induction z)\n  apply(auto)\n  done\n(*set add 0 x*)\nlemma add_zero:\"add 0 x=x\"\n  apply(induction x)\n  apply(auto)\n  done\n\nlemma suc_add:\"Suc(add y x) = add (Suc y)  x\"\n  apply(induction x)\n  apply(auto)\n  done\ntheorem add_com:\"add x y=add y x\"\n  apply(induction y)(*the different with using x or y as value ? ?*)\n  apply(auto)\n  apply(simp add:add_zero)\n  apply(simp add:suc_add)\n  done\n\n(*fun double*)\nfun double::\"nat\\<Rightarrow>nat\" \n  where\n\"double 0=0\"|\n\"double (Suc m) =2+(double m)\"(*Why here is add ,not mutl? ?*)\ntheorem double_add:\"double m=add m m\"\n  apply(induction m)\n   apply(auto)\n  apply(simp add:add_com)\n  done\nend"}
{"text": "informal statement Prove that there exist infinitely many integers $n$ such that $n, n+1, n+2$ are each the sum of the squares of two integers.formal statement theorem exercise_2000_a2 : \n  \u2200 N : \u2115, \u2203 n : \u2115, n > N \u2227 \u2203 i : fin 6 \u2192 \u2115, n = (i 0)^2 + (i 1)^2 \u2227 \n  n + 1 = (i 2)^2 + (i 3)^2 \u2227 n + 2 = (i 4)^2 + (i 5)^2 :="}
{"text": "/-\n\nIn this file we will address how to deal with some examples from logic, namely and and or.\n\n-/\n\n/- Ignore this for now. But all imports are on the top of the file. -/\n-- import tactic.suggest\n/- Uncomment after reading the last note. -/\n\n\n\n/- Prove that p \u2227 q \u2192 p. It should be pretty straight-forward -/\n\ntheorem p_and_q_implies_p (p q:Prop):  \n    p \u2227 q \u2192 p :=\nbegin\n    intro proof_of_p_and_q,\n    exact proof_of_p_and_q.left, -- how did we know about this?\nend\n\n/-\n\nIf you delete \"left\" and ask for the autocomplete (cmd+space), you will not find left.\nSo how did we know that it was the solution?\n\nIf you cmd+click on the \u2227 symbol, you go to its definition and you can discover that it is\na structure (similar to a struct in C or records in Haskell). You can see that it is made of\ntwo fields: left and right. In this case, we use the one that is most useful for our proof.\n\n-/\n\n/- Prove that p \u2192 p \u2228 q -/\n\ntheorem p_implies_p_or_q (p q:Prop) : \n    p \u2192 p \u2228 q := \nbegin\n    intro proof_of_p,\n    left,\n    exact proof_of_p,\nend\n\n/-\nWhile there are other options, here we use the left (as opposed to the right) tactic.\nThese two tactics can be used to focus on the right or left side or an \u2228-goal. We only\nneed to prove one of the sides.\n-/\n\n\ntheorem q_implies_p_or_q_or_r (p q r :Prop) : \n    q \u2192 (p \u2228 q) \u2228 r := \nbegin\n    sorry, -- it is another exercice.\nend\n\n\ntheorem p_implies_p_or_not_p (p:Prop) : p \u2192 p \u2228 (\u00ac p) :=\nbegin\n    sorry, -- it is yet another exercice.\nend\n\n/-\n    For this last theorem, the structure will be very similar to p_implies_p_or_q. In\n    fact, too similar! Instead of copying the proof, you should use the existing theorems\n    and lemmas. Tip: despite not being in the shown context, every theorem and lemma can be\n    used in the context of proofs.\n\n-/\n\n\n\n/- This next example is interesting, because we cannot go left or right. We have\nto go both ways.\n\nThat can be done using induction on the structure of or. If calling it an induction bothers\nyou, you can replace \"induction\" with \"cases\", which works in the same way.\n\n -/\n\nexample (n:\u2115) : n = 3 \u2228 n = 4 \u2192 n = 4 \u2228 n = 3 :=\nbegin\n    intros or_3_4,\n    induction or_3_4,\n    {\n        right,\n        exact or_3_4,\n    },\n    {\n        left,\n        exact or_3_4,\n    }\nend\n\n\n/-\n\nMy main complaints writing proofs was that I had to dive into the source code of\nlean standard library looking for lemmas that would solve my problem, without knowing its name.\n\nThis example should be trivial to solve, if we have a theorem that shows that \u2228 is commutative.\n\nLet's use the \"library_search\" tactic, imported from \"tactic.suggest\" on the top of this file,\nwhich you need to uncomment. Notice that it solves the goal, but has a blue wavy underline under \nit. Library_search is useful when writing proofs, but does not serve as a proof that others can \nread. Visual Studio Code shows a shortcut on the right to replace library_search with the found\nlemma. The code shown below is the found tactic. Feel free to replace it and try library_search.\n\n\nNote: library_search does not come with the lean standard library, and does not work on the webbrowser.\nThis tactic comes with the mathlib library, which you can install following the instructions on the Readme.\n\n-/\n\nexample (n:\u2115) : n = 3 \u2228 n = 4 \u2192 n = 4 \u2228 n = 3 :=\nbegin\n    exact or.swap,\nend"}
{"text": "/-\nCopyright (c) S\u00e9bastien Gou\u00ebzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S\u00e9bastien Gou\u00ebzel, Yourong Zang\n-/\nimport analysis.calculus.times_cont_diff\nimport analysis.complex.conformal\nimport analysis.calculus.conformal.normed_space\n\n/-! # Real differentiability of complex-differentiable functions\n\n`has_deriv_at.real_of_complex` expresses that, if a function on `\u2102` is differentiable (over `\u2102`),\nthen its restriction to `\u211d` is differentiable over `\u211d`, with derivative the real part of the\ncomplex derivative.\n\n`differentiable_at.conformal_at` states that a real-differentiable function with a nonvanishing\ndifferential from the complex plane into an arbitrary complex-normed space is conformal at a point\nif it's holomorphic at that point. This is a version of Cauchy-Riemann equations.\n\n`conformal_at_iff_differentiable_at_or_differentiable_at_comp_conj` proves that a real-differential\nfunction with a nonvanishing differential between the complex plane is conformal at a point if and\nonly if it's holomorphic or antiholomorphic at that point.\n\n## TODO\n\n* The classical form of Cauchy-Riemann equations\n* On a connected open set `u`, a function which is `conformal_at` each point is either holomorphic\nthroughout or antiholomorphic throughout.\n\n## Warning\n\nWe do NOT require conformal functions to be orientation-preserving in this file.\n-/\n\nsection real_deriv_of_complex\n/-! ### Differentiability of the restriction to `\u211d` of complex functions -/\nopen complex\nvariables {e : \u2102 \u2192 \u2102} {e' : \u2102} {z : \u211d}\n\n/-- If a complex function is differentiable at a real point, then the induced real function is also\ndifferentiable at this point, with a derivative equal to the real part of the complex derivative. -/\ntheorem has_strict_deriv_at.real_of_complex (h : has_strict_deriv_at e e' z) :\n  has_strict_deriv_at (\u03bbx:\u211d, (e x).re) e'.re z :=\nbegin\n  have A : has_strict_fderiv_at (coe : \u211d \u2192 \u2102) of_real_clm z := of_real_clm.has_strict_fderiv_at,\n  have B : has_strict_fderiv_at e\n    ((continuous_linear_map.smul_right 1 e' : \u2102 \u2192L[\u2102] \u2102).restrict_scalars \u211d)\n    (of_real_clm z) :=\n    h.has_strict_fderiv_at.restrict_scalars \u211d,\n  have C : has_strict_fderiv_at re re_clm (e (of_real_clm z)) := re_clm.has_strict_fderiv_at,\n  simpa using (C.comp z (B.comp z A)).has_strict_deriv_at\nend\n\n/-- If a complex function is differentiable at a real point, then the induced real function is also\ndifferentiable at this point, with a derivative equal to the real part of the complex derivative. -/\ntheorem has_deriv_at.real_of_complex (h : has_deriv_at e e' z) :\n  has_deriv_at (\u03bbx:\u211d, (e x).re) e'.re z :=\nbegin\n  have A : has_fderiv_at (coe : \u211d \u2192 \u2102) of_real_clm z := of_real_clm.has_fderiv_at,\n  have B : has_fderiv_at e ((continuous_linear_map.smul_right 1 e' : \u2102 \u2192L[\u2102] \u2102).restrict_scalars \u211d)\n    (of_real_clm z) :=\n    h.has_fderiv_at.restrict_scalars \u211d,\n  have C : has_fderiv_at re re_clm (e (of_real_clm z)) := re_clm.has_fderiv_at,\n  simpa using (C.comp z (B.comp z A)).has_deriv_at\nend\n\ntheorem times_cont_diff_at.real_of_complex {n : with_top \u2115} (h : times_cont_diff_at \u2102 n e z) :\n  times_cont_diff_at \u211d n (\u03bb x : \u211d, (e x).re) z :=\nbegin\n  have A : times_cont_diff_at \u211d n (coe : \u211d \u2192 \u2102) z,\n    from of_real_clm.times_cont_diff.times_cont_diff_at,\n  have B : times_cont_diff_at \u211d n e z := h.restrict_scalars \u211d,\n  have C : times_cont_diff_at \u211d n re (e z), from re_clm.times_cont_diff.times_cont_diff_at,\n  exact C.comp z (B.comp z A)\nend\n\ntheorem times_cont_diff.real_of_complex {n : with_top \u2115} (h : times_cont_diff \u2102 n e) :\n  times_cont_diff \u211d n (\u03bb x : \u211d, (e x).re) :=\ntimes_cont_diff_iff_times_cont_diff_at.2 $ \u03bb x,\n  h.times_cont_diff_at.real_of_complex\n\nvariables {E : Type*} [normed_group E] [normed_space \u2102 E]\n\nlemma has_strict_deriv_at.complex_to_real_fderiv' {f : \u2102 \u2192 E} {x : \u2102} {f' : E}\n  (h : has_strict_deriv_at f f' x) :\n  has_strict_fderiv_at f (re_clm.smul_right f' + I \u2022 im_clm.smul_right f') x :=\nby simpa only [complex.restrict_scalars_one_smul_right']\n  using h.has_strict_fderiv_at.restrict_scalars \u211d\n\nlemma has_deriv_at.complex_to_real_fderiv' {f : \u2102 \u2192 E} {x : \u2102} {f' : E} (h : has_deriv_at f f' x) :\n  has_fderiv_at f (re_clm.smul_right f' + I \u2022 im_clm.smul_right f') x :=\nby simpa only [complex.restrict_scalars_one_smul_right']\n  using h.has_fderiv_at.restrict_scalars \u211d\n\nlemma has_deriv_within_at.complex_to_real_fderiv' {f : \u2102 \u2192 E} {s : set \u2102} {x : \u2102} {f' : E}\n  (h : has_deriv_within_at f f' s x) :\n  has_fderiv_within_at f (re_clm.smul_right f' + I \u2022 im_clm.smul_right f') s x :=\nby simpa only [complex.restrict_scalars_one_smul_right']\n  using h.has_fderiv_within_at.restrict_scalars \u211d\n\nlemma has_strict_deriv_at.complex_to_real_fderiv {f : \u2102 \u2192 \u2102} {f' x : \u2102}\n  (h : has_strict_deriv_at f f' x) :\n  has_strict_fderiv_at f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) x :=\nby simpa only [complex.restrict_scalars_one_smul_right]\n  using h.has_strict_fderiv_at.restrict_scalars \u211d\n\nlemma has_deriv_at.complex_to_real_fderiv {f : \u2102 \u2192 \u2102} {f' x : \u2102} (h : has_deriv_at f f' x) :\n  has_fderiv_at f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) x :=\nby simpa only [complex.restrict_scalars_one_smul_right]\n  using h.has_fderiv_at.restrict_scalars \u211d\n\nlemma has_deriv_within_at.complex_to_real_fderiv {f : \u2102 \u2192 \u2102} {s : set \u2102} {f' x : \u2102}\n  (h : has_deriv_within_at f f' s x) :\n  has_fderiv_within_at f (f' \u2022 (1 : \u2102 \u2192L[\u211d] \u2102)) s x :=\nby simpa only [complex.restrict_scalars_one_smul_right]\n  using h.has_fderiv_within_at.restrict_scalars \u211d\n\nend real_deriv_of_complex\n\nsection conformality\n/-! ### Conformality of real-differentiable complex maps -/\nopen complex continuous_linear_map\nopen_locale complex_conjugate\n\nvariables\n\n/-- A real differentiable function of the complex plane into some complex normed space `E` is\n    conformal at a point `z` if it is holomorphic at that point with a nonvanishing differential.\n    This is a version of the Cauchy-Riemann equations. -/\nlemma differentiable_at.conformal_at {E : Type*}\n  [normed_group E] [normed_space \u211d E] [normed_space \u2102 E]\n  [is_scalar_tower \u211d \u2102 E] {z : \u2102} {f : \u2102 \u2192 E}\n  (hf' : fderiv \u211d f z \u2260 0) (h : differentiable_at \u2102 f z) :\n  conformal_at f z :=\nbegin\n  rw conformal_at_iff_is_conformal_map_fderiv,\n  rw (h.has_fderiv_at.restrict_scalars \u211d).fderiv at \u22a2 hf',\n  apply is_conformal_map_complex_linear,\n  contrapose! hf' with w,\n  simp [w]\nend\n\n/-- A complex function is conformal if and only if the function is holomorphic or antiholomorphic\n    with a nonvanishing differential. -/\nlemma conformal_at_iff_differentiable_at_or_differentiable_at_comp_conj {f : \u2102 \u2192 \u2102} {z : \u2102} :\n  conformal_at f z \u2194\n  (differentiable_at \u2102 f z \u2228 differentiable_at \u2102 (f \u2218 conj) (conj z)) \u2227 fderiv \u211d f z \u2260 0 :=\nbegin\n  rw conformal_at_iff_is_conformal_map_fderiv,\n  rw is_conformal_map_iff_is_complex_or_conj_linear,\n  apply and_congr_left,\n  intros h,\n  have h_diff := h.imp_symm fderiv_zero_of_not_differentiable_at,\n  apply or_congr,\n  { rw differentiable_at_iff_restrict_scalars \u211d h_diff },\n  rw \u2190 conj_conj z at h_diff,\n  rw differentiable_at_iff_restrict_scalars \u211d (h_diff.comp _ conj_cle.differentiable_at),\n  refine exists_congr (\u03bb g, rfl.congr _),\n  have : fderiv \u211d conj (conj z) = _ := conj_cle.fderiv,\n  simp [fderiv.comp _ h_diff conj_cle.differentiable_at, this, conj_conj],\nend\n\nend conformality\n"}
{"text": "/-\nCopyright (c) 2020 Johan Commelin. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Johan Commelin, Kenny Lau\n\n! This file was ported from Lean 3 source module number_theory.basic\n! leanprover-community/mathlib commit 168ad7fc5d8173ad38be9767a22d50b8ecf1cd00\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathlib.Algebra.GeomSum\nimport Mathlib.RingTheory.Ideal.Quotient\n\n/-!\n# Basic results in number theory\n\nThis file should contain basic results in number theory. So far, it only contains the essential\nlemma in the construction of the ring of Witt vectors.\n\n## Main statement\n\n`dvd_sub_pow_of_dvd_sub` proves that for elements `a` and `b` in a commutative ring `R` and for\nall natural numbers `p` and `k` if `p` divides `a-b` in `R`, then `p ^ (k + 1)` divides\n`a ^ (p ^ k) - b ^ (p ^ k)`.\n-/\n\n\nsection\n\nopen Ideal Ideal.Quotient\n\ntheorem dvd_sub_pow_of_dvd_sub {R : Type _} [CommRing R] {p : \u2115} {a b : R} (h : (p : R) \u2223 a - b)\n    (k : \u2115) : (p ^ (k + 1) : R) \u2223 a ^ p ^ k - b ^ p ^ k := by\n  induction' k with k ih\n  \u00b7 rwa [pow_one, pow_zero, pow_one, pow_one]\n  rw [pow_succ' p k, pow_mul, pow_mul, \u2190 geom_sum\u2082_mul, pow_succ, Nat.cast_mul]\n  refine' mul_dvd_mul _ ih\n  let f : R \u2192+* R \u29f8 span {(p : R)} := mk (span {(p : R)})\n  have hf : \u2200 r : R, (p : R) \u2223 r \u2194 f r = 0 := fun r \u21a6 by rw [eq_zero_iff_mem, mem_span_singleton]\n  rw [hf, map_sub, sub_eq_zero] at h\n  rw [hf, RingHom.map_geom_sum\u2082, map_pow, map_pow, h, geom_sum\u2082_self, mul_eq_zero_of_left]\n  rw [\u2190 map_natCast f, eq_zero_iff_mem, mem_span_singleton]\n#align dvd_sub_pow_of_dvd_sub dvd_sub_pow_of_dvd_sub\n\nend\n"}
{"text": "section\n  variables (x y z : \u2115)\n  variables (h\u2081 : x = y) (h\u2082 : y = z)\n\n  section include_hs\n    include h\u2081 h\u2082\n\n    theorem foo : x = z :=\n    begin\n      rw [h\u2081, h\u2082]\n    end\n  end include_hs\nend\n"}
{"text": "open classical\n\nvariables { p q r : Prop }\n\ntheorem not_not_iff : \u00ac\u00acp \u2194 p :=\n\u27e8by_contradiction \u2218 flip absurd, not_not_intro\u27e9 \n\ntheorem imp_classical : p \u2192 q \u2194 \u00ac p \u2228 q := \n\u27e8\u03bbh, by_cases (or.inr \u2218 h) or.inl, \u03bbh h1, h.elim (absurd h1) id\u27e9\n\ntheorem not_and_iff_neg_or : \u00ac (p \u2227 q) \u2194 (\u00ac p \u2228 \u00ac q) :=\nby { split; intro h,\n    { apply @by_cases p; intro h1,\n        { apply @by_cases q; intro h2,\n            { apply false.elim, apply h,\n                split, exact h1, exact h2 },\n            { right, exact h2 } },\n        { left, exact h1 } },\n    { intro h1, cases h1 with h2 h3, cases h with h h; apply h,\n        exact h2, exact h3 } }\n\ntheorem not_or_iff_neg_and : \u00ac (p \u2228 q) \u2194 (\u00ac p \u2227 \u00ac q) :=\nby { split; intro h, \n    { split; intro h1; apply h,\n        { left, exact h1 }, { right, exact h1 } },\n    { cases h with h h1, intro h2, cases h2 with h2 h2,\n        { apply h, exact h2 }, { apply h1, exact h2 } } }"}
{"text": "import init.data.set\nimport set_theory.cardinal.basic\n\nopen set\nopen_locale cardinal\n\ntheorem mk_le_of_surjective {\u03b1 \u03b2 : Type} {f : \u03b1 \u2192 \u03b2} \n  (hf : function.surjective f) :\n  #\u03b1 \u2265 #\u03b2 :=\nbegin\n  fsplit,\n  fsplit,\n  exact function.surj_inv hf,\n  exact function.injective_surj_inv hf,\nend\n\ntheorem mk_le_of_injective {\u03b1 \u03b2 : Type} {f : \u03b1 \u2192 \u03b2}\n  (hf : function.injective f) :\n  #\u03b1 \u2264 #\u03b2 := \nbegin \n  fsplit,\n  fsplit,\n  assumption,\n  assumption,\nend"}
{"text": "[STATEMENT]\nlemma projs [simp]:\n  \"\\<pi>\\<^sub>2(dsn, dsk, flag, hops, nhip, pre) = dsn\"\n  \"\\<pi>\\<^sub>3(dsn, dsk, flag, hops, nhip, pre) = dsk\"\n  \"\\<pi>\\<^sub>4(dsn, dsk, flag, hops, nhip, pre) = flag\"\n  \"\\<pi>\\<^sub>5(dsn, dsk, flag, hops, nhip, pre) = hops\"\n  \"\\<pi>\\<^sub>6(dsn, dsk, flag, hops, nhip, pre) = nhip\"\n  \"\\<pi>\\<^sub>7(dsn, dsk, flag, hops, nhip, pre) = pre\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. (\\<pi>\\<^sub>2 (dsn, dsk, flag, hops, nhip, pre) = dsn &&& \\<pi>\\<^sub>3 (dsn, dsk, flag, hops, nhip, pre) = dsk &&& \\<pi>\\<^sub>4 (dsn, dsk, flag, hops, nhip, pre) = flag) &&& \\<pi>\\<^sub>5 (dsn, dsk, flag, hops, nhip, pre) = hops &&& \\<pi>\\<^sub>6 (dsn, dsk, flag, hops, nhip, pre) = nhip &&& \\<pi>\\<^sub>7 (dsn, dsk, flag, hops, nhip, pre) = pre\n[PROOF STEP]\nby (clarsimp simp: proj2_def proj3_def proj4_def\n                     proj5_def proj6_def proj7_def)+"}
{"text": "module PatternSynonymNoParse where\n\npattern f x = a b\n"}
{"text": "lemma algebraic_int_of_real_iff [simp]: \"algebraic_int (of_real x :: 'a :: {field_char_0, real_algebra_1}) \\<longleftrightarrow> algebraic_int x\""}
{"text": "import data.list.basic\nopen list\nuniverse u\nvariables {\u03b1 : Type} (x y z : \u03b1) (xs ys zs : list \u03b1)\n\ndef mk_symm (xs : list \u03b1) := xs ++ reverse xs\n\ntheorem reverse_mk_symm (xs : list \u03b1) :\n  reverse (mk_symm xs) = mk_symm xs :=\n  by { unfold mk_symm, simp }\n"}
{"text": "[STATEMENT]\nlemma bl_of_nth_simps [simp, code]:\n  \"bl_of_nth 0 f = []\"\n  \"bl_of_nth (Suc n) f = f n # bl_of_nth n f\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. bl_of_nth 0 f = [] &&& bl_of_nth (Suc n) f = f n # bl_of_nth n f\n[PROOF STEP]\nby (simp_all add: bl_of_nth_def)"}
{"text": "lemma maze (P Q R S T U: Prop)\n(p : P)\n(h : P \u2192 Q)\n(i : Q \u2192 R)\n(j : Q \u2192 T)\n(k : S \u2192 T)\n(l : T \u2192 U)\n: U :=\nbegin\n    have q := h(p),\n    have t := j(q),\n    have u := l(t),\n    exact u,\nend"}
{"text": "--\nset_option autoBoundImplicitLocal false\nuniverse u\nvariable {\u03b1 : Type u}\nvariable {\u03b2 : \u03b1 \u2192 Type v}\n\ntheorem ex {p\u2081 p\u2082 : Sigma (fun a => \u03b2 a)} (h\u2081 : p\u2081.1 = p\u2082.1) (h : p\u2081.2 \u2245 p\u2082.2) : p\u2081 = p\u2082 :=\nmatch p\u2081, p\u2082, h\u2081, h with\n| \u27e8_, _\u27e9, \u27e8_, _\u27e9, rfl, HEq.refl _ => rfl\n"}
{"text": "[STATEMENT]\nlemma even_odd_mirror_path_injective [simp]:\n  \"even_mirror_path path = even_mirror_path path' \\<longleftrightarrow> path = path'\"\n  \"odd_mirror_path path = odd_mirror_path path' \\<longleftrightarrow> path = path'\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. (even_mirror_path path = even_mirror_path path') = (path = path') &&& (odd_mirror_path path = odd_mirror_path path') = (path = path')\n[PROOF STEP]\nby (induct path arbitrary: path') (case_tac path', simp_all split: dir.splits)+"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_51\n  (a b : \u211d)\n  (h\u2080 : 0 < a \u2227 0 < b)\n  (h\u2081 : a + b = 35)\n  (h\u2082 : a = (2/5) * b) :\n  b - a = 15 :=\nbegin\n  linarith,\nend"}
{"text": "(* *)\ntheory Dagstuhl\n  imports \"$HIPSTER_HOME/IsaHipster\"\nbegin    \n    \n(* Hard exercise  *)\nfun qrev :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere \n  \"qrev [] acc  = acc\"\n| \"qrev (x#xs) acc = qrev xs (x#acc)\"\n\nhipster rev qrev\nlemma lemma_a [thy_expl]: \"qrev (qrev z y) [] = qrev y z\"\n  apply (induct z arbitrary: y)\n  apply simp\n  apply simp\n  done\n    \nlemma lemma_aa [thy_expl]: \"rev y @ z = qrev y z\"\n  apply (induct y arbitrary: z)\napply simp\napply simp\napply (metis append_eq_append_conv2 rev.simps(2) rev_append rev_singleton_conv rev_swap)\ndone\n  \ntheorem hardExercise: \"rev xs = qrev xs []\"\n  sledgehammer\n  apply (induct xs)\n  apply auto  \n  sledgehammer\n  by (metis lemma_aa) \n\n    \nend"}
{"text": "universes u\n\naxiom elimEx (motive : Nat \u2192 Nat \u2192 Sort u) (x y : Nat)\n  (diag  : (a : Nat) \u2192 motive a a)\n  (upper : (delta a : Nat) \u2192 motive a (a + delta.succ))\n  (lower : (delta a : Nat) \u2192 motive (a + delta.succ) a)\n  : motive y x\n\ntheorem ex1 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p, q using elimEx with\n  | lower d => apply Or.inl -- Error\n  | upper d => apply Or.inr -- Error\n  | diag    => apply Or.inl; apply Nat.leRefl\n\ntheorem ex2 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p, q using elimEx2 with -- Error\n  | lower d => apply Or.inl\n  | upper d => apply Or.inr\n  | diag    => apply Or.inl; apply Nat.leRefl\n\ntheorem ex3 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p /- Error -/ using elimEx with\n  | lower d => apply Or.inl\n  | upper d => apply Or.inr\n  | diag    => apply Or.inl; apply Nat.leRefl\n\ntheorem ex4 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p using Nat.add with -- Error\n  | lower d => apply Or.inl\n  | upper d => apply Or.inr\n  | diag    => apply Or.inl; apply Nat.leRefl\n\ntheorem ex5 (x : Nat) : 0 + x = x := by\n  match x with\n  | 0   => done -- Error\n  | y+1 => done -- Error\n\ntheorem ex5b (x : Nat) : 0 + x = x := by\n  cases x with\n  | zero   => done -- Error\n  | succ y => done -- Error\n\ninductive Vec : Nat \u2192 Type\n  | nil  : Vec 0\n  | cons : Bool \u2192 {n : Nat} \u2192 Vec n \u2192 Vec (n+1)\n\ntheorem ex6 (x : Vec 0) : x = Vec.nil := by\n  cases x using Vec.casesOn with\n  | nil  => rfl\n  | cons => done -- Error\n\ntheorem ex7 (x : Vec 0) : x = Vec.nil := by\n  cases x with -- Error: TODO: improve error location\n  | nil  => rfl\n  | cons => done\n\ntheorem ex8 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p, q using elimEx with\n  | lower d => apply Or.inl; admit\n  | upper2 /- Error -/ d => apply Or.inr\n  | diag    => apply Or.inl; apply Nat.leRefl\n\ntheorem ex9 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p, q using elimEx with\n  | lower d => apply Or.inl; admit\n  | _ => apply Or.inr; admit\n  | diag    => apply Or.inl; apply Nat.leRefl\n\ntheorem ex10 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p, q using elimEx with\n  | lower d => apply Or.inl; admit\n  | upper d => apply Or.inr; admit\n  | diag    => apply Or.inl; apply Nat.leRefl\n  | _  /- error unused -/ => admit\n\ntheorem ex11 (p q : Nat) : p \u2264 q \u2228 p > q := by\n  cases p, q using elimEx with\n  | lower d => apply Or.inl; admit\n  | upper d => apply Or.inr; admit\n  | lower d /- error unused -/ => apply Or.inl; admit\n  | diag    => apply Or.inl; apply Nat.leRefl\n"}
{"text": "10\n* 15\n\n20\n- 10 # no error but unary minus here"}
{"text": "[STATEMENT]\nlemma strip_guards_whileAnno [simp]:\n \"strip_guards F (whileAnno b I V c) = whileAnno b I V (strip_guards F c)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. strip_guards F (whileAnno b I V c) = whileAnno b I V (strip_guards F c)\n[PROOF STEP]\nby (simp add: whileAnno_def  while_def)"}
{"text": "[STATEMENT]\nlemma word_add_def [code]:\n  \"a + b = word_of_int (uint a + uint b)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. a + b = word_of_int (uint a + uint b)\n[PROOF STEP]\nby transfer (simp add: take_bit_add)"}
{"text": "import Scripts.set_theory\n--===================--\n------ TOPOLOG\u00cdA ------\n--===================--\n\n-- Un espacio topol\u00f3gico sobre un tipo \u03b1 viene dado por un predicado 'is_open' sobre los conjuntos de\n-- elementos de \u03b1 junto con las pruebas de que ese predicado cumple los axiomas de la topolog\u00eda\nstructure topological_space (\u03b1 : Type u) where\n  is_open : Set \u03b1 \u2192 Prop\n  is_open_univ : is_open univ\n  is_open_inter : \u2200 (s t : Set \u03b1), is_open s \u2192 is_open t \u2192 is_open (s \u2229 t) \n  is_open_union : \u2200 (F : Set (Set \u03b1)), (\u2200 s, s \u2208 F \u2192 is_open s) \u2192 is_open (\u22c3\u2080 F)\n\n\n--Dos espacios tienen la misma topolog\u00eda si tienen los mismos abiertos\ntheorem topological_space_eq : \u2200 T T' : topological_space \u03b1, T.is_open = T'.is_open \u2192 T = T' :=\nfun \u27e8p, _, _, _\u27e9 \u27e8p', _, _, _\u27e9 h => by simp [h]\n\ntheorem topological_space_eq_iff (T : topological_space \u03b1) (T' : topological_space \u03b1) : \n  (\u2200 s, T.is_open s \u2194 T'.is_open s) \u2194 T = T' := \n    \u27e8fun h => topological_space_eq T T' (setext @h),\n     fun h _ => h \u25b8 Iff.rfl\u27e9\n\n-- Por comodidad\nattribute [class] topological_space\ndef is_open [T : topological_space \u03b1] : Set \u03b1 \u2192 Prop := T.is_open\n\n-- El vac\u00edo siempre es un abierto\ntheorem is_open_empty {\u03b1 : Type u} [T : topological_space \u03b1] : is_open (\u2205 : Set \u03b1) :=\n  have h : is_open (\u22c3\u2080 (\u2205 : Set (Set \u03b1))) := \n     T.is_open_union \u2205 (fun _ => fun h => h.elim)\n  unionF_empty \u25b8 h\n\n-- Un conjunto es cerrado si su complementario es abierto\ndef is_closed [topological_space \u03b1] (s : Set \u03b1) : Prop := is_open (-s)\n\n-- Una topolog\u00eda tambi\u00e9n puede definirse dando los cerrados\ndef topological_space_of_is_closed (is_closed : Set \u03b1 \u2192 Prop) (is_closed_empty : is_closed empty)\n  (is_closed_union : \u2200 (s t : Set \u03b1), is_closed s \u2192 is_closed t \u2192 is_closed (s \u222a t))\n  (is_closed_inter : \u2200 (F : Set (Set \u03b1)), (\u2200 s, s \u2208 F \u2192 is_closed s) \u2192 is_closed (\u22c2\u2080 F)) : \n  topological_space \u03b1 := \n  {\n    is_open := fun s => is_closed (-s),\n    is_open_univ := show is_closed (-univ) from eq_compl_univ \u25b8 is_closed_empty,\n    is_open_inter := fun s t hs ht =>\n        show is_closed (-(s \u2229 t)) from compl_inter_eq_union_compl \u25b8 (is_closed_union (-s) (-t) hs ht),\n    is_open_union := fun F h_open =>\n      have h_closed_cF : \u2200 s, s \u2208 complF F \u2192 is_closed s :=\n        fun s (h_cF_s : complF F s ) =>\n          have h_ccs : is_closed (-(-s)) := h_open (-s) h_cF_s\n          @compl_compl_eq \u03b1 s \u25b8 h_ccs\n      show is_closed (-(\u22c3\u2080 F)) from compl_unionF \u25b8 (is_closed_inter (complF F) h_closed_cF)\n  }"}
{"text": "constants (p q : Prop) (Hnq : \u00acq) (Hpq : p \u2192 q)\ntheorem t (Hp : p): false :=  Hnq (Hpq Hp)\ncheck t                  -- t : p \u2192 false\n"}
{"text": "theorem ex (h : a = 0) (p : Nat \u2192 Prop) : p a \u2192 p 0 := by\n  simp_all\n"}
{"text": "\ndata Id (A : Set) : Set where\n  wrap : A \u2192 Id A\n\ndata Maybe (A : Set) : Set where\n  nothing : Maybe A\n  just    : A \u2192 Maybe A\n\nmaybe : {A : Set} {B : Maybe A \u2192 Set} \u2192\n        ((x : A) \u2192 B (just x)) \u2192 B nothing \u2192 (x : Maybe A) \u2192 B x\nmaybe j n (just x) = j x\nmaybe j n nothing  = n\n\nrecord MaybeT (M : Set \u2192 Set) (A : Set) : Set where\n  constructor wrap\n  field\n    run : M (Maybe A)\n\nopen MaybeT public\n\npostulate\n  R : Set\n  r : R\n\nmodule M (_ : R) where\n\n  record Monad (M : Set \u2192 Set) : Set\u2081 where\n    field\n      return : \u2200 {A} \u2192 A \u2192 M A\n      _>>=_  : \u2200 {A B} \u2192 M A \u2192 (A \u2192 M B) \u2192 M B\n\n  open Monad \u2983 \u2026 \u2984 public\n\n  instance\n\n    transform : {M : Set \u2192 Set} \u2983 is-raw-monad : Monad M \u2984 \u2192\n                Monad (MaybeT M)\n    run (Monad.return transform x)   = return (just x)\n    run (Monad._>>=_  transform x f) =\n      run x >>= maybe (\u03bb x \u2192 run (f x)) (return nothing)\n\nopen M r\n\ninstance\n\n  id-raw-monad : Monad Id\n  Monad.return id-raw-monad            = wrap\n  Monad._>>=_  id-raw-monad (wrap x) f = f x\n\npostulate\n  _\u223c_      : {A : Set} \u2192 Id A \u2192 Id A \u2192 Set\n  refl     : {A : Set} (x : Id A) \u2192 x \u223c x\n  trans    : {A : Set} {x y z : Id A} \u2192 x \u223c y \u2192 y \u223c z \u2192 x \u223c z\n  id       : {A : Set} {x : Id A} (y : Id A) \u2192 x \u223c y \u2192 x \u223c y\n  >>=-cong : {A : Set} (x : Id A) {f g : A \u2192 Id A} \u2192\n             (\u2200 z \u2192 f z \u223c g z) \u2192 (x >>= f) \u223c (x >>= g)\n  assoc    : {A : Set} (x : Id A) (f : A \u2192 Id A) (g : A \u2192 Id A) \u2192\n             (x >>= (\u03bb x \u2192 f x >>= g)) \u223c ((x >>= f) >>= g)\n\nfails :\n  {A : Set}\n  (x : MaybeT Id A) (f : A \u2192 MaybeT Id A) (g : A \u2192 MaybeT Id A) \u2192\n  run (x >>= \u03bb x \u2192 f x >>= g) \u223c run ((x >>= f) >>= g)\nfails x f g =\n  trans (>>=-cong (run x) (maybe (\u03bb _ \u2192 refl _) (refl _)))\n        (id (run ((x >>= f) >>= g))\n            (assoc (run x) _ _))\n"}
{"text": "import data.list.basic \nopen list \nlemma foldr_ext {\u03b1 : Type*} {\u03b2 : Type*} {l : list \u03b1} (f f' : \u03b1 \u2192 \u03b2 \u2192 \u03b2) (s : \u03b2)\n  (H : \u2200 a \u2208 l, \u2200 b : \u03b2, f a b = f' a b) : foldr f s l = foldr f' s l :=\nbegin induction l with h l IH, {simp}, -- base case}\n  simp *,\n  suffices : foldr f s l = foldr f' s l,\n    rw this,\n  apply IH,\n  intros a Ha,\n  apply H,\n  -- simp still no work\n  simp * {contextual := tt} -- this work\n\nend\n\nlemma got_it (P Q R S : Prop) (IH : (P \u2192 R) \u2192 S) (H0 : P \u2192 Q) (H' : Q \u2192 R) : S := \nbegin\n--simp *, -- fails\nsimp * {contextual := tt},\nend \n"}
{"text": "import \n  tactic.induction\n  tactic.linarith\n  ...compiler\n  ...semantics\n\nopen vm_big_step env_big_step\n\n-- convert from environment-preserving to regular big_step\nlemma env_vm_big_step {env env' P S R} :\n    (env, P, S) \u27f9\u2099\u1d65 (env', R)\n  \u2192 (env, P, S) \u27f9\u1d65\u2098 R :=\nbegin\n  assume hnv,\n  induction' hnv,\n  case ERunEmpty {\n    apply RunEmpty\n  },\n  case ERunPush {\n    apply RunPush,\n    exact ih\n  },\n  case ERunOpInstr {\n    apply RunOpInstr,\n    exact ih\n  },\n  case ERunTBranch {\n    apply RunTBranch,\n    exact ih\n  },\n  case ERunFBranch {\n    apply RunFBranch,\n    { exact _x },\n    { exact ih }\n  },\n  case ERunJump {\n    apply RunJump,\n    { exact _x },\n    { exact ih }\n  },\n  case ERunLookup {\n    apply RunLookup,\n    { exact _x },\n    { exact ih }\n  },\n  case ERunOpenScope {\n    apply RunOpenScope,\n    exact ih\n  },\n  case ERunCloseScope {\n    apply RunCloseScope,\n    exact ih\n  }\nend\n\ntheorem from_interm_results\n  {E\u2081 E\u2082 E\u1d62 P\u2081 P\u2082 S S' I R} :\n    (E\u2081, P\u2081, S) \u27f9\u2099\u1d65 (E\u1d62, I)\n  \u2192 (E\u1d62, P\u2082, I ++ S') \u27f9\u2099\u1d65 (E\u2082, R)\n  \u2192 (E\u2081, P\u2081 ++ P\u2082, S ++ S') \u27f9\u2099\u1d65 (E\u2082, R) :=\nbegin\n  assume h1 h2,\n  induction' h1,\n  { exact h2 },\n  { apply ERunPush,\n    rw \u2190list.cons_append,\n    apply ih h2 },\n  case ERunOpInstr {\n    rw list.cons_append,\n    apply ERunOpInstr,\n    apply ih h2\n  },\n  case ERunTBranch {\n    rw list.cons_append,\n    apply ERunTBranch,\n    apply ih h2\n  },\n  case ERunFBranch {\n    rw list.cons_append,\n    apply ERunFBranch,\n    { rw [at_least, list.length_append], \n      rw [at_least] at _x,\n      linarith },\n    rw [list.drop_append_of_le_length],\n    apply ih h2,\n    exact _x\n  },\n  case ERunJump {\n    rw list.cons_append,\n    apply ERunJump,\n    { rw [at_least, list.length_append], \n      rw [at_least] at _x,\n      linarith },\n    rw [list.drop_append_of_le_length],\n    apply ih h2,\n    exact _x\n  },\n  case ERunLookup {\n    apply ERunLookup _x,\n    rw \u2190list.cons_append,\n    apply ih h2\n  },\n  case ERunOpenScope {\n    rw list.cons_append,\n    apply ERunOpenScope,\n    apply ih h2\n  },\n  case ERunCloseScope {\n    rw list.cons_append,\n    apply ERunCloseScope,\n    apply ih h2\n  }\nend\n\nlemma from_interm_results'\n  {E\u2081 E\u2082 E\u1d62 P\u2081 P\u2082 S I R} :\n    (E\u2081, P\u2081, S) \u27f9\u2099\u1d65 (E\u1d62, I)\n  \u2192 (E\u1d62, P\u2082, I) \u27f9\u2099\u1d65 (E\u2082, R)\n  \u2192 (E\u2081, P\u2081 ++ P\u2082, S) \u27f9\u2099\u1d65 (E\u2082, R) :=\nbegin\n  assume h1 h2,\n  rw \u2190list.append_nil I at h2,\n  rw \u2190list.append_nil S,\n  exact from_interm_results h1 h2\nend\n\ntheorem to_interm_results {E\u2081 E\u2082 e P S S' r} :\n  (E\u2081, compile e ++ P, S) \u27f9\u2099\u1d65 (E\u2082, r :: S')\n  \u2192 \u2203 v, (E\u2081, compile e, S) \u27f9\u2099\u1d65 (E\u2081, v :: S) \u2227 \n         (E\u2081, P, v :: S) \u27f9\u2099\u1d65 (E\u2082, r :: S') :=\nbegin\n  assume hnv,\n  induction' e,\n  case EVal {\n    rw compile at hnv \u22a2,\n    cases' hnv,\n    use v,\n    apply and.intro,\n    { apply ERunPush,\n      exact ERunEmpty },\n    { exact hnv }\n  },\n  case EOp {\n    rw compile at hnv \u22a2,\n    simp at hnv \u22a2,\n    cases' ih_e_1 hnv,\n    cases' h with he_1 h,\n    cases' ih_e h with u h',\n    cases' h' with he h',\n    cases' h',\n    use eval n m op,\n    apply and.intro,\n    { apply from_interm_results' he_1,\n      apply from_interm_results' he,\n      apply ERunOpInstr,\n      exact ERunEmpty },\n    { exact h' }\n  },\n  case EIf {\n    rw compile at hnv \u22a2,\n    simp at hnv \u22a2,\n    cases' ih_e hnv, clear hnv,\n    cases' h with he h,\n    cases' h,\n    case ERunTBranch {\n      cases' ih_e_1 h with w h',\n      cases' h' with he_1 h',\n      cases' h',\n      rw [list.drop_append_of_le_length,\n          list.drop_length,\n          list.nil_append] at h',\n      use w,\n      apply and.intro,\n      { apply from_interm_results' he,\n        apply ERunTBranch,\n        apply from_interm_results' he_1,\n        apply ERunJump,\n        exact at_least_refl,\n        rw list.drop_length,\n        exact ERunEmpty },\n      { exact h' },\n      refl\n    },\n    case ERunFBranch {\n      rw [nat.add_comm, \n          list.drop_add, \n          list.drop_one,\n          list.drop_append_of_le_length,\n          list.drop_length,\n          list.nil_append,\n          list.tail] at h,\n      cases' ih_e_2 h with w h',\n      cases' h' with he_2 h',\n      use w,\n      apply and.intro,\n      { apply from_interm_results' he,\n        apply ERunFBranch,\n        { rw [at_least, \n              list.length_append, \n              list.length_cons], \n          linarith },\n        rw [nat.add_comm, \n            list.drop_add, \n            list.drop_one,\n            list.drop_append_of_le_length,\n            list.drop_length,\n            list.nil_append,\n            list.tail],\n        exact he_2,\n        refl },\n      { exact h' },\n      refl\n    }\n  },\n  case EVar {\n    rw compile at hnv \u22a2,\n    cases' hnv,\n    use v,\n    apply and.intro,\n    { apply ERunLookup _x,\n      exact ERunEmpty },\n    { exact hnv }\n  },\n  case ELet {\n    rw compile at hnv \u22a2,\n    simp at hnv \u22a2,\n    cases' ih_e hnv,\n    cases' h with he h,\n    cases' h,\n    cases' ih_e_1 h with u h',\n    cases' h' with he_1 h',\n    cases' h',\n    use u,\n    apply and.intro,\n    { apply from_interm_results' he,\n      apply ERunOpenScope,\n      apply from_interm_results' he_1,\n      apply ERunCloseScope,\n      exact ERunEmpty },\n    { exact h' }\n  }\nend"}
{"text": "import Smt\n\ntheorem comm (f : Bool \u2192 Bool \u2192 Bool) (p q : Bool) : f p q == f q p := by\n  smt\n  admit\n"}
{"text": "(** Instance of identity on propositions *)\n\nTheorem not_False : ~ False.\nProof.  unfold not; trivial.  Qed.\n\nDefinition  not_False' : ~ False :=\n fun H => H.\n\nTheorem triple_neg : forall P:Prop, ~ ~ ~ P -> ~ P.\nProof.  auto. Qed.\n\nTheorem P3PQ : forall P Q:Prop, ~ ~ ~ P -> P -> Q.\nProof. tauto. Qed.\n\n(** instance of the transivity of -> \n*)\nTheorem contrap : forall P Q:Prop, (P -> Q) -> ~ Q -> ~ P.\nProof. auto. Qed.\n\nTheorem imp_absurd : forall P Q R:Prop, (P -> Q) -> (P -> ~ Q) -> P -> R.\nProof.  tauto. Qed.\n\n"}
{"text": "lemma coeffs_reflect_poly [code abstract]: \"coeffs (reflect_poly p) = rev (dropWhile ((=) 0) (coeffs p))\""}
{"text": "(** Some Neo-davidsonian Semantics*)\nRequire Import Bvector.\nRequire Import Coq.Lists.List.\nRequire Import Omega.\nLoad LibTactics.\nLtac AUTO:= cbv delta;intuition;try repeat congruence;  jauto;intuition.\nParameter Event Ind LOcation Instrument:Set.\nParameter Agent\n          Theme: Ind->Event->Prop.\nParameter Caesar Brutus:Ind.\nParameter IN: LOcation->Event->Prop.\nParameter WITH: Instrument->Event->Prop.  Definition In:= fun\nx:LOcation=>fun E: Event->Prop=> fun e1:Event=> exists e:Event, E e1/\\\nIN x e1.  Definition With:= fun x:Instrument=>fun E: Event->Prop=> fun\n                                                  e1:Event=> exists e:Event, E e1/\\ WITH x e1.\nParameter stab: Ind->Ind->Event->Prop.\nParameter e1:Event. \nDefinition stabs:= fun\nx:Ind=> fun y:Ind=>fun e1:Event=> exists e:Event, stab x y e /\\\nTheme(x)(e)/\\Agent(y)(e)/\\ e=e1.  Parameter a_knife: Instrument.\nParameter Rome Verona Athens: LOcation.  Theorem BRUTUS: (stabs Caesar\nBrutus e1)-> Agent(Brutus)(e1). (**AUTO automates the proof*)  cbv. intro.  destruct H. destruct\nH. destruct H0. destruct H1. firstorder. congruence. Qed.  Theorem\nBRUTUS1:(In Rome) ((With a_knife) (stabs Caesar Brutus)) e1-> WITH\na_knife e1. AUTO. Qed.  Theorem BRUTUS2:(In Rome) ((With a_knife)\n(stabs Caesar Brutus)) e1-> ((With a_knife) (stabs Caesar Brutus))\n                              e1. AUTO. Qed.\nTheorem BRUTUS3:(In Rome) ((With a_knife) (stabs\n                                             Caesar Brutus)) e1-> ((In Rome) (stabs Caesar Brutus)) e1. AUTO. Qed.\n\nTheorem BRUTUS4:(In Rome) ((With a_knife) (stabs Caesar Brutus)) e1->\n((stabs Caesar Brutus)) e1. AUTO. Qed.\n\n\n\n"}
{"text": "/-example : 1 + 2222 = 2223 :=\nbegin\n  reflexivity\nend\n\ntheorem foo : 1 + (2222222222222 : nat)  = 2222222222223 :=\nbegin\n  reflexivity\nend\n-/\n\ntheorem bar : 100003 + 100003 = 200006 :=\nrfl\n\n\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_234\n  (d : \u211d)\n  (h\u2080 : 27 / 125 * d = 9 / 25) :\n  3 / 5 * d^3 = 25 / 9 :=\nbegin\n  field_simp,\n  rw [mul_right_comm, pow_succ, mul_comm],\n  { nlinarith },\nend"}
{"text": "--\nset_option autoBoundImplicitLocal false\nuniverses u\nvariable {\u03b1 : Type u}\nvariable {\u03b2 : \u03b1 \u2192 Type v}\n\ntheorem ex {p\u2081 p\u2082 : Sigma (fun a => \u03b2 a)} (h\u2081 : p\u2081.1 = p\u2082.1) (h : p\u2081.2 \u2245 p\u2082.2) : p\u2081 = p\u2082 :=\nmatch p\u2081, p\u2082, h\u2081, h with\n| \u27e8_, _\u27e9, \u27e8_, _\u27e9, rfl, HEq.refl _ => rfl\n"}
{"text": "lemma (in algebra) sets_Collect_finite_All: assumes \"\\<And>i. i \\<in> S \\<Longrightarrow> {x\\<in>\\<Omega>. P i x} \\<in> M\" \"finite S\" shows \"{x\\<in>\\<Omega>. \\<forall>i\\<in>S. P i x} \\<in> M\""}
{"text": "informal statement Prove that a subgroup $H$ of $G$ is normal if and only if $[G, H] \\leq H$.formal statement theorem exercise_7_1_11 {R : Type*} [ring R] [is_domain R] \n  {x : R} (hx : x^2 = 1) : x = 1 \u2228 x = -1 :="}
{"text": "import data.complex.basic\nimport number_theory.divisors\n\ntheorem AMC_2021_A_25 (N:\u2115)(f:\u2115 \u2192 \u211d)(h:\u2200(n:\u2115), f n = (finset.card (nat.divisors n))/(n^(1/3)))(hN:\u2200(n:\u2115),n\u2260N \u2192 (f N > f n)):\nN=2520\n:=\nbegin\n  sorry\nend"}
{"text": "/-\nCopyright (c) 2020 Aaron Anderson. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Aaron Anderson\n-/\nimport ring_theory.int.basic\nimport data.nat.factorization.prime_pow\nimport algebra.squarefree\n\n/-!\n# Lemmas about squarefreeness of natural numbers\nA number is squarefree when it is not divisible by any squares except the squares of units.\n\n## Main Results\n - `nat.squarefree_iff_nodup_factors`: A positive natural number `x` is squarefree iff\n  the list `factors x` has no duplicate factors.\n\n## Tags\nsquarefree, multiplicity\n\n-/\n\nnamespace nat\n\nlemma squarefree_iff_nodup_factors {n : \u2115} (h0 : n \u2260 0) :\n  squarefree n \u2194 n.factors.nodup :=\nbegin\n  rw [unique_factorization_monoid.squarefree_iff_nodup_normalized_factors h0, nat.factors_eq],\n  simp,\nend\n\ntheorem squarefree_iff_prime_squarefree {n : \u2115} : squarefree n \u2194 \u2200 x, prime x \u2192 \u00ac x * x \u2223 n :=\nsquarefree_iff_irreducible_sq_not_dvd_of_exists_irreducible \u27e8_, prime_two\u27e9\n\nlemma squarefree.factorization_le_one {n : \u2115} (p : \u2115) (hn : squarefree n) :\n  n.factorization p \u2264 1 :=\nbegin\n  rcases eq_or_ne n 0 with rfl | hn',\n  { simp },\n  rw [multiplicity.squarefree_iff_multiplicity_le_one] at hn,\n  by_cases hp : p.prime,\n  { have := hn p,\n    simp only [multiplicity_eq_factorization hp hn', nat.is_unit_iff, hp.ne_one, or_false] at this,\n    exact_mod_cast this },\n  { rw factorization_eq_zero_of_non_prime _ hp,\n    exact zero_le_one }\nend\n\nlemma squarefree_of_factorization_le_one {n : \u2115} (hn : n \u2260 0) (hn' : \u2200 p, n.factorization p \u2264 1) :\n  squarefree n :=\nbegin\n  rw [squarefree_iff_nodup_factors hn, list.nodup_iff_count_le_one],\n  intro a,\n  rw factors_count_eq,\n  apply hn',\nend\n\nlemma squarefree_iff_factorization_le_one {n : \u2115} (hn : n \u2260 0) :\n  squarefree n \u2194 \u2200 p, n.factorization p \u2264 1 :=\n\u27e8\u03bb p hn, squarefree.factorization_le_one hn p, squarefree_of_factorization_le_one hn\u27e9\n\nlemma squarefree.ext_iff {n m : \u2115} (hn : squarefree n) (hm : squarefree m) :\n  n = m \u2194 \u2200 p, prime p \u2192 (p \u2223 n \u2194 p \u2223 m) :=\nbegin\n  refine \u27e8by { rintro rfl, simp }, \u03bb h, eq_of_factorization_eq hn.ne_zero hm.ne_zero (\u03bb p, _)\u27e9,\n  by_cases hp : p.prime,\n  { have h\u2081 := h _ hp,\n    rw [\u2190not_iff_not, hp.dvd_iff_one_le_factorization hn.ne_zero, not_le, lt_one_iff,\n      hp.dvd_iff_one_le_factorization hm.ne_zero, not_le, lt_one_iff] at h\u2081,\n    have h\u2082 := squarefree.factorization_le_one p hn,\n    have h\u2083 := squarefree.factorization_le_one p hm,\n    rw [nat.le_add_one_iff, le_zero_iff] at h\u2082 h\u2083,\n    cases h\u2082,\n    { rwa [h\u2082, eq_comm, \u2190h\u2081] },\n    { rw [h\u2082, h\u2083.resolve_left],\n      rw [\u2190h\u2081, h\u2082],\n      simp only [nat.one_ne_zero, not_false_iff] } },\n  rw [factorization_eq_zero_of_non_prime _ hp, factorization_eq_zero_of_non_prime _ hp],\nend\n\nlemma squarefree_pow_iff {n k : \u2115} (hn : n \u2260 1) (hk : k \u2260 0) :\n  squarefree (n ^ k) \u2194 squarefree n \u2227 k = 1 :=\nbegin\n  refine \u27e8\u03bb h, _, by { rintro \u27e8hn, rfl\u27e9, simpa }\u27e9,\n  rcases eq_or_ne n 0 with rfl | hn\u2080,\n  { simpa [zero_pow hk.bot_lt] using h },\n  refine \u27e8squarefree_of_dvd_of_squarefree (dvd_pow_self _ hk) h, by_contradiction $ \u03bb h\u2081, _\u27e9,\n  have : 2 \u2264 k := k.two_le_iff.mpr \u27e8hk, h\u2081\u27e9,\n  apply hn (nat.is_unit_iff.1 (h _ _)),\n  rw \u2190sq,\n  exact pow_dvd_pow _ this\nend\n\nlemma squarefree_and_prime_pow_iff_prime {n : \u2115} :\n  squarefree n \u2227 is_prime_pow n \u2194 prime n :=\nbegin\n  refine iff.symm \u27e8\u03bb hn, \u27e8hn.squarefree, hn.is_prime_pow\u27e9, _\u27e9,\n  rw is_prime_pow_nat_iff,\n  rintro \u27e8h, p, k, hp, hk, rfl\u27e9,\n  rw squarefree_pow_iff hp.ne_one hk.ne' at h,\n  rwa [h.2, pow_one],\nend\n\n/-- Assuming that `n` has no factors less than `k`, returns the smallest prime `p` such that\n  `p^2 \u2223 n`. -/\ndef min_sq_fac_aux : \u2115 \u2192 \u2115 \u2192 option \u2115\n| n k :=\n  if h : n < k * k then none else\n  have nat.sqrt n + 2 - (k + 2) < nat.sqrt n + 2 - k,\n    by { rw nat.add_sub_add_right, exact nat.min_fac_lemma n k h },\n  if k \u2223 n then\n    let n' := n / k in\n    have nat.sqrt n' + 2 - (k + 2) < nat.sqrt n + 2 - k, from\n      lt_of_le_of_lt (nat.sub_le_sub_right\n        (nat.add_le_add_right (nat.sqrt_le_sqrt $ nat.div_le_self _ _) _) _) this,\n    if k \u2223 n' then some k else min_sq_fac_aux n' (k + 2)\n  else min_sq_fac_aux n (k + 2)\nusing_well_founded {rel_tac :=\n  \u03bb _ _, `[exact \u27e8_, measure_wf (\u03bb \u27e8n, k\u27e9, nat.sqrt n + 2 - k)\u27e9]}\n\n/-- Returns the smallest prime factor `p` of `n` such that `p^2 \u2223 n`, or `none` if there is no\n  such `p` (that is, `n` is squarefree). See also `squarefree_iff_min_sq_fac`. -/\ndef min_sq_fac (n : \u2115) : option \u2115 :=\nif 2 \u2223 n then\n  let n' := n / 2 in\n  if 2 \u2223 n' then some 2 else min_sq_fac_aux n' 3\nelse min_sq_fac_aux n 3\n\n/-- The correctness property of the return value of `min_sq_fac`.\n  * If `none`, then `n` is squarefree;\n  * If `some d`, then `d` is a minimal square factor of `n` -/\ndef min_sq_fac_prop (n : \u2115) : option \u2115 \u2192 Prop\n| none := squarefree n\n| (some d) := prime d \u2227 d * d \u2223 n \u2227 \u2200 p, prime p \u2192 p * p \u2223 n \u2192 d \u2264 p\n\ntheorem min_sq_fac_prop_div (n) {k} (pk : prime k) (dk : k \u2223 n) (dkk : \u00ac k * k \u2223 n)\n  {o} (H : min_sq_fac_prop (n / k) o) : min_sq_fac_prop n o :=\nbegin\n  have : \u2200 p, prime p \u2192 p*p \u2223 n \u2192 k*(p*p) \u2223 n := \u03bb p pp dp,\n    have _ := (coprime_primes pk pp).2 (\u03bb e, by { subst e, contradiction }),\n    (coprime_mul_iff_right.2 \u27e8this, this\u27e9).mul_dvd_of_dvd_of_dvd dk dp,\n  cases o with d,\n  { rw [min_sq_fac_prop, squarefree_iff_prime_squarefree] at H \u22a2,\n    exact \u03bb p pp dp, H p pp ((dvd_div_iff dk).2 (this _ pp dp)) },\n  { obtain \u27e8H1, H2, H3\u27e9 := H,\n    simp only [dvd_div_iff dk] at H2 H3,\n    exact \u27e8H1, dvd_trans (dvd_mul_left _ _) H2, \u03bb p pp dp, H3 _ pp (this _ pp dp)\u27e9 }\nend\n\ntheorem min_sq_fac_aux_has_prop : \u2200 {n : \u2115} k, 0 < n \u2192 \u2200 i, k = 2*i+3 \u2192\n  (\u2200 m, prime m \u2192 m \u2223 n \u2192 k \u2264 m) \u2192 min_sq_fac_prop n (min_sq_fac_aux n k)\n| n k := \u03bb n0 i e ih, begin\n  rw min_sq_fac_aux,\n  by_cases h : n < k*k; simp [h],\n  { refine squarefree_iff_prime_squarefree.2 (\u03bb p pp d, _),\n    have := ih p pp (dvd_trans \u27e8_, rfl\u27e9 d),\n    have := nat.mul_le_mul this this,\n    exact not_le_of_lt h (le_trans this (le_of_dvd n0 d)) },\n  have k2 : 2 \u2264 k, { subst e, exact dec_trivial },\n  have k0 : 0 < k := lt_of_lt_of_le dec_trivial k2,\n  have IH : \u2200 n', n' \u2223 n \u2192 \u00ac k \u2223 n' \u2192 min_sq_fac_prop n' (n'.min_sq_fac_aux (k + 2)),\n  { intros n' nd' nk,\n    have hn' := le_of_dvd n0 nd',\n    refine\n      have nat.sqrt n' - k < nat.sqrt n + 2 - k, from\n        lt_of_le_of_lt (nat.sub_le_sub_right (nat.sqrt_le_sqrt hn') _) (nat.min_fac_lemma n k h),\n      @min_sq_fac_aux_has_prop n' (k+2) (pos_of_dvd_of_pos nd' n0)\n        (i+1) (by simp [e, left_distrib]) (\u03bb m m2 d, _),\n    cases nat.eq_or_lt_of_le (ih m m2 (dvd_trans d nd')) with me ml,\n    { subst me, contradiction },\n    apply (nat.eq_or_lt_of_le ml).resolve_left, intro me,\n    rw [\u2190 me, e] at d, change 2 * (i + 2) \u2223 n' at d,\n    have := ih _ prime_two (dvd_trans (dvd_of_mul_right_dvd d) nd'),\n    rw e at this, exact absurd this dec_trivial },\n  have pk : k \u2223 n \u2192 prime k,\n  { refine \u03bb dk, prime_def_min_fac.2 \u27e8k2, le_antisymm (min_fac_le k0) _\u27e9,\n    exact ih _ (min_fac_prime (ne_of_gt k2)) (dvd_trans (min_fac_dvd _) dk) },\n  split_ifs with dk dkk,\n  { exact \u27e8pk dk, (nat.dvd_div_iff dk).1 dkk, \u03bb p pp d, ih p pp (dvd_trans \u27e8_, rfl\u27e9 d)\u27e9 },\n  { specialize IH (n/k) (div_dvd_of_dvd dk) dkk,\n    exact min_sq_fac_prop_div _ (pk dk) dk (mt (nat.dvd_div_iff dk).2 dkk) IH },\n  { exact IH n (dvd_refl _) dk }\nend\nusing_well_founded {rel_tac :=\n  \u03bb _ _, `[exact \u27e8_, measure_wf (\u03bb \u27e8n, k\u27e9, nat.sqrt n + 2 - k)\u27e9]}\n\ntheorem min_sq_fac_has_prop (n : \u2115) : min_sq_fac_prop n (min_sq_fac n) :=\nbegin\n  dunfold min_sq_fac, split_ifs with d2 d4,\n  { exact \u27e8prime_two, (dvd_div_iff d2).1 d4, \u03bb p pp _, pp.two_le\u27e9 },\n  { cases nat.eq_zero_or_pos n with n0 n0, { subst n0, cases d4 dec_trivial },\n    refine min_sq_fac_prop_div _ prime_two d2 (mt (dvd_div_iff d2).2 d4) _,\n    refine min_sq_fac_aux_has_prop 3 (nat.div_pos (le_of_dvd n0 d2) dec_trivial) 0 rfl _,\n    refine \u03bb p pp dp, succ_le_of_lt (lt_of_le_of_ne pp.two_le _),\n    rintro rfl, contradiction },\n  { cases nat.eq_zero_or_pos n with n0 n0, { subst n0, cases d2 dec_trivial },\n    refine min_sq_fac_aux_has_prop _ n0 0 rfl _,\n    refine \u03bb p pp dp, succ_le_of_lt (lt_of_le_of_ne pp.two_le _),\n    rintro rfl, contradiction },\nend\n\ntheorem min_sq_fac_prime {n d : \u2115} (h : n.min_sq_fac = some d) : prime d :=\nby { have := min_sq_fac_has_prop n, rw h at this, exact this.1 }\n\ntheorem min_sq_fac_dvd {n d : \u2115} (h : n.min_sq_fac = some d) : d * d \u2223 n :=\nby { have := min_sq_fac_has_prop n, rw h at this, exact this.2.1 }\n\ntheorem min_sq_fac_le_of_dvd {n d : \u2115} (h : n.min_sq_fac = some d)\n  {m} (m2 : 2 \u2264 m) (md : m * m \u2223 n) : d \u2264 m :=\nbegin\n  have := min_sq_fac_has_prop n, rw h at this,\n  have fd := min_fac_dvd m,\n  exact le_trans\n    (this.2.2 _ (min_fac_prime $ ne_of_gt m2) (dvd_trans (mul_dvd_mul fd fd) md))\n    (min_fac_le $ lt_of_lt_of_le dec_trivial m2),\nend\n\nlemma squarefree_iff_min_sq_fac {n : \u2115} :\n  squarefree n \u2194 n.min_sq_fac = none :=\nbegin\n  have := min_sq_fac_has_prop n,\n  split; intro H,\n  { cases n.min_sq_fac with d, {refl},\n    cases squarefree_iff_prime_squarefree.1 H _ this.1 this.2.1 },\n  { rwa H at this }\nend\n\ninstance : decidable_pred (squarefree : \u2115 \u2192 Prop) :=\n\u03bb n, decidable_of_iff' _ squarefree_iff_min_sq_fac\n\ntheorem squarefree_two : squarefree 2 := by rw squarefree_iff_nodup_factors; norm_num\n\nopen unique_factorization_monoid\n\nlemma divisors_filter_squarefree {n : \u2115} (h0 : n \u2260 0) :\n  (n.divisors.filter squarefree).val =\n    (unique_factorization_monoid.normalized_factors n).to_finset.powerset.val.map\n      (\u03bb x, x.val.prod) :=\nbegin\n  rw (finset.nodup _).ext ((finset.nodup _).map_on _),\n  { intro a,\n    simp only [multiset.mem_filter, id.def, multiset.mem_map, finset.filter_val, \u2190 finset.mem_def,\n      mem_divisors],\n    split,\n    { rintro \u27e8\u27e8an, h0\u27e9, hsq\u27e9,\n      use (unique_factorization_monoid.normalized_factors a).to_finset,\n      simp only [id.def, finset.mem_powerset],\n      rcases an with \u27e8b, rfl\u27e9,\n      rw mul_ne_zero_iff at h0,\n      rw unique_factorization_monoid.squarefree_iff_nodup_normalized_factors h0.1 at hsq,\n      rw [multiset.to_finset_subset, multiset.to_finset_val, hsq.dedup, \u2190 associated_iff_eq,\n        normalized_factors_mul h0.1 h0.2],\n      exact \u27e8multiset.subset_of_le (multiset.le_add_right _ _), normalized_factors_prod h0.1\u27e9 },\n    { rintro \u27e8s, hs, rfl\u27e9,\n      rw [finset.mem_powerset, \u2190 finset.val_le_iff, multiset.to_finset_val] at hs,\n      have hs0 : s.val.prod \u2260 0,\n      { rw [ne.def, multiset.prod_eq_zero_iff],\n        simp only [exists_prop, id.def, exists_eq_right],\n        intro con,\n        apply not_irreducible_zero (irreducible_of_normalized_factor 0\n            (multiset.mem_dedup.1 (multiset.mem_of_le hs con))) },\n      rw (normalized_factors_prod h0).symm.dvd_iff_dvd_right,\n      refine \u27e8\u27e8multiset.prod_dvd_prod_of_le (le_trans hs (multiset.dedup_le _)), h0\u27e9, _\u27e9,\n      have h := unique_factorization_monoid.factors_unique irreducible_of_normalized_factor\n        (\u03bb x hx, irreducible_of_normalized_factor x (multiset.mem_of_le\n          (le_trans hs (multiset.dedup_le _)) hx)) (normalized_factors_prod hs0),\n      rw [associated_eq_eq, multiset.rel_eq] at h,\n      rw [unique_factorization_monoid.squarefree_iff_nodup_normalized_factors hs0, h],\n      apply s.nodup } },\n  { intros x hx y hy h,\n    rw [\u2190 finset.val_inj, \u2190 multiset.rel_eq, \u2190 associated_eq_eq],\n    rw [\u2190 finset.mem_def, finset.mem_powerset] at hx hy,\n    apply unique_factorization_monoid.factors_unique _ _ (associated_iff_eq.2 h),\n    { intros z hz,\n      apply irreducible_of_normalized_factor z,\n      rw \u2190 multiset.mem_to_finset,\n      apply hx hz },\n    { intros z hz,\n      apply irreducible_of_normalized_factor z,\n      rw \u2190 multiset.mem_to_finset,\n      apply hy hz } }\nend\n\nopen_locale big_operators\n\nlemma sum_divisors_filter_squarefree {n : \u2115} (h0 : n \u2260 0)\n  {\u03b1 : Type*} [add_comm_monoid \u03b1] {f : \u2115 \u2192 \u03b1} :\n  \u2211 i in (n.divisors.filter squarefree), f i =\n    \u2211 i in (unique_factorization_monoid.normalized_factors n).to_finset.powerset, f (i.val.prod) :=\nby rw [finset.sum_eq_multiset_sum, divisors_filter_squarefree h0, multiset.map_map,\n    finset.sum_eq_multiset_sum]\n\nlemma sq_mul_squarefree_of_pos {n : \u2115} (hn : 0 < n) :\n  \u2203 a b : \u2115, 0 < a \u2227 0 < b \u2227 b ^ 2 * a = n \u2227 squarefree a :=\nbegin\n  let S := {s \u2208 finset.range (n + 1) | s \u2223 n \u2227 \u2203 x, s = x ^ 2},\n  have hSne : S.nonempty,\n  { use 1,\n    have h1 : 0 < n \u2227 \u2203 (x : \u2115), 1 = x ^ 2 := \u27e8hn, \u27e81, (one_pow 2).symm\u27e9\u27e9,\n    simpa [S] },\n  let s := finset.max' S hSne,\n  have hs : s \u2208 S := finset.max'_mem S hSne,\n  simp only [finset.sep_def, S, finset.mem_filter, finset.mem_range] at hs,\n  obtain \u27e8hsn1, \u27e8a, hsa\u27e9, \u27e8b, hsb\u27e9\u27e9 := hs,\n  rw hsa at hn,\n  obtain \u27e8hlts, hlta\u27e9 := canonically_ordered_comm_semiring.mul_pos.mp hn,\n  rw hsb at hsa hn hlts,\n  refine \u27e8a, b, hlta, (pow_pos_iff zero_lt_two).mp hlts, hsa.symm, _\u27e9,\n  rintro x \u27e8y, hy\u27e9,\n  rw nat.is_unit_iff,\n  by_contra hx,\n  refine lt_le_antisymm _ (finset.le_max' S ((b * x) ^ 2) _),\n  { simp_rw [S, hsa, finset.sep_def, finset.mem_filter, finset.mem_range],\n    refine \u27e8lt_succ_iff.mpr (le_of_dvd hn _), _, \u27e8b * x, rfl\u27e9\u27e9; use y; rw hy; ring },\n  { convert lt_mul_of_one_lt_right hlts\n      (one_lt_pow 2 x zero_lt_two (one_lt_iff_ne_zero_and_ne_one.mpr \u27e8\u03bb h, by simp * at *, hx\u27e9)),\n    rw mul_pow },\nend\n\nlemma sq_mul_squarefree_of_pos' {n : \u2115} (h : 0 < n) :\n  \u2203 a b : \u2115, (b + 1) ^ 2 * (a + 1) = n \u2227 squarefree (a + 1) :=\nbegin\n  obtain \u27e8a\u2081, b\u2081, ha\u2081, hb\u2081, hab\u2081, hab\u2082\u27e9 := sq_mul_squarefree_of_pos h,\n  refine \u27e8a\u2081.pred, b\u2081.pred, _, _\u27e9;\n  simpa only [add_one, succ_pred_eq_of_pos, ha\u2081, hb\u2081],\nend\n\nlemma sq_mul_squarefree (n : \u2115) : \u2203 a b : \u2115, b ^ 2 * a = n \u2227 squarefree a :=\nbegin\n  cases n,\n  { exact \u27e81, 0, (by simp), squarefree_one\u27e9 },\n  { obtain \u27e8a, b, -, -, h\u2081, h\u2082\u27e9 := sq_mul_squarefree_of_pos (succ_pos n),\n    exact \u27e8a, b, h\u2081, h\u2082\u27e9 },\nend\n\n/-- `squarefree` is multiplicative. Note that the \u2192 direction does not require `hmn`\nand generalizes to arbitrary commutative monoids. See `squarefree.of_mul_left` and\n`squarefree.of_mul_right` above for auxiliary lemmas. -/\nlemma squarefree_mul {m n : \u2115} (hmn : m.coprime n) :\n  squarefree (m * n) \u2194 squarefree m \u2227 squarefree n :=\nbegin\n  simp only [squarefree_iff_prime_squarefree, \u2190sq, \u2190forall_and_distrib],\n  refine ball_congr (\u03bb p hp, _),\n  simp only [hmn.is_prime_pow_dvd_mul (hp.is_prime_pow.pow two_ne_zero), not_or_distrib],\nend\n\nend nat\n\n/-! ### Square-free prover -/\n\nopen norm_num\n\nnamespace tactic\nnamespace norm_num\n\n/-- A predicate representing partial progress in a proof of `squarefree`. -/\ndef squarefree_helper (n k : \u2115) : Prop :=\n0 < k \u2192 (\u2200 m, nat.prime m \u2192 m \u2223 bit1 n \u2192 bit1 k \u2264 m) \u2192 squarefree (bit1 n)\n\nlemma squarefree_bit10 (n : \u2115) (h : squarefree_helper n 1) :\n  squarefree (bit0 (bit1 n)) :=\nbegin\n  refine @nat.min_sq_fac_prop_div _ _ nat.prime_two two_dvd_bit0 _ none _,\n  { rw [bit0_eq_two_mul (bit1 n), mul_dvd_mul_iff_left (@two_ne_zero \u2115 _ _)],\n    exact nat.not_two_dvd_bit1 _ },\n  { rw [bit0_eq_two_mul, nat.mul_div_right _ (dec_trivial:0<2)],\n    refine h dec_trivial (\u03bb p pp dp, nat.succ_le_of_lt (lt_of_le_of_ne pp.two_le _)),\n    rintro rfl, exact nat.not_two_dvd_bit1 _ dp }\nend\n\nlemma squarefree_bit1 (n : \u2115) (h : squarefree_helper n 1) :\n  squarefree (bit1 n) :=\nbegin\n  refine h dec_trivial (\u03bb p pp dp, nat.succ_le_of_lt (lt_of_le_of_ne pp.two_le _)),\n  rintro rfl, exact nat.not_two_dvd_bit1 _ dp\nend\n\nlemma squarefree_helper_0 {k} (k0 : 0 < k)\n  {p : \u2115} (pp : nat.prime p) (h : bit1 k \u2264 p) : bit1 (k + 1) \u2264 p \u2228 bit1 k = p :=\nbegin\n  rcases lt_or_eq_of_le h with (hp:_+1\u2264_) | hp,\n  { rw [bit1, bit0_eq_two_mul] at hp, change 2*(_+1) \u2264 _ at hp,\n    rw [bit1, bit0_eq_two_mul],\n    refine or.inl (lt_of_le_of_ne hp _), unfreezingI { rintro rfl },\n    exact nat.not_prime_mul dec_trivial (lt_add_of_pos_left _ k0) pp },\n  { exact or.inr hp }\nend\n\nlemma squarefree_helper_1 (n k k' : \u2115) (e : k + 1 = k')\n  (hk : nat.prime (bit1 k) \u2192 \u00ac bit1 k \u2223 bit1 n)\n  (H : squarefree_helper n k') : squarefree_helper n k :=\n\u03bb k0 ih, begin\n  subst e,\n  refine H (nat.succ_pos _) (\u03bb p pp dp, _),\n  refine (squarefree_helper_0 k0 pp (ih p pp dp)).resolve_right (\u03bb hp, _),\n  subst hp, cases hk pp dp\nend\n\nlemma squarefree_helper_2 (n k k' c : \u2115) (e : k + 1 = k')\n  (hc : bit1 n % bit1 k = c) (c0 : 0 < c)\n  (h : squarefree_helper n k') : squarefree_helper n k :=\nbegin\n  refine squarefree_helper_1 _ _ _ e (\u03bb _, _) h,\n  refine mt _ (ne_of_gt c0), intro e\u2081,\n  rwa [\u2190 hc, \u2190 nat.dvd_iff_mod_eq_zero],\nend\n\nlemma squarefree_helper_3 (n n' k k' c : \u2115) (e : k + 1 = k')\n  (hn' : bit1 n' * bit1 k = bit1 n)\n  (hc : bit1 n' % bit1 k = c) (c0 : 0 < c)\n  (H : squarefree_helper n' k') : squarefree_helper n k :=\n\u03bb k0 ih, begin\n  subst e,\n  have k0' : 0 < bit1 k := bit1_pos (nat.zero_le _),\n  have dn' : bit1 n' \u2223 bit1 n := \u27e8_, hn'.symm\u27e9,\n  have dk : bit1 k \u2223 bit1 n := \u27e8_, ((mul_comm _ _).trans hn').symm\u27e9,\n  have : bit1 n / bit1 k = bit1 n',\n  { rw [\u2190 hn', nat.mul_div_cancel _ k0'] },\n  have k2 : 2 \u2264 bit1 k := nat.succ_le_succ (bit0_pos k0),\n  have pk : (bit1 k).prime,\n  { refine nat.prime_def_min_fac.2 \u27e8k2, le_antisymm (nat.min_fac_le k0') _\u27e9,\n    exact ih _ (nat.min_fac_prime (ne_of_gt k2)) (dvd_trans (nat.min_fac_dvd _) dk) },\n  have dkk' : \u00ac bit1 k \u2223 bit1 n', {rw [nat.dvd_iff_mod_eq_zero, hc], exact ne_of_gt c0},\n  have dkk : \u00ac bit1 k * bit1 k \u2223 bit1 n, {rwa [\u2190 nat.dvd_div_iff dk, this]},\n  refine @nat.min_sq_fac_prop_div _ _ pk dk dkk none _,\n  rw this, refine H (nat.succ_pos _) (\u03bb p pp dp, _),\n  refine (squarefree_helper_0 k0 pp (ih p pp $ dvd_trans dp dn')).resolve_right (\u03bb e, _),\n  subst e, contradiction\nend\n\nlemma squarefree_helper_4 (n k k' : \u2115) (e : bit1 k * bit1 k = k')\n  (hd : bit1 n < k') : squarefree_helper n k :=\nbegin\n  cases nat.eq_zero_or_pos n with h h,\n  { subst n, exact \u03bb _ _, squarefree_one },\n  subst e,\n  refine \u03bb k0 ih, irreducible.squarefree (nat.prime_def_le_sqrt.2 \u27e8bit1_lt_bit1.2 h, _\u27e9),\n  intros m m2 hm md,\n  obtain \u27e8p, pp, hp\u27e9 := nat.exists_prime_and_dvd (ne_of_gt m2),\n  have := (ih p pp (dvd_trans hp md)).trans\n    (le_trans (nat.le_of_dvd (lt_of_lt_of_le dec_trivial m2) hp) hm),\n  rw nat.le_sqrt at this,\n  exact not_le_of_lt hd this\nend\n\nlemma not_squarefree_mul (a aa b n : \u2115) (ha : a * a = aa) (hb : aa * b = n)\n  (h\u2081 : 1 < a) : \u00ac squarefree n :=\nby { rw [\u2190 hb, \u2190 ha], exact \u03bb H, ne_of_gt h\u2081 (nat.is_unit_iff.1 $ H _ \u27e8_, rfl\u27e9) }\n\n/-- Given `e` a natural numeral and `a : nat` with `a^2 \u2223 n`, return `\u22a2 \u00ac squarefree e`. -/\nmeta def prove_non_squarefree (e : expr) (n a : \u2115) : tactic expr := do\n  let ea := reflect a,\n  let eaa := reflect (a*a),\n  c \u2190 mk_instance_cache `(nat),\n  (c, p\u2081) \u2190 prove_lt_nat c `(1) ea,\n  let b := n / (a*a), let eb := reflect b,\n  (c, eaa, pa) \u2190 prove_mul_nat c ea ea,\n  (c, e', pb) \u2190 prove_mul_nat c eaa eb,\n  guard (e' =\u2090 e),\n  return $ `(@not_squarefree_mul).mk_app [ea, eaa, eb, e, pa, pb, p\u2081]\n\n/-- Given `en`,`en1 := bit1 en`, `n1` the value of `en1`, `ek`,\n  returns `\u22a2 squarefree_helper en ek`. -/\nmeta def prove_squarefree_aux : \u2200 (ic : instance_cache) (en en1 : expr) (n1 : \u2115)\n  (ek : expr) (k : \u2115), tactic expr\n| ic en en1 n1 ek k := do\n  let k1 := bit1 k,\n  let ek1 := `(bit1:\u2115\u2192\u2115).mk_app [ek],\n  if n1 < k1*k1 then do\n    (ic, ek', p\u2081) \u2190 prove_mul_nat ic ek1 ek1,\n    (ic, p\u2082) \u2190 prove_lt_nat ic en1 ek',\n    pure $ `(squarefree_helper_4).mk_app [en, ek, ek', p\u2081, p\u2082]\n  else do\n    let c := n1 % k1,\n    let k' := k+1, let ek' := reflect k',\n    (ic, p\u2081) \u2190 prove_succ ic ek ek',\n    if c = 0 then do\n      let n1' := n1 / k1,\n      let n' := n1' / 2, let en' := reflect n',\n      let en1' := `(bit1:\u2115\u2192\u2115).mk_app [en'],\n      (ic, _, pn') \u2190 prove_mul_nat ic en1' ek1,\n      let c := n1' % k1,\n      guard (c \u2260 0),\n      (ic, ec, pc) \u2190 prove_div_mod ic en1' ek1 tt,\n      (ic, p\u2080) \u2190 prove_pos ic ec,\n      p\u2082 \u2190 prove_squarefree_aux ic en' en1' n1' ek' k',\n      pure $ `(squarefree_helper_3).mk_app [en, en', ek, ek', ec, p\u2081, pn', pc, p\u2080, p\u2082]\n    else do\n      (ic, ec, pc) \u2190 prove_div_mod ic en1 ek1 tt,\n      (ic, p\u2080) \u2190 prove_pos ic ec,\n      p\u2082 \u2190 prove_squarefree_aux ic en en1 n1 ek' k',\n      pure $ `(squarefree_helper_2).mk_app [en, ek, ek', ec, p\u2081, pc, p\u2080, p\u2082]\n\n/-- Given `n > 0` a squarefree natural numeral, returns `\u22a2 squarefree n`. -/\nmeta def prove_squarefree (en : expr) (n : \u2115) : tactic expr :=\nmatch match_numeral en with\n| match_numeral_result.one := pure `(@squarefree_one \u2115 _)\n| match_numeral_result.bit0 en1 := match match_numeral en1 with\n  | match_numeral_result.one := pure `(nat.squarefree_two)\n  | match_numeral_result.bit1 en := do\n    ic \u2190 mk_instance_cache `(\u2115),\n    p \u2190 prove_squarefree_aux ic en en1 (n / 2) `(1:\u2115) 1,\n    pure $ `(squarefree_bit10).mk_app [en, p]\n  | _ := failed\n  end\n| match_numeral_result.bit1 en' := do\n  ic \u2190 mk_instance_cache `(\u2115),\n  p \u2190 prove_squarefree_aux ic en' en n `(1:\u2115) 1,\n  pure $ `(squarefree_bit1).mk_app [en', p]\n| _ := failed\nend\n\n/-- Evaluates the `prime` and `min_fac` functions. -/\n@[norm_num] meta def eval_squarefree : expr \u2192 tactic (expr \u00d7 expr)\n| `(squarefree (%%e : \u2115)) := do\n  n \u2190 e.to_nat,\n  match n with\n  | 0 := false_intro `(@not_squarefree_zero \u2115 _ _)\n  | 1 := true_intro `(@squarefree_one \u2115 _)\n  | _ := match n.min_sq_fac with\n    | some d := prove_non_squarefree e n d >>= false_intro\n    | none := prove_squarefree e n >>= true_intro\n    end\n  end\n| _ := failed\n\nend norm_num\nend tactic\n"}
{"text": "--\n-- The Computer Language Benchmarks Game\n-- https://salsa.debian.org/benchmarksgame-team/benchmarksgame/\n--\n-- Contributed by Don Stewart\n-- *reset*\n--\n-- import System.Environment\nimport Data.Bits\n-- import Text.Printf\n\n--\n-- an artificially strict tree. \n--\n-- normally you would ensure the branches are lazy, but this benchmark\n-- requires strict allocation.\n--\ndata Tree = Nil | Node Int Tree Tree\n\nminN : Int\nminN = 4\n\n-- io s n t = printf \"%s of depth %d\\t check: %d\\n\" s n t\n-- io : String -> Int -> Int -> IO ()\n-- io s n t = putStrLn (s ++ \" of depth \" ++ (show d) ++ \"\\t check: \" ++ (show t))\n\n-- traverse the tree, counting up the nodes\nccheck : Tree -> Int\nccheck Nil          = 0\nccheck (Node i l r) = 1 + ccheck l + ccheck r\n\n-- build a tree\nmake : Int -> Int -> Tree\nmake i 0 = Node i Nil Nil\nmake i d = Node i (make d d2) (make d2 d2)\n  where d2 = d-1\n\n-- allocate and check lots of trees\nsumT : Int -> Int -> Int -> Int\nsumT d 0 t = t\nsumT d i t = sumT d (i-1) (t + a)\n  where a = ccheck (make 0 d)\n\n-- generate many trees\ndepth : Int -> Int -> List (Int, Int, Int)\ndepth d m = \n    if d <= m then (n, d, (sumT d n 0)) :: depth (d+2) m\n    else []\n    where n = 2 * (m - d + minN)\n\n\nmain : IO ()\nmain = do\n    -- n <- getArgs >>= readIO . head\n    let n = 25\n    let maxN     = max (minN + 2) n\n    let stretchN = maxN + 1\n\n    -- stretch memory tree\n    let c = ccheck (make 0 stretchN)\n    -- io \"stretch tree\" stretchN c\n\n    -- allocate a long lived tree\n    let long    = make 0 maxN\n\n    -- allocate, walk, and deallocate many bottom-up binary trees\n    let vs = depth minN maxN\n    -- traverse (\\ (m,d,i) => io (show m ++ \"\\t trees\") d i) vs\n    traverse_ (putStrLn . show) vs\n\n    -- confirm the the long-lived binary tree still exists\n    -- io \"long lived tree\" maxN (ccheck long)\n\n\n"}
{"text": "import topology.instances.real\nimport data.complex.exponential\nimport data.real.irrational \n\nopen filter real\nopen_locale topological_space \nopen_locale big_operators \n\nnoncomputable def e : \u2115 \u2192 \u211d := \u03bb n, \u2211 i in finset.range(n+1), 1 / (nat.factorial i)\n\ntheorem part_a (n : \u2115) :\n  \u2203 p : \u2115, e n = p / (nat.factorial n) :=\nbegin   \n  sorry \nend \n\ntheorem part_b (n : \u2115) : \n  0 < exp 1 - e n \u2227 exp 1 - e n < 1 / (n * nat.factorial n) :=\nbegin \n  sorry \nend \n\ntheorem part_c : \n  \u2203 p : \u2115 \u2192 \u211d, \u2200 n : \u2115, 0 < exp 1 * nat.factorial n - e n \u2227 \n  exp 1 * nat.factorial n - e n < 1 / (n * nat.factorial n) :=\nbegin \n  sorry \nend \n\n-- Assume e is rational, then show n!e \u2208 \u2124 for some n.\ntheorem part_d : \n  irrational (exp 1) := \nbegin \n  sorry \nend \n"}
{"text": "module Figures\nusing AverageShiftedHistograms, Distributions, Plots\ngr()\n\n\n# sz = 1000\n# o = ash(rand(Gamma(5, 1), sz), rng=0:.05:20, m = 15)\n\n# anim = @animate for i in 1:50\n#     plot(o, title = \"Nobs = $(sz * i)\", ylim = (0, .5))\n#     ash!(o, rand(Gamma(5, 1), sz))\n# end\n# gif(anim, \"animation.gif\", fps = 10)\n\n\n\n# k = [\n#     Kernels.biweight,\n#     Kernels.cosine,\n#     Kernels.epanechnikov,\n#     Kernels.triangular,\n#     Kernels.tricube,\n#     Kernels.uniform,\n#     Kernels.gaussian,\n#     Kernels.logistic\n# ]\n# l = [\n#     \"biweight\"\n#     \"cosine\"\n#     \"epanechnikov\"\n#     \"triangular\"\n#     \"tricube\"\n#     \"uniform\"\n#     \"gaussian\"\n#     \"logistic\"\n# ]\n# plot(k, -1.1, 1.1, palette = :darktest, label = l, line=:auto, w=2)\n\n\n\nend\n"}
{"text": "import Mathlib\nimport LeanAide\n\n/-!\n## A bit of AI\n\nWe use `leanaide` for a bit of AI. For more direct use (such as debugging), can use\n\n```lean\n#eval translateViewM \"There are infinitely many odd numbers\"\n```\n\nFor more details on using the AI, please see the [README](https://github.com/siddhartha-gadgil/LeanAide#readme) of the LeanAide project.\n\nWe also complete the proof as an example.\n-/\n\n\n/- There are infinitely many odd numbers -/\nexample : \u2200 (n : \u2115), \u2203 m, m > n \u2227 m % 2 = 1 := by\n  intro n -- introduce a variable n\n  use 2 * n + 1 -- use `m = 2 * n + 1`\n  apply And.intro -- apply the constructor of `\u2227` to split goals\n  \u00b7 linarith -- solve the first goal using `linarith` \n  \u00b7 simp [Nat.add_mod] -- solve the second goal using `simp` with the lemma `Nat.add_mod`\n"}
{"text": "theory Ex045\n  imports Main \nbegin \n\ntheorem \"C \\<longrightarrow> \\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A)\" \nproof - \n  {\n    assume C\n    {\n      assume \"\\<not>(\\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A))\" \n      {\n        assume A \n        {\n          assume \"B \\<or> C\"\n          from \\<open>A\\<close> have A by assumption\n        }\n        hence \"(B \\<or> C) \\<longrightarrow> A\" by (rule impI)\n        hence \"\\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A)\" by (rule disjI2)\n        with \\<open>\\<not>(\\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A))\\<close> have False by (rule notE)\n      }\n      hence \"\\<not>A\" by (rule notI)\n      hence \"\\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A)\" by (rule disjI1)\n      with \\<open>\\<not>(\\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A))\\<close> have False by contradiction\n    }\n    hence \"\\<not>\\<not>(\\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A))\" by (rule notI)\n    hence \"\\<not>A \\<or> ((B \\<or> C) \\<longrightarrow> A)\" by (rule notnotD)\n  }\n  thus ?thesis by (rule impI)\nqed\n\n\n      "}
{"text": "(*  Title:      Containers/Set_Impl.thy\n    Author:     Andreas Lochbihler, KIT\n                Ren\u00e9 Thiemann, UIBK *)\n\ntheory Set_Impl imports\n  Collection_Enum\n  DList_Set\n  RBT_Set2\n  Closure_Set\n  Containers_Generator\n  Complex_Main\nbegin\n\nsection \\<open>Different implementations of sets\\<close>\n\nsubsection \\<open>Auxiliary functions\\<close>\n\ntext \\<open>A simple quicksort implementation\\<close>\n\ncontext ord begin\n\nfunction (sequential) quicksort_acc :: \"'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\n  and quicksort_part :: \"'a list \\<Rightarrow> 'a \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> 'a list\"\nwhere\n  \"quicksort_acc ac [] = ac\"\n| \"quicksort_acc ac [x] = x # ac\"\n| \"quicksort_acc ac (x # xs) = quicksort_part ac x [] [] [] xs\"\n| \"quicksort_part ac x lts eqs gts [] = quicksort_acc (eqs @ x # quicksort_acc ac gts) lts\"\n| \"quicksort_part ac x lts eqs gts (z # zs) =\n  (if z > x then quicksort_part ac x lts eqs (z # gts) zs\n   else if z < x then quicksort_part ac x (z # lts) eqs gts zs\n   else quicksort_part ac x lts (z # eqs) gts zs)\"\nby pat_completeness simp_all\n\nlemma length_quicksort_accp:\n  \"quicksort_acc_quicksort_part_dom (Inl (ac, xs)) \\<Longrightarrow> length (quicksort_acc ac xs) = length ac + length xs\"\n  and length_quicksort_partp:\n  \"quicksort_acc_quicksort_part_dom (Inr (ac, x, lts, eqs, gts, zs)) \n  \\<Longrightarrow> length (quicksort_part ac x lts eqs gts zs) = length ac + 1 + length lts + length eqs + length gts + length zs\"\napply(induct rule: quicksort_acc_quicksort_part.pinduct)\napply(simp_all add: quicksort_acc.psimps quicksort_part.psimps)\ndone\n\ntermination\napply(relation \"measure (case_sum (\\<lambda>(_, xs). 2 * length xs ^ 2) (\\<lambda>(_, _, lts, eqs, gts, zs). 2 * (length lts + length eqs + length gts + length zs) ^ 2 + length zs + 1))\")\napply(simp_all add: power2_eq_square add_mult_distrib add_mult_distrib2 length_quicksort_accp)\ndone\n\ndefinition quicksort :: \"'a list \\<Rightarrow> 'a list\"\nwhere \"quicksort = quicksort_acc []\"\n\nlemma set_quicksort_acc [simp]: \"set (quicksort_acc ac xs) = set ac \\<union> set xs\"\n  and set_quicksort_part [simp]:\n  \"set (quicksort_part ac x lts eqs gts zs) =\n  set ac \\<union> {x} \\<union> set lts \\<union> set eqs \\<union> set gts \\<union> set zs\"\nby(induct ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct)(auto split: if_split_asm)\n\nlemma set_quicksort [simp]: \"set (quicksort xs) = set xs\"\nby(simp add: quicksort_def)\n\nlemma distinct_quicksort_acc: \n  \"distinct (quicksort_acc ac xs) = distinct (ac @ xs)\"\n  and distinct_quicksort_part:\n  \"distinct (quicksort_part ac x lts eqs gts zs) = distinct (ac @ [x] @ lts @ eqs @ gts @ zs)\"\nby(induct ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct) auto\n\nlemma distinct_quicksort [simp]: \"distinct (quicksort xs) = distinct xs\"\nby(simp add: quicksort_def distinct_quicksort_acc)\n\nend\n\nlemmas [code] =\n  ord.quicksort_acc.simps quicksort_acc.simps\n  ord.quicksort_part.simps quicksort_part.simps\n  ord.quicksort_def quicksort_def\n\ncontext linorder begin\n\nlemma sorted_quicksort_acc:\n  \"\\<lbrakk> sorted ac; \\<forall>x \\<in> set xs. \\<forall>a \\<in> set ac. x < a \\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_acc ac xs)\"\n  and sorted_quicksort_part:\n  \"\\<lbrakk> sorted ac; \\<forall>y \\<in> set lts \\<union> {x} \\<union> set eqs \\<union> set gts \\<union> set zs. \\<forall>a \\<in> set ac. y < a;\n     \\<forall>y \\<in> set lts. y < x; \\<forall>y \\<in> set eqs. y = x; \\<forall>y \\<in> set gts. y > x \\<rbrakk>\n  \\<Longrightarrow> sorted (quicksort_part ac x lts eqs gts zs)\"\nproof(induction ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct)\n  case 1 thus ?case by simp\nnext\n  case 2 thus ?case by(auto)\nnext\n  case 3 thus ?case by simp\nnext\n  case (4 ac x lts eqs gts)\n  note ac_greater = \\<open>\\<forall>y\\<in>set lts \\<union> {x} \\<union> set eqs \\<union> set gts \\<union> set []. \\<forall>a\\<in>set ac. y < a\\<close>\n  have \"sorted eqs\" \"set eqs \\<subseteq> {x}\" using \\<open>\\<forall>y\\<in>set eqs. y = x\\<close> \n    by(induct eqs)(simp_all)\n  moreover have \"\\<forall>y \\<in> set ac \\<union> set gts. x \\<le> y\"\n    using \\<open>\\<forall>a\\<in>set gts. x < a\\<close> ac_greater by auto\n  moreover have \"sorted (quicksort_acc ac gts)\" \n    using \\<open>sorted ac\\<close> ac_greater by(auto intro: \"4.IH\")\n  ultimately have \"sorted (eqs @ x # quicksort_acc ac gts)\"\n    by(auto simp add: sorted_append)\n  moreover have \"\\<forall>y\\<in>set lts. \\<forall>a\\<in>set (eqs @ x # quicksort_acc ac gts). y < a\"\n    using \\<open>\\<forall>y\\<in>set lts. y < x\\<close> ac_greater \\<open>\\<forall>a\\<in>set gts. x < a\\<close> \\<open>\\<forall>y\\<in>set eqs. y = x\\<close>\n    by fastforce\n  ultimately show ?case by(simp add: \"4.IH\")\nnext\n  case 5 thus ?case by(simp add: not_less eq_iff)\nqed\n\nlemma sorted_quicksort [simp]: \"sorted (quicksort xs)\"\nby(simp add: quicksort_def sorted_quicksort_acc)\n\nlemma insort_key_append1:\n  \"\\<forall>y \\<in> set ys. f x < f y \\<Longrightarrow> insort_key f x (xs @ ys) = insort_key f x xs @ ys\"\nproof(induct xs)\n  case Nil\n  thus ?case by(cases ys) auto\nqed simp\n\nlemma insort_key_append2:\n  \"\\<forall>y \\<in> set xs. f x > f y \\<Longrightarrow> insort_key f x (xs @ ys) = xs @ insort_key f x ys\"\nby(induct xs) auto\n\nlemma sort_key_append:\n  \"\\<forall>x\\<in>set xs. \\<forall>y\\<in>set ys. f x < f y \\<Longrightarrow> sort_key f (xs @ ys) = sort_key f xs @ sort_key f ys\"\nby(induct xs)(simp_all add: insort_key_append1)\n\ndefinition single_list :: \"'a \\<Rightarrow> 'a list\" where \"single_list a = [a]\"\n\nlemma to_single_list: \"x # xs = single_list x @ xs\"\nby(simp add: single_list_def)\n\nlemma sort_snoc: \"sort (xs @ [x]) = insort x (sort xs)\"\nby(induct xs)(simp_all add: insort_left_comm)\n\nlemma sort_append_swap: \"sort (xs @ ys) = sort (ys @ xs)\"\nby(induct xs arbitrary: ys rule: rev_induct)(simp_all add: sort_snoc[symmetric])\n\nlemma sort_append_swap2: \"sort (xs @ ys @ zs) = sort (ys @ xs @ zs)\"\nby(induct xs)(simp_all, subst (1 2) sort_append_swap, simp)\n\n\nlemma sort_Cons_append_swap: \"sort (x # xs) = sort (xs @ [x])\"\nby(subst sort_append_swap) simp\n\nlemma sort_append_Cons_swap: \"sort (ys @ x # xs) = sort (ys @ xs @ [x])\"\napply(induct ys)\n apply(simp only: append.simps sort_Cons_append_swap)\napply simp\ndone\n\nlemma quicksort_acc_conv_sort: \n  \"quicksort_acc ac xs = sort xs @ ac\"\n  and quicksort_part_conv_sort: \n  \"\\<lbrakk> \\<forall>y \\<in> set lts. y < x; \\<forall>y \\<in> set eqs. y = x; \\<forall>y \\<in> set gts. y > x \\<rbrakk> \n  \\<Longrightarrow> quicksort_part ac x lts eqs gts zs = sort (lts @ eqs @ gts @ x # zs) @ ac\"\nproof(induct ac xs and ac x lts eqs gts zs rule: quicksort_acc_quicksort_part.induct)\n  case 1 thus ?case by simp\nnext\n  case 2 thus ?case by simp\nnext\n  case 3 thus ?case by simp\nnext\n  case (4 ac x lts eqs gts)\n  note eqs = \\<open>\\<forall>y\\<in>set eqs. y = x\\<close>\n  { fix eqs\n    assume \"\\<forall>y\\<in>set eqs. y = x\"\n    hence \"insort x eqs = x # eqs\" by(induct eqs) simp_all }\n  note [simp] = this\n  from eqs have [simp]: \"sort eqs = eqs\" by(induct eqs) simp_all\n  from eqs have [simp]: \"eqs @ [x] = x # eqs\" by(induct eqs) simp_all\n\n  show ?case using 4\n    apply(subst sort_key_append)\n     apply(auto 4 3 dest: bspec)[1]\n    apply(simp add: append_assoc[symmetric] sort_snoc del: append_assoc)\n    apply(subst sort_key_append)\n    apply(auto 4 3 simp add: insort_key_append1 dest: bspec)\n    done\nnext\n  case (5 ac x lts eqs gts z zs)\n  have \"\\<lbrakk> \\<not> z < x; \\<not> x < z \\<rbrakk> \\<Longrightarrow> z = x\" by simp\n  thus ?case using 5\n    apply(simp del: sort_key_simps)\n    apply(safe, simp_all del: sort_key_simps add: to_single_list)\n      apply(subst sort_append_swap)\n      apply(fold append_assoc)\n      apply(subst (2) sort_append_swap)\n      apply(subst sort_append_swap2)\n      apply(unfold append_assoc)\n      apply(rule refl)\n     apply(subst (1 5) append_assoc[symmetric])\n     apply(subst (1 2) sort_append_swap)\n     apply(unfold append_assoc)\n     apply(subst sort_append_swap2)\n     apply(subst (1 2) sort_append_swap)\n     apply(unfold append_assoc)\n     apply(subst sort_append_swap2)\n     apply(rule refl)\n    apply(subst (2 6) append_assoc[symmetric])\n    apply(subst (2 5) append_assoc[symmetric])\n    apply(subst (1 2) sort_append_swap2)\n    apply(subst (4) append_assoc)\n    apply(subst (2) sort_append_swap2)\n    apply simp\n    done\nqed\n\nlemma quicksort_conv_sort: \"quicksort xs = sort xs\"\nby(simp add: quicksort_def quicksort_acc_conv_sort)\n\nlemma sort_remdups: \"sort (remdups xs) = remdups (sort xs)\"\nby(rule sorted_distinct_set_unique) simp_all\n\nend\n\ntext \\<open>Removing duplicates from a sorted list\\<close>\n\ncontext ord begin\n\nfun remdups_sorted :: \"'a list \\<Rightarrow> 'a list\"\nwhere\n  \"remdups_sorted [] = []\"\n| \"remdups_sorted [x] = [x]\"\n| \"remdups_sorted (x#y#xs) = (if x < y then x # remdups_sorted (y#xs) else remdups_sorted (y#xs))\"\n\nend\n\nlemmas [code] = ord.remdups_sorted.simps\n\ncontext linorder begin\n\n\n\nlemma distinct_remdups_sorted [simp]: \"sorted xs \\<Longrightarrow> distinct (remdups_sorted xs)\"\nby(induct xs rule: remdups_sorted.induct)(auto)\n\nlemma remdups_sorted_conv_remdups: \"sorted xs \\<Longrightarrow> remdups_sorted xs = remdups xs\"\nby(induct xs rule: remdups_sorted.induct)(auto)\n\nend\n\ntext \\<open>An specialised operation to convert a finite set into a sorted list\\<close>\n\ndefinition csorted_list_of_set :: \"'a :: ccompare set \\<Rightarrow> 'a list\"\nwhere [code del]: \n  \"csorted_list_of_set A = \n  (if ID CCOMPARE('a) = None \\<or> \\<not> finite A then undefined else linorder.sorted_list_of_set cless_eq A)\"\n\nlemma csorted_list_of_set_set [simp]:\n  \"\\<lbrakk> ID CCOMPARE('a :: ccompare) = Some c; linorder.sorted (le_of_comp c) xs; distinct xs \\<rbrakk> \n  \\<Longrightarrow> linorder.sorted_list_of_set (le_of_comp c) (set xs) = xs\"\nby(simp add: distinct_remdups_id linorder.sorted_list_of_set_sort_remdups[OF ID_ccompare] linorder.sorted_sort_id[OF ID_ccompare])\n\nlemma csorted_list_of_set_split:\n  fixes A :: \"'a :: ccompare set\" shows\n  \"P (csorted_list_of_set A) \\<longleftrightarrow> \n  (\\<forall>xs. ID CCOMPARE('a) \\<noteq> None \\<longrightarrow> finite A \\<longrightarrow> A = set xs \\<longrightarrow> distinct xs \\<longrightarrow> linorder.sorted cless_eq xs \\<longrightarrow> P xs) \\<and> \n  (ID CCOMPARE('a) = None \\<or> \\<not> finite A \\<longrightarrow> P undefined)\"\nby(auto simp add: csorted_list_of_set_def linorder.sorted_list_of_set[OF ID_ccompare])\n\ncode_identifier code_module Set \\<rightharpoonup> (SML) Set_Impl\n  | code_module Set_Impl \\<rightharpoonup> (SML) Set_Impl\n\nsubsection \\<open>Delete code equation with set as constructor\\<close>\n\nlemma is_empty_unfold [code_unfold]:\n  \"set_eq A {} = Set.is_empty A\"\n  \"set_eq {} A = Set.is_empty A\"\nby(auto simp add: Set.is_empty_def set_eq_def)\n\ndefinition is_UNIV :: \"'a set \\<Rightarrow> bool\"\nwhere [code del]: \"is_UNIV A \\<longleftrightarrow> A = UNIV\"\n\nlemma is_UNIV_unfold [code_unfold]: \n  \"A = UNIV \\<longleftrightarrow> is_UNIV A\" \n  \"UNIV = A \\<longleftrightarrow> is_UNIV A\"\n  \"set_eq A UNIV \\<longleftrightarrow> is_UNIV A\"\n  \"set_eq UNIV A \\<longleftrightarrow> is_UNIV A\"\nby(auto simp add: is_UNIV_def set_eq_def)\n\nlemma [code_unfold del, symmetric, code_post del]:\n  \"x \\<in> set xs \\<equiv> List.member xs x\" \nby(simp add: List.member_def)\n\nlemma [code_unfold del, symmetric, code_post del]:\n  \"finite \\<equiv> Cardinality.finite'\" by(simp)\n\nlemma [code_unfold del, symmetric, code_post del]:\n  \"card \\<equiv> Cardinality.card'\" by simp\n\ndeclare [[code drop:\n  Set.empty\n  Set.is_empty\n  uminus_set_inst.uminus_set\n  Set.member\n  Set.insert\n  Set.remove\n  UNIV\n  Set.filter\n  image\n  Set.subset_eq\n  Ball\n  Bex\n  Set.union\n  minus_set_inst.minus_set\n  Set.inter\n  card\n  Set.bind\n  the_elem\n  Pow\n  sum\n  Gcd\n  Lcm\n  Product_Type.product\n  Id_on\n  Image\n  trancl\n  relcomp\n  wf\n  Min\n  Inf_fin\n  Max\n  Sup_fin\n  \"Inf :: 'a set set \\<Rightarrow> 'a set\"\n  \"Sup :: 'a set set \\<Rightarrow> 'a set\"\n  sorted_list_of_set\n  List.map_project\n  Sup_pred_inst.Sup_pred\n  finite\n  Cardinality.finite'\n  card\n  Cardinality.card'\n  Inf_pred_inst.Inf_pred\n  pred_of_set\n  Cardinality.subset'\n  Cardinality.eq_set\n  Wellfounded.acc\n  Bleast\n  can_select\n  \"set_eq :: 'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\"\n  irrefl\n  bacc\n  set_of_pred\n  set_of_seq\n  ]]\n\ndeclare \n  Cardinality.finite'_def[code]\n  Cardinality.card'_def[code]\n\nsubsection \\<open>Set implementations\\<close>\n\ndefinition Collect_set :: \"('a \\<Rightarrow> bool) \\<Rightarrow> 'a set\"\nwhere [simp]: \"Collect_set = Collect\"\n\ndefinition DList_set :: \"'a :: ceq set_dlist \\<Rightarrow> 'a set\"\nwhere \"DList_set = Collect o DList_Set.member\"\n\ndefinition RBT_set :: \"'a :: ccompare set_rbt \\<Rightarrow> 'a set\"\nwhere \"RBT_set = Collect o RBT_Set2.member\"\n\ndefinition Complement :: \"'a set \\<Rightarrow> 'a set\"\nwhere [simp]: \"Complement A = - A\"\n\ndefinition Set_Monad :: \"'a list \\<Rightarrow> 'a set\"\nwhere [simp]: \"Set_Monad = set\"\n\ncode_datatype Collect_set DList_set RBT_set Set_Monad Complement\n\nlemma DList_set_empty [simp]: \"DList_set DList_Set.empty = {}\"\nby(simp add: DList_set_def)\n\nlemma RBT_set_empty [simp]: \"RBT_set RBT_Set2.empty = {}\"\nby(simp add: RBT_set_def)\n\nlemma RBT_set_conv_keys: \n  \"ID CCOMPARE('a :: ccompare) \\<noteq> None \n  \\<Longrightarrow> RBT_set (t :: 'a set_rbt) = set (RBT_Set2.keys t)\"\nby(clarsimp simp add: RBT_set_def member_conv_keys)\n\nsubsection \\<open>Set operations\\<close>\n\ntext \\<open>\n  A collection of all the theorems about @{const Complement}.\n\\<close>\nML \\<open>\nstructure Set_Complement_Eqs = Named_Thms\n(\n  val name = @{binding set_complement_code}\n  val description = \"Code equations involving set complement\"\n)\n\\<close>\nsetup \\<open>Set_Complement_Eqs.setup\\<close>\n\ntext \\<open>Various fold operations over sets\\<close>\n\ntypedef ('a, 'b) comp_fun_commute = \"{f :: 'a \\<Rightarrow> 'b \\<Rightarrow> 'b. comp_fun_commute f}\"\n  morphisms comp_fun_commute_apply Abs_comp_fun_commute\nby(rule exI[where x=\"\\<lambda>_. id\"])(simp, unfold_locales, auto)\n\nsetup_lifting type_definition_comp_fun_commute\n\nlemma comp_fun_commute_apply' [simp]:\n  \"comp_fun_commute (comp_fun_commute_apply f)\"\nusing comp_fun_commute_apply[of f] by simp\n\nlift_definition set_fold_cfc :: \"('a, 'b) comp_fun_commute \\<Rightarrow> 'b \\<Rightarrow> 'a set \\<Rightarrow> 'b\" is \"Finite_Set.fold\" .\n\ndeclare [[code drop: set_fold_cfc]]\n\nlemma set_fold_cfc_code [code]:\n  fixes xs :: \"'a :: ceq list\" \n  and dxs :: \"'a :: ceq set_dlist\"\n  and rbt :: \"'b :: ccompare set_rbt\"\n  shows set_fold_cfc_Complement[set_complement_code]:\n  \"set_fold_cfc f''' b (Complement A) = Code.abort (STR ''set_fold_cfc not supported on Complement'') (\\<lambda>_. set_fold_cfc f''' b (Complement A))\"\n  and\n  \"set_fold_cfc f''' b (Collect_set P) = Code.abort (STR ''set_fold_cfc not supported on Collect_set'') (\\<lambda>_. set_fold_cfc f''' b (Collect_set P))\"\n  \"set_fold_cfc f b (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc Set_Monad: ceq = None'') (\\<lambda>_. set_fold_cfc f b (Set_Monad xs))\n                 | Some eq \\<Rightarrow> List.fold (comp_fun_commute_apply f) (equal_base.list_remdups eq xs) b)\"\n  (is ?Set_Monad)\n  \"set_fold_cfc f' b (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc DList_set: ceq = None'') (\\<lambda>_. set_fold_cfc f' b (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (comp_fun_commute_apply f') dxs b)\"\n  (is ?DList_set)\n  \"set_fold_cfc f'' b (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfc RBT_set: ccompare = None'') (\\<lambda>_. set_fold_cfc f'' b (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (comp_fun_commute_apply f'') rbt b)\"\n  (is ?RBT_set)\nproof -\n  show ?Set_Monad\n    by(auto split: option.split dest!: Collection_Eq.ID_ceq simp add: set_fold_cfc_def comp_fun_commute.fold_set_fold_remdups)\n  show ?DList_set\n    apply(auto split: option.split simp add: DList_set_def)\n    apply transfer\n    apply(auto dest: Collection_Eq.ID_ceq simp add: List.member_def[abs_def] comp_fun_commute.fold_set_fold_remdups distinct_remdups_id)\n    done\n  show ?RBT_set\n    apply(auto split: option.split simp add: RBT_set_conv_keys fold_conv_fold_keys)\n    apply transfer\n    apply(simp add: comp_fun_commute.fold_set_fold_remdups distinct_remdups_id linorder.distinct_keys[OF ID_ccompare] ord.is_rbt_rbt_sorted)\n    done\nqed simp_all\n\ntypedef ('a, 'b) comp_fun_idem = \"{f :: 'a \\<Rightarrow> 'b \\<Rightarrow> 'b. comp_fun_idem f}\"\n  morphisms comp_fun_idem_apply Abs_comp_fun_idem\nby(rule exI[where x=\"\\<lambda>_. id\"])(simp, unfold_locales, auto)\n\nsetup_lifting type_definition_comp_fun_idem\n\nlemma comp_fun_idem_apply' [simp]:\n  \"comp_fun_idem (comp_fun_idem_apply f)\"\nusing comp_fun_idem_apply[of f] by simp\n\nlift_definition set_fold_cfi :: \"('a, 'b) comp_fun_idem \\<Rightarrow> 'b \\<Rightarrow> 'a set \\<Rightarrow> 'b\" is \"Finite_Set.fold\" .\n\ndeclare [[code drop: set_fold_cfi]]\n\nlemma set_fold_cfi_code [code]:\n  fixes xs :: \"'a list\" \n  and dxs :: \"'b :: ceq set_dlist\"\n  and rbt :: \"'c :: ccompare set_rbt\" shows\n  \"set_fold_cfi f b (Complement A) = Code.abort (STR ''set_fold_cfi not supported on Complement'') (\\<lambda>_. set_fold_cfi f b (Complement A))\"\n  \"set_fold_cfi f b (Collect_set P) = Code.abort (STR ''set_fold_cfi not supported on Collect_set'') (\\<lambda>_. set_fold_cfi f b (Collect_set P))\"\n  \"set_fold_cfi f b (Set_Monad xs) = List.fold (comp_fun_idem_apply f) xs b\"\n  (is ?Set_Monad)\n  \"set_fold_cfi f' b (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfi DList_set: ceq = None'') (\\<lambda>_. set_fold_cfi f' b (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (comp_fun_idem_apply f') dxs b)\"\n  (is ?DList_set)\n  \"set_fold_cfi f'' b (RBT_set rbt) =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''set_fold_cfi RBT_set: ccompare = None'') (\\<lambda>_. set_fold_cfi f'' b (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (comp_fun_idem_apply f'') rbt b)\"\n  (is ?RBT_set)\nproof -\n  show ?Set_Monad\n    by(auto split: option.split dest!: Collection_Eq.ID_ceq simp add: set_fold_cfi_def comp_fun_idem.fold_set_fold)\n  show ?DList_set\n    apply(auto split: option.split simp add: DList_set_def)\n    apply transfer\n    apply(auto dest: Collection_Eq.ID_ceq simp add: List.member_def[abs_def] comp_fun_idem.fold_set_fold)\n    done\n  show ?RBT_set\n    apply(auto split: option.split simp add: RBT_set_conv_keys fold_conv_fold_keys)\n    apply transfer\n    apply(simp add: comp_fun_idem.fold_set_fold)\n    done\nqed simp_all\n\ntypedef 'a semilattice_set = \"{f :: 'a \\<Rightarrow> 'a \\<Rightarrow> 'a. semilattice_set f}\"\n  morphisms semilattice_set_apply Abs_semilattice_set\nproof\n  show \"(\\<lambda>x y. if x = y then x else undefined) \\<in> ?semilattice_set\"\n    unfolding mem_Collect_eq by(unfold_locales) simp_all\nqed\n\nsetup_lifting type_definition_semilattice_set\n\nlemma semilattice_set_apply' [simp]:\n  \"semilattice_set (semilattice_set_apply f)\"\nusing semilattice_set_apply[of f] by simp\n\nlemma comp_fun_idem_semilattice_set_apply [simp]:\n  \"comp_fun_idem (semilattice_set_apply f)\"\nproof -\n  interpret semilattice_set \"semilattice_set_apply f\" by simp\n  show ?thesis by(unfold_locales)(simp_all add: fun_eq_iff left_commute)\nqed \n\nlift_definition set_fold1 :: \"'a semilattice_set \\<Rightarrow> 'a set \\<Rightarrow> 'a\" is \"semilattice_set.F\" .\n\nlemma (in semilattice_set) F_set_conv_fold:\n  \"xs \\<noteq> [] \\<Longrightarrow> F (set xs) = Finite_Set.fold f (hd xs) (set (tl xs))\"\nby(clarsimp simp add: neq_Nil_conv eq_fold)\n\nlemma set_fold1_code [code]:\n  fixes rbt :: \"'a :: {ccompare, lattice} set_rbt\"\n  and dxs :: \"'b :: {ceq, lattice} set_dlist\" shows\n  set_fold1_Complement[set_complement_code]:\n  \"set_fold1 f (Complement A) = Code.abort (STR ''set_fold1: Complement'') (\\<lambda>_. set_fold1 f (Complement A))\"\n  and \"set_fold1 f (Collect_set P) = Code.abort (STR ''set_fold1: Collect_set'') (\\<lambda>_. set_fold1 f (Collect_set P))\"\n  and \"set_fold1 f (Set_Monad (x # xs)) = fold (semilattice_set_apply f) xs x\" (is \"?Set_Monad\")\n  and\n  \"set_fold1 f' (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''set_fold1 DList_set: ceq = None'') (\\<lambda>_. set_fold1 f' (DList_set dxs))\n                  | Some _ \\<Rightarrow> if DList_Set.null dxs then Code.abort (STR ''set_fold1 DList_set: empty set'') (\\<lambda>_. set_fold1 f' (DList_set dxs))\n                              else DList_Set.fold (semilattice_set_apply f') (DList_Set.tl dxs) (DList_Set.hd dxs))\"\n  (is \"?DList_set\")\n  and\n  \"set_fold1 f'' (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''set_fold1 RBT_set: ccompare = None'') (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n                     | Some _ \\<Rightarrow> if RBT_Set2.is_empty rbt then Code.abort (STR ''set_fold1 RBT_set: empty set'') (\\<lambda>_. set_fold1 f'' (RBT_set rbt))\n                                 else RBT_Set2.fold1 (semilattice_set_apply f'') rbt)\"\n  (is \"?RBT_set\")\nproof -\n  show ?Set_Monad\n    by(simp add: set_fold1_def semilattice_set.eq_fold comp_fun_idem.fold_set_fold)\n  show ?DList_set\n    by(simp add: set_fold1_def semilattice_set.F_set_conv_fold comp_fun_idem.fold_set_fold DList_set_def DList_Set.Collect_member split: option.split)(transfer, simp)\n  show ?RBT_set\n    by(simp add: set_fold1_def semilattice_set.F_set_conv_fold comp_fun_idem.fold_set_fold RBT_set_def RBT_Set2.member_conv_keys RBT_Set2.fold1_conv_fold split: option.split)\nqed simp_all\n\ntext \\<open>Implementation of set operations\\<close>\n\nlemma Collect_code [code]:\n  fixes P :: \"'a :: cenum \\<Rightarrow> bool\" shows\n  \"Collect P =\n  (case ID CENUM('a) of None \\<Rightarrow> Collect_set P\n            | Some (enum, _) \\<Rightarrow> Set_Monad (filter P enum))\"\nby(auto split: option.split dest: in_cenum)\n\nlemma finite_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\"\n  and A :: \"'c :: finite_UNIV set\" and P :: \"'c \\<Rightarrow> bool\" shows\n  \"finite (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''finite DList_set: ceq = None'') (\\<lambda>_. finite (DList_set dxs))\n                 | Some _ \\<Rightarrow> True)\"\n  \"finite (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''finite RBT_set: ccompare = None'') (\\<lambda>_. finite (RBT_set rbt))\n                     | Some _ \\<Rightarrow> True)\"\n  and finite_Complement [set_complement_code]:\n  \"finite (Complement A) \\<longleftrightarrow>\n  (if of_phantom (finite_UNIV :: 'c finite_UNIV) then True\n   else if finite A then False\n   else Code.abort (STR ''finite Complement: infinite set'') (\\<lambda>_. finite (Complement A)))\"\n  and\n  \"finite (Set_Monad xs) = True\"\n  \"finite (Collect_set P) \\<longleftrightarrow>\n  of_phantom (finite_UNIV :: 'c finite_UNIV) \\<or> Code.abort (STR ''finite Collect_set'') (\\<lambda>_. finite (Collect_set P))\"\nby(auto simp add: DList_set_def RBT_set_def member_conv_keys card_gt_0_iff finite_UNIV split: option.split elim: finite_subset[rotated 1])\n\nlemma card_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" and xs :: \"'a list\"\n  and rbt :: \"'b :: ccompare set_rbt\" \n  and A :: \"'c :: card_UNIV set\" shows\n  \"card (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''card DList_set: ceq = None'') (\\<lambda>_. card (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.length dxs)\"\n  \"card (RBT_set rbt) = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''card RBT_set: ccompare = None'') (\\<lambda>_. card (RBT_set rbt))\n                    | Some _ \\<Rightarrow> length (RBT_Set2.keys rbt))\"\n  \"card (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''card Set_Monad: ceq = None'') (\\<lambda>_. card (Set_Monad xs))\n                 | Some eq \\<Rightarrow> length (equal_base.list_remdups eq xs))\"\n  and card_Complement [set_complement_code]:\n  \"card (Complement A) =\n   (let a = card A; s = CARD('c)\n    in if s > 0 then s - a \n       else if finite A then 0\n       else Code.abort (STR ''card Complement: infinite'') (\\<lambda>_. card (Complement A)))\" \nby(auto simp add: RBT_set_def member_conv_keys distinct_card DList_set_def Let_def card_UNIV Compl_eq_Diff_UNIV card_Diff_subset_Int card_gt_0_iff finite_subset[of A UNIV] List.card_set dest: Collection_Eq.ID_ceq split: option.split)\n\nlemma is_UNIV_code [code]:\n  fixes rbt :: \"'a :: {cproper_interval, finite_UNIV} set_rbt\" \n  and A :: \"'b :: card_UNIV set\" shows\n  \"is_UNIV A \\<longleftrightarrow>\n   (let a = CARD('b);\n        b = card A\n    in if a > 0 then a = b\n       else if b > 0 then False\n       else Code.abort (STR ''is_UNIV called on infinite type and set'') (\\<lambda>_. is_UNIV A))\"\n  (is ?generic)\n  \"is_UNIV (RBT_set rbt) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''is_UNIV RBT_set: ccompare = None'') (\\<lambda>_. is_UNIV (RBT_set rbt))\n                     | Some _ \\<Rightarrow> of_phantom (finite_UNIV :: 'a finite_UNIV) \\<and> proper_intrvl.exhaustive_fusion cproper_interval rbt_keys_generator (RBT_Set2.init rbt))\"\n  (is ?rbt)\nproof -\n  {\n    fix c\n    assume linorder: \"ID CCOMPARE('a) = Some c\"\n    have \"is_UNIV (RBT_set rbt) =\n      (finite (UNIV :: 'a set) \\<and> proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt))\"\n      (is \"?lhs \\<longleftrightarrow> ?rhs\")\n    proof\n      assume ?lhs\n      have \"finite (UNIV :: 'a set)\"\n        unfolding \\<open>?lhs\\<close>[unfolded is_UNIV_def, symmetric]\n        using linorder \n        by(simp add: finite_code)\n      moreover\n      hence \"proper_intrvl.exhaustive cproper_interval (RBT_Set2.keys rbt)\"\n        using linorder \\<open>?lhs\\<close>\n        by(simp add: linorder_proper_interval.exhaustive_correct[OF ID_ccompare_interval[OF linorder]] sorted_RBT_Set_keys is_UNIV_def RBT_set_conv_keys)\n      ultimately show ?rhs ..\n    next\n      assume ?rhs\n      thus ?lhs using linorder\n        by(auto simp add: linorder_proper_interval.exhaustive_correct[OF ID_ccompare_interval[OF linorder]] sorted_RBT_Set_keys is_UNIV_def RBT_set_conv_keys)\n    qed }\n  thus ?rbt\n    by(auto simp add: finite_UNIV proper_intrvl.exhaustive_fusion_def unfoldr_rbt_keys_generator is_UNIV_def split: option.split)\n\n  show ?generic\n    by(auto simp add: Let_def is_UNIV_def dest: card_seteq[of UNIV A] dest!: card_ge_0_finite)\nqed\n\nlemma is_empty_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" \n  and A :: \"'c set\" shows\n  \"Set.is_empty (Set_Monad xs) \\<longleftrightarrow> xs = []\"\n  \"Set.is_empty (DList_set dxs) \\<longleftrightarrow> \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''is_empty DList_set: ceq = None'') (\\<lambda>_. Set.is_empty (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.null dxs)\" (is ?DList_set)\n  \"Set.is_empty (RBT_set rbt) \\<longleftrightarrow> \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''is_empty RBT_set: ccompare = None'') (\\<lambda>_. Set.is_empty (RBT_set rbt))\n                  | Some _ \\<Rightarrow> RBT_Set2.is_empty rbt)\" (is ?RBT_set)\n  and is_empty_Complement [set_complement_code]:\n  \"Set.is_empty (Complement A) \\<longleftrightarrow> is_UNIV A\" (is ?Complement)\nproof -\n  show ?DList_set\n    by(clarsimp simp add: DList_set_def Set.is_empty_def DList_Set.member_empty_empty split: option.split)\n\n  show ?RBT_set\n    by(clarsimp simp add: RBT_set_def Set.is_empty_def RBT_Set2.member_empty_empty[symmetric] fun_eq_iff simp del: RBT_Set2.member_empty_empty split: option.split)\n\n  show ?Complement\n    by(auto simp add: is_UNIV_def Set.is_empty_def)\nqed(simp_all add: Set.is_empty_def List.null_def)\n\nlemma Set_insert_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"\\<And>x. Set.insert x (Collect_set A) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''insert Collect_set: ceq = None'') (\\<lambda>_. Set.insert x (Collect_set A))\n                | Some eq \\<Rightarrow> Collect_set (equal_base.fun_upd eq A x True))\"\n  \"\\<And>x. Set.insert x (Set_Monad xs) = Set_Monad (x # xs)\"\n  \"\\<And>x. Set.insert x (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''insert DList_set: ceq = None'') (\\<lambda>_. Set.insert x (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.insert x dxs))\"\n  \"\\<And>x. Set.insert x (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''insert RBT_set: ccompare = None'') (\\<lambda>_. Set.insert x (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.insert x rbt))\"\n  and insert_Complement [set_complement_code]:\n  \"\\<And>x. Set.insert x (Complement X) = Complement (Set.remove x X)\"\nby(auto split: option.split dest: equal.equal_eq[OF ID_ceq] simp add: DList_set_def DList_Set.member_insert RBT_set_def)\n\nlemma Set_member_code [code]:\n  fixes xs :: \"'a :: ceq list\" shows\n  \"\\<And>x. x \\<in> Collect_set A \\<longleftrightarrow> A x\"\n  \"\\<And>x. x \\<in> DList_set dxs \\<longleftrightarrow> DList_Set.member dxs x\"\n  \"\\<And>x. x \\<in> RBT_set rbt \\<longleftrightarrow> RBT_Set2.member rbt x\"\n  and mem_Complement [set_complement_code]:\n  \"\\<And>x. x \\<in> Complement X \\<longleftrightarrow> x \\<notin> X\"\n  and\n  \"\\<And>x. x \\<in> Set_Monad xs \\<longleftrightarrow>\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''member Set_Monad: ceq = None'') (\\<lambda>_. x \\<in> Set_Monad xs)\n                 | Some eq \\<Rightarrow> equal_base.list_member eq xs x)\"\nby(auto simp add: DList_set_def RBT_set_def List.member_def split: option.split dest!: Collection_Eq.ID_ceq)\n\nlemma Set_remove_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"\\<And>x. Set.remove x (Collect_set A) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''remove Collect: ceq = None'') (\\<lambda>_. Set.remove x (Collect_set A))\n                 | Some eq \\<Rightarrow> Collect_set (equal_base.fun_upd eq A x False))\"\n  \"\\<And>x. Set.remove x (DList_set dxs) = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''remove DList_set: ceq = None'') (\\<lambda>_. Set.remove x (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.remove x dxs))\"\n  \"\\<And>x. Set.remove x (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''remove RBT_set: ccompare = None'') (\\<lambda>_. Set.remove x (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.remove x rbt))\"\n  and remove_Complement [set_complement_code]:\n  \"\\<And>x A. Set.remove x (Complement A) = Complement (Set.insert x A)\"\nby(auto split: option.split if_split_asm dest: equal.equal_eq[OF ID_ceq] simp add: DList_set_def DList_Set.member_remove RBT_set_def)\n\nlemma Set_uminus_code [code, set_complement_code]:\n  \"- A = Complement A\"\n  \"- (Collect_set P) = Collect_set (\\<lambda>x. \\<not> P x)\"\n  \"- (Complement B) = B\"\nby auto\n\ntext \\<open>\n  These equations represent complements as true complements.\n  If you want that the complement operations returns an explicit enumeration of the elements, use the following set of equations which use @{class cenum}.\n\\<close>\n\nlemma Set_uminus_cenum:\n  fixes A :: \"'a :: cenum set\" shows\n  \"- A =\n  (case ID CENUM('a) of None \\<Rightarrow> Complement A\n            | Some (enum, _) \\<Rightarrow> Set_Monad (filter (\\<lambda>x. x \\<notin> A) enum))\"\n  and \"- (Complement B) = B\"\nby(auto split: option.split dest: ID_cEnum)\n\nlemma Set_minus_code [code]: \"A - B = A \\<inter> (- B)\"\nby(rule Diff_eq)\n\nlemma Set_union_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: ccompare set_rbt\"\n  and rbt :: \"'b :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'b set_dlist\"\n  and dxs1 dxs2 :: \"'c :: ceq set_dlist\" shows\n  \"RBT_set rbt1 \\<union> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<union> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.union rbt1 rbt2))\" (is ?RBT_set_RBT_set)\n  \"RBT_set rbt \\<union> DList_set dxs =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''union RBT_set DList_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''union RBT_set DList_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\" (is ?RBT_set_DList_set)\n  \"DList_set dxs \\<union> RBT_set rbt =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''union DList_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''union DList_set RBT_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<union> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (DList_Set.fold RBT_Set2.insert dxs rbt))\" (is ?DList_set_RBT_set)\n  \"DList_set dxs1 \\<union> DList_set dxs2 = \n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union DList_set DList_set: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<union> DList_set dxs2)\n                      | Some _ \\<Rightarrow> DList_set (DList_Set.union dxs1 dxs2))\" (is ?DList_set_DList_set)\n  \"Set_Monad zs \\<union> RBT_set rbt2 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union Set_Monad RBT_set: ccompare = None'') (\\<lambda>_. Set_Monad zs \\<union> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt2))\" (is ?Set_Monad_RBT_set)\n  \"RBT_set rbt1 \\<union> Set_Monad zs =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''union RBT_set Set_Monad: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<union> Set_Monad zs)\n                      | Some _ \\<Rightarrow> RBT_set (fold RBT_Set2.insert zs rbt1))\" (is ?RBT_set_Set_Monad)\n  \"Set_Monad ws \\<union> DList_set dxs2 =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union Set_Monad DList_set: ceq = None'') (\\<lambda>_. Set_Monad ws \\<union> DList_set dxs2)\n                  | Some _ \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs2))\" (is ?Set_Monad_DList_set)\n  \"DList_set dxs1 \\<union> Set_Monad ws =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''union DList_set Set_Monad: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<union> Set_Monad ws)\n                  | Some _ \\<Rightarrow> DList_set (fold DList_Set.insert ws dxs1))\" (is ?DList_set_Set_Monad)\n  \"Set_Monad xs \\<union> Set_Monad ys = Set_Monad (xs @ ys)\"\n  \"Collect_set A \\<union> B = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\"\n  \"B \\<union> Collect_set A = Collect_set (\\<lambda>x. A x \\<or> x \\<in> B)\"\n  and Set_union_Complement [set_complement_code]:\n  \"Complement B \\<union> B' = Complement (B \\<inter> - B')\"\n  \"B' \\<union> Complement B = Complement (- B' \\<inter> B)\"\nproof -\n  show ?RBT_set_RBT_set ?Set_Monad_RBT_set ?RBT_set_Set_Monad\n    by(auto split: option.split simp add: RBT_set_def)\n\n  show ?RBT_set_DList_set ?DList_set_RBT_set\n    by(auto split: option.split simp add: RBT_set_def DList_set_def DList_Set.fold_def DList_Set.member_def List.member_def dest: equal.equal_eq[OF ID_ceq])\n\n  show ?DList_set_Set_Monad ?Set_Monad_DList_set\n    by(auto split: option.split simp add: DList_set_def DList_Set.member_fold_insert)\n\n  show ?DList_set_DList_set \n    by(auto split: option.split simp add: DList_set_def DList_Set.member_union)\nqed(auto)\n\nlemma Set_inter_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: ccompare set_rbt\"\n  and rbt :: \"'b :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'b set_dlist\"\n  and dxs1 dxs2 :: \"'c :: ceq set_dlist\" \n  and xs1 xs2 :: \"'c list\"\n  shows\n  \"Collect_set A'' \\<inter> J = Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\" (is ?collect1)\n  \"J \\<inter> Collect_set A'' = Collect_set (\\<lambda>x. A'' x \\<and> x \\<in> J)\" (is ?collect2)\n\n  \"Set_Monad xs'' \\<inter> I = Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\" (is ?monad1)\n  \"I \\<inter> Set_Monad xs'' = Set_Monad (filter (\\<lambda>x. x \\<in> I) xs'')\" (is ?monad2)\n\n  \"DList_set dxs1 \\<inter> H =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set1: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> H)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs1))\" (is ?dlist1)\n  \"H \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set2: ceq = None'') (\\<lambda>_. H \\<inter> DList_set dxs2)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (\\<lambda>x. x \\<in> H) dxs2))\" (is ?dlist2)\n\n  \"RBT_set rbt1 \\<inter> G =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set1: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> G)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt1))\" (is ?rbt1)\n  \"G \\<inter> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set2: ccompare = None'') (\\<lambda>_. G \\<inter> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.filter (\\<lambda>x. x \\<in> G) rbt2))\" (is ?rbt2)\n  and Set_inter_Complement [set_complement_code]:\n  \"Complement B'' \\<inter> Complement B''' = Complement (B'' \\<union> B''')\" (is ?complement)\n  and\n  \"Set_Monad xs \\<inter> RBT_set rbt1 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt1 xs))\" (is ?monad_rbt)\n  \"Set_Monad xs' \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad DList_set: ceq = None'') (\\<lambda>_. Set_Monad xs' \\<inter> DList_set dxs2)\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs2))\" (is ?monad_dlist)\n  \"Set_Monad xs1 \\<inter> Set_Monad xs2 =\n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter Set_Monad Set_Monad: ceq = None'') (\\<lambda>_. Set_Monad xs1 \\<inter> Set_Monad xs2)\n                 | Some eq \\<Rightarrow> Set_Monad (filter (equal_base.list_member eq xs2) xs1))\" (is ?monad)\n\n  \"DList_set dxs \\<inter> RBT_set rbt = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''inter DList_set RBT_set: ccompare = None'') (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''inter DList_set RBT_set: ceq = None'') (\\<lambda>_. DList_set dxs \\<inter> RBT_set rbt)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt (list_of_dlist dxs)))\" (is ?dlist_rbt)\n  \"DList_set dxs1 \\<inter> DList_set dxs2 =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set DList_set: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> DList_set dxs2)\n                   | Some _ \\<Rightarrow> DList_set (DList_Set.filter (DList_Set.member dxs2) dxs1))\" (is ?dlist)\n  \"DList_set dxs1 \\<inter> Set_Monad xs' =\n   (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''inter DList_set Set_Monad: ceq = None'') (\\<lambda>_. DList_set dxs1 \\<inter> Set_Monad xs')\n                  | Some eq \\<Rightarrow> DList_set (DList_Set.filter (equal_base.list_member eq xs') dxs1))\" (is ?dlist_monad)\n\n  \"RBT_set rbt1 \\<inter> RBT_set rbt2 =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> RBT_set rbt2)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter rbt1 rbt2))\" (is ?rbt_rbt)\n  \"RBT_set rbt \\<inter> DList_set dxs = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set DList_set: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n                      | Some _ \\<Rightarrow>\n       case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set DList_set: ceq = None'') (\\<lambda>_. RBT_set rbt \\<inter> DList_set dxs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt (list_of_dlist dxs)))\" (is ?rbt_dlist)\n  \"RBT_set rbt1 \\<inter> Set_Monad xs =\n   (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''inter RBT_set Set_Monad: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<inter> Set_Monad xs)\n                      | Some _ \\<Rightarrow> RBT_set (RBT_Set2.inter_list rbt1 xs))\" (is ?rbt_monad) \nproof -\n  show ?rbt_rbt ?rbt1 ?rbt2 ?rbt_dlist ?rbt_monad ?dlist_rbt ?monad_rbt\n    by(auto simp add: RBT_set_def DList_set_def DList_Set.member_def List.member_def dest: equal.equal_eq[OF ID_ceq] split: option.split)\n  show ?dlist ?dlist1 ?dlist2 ?dlist_monad ?monad_dlist ?monad ?monad1 ?monad2 ?collect1 ?collect2 ?complement\n    by(auto simp add: DList_set_def List.member_def dest!: Collection_Eq.ID_ceq split: option.splits)\nqed\n\nlemma Set_bind_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Set.bind (Set_Monad xs) f = fold ((\\<union>) \\<circ> f) xs (Set_Monad [])\" (is ?Set_Monad)\n  \"Set.bind (DList_set dxs) f' =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''bind DList_set: ceq = None'') (\\<lambda>_. Set.bind (DList_set dxs) f')\n                  | Some _ \\<Rightarrow> DList_Set.fold (union \\<circ> f') dxs {})\" (is ?DList)\n  \"Set.bind (RBT_set rbt) f'' = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''bind RBT_set: ccompare = None'') (\\<lambda>_. Set.bind (RBT_set rbt) f'')\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (union \\<circ> f'') rbt {})\" (is ?RBT)\nproof -\n  show ?Set_Monad by(simp add: set_bind_conv_fold)\n  show ?DList by(auto simp add: DList_set_def DList_Set.member_def List.member_def List.member_def[abs_def] set_bind_conv_fold DList_Set.fold_def split: option.split dest: equal.equal_eq[OF ID_ceq] ID_ceq)\n  show ?RBT by(clarsimp split: option.split simp add: RBT_set_def RBT_Set2.fold_conv_fold_keys RBT_Set2.member_conv_keys set_bind_conv_fold)\nqed\n\nlemma UNIV_code [code]: \"UNIV = - {}\"\nby(simp)\n\nlift_definition inf_sls :: \"'a :: lattice semilattice_set\" is \"inf\" by unfold_locales\n\nlemma Inf_fin_code [code]: \"Inf_fin A = set_fold1 inf_sls A\"\nby transfer(simp add: Inf_fin_def)\n\nlift_definition sup_sls :: \"'a :: lattice semilattice_set\" is \"sup\" by unfold_locales\n\nlemma Sup_fin_code [code]: \"Sup_fin A = set_fold1 sup_sls A\"\nby transfer(simp add: Sup_fin_def)\n\nlift_definition inf_cfi :: \"('a :: lattice, 'a) comp_fun_idem\" is \"inf\"\nby(rule comp_fun_idem_inf)\n\nlemma Inf_code:\n  fixes A :: \"'a :: complete_lattice set\" shows\n  \"Inf A = (if finite A then set_fold_cfi inf_cfi top A else Code.abort (STR ''Inf: infinite'') (\\<lambda>_. Inf A))\"\nby transfer(simp add: Inf_fold_inf)\n\nlift_definition sup_cfi :: \"('a :: lattice, 'a) comp_fun_idem\" is \"sup\"\nby(rule comp_fun_idem_sup)\n\nlemma Sup_code:\n  fixes A :: \"'a :: complete_lattice set\" shows\n  \"Sup A = (if finite A then set_fold_cfi sup_cfi bot A else Code.abort (STR ''Sup: infinite'') (\\<lambda>_. Sup A))\"\nby transfer(simp add: Sup_fold_sup)\n\nlemmas Inter_code [code] = Inf_code[where ?'a = \"_ :: type set\"]\nlemmas Union_code [code] = Sup_code[where ?'a = \"_ :: type set\"]\nlemmas Predicate_Inf_code [code] = Inf_code[where ?'a = \"_ :: type Predicate.pred\"]\nlemmas Predicate_Sup_code [code] = Sup_code[where ?'a = \"_ :: type Predicate.pred\"]\nlemmas Inf_fun_code [code] = Inf_code[where ?'a = \"_ :: type \\<Rightarrow> _ :: complete_lattice\"]\nlemmas Sup_fun_code [code] = Sup_code[where ?'a = \"_ :: type \\<Rightarrow> _ :: complete_lattice\"]\n\nlift_definition min_sls :: \"'a :: linorder semilattice_set\" is min by unfold_locales\n\nlemma Min_code [code]: \"Min A = set_fold1 min_sls A\"\nby transfer(simp add: Min_def)\n\nlift_definition max_sls :: \"'a :: linorder semilattice_set\" is max by unfold_locales\n\nlemma Max_code [code]: \"Max A = set_fold1 max_sls A\"\nby transfer(simp add: Max_def)\n\ntext \\<open>\n  We do not implement @{term Ball}, @{term Bex}, and @{term sorted_list_of_set} for @{term Collect_set} using @{term cEnum},\n  because it should already have been converted to an explicit list of elements if that is possible.\n\\<close>\n\nlemma Ball_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"Ball (Set_Monad xs) P = list_all P xs\"\n  \"Ball (DList_set dxs) P' = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Ball DList_set: ceq = None'') (\\<lambda>_. Ball (DList_set dxs) P')\n                  | Some _ \\<Rightarrow> DList_Set.dlist_all P' dxs)\"\n  \"Ball (RBT_set rbt) P'' = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''Ball RBT_set: ccompare = None'') (\\<lambda>_. Ball (RBT_set rbt) P'')\n                     | Some _ \\<Rightarrow> RBT_Set2.all P'' rbt)\"\nby(simp_all add: DList_set_def RBT_set_def list_all_iff dlist_all_conv_member RBT_Set2.all_conv_all_member split: option.splits)\n\nlemma Bex_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\"\n  and dxs :: \"'b :: ceq set_dlist\" shows\n  \"Bex (Set_Monad xs) P = list_ex P xs\"\n  \"Bex (DList_set dxs) P' = \n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Bex DList_set: ceq = None'') (\\<lambda>_. Bex (DList_set dxs) P')\n                  | Some _ \\<Rightarrow> DList_Set.dlist_ex P' dxs)\"\n  \"Bex (RBT_set rbt) P'' = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''Bex RBT_set: ccompare = None'') (\\<lambda>_. Bex (RBT_set rbt) P'')\n                     | Some _ \\<Rightarrow> RBT_Set2.ex P'' rbt)\"\nby(simp_all add: DList_set_def RBT_set_def list_ex_iff dlist_ex_conv_member RBT_Set2.ex_conv_ex_member split: option.splits)\n\nlemma csorted_list_of_set_code [code]:\n  fixes rbt :: \"'a :: ccompare set_rbt\" \n  and dxs :: \"'b :: {ccompare, ceq} set_dlist\" \n  and xs :: \"'a :: ccompare list\" shows\n  \"csorted_list_of_set (RBT_set rbt) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set RBT_set: ccompare = None'') (\\<lambda>_. csorted_list_of_set (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.keys rbt)\"\n  \"csorted_list_of_set (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set DList_set: ceq = None'') (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n              | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set DList_set: ccompare = None'') (\\<lambda>_. csorted_list_of_set (DList_set dxs))\n                 | Some c \\<Rightarrow> ord.quicksort (lt_of_comp c) (list_of_dlist dxs))\"\n  \"csorted_list_of_set (Set_Monad xs) =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''csorted_list_of_set Set_Monad: ccompare = None'') (\\<lambda>_. csorted_list_of_set (Set_Monad xs))\n              | Some c \\<Rightarrow> ord.remdups_sorted (lt_of_comp c) (ord.quicksort (lt_of_comp c) xs))\"\nby(auto split: option.split simp add: RBT_set_def DList_set_def DList_Set.Collect_member member_conv_keys sorted_RBT_Set_keys linorder.sorted_list_of_set_sort_remdups[OF ID_ccompare] linorder.quicksort_conv_sort[OF ID_ccompare] distinct_remdups_id distinct_list_of_dlist linorder.remdups_sorted_conv_remdups[OF ID_ccompare] linorder.sorted_sort[OF ID_ccompare] linorder.sort_remdups[OF ID_ccompare] csorted_list_of_set_def)\n\nlemma cless_set_code [code]:\n  fixes rbt rbt' :: \"'a :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'b :: cproper_interval set_rbt\"\n  and A B :: \"'a set\" \n  and A' B' :: \"'b set\" shows\n  \"cless_set A B \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set: ccompare = None'') (\\<lambda>_. cless_set A B)\n              | Some c \\<Rightarrow>\n     if finite A \\<and> finite B then ord.lexordp (\\<lambda>x y. lt_of_comp c y x) (csorted_list_of_set A) (csorted_list_of_set B)\n     else Code.abort (STR ''cless_set: infinite set'') (\\<lambda>_. cless_set A B))\"\n  (is \"?fin_fin\")\n  and cless_set_Complement2 [set_complement_code]:\n  \"cless_set A' (Complement B') \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement2: ccompare = None'') (\\<lambda>_. cless_set A' (Complement B'))\n              | Some c \\<Rightarrow>\n     if finite A' \\<and> finite B' then\n        finite (UNIV :: 'b set) \\<longrightarrow>\n        proper_intrvl.set_less_aux_Compl (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n     else Code.abort (STR ''cless_set Complement2: infinite set'') (\\<lambda>_. cless_set A' (Complement B')))\"\n  (is \"?fin_Compl_fin\")\n  and cless_set_Complement1 [set_complement_code]:\n  \"cless_set (Complement A') B' \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement1: ccompare = None'') (\\<lambda>_. cless_set (Complement A') B')\n              | Some c \\<Rightarrow>\n      if finite A' \\<and> finite B' then\n        finite (UNIV :: 'b set) \\<and>\n        proper_intrvl.Compl_set_less_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n      else Code.abort (STR ''cless_set Complement1: infinite set'') (\\<lambda>_. cless_set (Complement A') B'))\"\n  (is \"?Compl_fin_fin\")\n  and cless_set_Complement12 [set_complement_code]:\n  \"cless_set (Complement A) (Complement B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set Complement Complement: ccompare = None'') (\\<lambda>_. cless_set (Complement A) (Complement B))\n                     | Some _ \\<Rightarrow> cless B A)\" (is ?Compl_Compl)\n  and\n  \"cless_set (RBT_set rbt) (RBT_set rbt') \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_set RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cless_set (RBT_set rbt) (RBT_set rbt'))\n             | Some c \\<Rightarrow> ord.lexord_fusion (\\<lambda>x y. lt_of_comp c y x) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt) (RBT_Set2.init rbt'))\"\n    (is ?rbt_rbt)\n  and cless_set_rbt_Complement2 [set_complement_code]:\n  \"cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cless_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<longrightarrow>\n     proper_intrvl.set_less_aux_Compl_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?rbt_Compl)\n  and cless_set_rbt_Complement1 [set_complement_code]:\n  \"cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_set (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cless_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<and> \n     proper_intrvl.Compl_set_less_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?Compl_rbt)\nproof -\n  note [split] = option.split csorted_list_of_set_split\n    and [simp] = \n    le_of_comp_of_ords_linorder[OF ID_ccompare]\n    lt_of_comp_of_ords\n    finite_subset[OF subset_UNIV] ccompare_set_def ID_Some\n    ord.lexord_fusion_def proper_intrvl.Compl_set_less_aux_fusion_def\n    proper_intrvl.set_less_aux_Compl_fusion_def\n    unfoldr_rbt_keys_generator\n    RBT_set_def sorted_RBT_Set_keys member_conv_keys\n    linorder.set_less_finite_iff[OF ID_ccompare]\n    linorder.set_less_aux_code[OF ID_ccompare, symmetric]\n    linorder.Compl_set_less_Compl[OF ID_ccompare]\n    linorder.infinite_set_less_Complement[OF ID_ccompare]\n    linorder.infinite_Complement_set_less[OF ID_ccompare]\n    linorder_proper_interval.set_less_aux_Compl2_conv_set_less_aux_Compl[OF ID_ccompare_interval, symmetric]\n    linorder_proper_interval.Compl1_set_less_aux_conv_Compl_set_less_aux[OF ID_ccompare_interval, symmetric]\n\n  show ?Compl_Compl by simp\n  show ?rbt_rbt by auto\n  show ?rbt_Compl by(cases \"finite (UNIV :: 'b set)\") auto\n  show ?Compl_rbt by(cases \"finite (UNIV :: 'b set)\") auto\n  show ?fin_fin by auto\n  show ?fin_Compl_fin by(cases \"finite (UNIV :: 'b set)\", auto)\n  show ?Compl_fin_fin by(cases \"finite (UNIV :: 'b set)\") auto\nqed\n\nlemma le_of_comp_set_less_eq: \n  \"le_of_comp (comp_of_ords (ord.set_less_eq le) (ord.set_less le)) = ord.set_less_eq le\"\n  by (rule le_of_comp_of_ords_gen, simp add: ord.set_less_def)\n\nlemma cless_eq_set_code [code]:\n  fixes rbt rbt' :: \"'a :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'b :: cproper_interval set_rbt\"\n  and A B :: \"'a set\" \n  and A' B' :: \"'b set\" shows\n  \"cless_eq_set A B \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set: ccompare = None'') (\\<lambda>_. cless_eq_set A B)\n              | Some c \\<Rightarrow>\n     if finite A \\<and> finite B then \n        ord.lexordp_eq (\\<lambda>x y. lt_of_comp c y x) (csorted_list_of_set A) (csorted_list_of_set B)\n     else Code.abort (STR ''cless_eq_set: infinite set'') (\\<lambda>_. cless_eq_set A B))\"\n  (is \"?fin_fin\")\n  and cless_eq_set_Complement2 [set_complement_code]:\n  \"cless_eq_set A' (Complement B') \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement2: ccompare = None'') (\\<lambda>_. cless_eq_set A' (Complement B'))\n              | Some c \\<Rightarrow>\n     if finite A' \\<and> finite B' then \n        finite (UNIV :: 'b set) \\<longrightarrow>\n        proper_intrvl.set_less_eq_aux_Compl (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n     else Code.abort (STR ''cless_eq_set Complement2: infinite set'') (\\<lambda>_. cless_eq_set A' (Complement B')))\"\n  (is \"?fin_Compl_fin\")\n  and cless_eq_set_Complement1 [set_complement_code]:\n  \"cless_eq_set (Complement A') B' \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement1: ccompare = None'') (\\<lambda>_. cless_eq_set (Complement A') B')\n              | Some c \\<Rightarrow>\n    if finite A' \\<and> finite B' then \n      finite (UNIV :: 'b set) \\<and>\n      proper_intrvl.Compl_set_less_eq_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A') (csorted_list_of_set B')\n    else Code.abort (STR ''cless_eq_set Complement1: infinite set'') (\\<lambda>_. cless_eq_set (Complement A') B'))\"\n  (is \"?Compl_fin_fin\")\n  and cless_eq_set_Complement12 [set_complement_code]:\n  \"cless_eq_set (Complement A) (Complement B) \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set Complement Complement: ccompare = None'') (\\<lambda>_. cless_eq (Complement A) (Complement B))\n             | Some c \\<Rightarrow> cless_eq_set B A)\" \n  (is ?Compl_Compl)\n\n  \"cless_eq_set (RBT_set rbt) (RBT_set rbt') \\<longleftrightarrow> \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cless_eq_set (RBT_set rbt) (RBT_set rbt'))\n             | Some c \\<Rightarrow> ord.lexord_eq_fusion (\\<lambda>x y. lt_of_comp c y x) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt) (RBT_Set2.init rbt'))\" \n    (is ?rbt_rbt)\n  and cless_eq_set_rbt_Complement2 [set_complement_code]:\n  \"cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cless_eq_set (RBT_set rbt1) (Complement (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<longrightarrow>\n     proper_intrvl.set_less_eq_aux_Compl_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?rbt_Compl)\n  and cless_eq_set_rbt_Complement1 [set_complement_code]:\n  \"cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2) \\<longleftrightarrow>\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''cless_eq_set (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cless_eq_set (Complement (RBT_set rbt1)) (RBT_set rbt2))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'b set) \\<and> \n     proper_intrvl.Compl_set_less_eq_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n    (is ?Compl_rbt)\nproof -\n  note [split] = option.split csorted_list_of_set_split\n    and [simp] = \n    le_of_comp_set_less_eq\n    finite_subset[OF subset_UNIV] ccompare_set_def ID_Some\n    ord.lexord_eq_fusion_def proper_intrvl.Compl_set_less_eq_aux_fusion_def\n    proper_intrvl.set_less_eq_aux_Compl_fusion_def\n    unfoldr_rbt_keys_generator\n    RBT_set_def sorted_RBT_Set_keys member_conv_keys\n    linorder.set_less_eq_finite_iff[OF ID_ccompare]\n    linorder.set_less_eq_aux_code[OF ID_ccompare, symmetric]\n    linorder.Compl_set_less_eq_Compl[OF ID_ccompare]\n    linorder.infinite_set_less_eq_Complement[OF ID_ccompare]\n    linorder.infinite_Complement_set_less_eq[OF ID_ccompare]\n    linorder_proper_interval.set_less_eq_aux_Compl2_conv_set_less_eq_aux_Compl[OF ID_ccompare_interval, symmetric]\n    linorder_proper_interval.Compl1_set_less_eq_aux_conv_Compl_set_less_eq_aux[OF ID_ccompare_interval, symmetric]\n\n  show ?Compl_Compl by simp\n  show ?rbt_rbt by auto\n  show ?rbt_Compl by(cases \"finite (UNIV :: 'b set)\") auto\n  show ?Compl_rbt by(cases \"finite (UNIV :: 'b set)\") auto\n  show ?fin_fin by auto\n  show ?fin_Compl_fin by (cases \"finite (UNIV :: 'b set)\", auto)\n  show ?Compl_fin_fin by(cases \"finite (UNIV :: 'b set)\") auto\nqed\n\nlemma cproper_interval_set_Some_Some_code [code]:\n  fixes rbt1 rbt2 :: \"'a :: cproper_interval set_rbt\" \n  and A B :: \"'a set\" shows\n\n  \"cproper_interval (Some A) (Some B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval: ccompare = None'') (\\<lambda>_. cproper_interval (Some A) (Some B))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_aux (lt_of_comp c) cproper_interval (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?fin_fin)\n  and cproper_interval_set_Some_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some A) (Some (Complement B)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement2: ccompare = None'') (\\<lambda>_. cproper_interval (Some A) (Some (Complement B)))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_Compl_aux (lt_of_comp c) cproper_interval None 0 (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?fin_Compl_fin)\n  and cproper_interval_set_Some_Complement_Some [set_complement_code]:\n  \"cproper_interval (Some (Complement A)) (Some B) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement1: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement A)) (Some B))\n              | Some c \\<Rightarrow>\n       finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_Compl_set_aux (lt_of_comp c) cproper_interval None (csorted_list_of_set A) (csorted_list_of_set B))\"\n  (is ?Compl_fin_fin)\n  and cproper_interval_set_Some_Complement_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some (Complement A)) (Some (Complement B)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval Complement Complement: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement A)) (Some (Complement B)))\n             | Some _ \\<Rightarrow> cproper_interval (Some B) (Some A))\"\n  (is ?Compl_Compl)\n\n  \"cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval RBT_set RBT_set: ccompare = None'') (\\<lambda>_. cproper_interval (Some (RBT_set rbt1)) (Some (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?rbt_rbt)\n  and cproper_interval_set_Some_rbt_Some_Complement [set_complement_code]:\n  \"cproper_interval (Some (RBT_set rbt1)) (Some (Complement (RBT_set rbt2))) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval RBT_set (Complement RBT_set): ccompare = None'') (\\<lambda>_. cproper_interval (Some (RBT_set rbt1)) (Some (Complement (RBT_set rbt2))))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_set_Compl_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None 0 (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?rbt_Compl_rbt)\n  and cproper_interval_set_Some_Complement_Some_rbt [set_complement_code]:\n  \"cproper_interval (Some (Complement (RBT_set rbt1))) (Some (RBT_set rbt2)) \\<longleftrightarrow>\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''cproper_interval (Complement RBT_set) RBT_set: ccompare = None'') (\\<lambda>_. cproper_interval (Some (Complement (RBT_set rbt1))) (Some (RBT_set rbt2)))\n             | Some c \\<Rightarrow>\n     finite (UNIV :: 'a set) \\<and> proper_intrvl.proper_interval_Compl_set_aux_fusion (lt_of_comp c) cproper_interval rbt_keys_generator rbt_keys_generator None (RBT_Set2.init rbt1) (RBT_Set2.init rbt2))\"\n  (is ?Compl_rbt_rbt)\nproof -\n  note [split] = option.split csorted_list_of_set_split\n    and [simp] = \n    lt_of_comp_of_ords\n    finite_subset[OF subset_UNIV] ccompare_set_def ID_Some\n    linorder.set_less_finite_iff[OF ID_ccompare]\n    RBT_set_def sorted_RBT_Set_keys member_conv_keys\n    linorder.distinct_entries[OF ID_ccompare]\n    unfoldr_rbt_keys_generator\n    proper_intrvl.proper_interval_set_aux_fusion_def\n    proper_intrvl.proper_interval_set_Compl_aux_fusion_def\n    proper_intrvl.proper_interval_Compl_set_aux_fusion_def \n    linorder_proper_interval.proper_interval_set_aux[OF ID_ccompare_interval]\n    linorder_proper_interval.proper_interval_set_Compl_aux[OF ID_ccompare_interval]\n    linorder_proper_interval.proper_interval_Compl_set_aux[OF ID_ccompare_interval]\n    and [cong] = conj_cong\n\n  show ?Compl_Compl\n    by(clarsimp simp add: Complement_cproper_interval_set_Complement simp del: cproper_interval_set_Some_Some)\n  \n  show ?rbt_rbt ?rbt_Compl_rbt ?Compl_rbt_rbt by auto\n  show ?fin_fin ?fin_Compl_fin ?Compl_fin_fin by auto\nqed\n\ncontext ord begin\n\nfun sorted_list_subset :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> 'a list \\<Rightarrow> 'a list \\<Rightarrow> bool\"\nwhere\n  \"sorted_list_subset eq [] ys = True\"\n| \"sorted_list_subset eq (x # xs) [] = False\"\n| \"sorted_list_subset eq (x # xs) (y # ys) \\<longleftrightarrow>\n  (if eq x y then sorted_list_subset eq xs ys\n   else x > y \\<and> sorted_list_subset eq (x # xs) ys)\"\n\nend\n\ncontext linorder begin\n\nlemma sorted_list_subset_correct:\n  \"\\<lbrakk> sorted xs; distinct xs; sorted ys; distinct ys \\<rbrakk> \n  \\<Longrightarrow> sorted_list_subset (=) xs ys \\<longleftrightarrow> set xs \\<subseteq> set ys\"\napply(induct \"(=) :: 'a \\<Rightarrow> 'a \\<Rightarrow> bool\" xs ys rule: sorted_list_subset.induct)\napply(auto 6 2)\napply auto\nby (metis eq_iff insert_iff subsetD)\n\nend\n\ncontext ord begin\n\ndefinition sorted_list_subset_fusion :: \"('a \\<Rightarrow> 'a \\<Rightarrow> bool) \\<Rightarrow> ('a, 's1) generator \\<Rightarrow> ('a, 's2) generator \\<Rightarrow> 's1 \\<Rightarrow> 's2 \\<Rightarrow> bool\"\nwhere \"sorted_list_subset_fusion eq g1 g2 s1 s2 = sorted_list_subset eq (list.unfoldr g1 s1) (list.unfoldr g2 s2)\"\n\nlemma sorted_list_subset_fusion_code:\n  \"sorted_list_subset_fusion eq g1 g2 s1 s2 =\n  (if list.has_next g1 s1 then\n     let (x, s1') = list.next g1 s1\n     in list.has_next g2 s2 \\<and> (\n        let (y, s2') = list.next g2 s2 \n        in if eq x y then sorted_list_subset_fusion eq g1 g2 s1' s2' \n           else y < x \\<and> sorted_list_subset_fusion eq g1 g2 s1 s2')\n   else True)\"\nunfolding sorted_list_subset_fusion_def\nby(subst (1 2 5) list.unfoldr.simps)(simp add: split_beta Let_def)\n\nend\n\nlemmas [code] = ord.sorted_list_subset_fusion_code\n\ntext \\<open>\n  Define a new constant for the subset operation\n  because @{theory \"HOL-Library.Cardinality\"} introduces @{const \"Cardinality.subset'\"}\n  and rewrites @{const \"subset\"} to @{const \"Cardinality.subset'\"} \n  based on the sort of the element type.\n\\<close>\n\ndefinition subset_eq :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> bool\"\nwhere [simp, code del]: \"subset_eq = (\\<subseteq>)\"\n\nlemma subseteq_code [code]: \"(\\<subseteq>) = subset_eq\"\nby simp\n\nlemma subset'_code [code]: \"Cardinality.subset' = subset_eq\"\nby simp\n\nlemma subset_eq_code [folded subset_eq_def, code]:\n  fixes A1 A2 :: \"'a set\"\n  and rbt :: \"'b :: ccompare set_rbt\"\n  and rbt1 rbt2 :: \"'d :: {ccompare, ceq} set_rbt\"\n  and dxs :: \"'c :: ceq set_dlist\" \n  and xs :: \"'c list\" shows\n  \"RBT_set rbt \\<subseteq> B \\<longleftrightarrow> \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''subset RBT_set1: ccompare = None'') (\\<lambda>_. RBT_set rbt \\<subseteq> B)\n                     | Some _ \\<Rightarrow> list_all_fusion rbt_keys_generator (\\<lambda>x. x \\<in> B) (RBT_Set2.init rbt))\" (is ?rbt)\n  \"DList_set dxs \\<subseteq> C \\<longleftrightarrow> \n  (case ID CEQ('c) of None \\<Rightarrow> Code.abort (STR ''subset DList_set1: ceq = None'') (\\<lambda>_. DList_set dxs \\<subseteq> C)\n                     | Some _ \\<Rightarrow> DList_Set.dlist_all (\\<lambda>x. x \\<in> C) dxs)\" (is ?dlist)\n  \"Set_Monad xs \\<subseteq> C \\<longleftrightarrow> list_all (\\<lambda>x. x \\<in> C) xs\" (is ?Set_Monad)\n  and Collect_subset_eq_Complement [folded subset_eq_def, set_complement_code]:\n  \"Collect_set P \\<subseteq> Complement A \\<longleftrightarrow> A \\<subseteq> {x. \\<not> P x}\" (is ?Collect_set_Compl)\n  and Complement_subset_eq_Complement [folded subset_eq_def, set_complement_code]:\n  \"Complement A1 \\<subseteq> Complement A2 \\<longleftrightarrow> A2 \\<subseteq> A1\" (is ?Compl)\n  and\n  \"RBT_set rbt1 \\<subseteq> RBT_set rbt2 \\<longleftrightarrow>\n  (case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''subset RBT_set RBT_set: ccompare = None'') (\\<lambda>_. RBT_set rbt1 \\<subseteq> RBT_set rbt2)\n                     | Some c \\<Rightarrow> \n    (case ID CEQ('d) of None \\<Rightarrow> ord.sorted_list_subset_fusion (lt_of_comp c) (\\<lambda> x y. c x y = Eq) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n                   | Some eq \\<Rightarrow> ord.sorted_list_subset_fusion (lt_of_comp c) eq rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)))\" \n  (is ?rbt_rbt)\nproof -\n  show ?rbt_rbt \n    by (auto simp add: comparator.eq[OF ID_ccompare'] RBT_set_def member_conv_keys unfoldr_rbt_keys_generator ord.sorted_list_subset_fusion_def linorder.sorted_list_subset_correct[OF ID_ccompare] sorted_RBT_Set_keys split: option.split dest!: ID_ceq[THEN equal.equal_eq] del: iffI)\n  show ?rbt\n    by(auto simp add: RBT_set_def member_conv_keys list_all_fusion_def unfoldr_rbt_keys_generator keys.rep_eq list_all_iff split: option.split)\n  show ?dlist by(auto simp add: DList_set_def dlist_all_conv_member split: option.split)\n  show ?Set_Monad by(auto simp add: list_all_iff split: option.split)\n  show ?Collect_set_Compl ?Compl by auto\nqed\n\nhide_const (open) subset_eq\nhide_fact (open) subset_eq_def\n\nlemma eq_set_code [code]: \"Cardinality.eq_set = set_eq\"\nby(simp add: set_eq_def)\n\nlemma set_eq_code [code]:\n  fixes rbt1 rbt2 :: \"'b :: {ccompare, ceq} set_rbt\" shows\n  \"set_eq A B \\<longleftrightarrow> A \\<subseteq> B \\<and> B \\<subseteq> A\"\n  and set_eq_Complement_Complement [set_complement_code]:\n  \"set_eq (Complement A) (Complement B) = set_eq A B\"\n  and\n  \"set_eq (RBT_set rbt1) (RBT_set rbt2) = \n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''set_eq RBT_set RBT_set: ccompare = None'') (\\<lambda>_. set_eq (RBT_set rbt1) (RBT_set rbt2))\n                     | Some c \\<Rightarrow> \n     (case ID CEQ('b) of None \\<Rightarrow> list_all2_fusion (\\<lambda> x y. c x y = Eq) rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)\n                    | Some eq \\<Rightarrow> list_all2_fusion eq rbt_keys_generator rbt_keys_generator (RBT_Set2.init rbt1) (RBT_Set2.init rbt2)))\"\n  (is ?rbt_rbt)\nproof -\n  show ?rbt_rbt\n    by (auto 4 3 split: option.split simp add: comparator.eq[OF ID_ccompare'] sorted_RBT_Set_keys list_all2_fusion_def unfoldr_rbt_keys_generator RBT_set_conv_keys set_eq_def list.rel_eq dest!: ID_ceq[THEN equal.equal_eq] intro: linorder.sorted_distinct_set_unique[OF ID_ccompare])\nqed(auto simp add: set_eq_def)\n\nlemma Set_project_code [code]:\n  \"Set.filter P A = A \\<inter> Collect_set P\"\nby(auto simp add: Set.filter_def)\n\nlemma Set_image_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"image f (Set_Monad xs) = Set_Monad (map f xs)\"\n  \"image f (Collect_set A) = Code.abort (STR ''image Collect_set'') (\\<lambda>_. image f (Collect_set A))\"\n  and image_Complement_Complement [set_complement_code]:\n  \"image f (Complement (Complement B)) = image f B\"\n  and\n  \"image g (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''image DList_set: ceq = None'') (\\<lambda>_. image g (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (insert \\<circ> g) dxs {})\"\n  (is ?dlist)\n  \"image h (RBT_set rbt) = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''image RBT_set: ccompare = None'') (\\<lambda>_. image h (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (insert \\<circ> h) rbt {})\"\n   (is ?rbt)\nproof -\n  { fix xs have \"fold (insert \\<circ> g) xs {} = g ` set xs\"\n      by(induct xs rule: rev_induct) simp_all }\n  thus ?dlist\n    by(simp add: DList_set_def DList_Set.fold_def DList_Set.Collect_member split: option.split)\n  { fix xs have \"fold (insert \\<circ> h) xs {} = h ` set xs\"\n      by(induct xs rule: rev_induct) simp_all }\n  thus ?rbt by(auto simp add: RBT_set_def fold_conv_fold_keys member_conv_keys split: option.split)\nqed simp_all\n\nlemma the_elem_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"the_elem (Set_Monad [x]) = x\"\n  \"the_elem (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''the_elem DList_set: ceq = None'') (\\<lambda>_. the_elem (DList_set dxs))\n                  | Some _ \\<Rightarrow> \n     case list_of_dlist dxs of [x] \\<Rightarrow> x \n       | _ \\<Rightarrow> Code.abort (STR ''the_elem DList_set: not unique'') (\\<lambda>_. the_elem (DList_set dxs)))\"\n  \"the_elem (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''the_elem RBT_set: ccompare = None'') (\\<lambda>_. the_elem (RBT_set rbt))\n                     | Some _ \\<Rightarrow> \n     case RBT_Mapping2.impl_of rbt of RBT_Impl.Branch _ RBT_Impl.Empty x _ RBT_Impl.Empty \\<Rightarrow> x\n       | _ \\<Rightarrow> Code.abort (STR ''the_elem RBT_set: not unique'') (\\<lambda>_. the_elem (RBT_set rbt)))\"\nby(auto simp add: RBT_set_def DList_set_def DList_Set.Collect_member the_elem_def member_conv_keys split: option.split list.split rbt.split)(simp add: RBT_Set2.keys_def)\n\nlemma Pow_set_conv_fold:\n  \"Pow (set xs \\<union> A) = fold (\\<lambda>x A. A \\<union> insert x ` A) xs (Pow A)\"\nby(induct xs rule: rev_induct)(auto simp add: Pow_insert)\n\nlemma Pow_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Pow A = Collect_set (\\<lambda>B. B \\<subseteq> A)\"\n  \"Pow (Set_Monad xs) = fold (\\<lambda>x A. A \\<union> insert x ` A) xs {{}}\"\n  \"Pow (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Pow DList_set: ceq = None'') (\\<lambda>_. Pow (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>x A. A \\<union> insert x ` A) dxs {{}})\"\n  \"Pow (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''Pow RBT_set: ccompare = None'') (\\<lambda>_. Pow (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x A. A \\<union> insert x ` A) rbt {{}})\"\nby(auto simp add: DList_set_def DList_Set.Collect_member DList_Set.fold_def RBT_set_def fold_conv_fold_keys member_conv_keys Pow_set_conv_fold[where A=\"{}\", simplified] split: option.split)\n\nlemma fold_singleton: \"Finite_Set.fold f x {y} = f y x\"\nby(fastforce simp add: Finite_Set.fold_def intro: fold_graph.intros elim: fold_graph.cases)\n\nlift_definition sum_cfc :: \"('a \\<Rightarrow> 'b :: comm_monoid_add) \\<Rightarrow> ('a, 'b) comp_fun_commute\"\nis \"\\<lambda>f :: 'a \\<Rightarrow> 'b. plus \\<circ> f\"\nby(unfold_locales)(simp add: fun_eq_iff add.left_commute)\n\nlemma sum_code [code]:\n  \"sum f A = (if finite A then set_fold_cfc (sum_cfc f) 0 A else 0)\"\n  by transfer(simp add: sum.eq_fold)\n\nlemma product_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  and dys :: \"'b :: ceq set_dlist\" \n  and rbt1 :: \"'c :: ccompare set_rbt\"\n  and rbt2 :: \"'d :: ccompare set_rbt\" shows\n  \"Product_Type.product A B = Collect_set (\\<lambda>(x, y). x \\<in> A \\<and> y \\<in> B)\"\n\n  \"Product_Type.product (Set_Monad xs) (Set_Monad ys) = \n   Set_Monad (fold (\\<lambda>x. fold (\\<lambda>y rest. (x, y) # rest) ys) xs [])\"\n  (is ?Set_Monad)\n\n  \"Product_Type.product (DList_set dxs) B1 = \n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''product DList_set1: ceq = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) B1)\n                   | Some _ \\<Rightarrow>  DList_Set.fold (\\<lambda>x rest. Pair x ` B1 \\<union> rest) dxs {})\" \n  (is \"?dlist1\")\n\n  \"Product_Type.product A1 (DList_set dys) = \n   (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''product DList_set2: ceq = None'') (\\<lambda>_. Product_Type.product A1 (DList_set dys))\n                   | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>y rest. (\\<lambda>x. (x, y)) ` A1 \\<union> rest) dys {})\"\n  (is \"?dlist2\")\n\n  \"Product_Type.product (DList_set dxs) (DList_set dys) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''product DList_set DList_set: ceq1 = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n                  | Some _ \\<Rightarrow> \n     case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''product DList_set DList_set: ceq2 = None'') (\\<lambda>_. Product_Type.product (DList_set dxs) (DList_set dys))\n                    | Some _ \\<Rightarrow> DList_set (DList_Set.product dxs dys))\"\n\n  \"Product_Type.product (RBT_set rbt1) B2 =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''product RBT_set: ccompare1 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) B2)\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x rest. Pair x ` B2 \\<union> rest) rbt1 {})\"\n  (is \"?rbt1\")\n\n  \"Product_Type.product A2 (RBT_set rbt2) =\n  (case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''product RBT_set: ccompare2 = None'') (\\<lambda>_. Product_Type.product A2 (RBT_set rbt2))\n                     | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>y rest. (\\<lambda>x. (x, y)) ` A2 \\<union> rest) rbt2 {})\"\n  (is \"?rbt2\")\n\n  \"Product_Type.product (RBT_set rbt1) (RBT_set rbt2) =\n  (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''product RBT_set RBT_set: ccompare1 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''product RBT_set RBT_set: ccompare2 = None'') (\\<lambda>_. Product_Type.product (RBT_set rbt1) (RBT_set rbt2))\n                       | Some _ \\<Rightarrow> RBT_set (RBT_Set2.product rbt1 rbt2))\"\nproof -\n  have [simp]: \"\\<And>a zs. fold (\\<lambda>y. (#) (a, y)) ys zs = rev (map (Pair a) ys) @ zs\"\n    by(induct ys) simp_all\n  have [simp]: \"\\<And>zs. fold (\\<lambda>x. fold (\\<lambda>y rest. (x, y) # rest) ys) xs zs = rev (concat (map (\\<lambda>x. map (Pair x) ys) xs)) @ zs\"\n    by(induct xs) simp_all\n  show ?Set_Monad by(auto simp add: Product_Type.product_def)\n\n  { fix xs :: \"'a list\"\n    have \"fold (\\<lambda>x. (\\<union>) (Pair x ` B1)) xs {} = set xs \\<times> B1\"\n      by(induct xs rule: rev_induct) auto }\n  thus ?dlist1 \n    by(simp add: Product_Type.product_def DList_set_def DList_Set.fold.rep_eq DList_Set.Collect_member split: option.split) \n\n  { fix ys :: \"'b list\"\n    have \"fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A1)) ys {} = A1 \\<times> set ys\"\n      by(induct ys rule: rev_induct) auto }\n  thus ?dlist2\n    by(simp add: Product_Type.product_def DList_set_def DList_Set.fold.rep_eq DList_Set.Collect_member split: option.split)\n\n  { fix xs :: \"'c list\"\n    have \"fold (\\<lambda>x. (\\<union>) (Pair x ` B2)) xs {} = set xs \\<times> B2\"\n      by(induct xs rule: rev_induct) auto }\n  thus ?rbt1\n    by(simp add: Product_Type.product_def RBT_set_def RBT_Set2.member_product RBT_Set2.member_conv_keys fold_conv_fold_keys split: option.split)\n\n  { fix ys :: \"'d list\"\n    have \"fold (\\<lambda>y. (\\<union>) ((\\<lambda>x. (x, y)) ` A2)) ys {} = A2 \\<times> set ys\"\n      by(induct ys rule: rev_induct) auto }\n  thus ?rbt2\n    by(simp add: Product_Type.product_def RBT_set_def RBT_Set2.member_product RBT_Set2.member_conv_keys fold_conv_fold_keys split: option.split)\nqed(auto simp add: RBT_set_def DList_set_def Product_Type.product_def DList_Set.product_member RBT_Set2.member_product split: option.split)\n\nlemma Id_on_code [code]: \n  fixes A :: \"'a :: ceq set\"\n  and dxs :: \"'a set_dlist\" \n  and P :: \"'a \\<Rightarrow> bool\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"Id_on B = (\\<lambda>x. (x, x)) ` B\"\n  and Id_on_Complement [set_complement_code]:\n  \"Id_on (Complement A) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on Complement: ceq = None'') (\\<lambda>_. Id_on (Complement A))\n                 | Some eq \\<Rightarrow> Collect_set (\\<lambda>(x, y). eq x y \\<and> x \\<notin> A))\"\n  and\n  \"Id_on (Collect_set P) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on Collect_set: ceq = None'') (\\<lambda>_. Id_on (Collect_set P))\n                 | Some eq \\<Rightarrow> Collect_set (\\<lambda>(x, y). eq x y \\<and> P x))\"\n  \"Id_on (DList_set dxs) = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Id_on DList_set: ceq = None'') (\\<lambda>_. Id_on (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_set (DList_Set.Id_on dxs))\"\n  \"Id_on (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''Id_on RBT_set: ccompare = None'') (\\<lambda>_. Id_on (RBT_set rbt))\n                     | Some _ \\<Rightarrow> RBT_set (RBT_Set2.Id_on rbt))\"\nby(auto simp add: DList_set_def RBT_set_def DList_Set.member_Id_on RBT_Set2.member_Id_on dest: equal.equal_eq[OF ID_ceq] split: option.split)\n\nlemma Image_code [code]:\n  fixes dxs :: \"('a :: ceq \\<times> 'b :: ceq) set_dlist\" \n  and rbt :: \"('c :: ccompare \\<times> 'd :: ccompare) set_rbt\" shows\n  \"X `` Y = snd ` Set.filter (\\<lambda>(x, y). x \\<in> Y) X\"\n  (is ?generic)\n\n  \"Set_Monad rxs `` A = Set_Monad (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs [])\"\n  (is ?Set_Monad)\n  \"DList_set dxs `` B = \n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''Image DList_set: ceq1 = None'') (\\<lambda>_. DList_set dxs `` B)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''Image DList_set: ceq2 = None'') (\\<lambda>_. DList_set dxs `` B)\n                    | Some _ \\<Rightarrow>\n        DList_Set.fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) dxs {})\"\n  (is ?DList_set)\n  \"RBT_set rbt `` C =\n   (case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''Image RBT_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt `` C)\n                      | Some _ \\<Rightarrow>\n      case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''Image RBT_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt `` C)\n                        | Some _ \\<Rightarrow>\n        RBT_Set2.fold (\\<lambda>(x, y) acc. if x \\<in> C then insert y acc else acc) rbt {})\"\n  (is ?RBT_set)\nproof -\n  show ?generic by(auto intro: rev_image_eqI)\n\n  have \"set (fold (\\<lambda>(x, y) rest. if x \\<in> A then y # rest else rest) rxs []) = set rxs `` A\"\n    by(induct rxs rule: rev_induct)(auto split: if_split_asm)\n  thus ?Set_Monad by(auto)\n\n  { fix dxs :: \"('a \\<times> 'b) list\"\n    have \"fold (\\<lambda>(x, y) acc. if x \\<in> B then insert y acc else acc) dxs {} = set dxs `` B\"\n      by(induct dxs rule: rev_induct)(auto split: if_split_asm) }\n  thus ?DList_set\n    by(clarsimp simp add: DList_set_def Collect_member ceq_prod_def ID_Some DList_Set.fold.rep_eq split: option.split)\n\n\n  { fix rbt :: \"(('c \\<times> 'd) \\<times> unit) list\"\n    have \"fold (\\<lambda>(a, _). case a of (x, y) \\<Rightarrow> \\<lambda>acc. if x \\<in> C then insert y acc else acc) rbt {} = (fst ` set rbt) `` C\"\n      by(induct rbt rule: rev_induct)(auto simp add: split_beta split: if_split_asm) }\n  thus ?RBT_set\n    by(clarsimp simp add: RBT_set_def ccompare_prod_def ID_Some RBT_Set2.fold.rep_eq member_conv_keys RBT_Set2.keys.rep_eq RBT_Impl.fold_def RBT_Impl.keys_def split: option.split)\nqed\n\nlemma insert_relcomp: \"insert (a, b) A O B = A O B \\<union> {a} \\<times> {c. (b, c) \\<in> B}\"\nby auto\n\nlemma trancl_code [code]:\n  \"trancl A = \n  (if finite A then ntrancl (card A - 1) A else Code.abort (STR ''trancl: infinite set'') (\\<lambda>_. trancl A))\"\nby (simp add: finite_trancl_ntranl)\n\nlemma set_relcomp_set:\n  \"set xs O set ys = fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if y = y' then insert (x, z) A else A) ys) xs {}\"\nproof(induct xs rule: rev_induct)\n  case Nil show ?case by simp\nnext\n  case (snoc x xs)\n  note [[show_types]]\n  { fix a :: 'a and b :: 'c and X :: \"('a \\<times> 'b) set\"\n    have \"fold (\\<lambda>(y', z) A. if b = y' then insert (a, z) A else A) ys X = X \\<union> {a} \\<times> {c. (b, c) \\<in> set ys}\"\n      by(induct ys arbitrary: X rule: rev_induct)(auto split: if_split_asm) }\n  thus ?case using snoc by(cases x)(simp add: insert_relcomp)\nqed\n\nlemma If_not: \"(if \\<not> a then b else c) = (if a then c else b)\" \nby auto\n\nlemma relcomp_code [code]:\n  fixes rbt1 :: \"('a :: ccompare \\<times> 'b :: ccompare) set_rbt\"\n  and rbt2 :: \"('b \\<times> 'c :: ccompare) set_rbt\"\n  and rbt3 :: \"('a \\<times> 'd :: {ccompare, ceq}) set_rbt\" \n  and rbt4 :: \"('d \\<times> 'a) set_rbt\"\n  and rbt5 :: \"('b \\<times> 'a) set_rbt\"\n  and dxs1 :: \"('d \\<times> 'e :: ceq) set_dlist\" \n  and dxs2 :: \"('e \\<times> 'd) set_dlist\"\n  and dxs3 :: \"('e \\<times> 'f :: ceq) set_dlist\"\n  and dxs4 :: \"('f \\<times> 'g :: ceq) set_dlist\"\n  and xs1 :: \"('h \\<times> 'i :: ceq) list\"\n  and xs2 :: \"('i \\<times> 'j) list\"\n  and xs3 :: \"('b \\<times> 'h) list\"\n  and xs4 :: \"('h \\<times> 'b) list\"\n  and xs5 :: \"('f \\<times> 'h) list\"\n  and xs6 :: \"('h \\<times> 'f) list\"\n  shows\n  \"RBT_set rbt1 O RBT_set rbt2 = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n           | Some c_b \\<Rightarrow>\n       case ID CCOMPARE('c) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set RBT_set: ccompare3 = None'') (\\<lambda>_. RBT_set rbt1 O RBT_set rbt2)\n                         | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) rbt2) rbt1 {})\"\n  (is ?rbt_rbt)\n\n  \"RBT_set rbt3 O DList_set dxs1 = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ccompare1 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ccompare2 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                       | Some _ \\<Rightarrow>\n       case ID CEQ('d) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ceq2 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                     | Some eq \\<Rightarrow>\n         case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set DList_set: ceq3 = None'') (\\<lambda>_. RBT_set rbt3 O DList_set dxs1)\n                        | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs1) rbt3 {})\"\n  (is ?rbt_dlist)\n\n  \"DList_set dxs2 O RBT_set rbt4 = \n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ceq1 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                  | Some _ \\<Rightarrow>\n     case ID CCOMPARE('d) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ceq2 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                       | Some _ \\<Rightarrow>\n       case ID CEQ('d) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ccompare2 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                     | Some eq \\<Rightarrow>\n         case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set RBT_set: ccompare3 = None'') (\\<lambda>_. DList_set dxs2 O RBT_set rbt4)\n                           | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) rbt4) dxs2 {})\"\n  (is ?dlist_rbt)\n\n  \"DList_set dxs3 O DList_set dxs4 =\n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq1 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq2 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                   | Some eq \\<Rightarrow>\n       case ID CEQ('g) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set DList_set: ceq3 = None'') (\\<lambda>_. DList_set dxs3 O DList_set dxs4)\n                      | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs4) dxs3 {})\"\n  (is ?dlist_dlist)\n\n  \"Set_Monad xs1 O Set_Monad xs2 =\n  (case ID CEQ('i) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad Set_Monad: ceq = None'') (\\<lambda>_. Set_Monad xs1 O Set_Monad xs2)\n                 | Some eq \\<Rightarrow> fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) xs2) xs1 {})\"\n  (is ?monad_monad)\n\n  \"RBT_set rbt1 O Set_Monad xs3 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set Set_Monad: ccompare1 = None'') (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp RBT_set Set_Monad: ccompare2 = None'') (\\<lambda>_. RBT_set rbt1 O Set_Monad xs3)\n           | Some c_b \\<Rightarrow> RBT_Set2.fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) xs3) rbt1 {})\"\n  (is ?rbt_monad)\n\n  \"Set_Monad xs4 O RBT_set rbt5 =\n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad RBT_set: ccompare1 = None'') (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n                     | Some _ \\<Rightarrow>\n     case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad RBT_set: ccompare2 = None'') (\\<lambda>_. Set_Monad xs4 O RBT_set rbt5)\n           | Some c_b \\<Rightarrow> fold (\\<lambda>(x, y). RBT_Set2.fold (\\<lambda>(y', z) A. if c_b y y' \\<noteq> Eq then A else insert (x, z) A) rbt5) xs4 {})\"\n  (is ?monad_rbt)\n\n  \"DList_set dxs3 O Set_Monad xs5 =\n  (case ID CEQ('e) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set Set_Monad: ceq1 = None'') (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n                  | Some _ \\<Rightarrow>\n     case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp DList_set Set_Monad: ceq2 = None'') (\\<lambda>_. DList_set dxs3 O Set_Monad xs5)\n                   | Some eq \\<Rightarrow> DList_Set.fold (\\<lambda>(x, y). fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) xs5) dxs3 {})\"\n  (is ?dlist_monad)\n\n  \"Set_Monad xs6 O DList_set dxs4 =\n  (case ID CEQ('f) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad DList_set: ceq1 = None'') (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n                      | Some eq \\<Rightarrow>\n     case ID CEQ('g) of None \\<Rightarrow> Code.abort (STR ''relcomp Set_Monad DList_set: ceq2 = None'') (\\<lambda>_. Set_Monad xs6 O DList_set dxs4)\n                   | Some _ \\<Rightarrow> fold (\\<lambda>(x, y). DList_Set.fold (\\<lambda>(y', z) A. if eq y y' then insert (x, z) A else A) dxs4) xs6 {})\"\n  (is ?monad_dlist)\nproof -\n\n  show ?rbt_rbt ?rbt_monad ?monad_rbt\n    by(auto simp add: comparator.eq[OF ID_ccompare'] RBT_set_def ccompare_prod_def member_conv_keys ID_Some RBT_Set2.fold_conv_fold_keys' RBT_Set2.keys.rep_eq If_not set_relcomp_set split: option.split del: equalityI)\n\n  show ?rbt_dlist ?dlist_rbt ?dlist_dlist ?monad_monad ?dlist_monad ?monad_dlist\n    by(auto simp add: RBT_set_def DList_set_def member_conv_keys ID_Some ccompare_prod_def ceq_prod_def Collect_member RBT_Set2.fold_conv_fold_keys' RBT_Set2.keys.rep_eq DList_Set.fold.rep_eq set_relcomp_set dest: equal.equal_eq[OF ID_ceq] split: option.split del: equalityI)\nqed\n\nlemma irrefl_code [code]:\n  fixes r :: \"('a :: {ceq, ccompare} \\<times> 'a) set\" shows\n  \"irrefl r \\<longleftrightarrow> \n  (case ID CEQ('a) of Some eq \\<Rightarrow> (\\<forall>(x, y) \\<in> r. \\<not> eq x y) | None \\<Rightarrow>\n    case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''irrefl: ceq = None & ccompare = None'') (\\<lambda>_. irrefl r)\n                | Some c \\<Rightarrow> (\\<forall>(x, y) \\<in> r. c x y \\<noteq> Eq))\"\napply(auto simp add: irrefl_distinct comparator.eq[OF ID_ccompare'] split: option.split dest!: ID_ceq[THEN equal.equal_eq])\ndone\n\nlemma wf_code [code]:\n  fixes rbt :: \"('a :: ccompare \\<times> 'a) set_rbt\" \n  and dxs :: \"('b :: ceq \\<times> 'b) set_dlist\" shows\n  \"wf (Set_Monad xs) = acyclic (Set_Monad xs)\"\n  \"wf (RBT_set rbt) = \n  (case ID CCOMPARE('a) of None \\<Rightarrow> Code.abort (STR ''wf RBT_set: ccompare = None'') (\\<lambda>_. wf (RBT_set rbt))\n                     | Some _ \\<Rightarrow> acyclic (RBT_set rbt))\"\n  \"wf (DList_set dxs) =\n  (case ID CEQ('b) of None \\<Rightarrow> Code.abort (STR ''wf DList_set: ceq = None'') (\\<lambda>_. wf (DList_set dxs))\n                     | Some _ \\<Rightarrow> acyclic (DList_set dxs))\"\nby(auto simp add: wf_iff_acyclic_if_finite split: option.split del: iffI)(simp_all add: wf_iff_acyclic_if_finite finite_code ccompare_prod_def ceq_prod_def ID_Some)\n\nlemma bacc_code [code]:\n  \"bacc R 0 = - snd ` R\"\n  \"bacc R (Suc n) = (let rec = bacc R n in rec \\<union> - snd ` (Set.filter (\\<lambda>(y, x). y \\<notin> rec) R))\"\nby(auto intro: rev_image_eqI simp add: Let_def)\n\n(* TODO: acc could also be computed for infinite universes if r is finite *)\n\nlemma acc_code [code]:\n  fixes A :: \"('a :: {finite, card_UNIV} \\<times> 'a) set\" shows\n  \"Wellfounded.acc A = bacc A (of_phantom (card_UNIV :: 'a card_UNIV))\"\nby(simp add: card_UNIV acc_bacc_eq)\n\nlemma sorted_list_of_set_code [code]:\n  fixes dxs :: \"'a :: {linorder, ceq} set_dlist\"\n  and rbt :: \"'b :: {linorder, ccompare} set_rbt\"\n  shows\n  \"sorted_list_of_set (Set_Monad xs) = sort (remdups xs)\"\n  \"sorted_list_of_set (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''sorted_list_of_set DList_set: ceq = None'') (\\<lambda>_. sorted_list_of_set (DList_set dxs))\n                  | Some _ \\<Rightarrow> sort (list_of_dlist dxs))\"\n  \"sorted_list_of_set (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''sorted_list_of_set RBT_set: ccompare = None'') (\\<lambda>_. sorted_list_of_set (RBT_set rbt))\n                     | Some _ \\<Rightarrow> sort (RBT_Set2.keys rbt))\"\n  \\<comment> \\<open>We must sort the keys because @{term ccompare}'s ordering need not coincide with @{term linorder}'s.\\<close>\nby(auto simp add: DList_set_def RBT_set_def sorted_list_of_set_sort_remdups Collect_member distinct_remdups_id distinct_list_of_dlist member_conv_keys split: option.split)\n\nlemma map_project_set: \"List.map_project f (set xs) = set (List.map_filter f xs)\"\nby(auto simp add: List.map_project_def List.map_filter_def intro: rev_image_eqI)\n\nlemma map_project_simps:\n  shows map_project_empty: \"List.map_project f {} = {}\"\n  and map_project_insert: \n  \"List.map_project f (insert x A) = \n  (case f x of None \\<Rightarrow> List.map_project f A \n   | Some y \\<Rightarrow> insert y (List.map_project f A))\"\nby(auto simp add: List.map_project_def split: option.split)\n\nlemma map_project_conv_fold: \n  \"List.map_project f (set xs) = \n   fold (\\<lambda>x A. case f x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) xs {}\"\nby(induct xs rule: rev_induct)(simp_all add: map_project_simps cong: option.case_cong)\n\nlemma map_project_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"List.map_project f (Set_Monad xs) = Set_Monad (List.map_filter f xs)\"\n  \"List.map_project g (DList_set dxs) = \n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''map_project DList_set: ceq = None'') (\\<lambda>_. List.map_project g (DList_set dxs))\n                   | Some _ \\<Rightarrow> DList_Set.fold (\\<lambda>x A. case g x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) dxs {})\"\n  (is ?dlist)\n  \"List.map_project h (RBT_set rbt) = \n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''map_project RBT_set: ccompare = None'') (\\<lambda>_. List.map_project h (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (\\<lambda>x A. case h x of None \\<Rightarrow> A | Some y \\<Rightarrow> insert y A) rbt {})\"\n  (is ?rbt)\nproof -\n  show ?dlist ?rbt\n    by(auto split: option.split simp add: RBT_set_def DList_set_def DList_Set.fold.rep_eq Collect_member map_project_conv_fold RBT_Set2.fold_conv_fold_keys member_conv_keys del: equalityI)\nqed(auto simp add: List.map_project_def List.map_filter_def intro: rev_image_eqI)\n\nlemma Bleast_code [code]:\n  \"Bleast A P = \n  (if finite A then case filter P (sorted_list_of_set A) of [] \\<Rightarrow> abort_Bleast A P | x # xs \\<Rightarrow> x \n   else abort_Bleast A P)\"\nproof(cases \"finite A\")\n  case True\n  hence *: \"A = set (sorted_list_of_set A)\" by(simp add: sorted_list_of_set)\n  show ?thesis using True\n    by(subst (1 3) *)(unfold Bleast_code, simp add: sorted_sort_id)\nqed(simp add: abort_Bleast_def Bleast_def)\n\nlemma can_select_code [code]:\n  fixes xs :: \"'a :: ceq list\" \n  and dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"can_select P (Set_Monad xs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''can_select Set_Monad: ceq = None'') (\\<lambda>_. can_select P (Set_Monad xs))\n                 | Some eq \\<Rightarrow> case filter P xs of Nil \\<Rightarrow> False | x # xs \\<Rightarrow> list_all (eq x) xs)\"\n  (is ?Set_Monad)\n  \"can_select Q (DList_set dxs) =\n  (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''can_select DList_set: ceq = None'') (\\<lambda>_. can_select Q (DList_set dxs))\n                  | Some _ \\<Rightarrow> DList_Set.length (DList_Set.filter Q dxs) = 1)\"\n  (is ?dlist)\n  \"can_select R (RBT_set rbt) =\n  (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''can_select RBT_set: ccompare = None'') (\\<lambda>_. can_select R (RBT_set rbt))\n                 | Some _ \\<Rightarrow> singleton_list_fusion (filter_generator R rbt_keys_generator) (RBT_Set2.init rbt))\"\n  (is ?rbt)\nproof -\n  show ?Set_Monad\n    apply(auto split: option.split list.split dest!: ID_ceq[THEN equal.equal_eq] dest: filter_eq_ConsD simp add: can_select_def filter_empty_conv list_all_iff)\n    apply(drule filter_eq_ConsD, fastforce)\n    apply(drule filter_eq_ConsD, clarsimp, blast)\n    done\n  \n  show ?dlist\n    by(clarsimp simp add: can_select_def card_eq_length[symmetric] Set_member_code card_eq_Suc_0_ex1 simp del: card_eq_length split: option.split)\n  \n  note [simp del] = distinct_keys\n  show ?rbt\n    using distinct_keys[of rbt]\n    apply(auto simp add: can_select_def singleton_list_fusion_def unfoldr_filter_generator unfoldr_rbt_keys_generator Set_member_code member_conv_keys filter_empty_conv empty_filter_conv split: option.split list.split dest: filter_eq_ConsD)\n      apply(drule filter_eq_ConsD, fastforce)\n     apply(drule filter_eq_ConsD, fastforce simp add: empty_filter_conv)\n    apply(drule filter_eq_ConsD)\n    apply clarsimp\n    apply(drule Cons_eq_filterD)\n    apply clarify\n    apply(simp (no_asm_use))\n    apply blast\n    done\nqed\n\nlemma pred_of_set_code [code]:\n  fixes dxs :: \"'a :: ceq set_dlist\" \n  and rbt :: \"'b :: ccompare set_rbt\" shows\n  \"pred_of_set (Set_Monad xs) = fold (sup \\<circ> Predicate.single) xs bot\"\n  \"pred_of_set (DList_set dxs) =\n   (case ID CEQ('a) of None \\<Rightarrow> Code.abort (STR ''pred_of_set DList_set: ceq = None'') (\\<lambda>_. pred_of_set (DList_set dxs))\n                   | Some _ \\<Rightarrow> DList_Set.fold (sup \\<circ> Predicate.single) dxs bot)\"\n  \"pred_of_set (RBT_set rbt) =\n   (case ID CCOMPARE('b) of None \\<Rightarrow> Code.abort (STR ''pred_of_set RBT_set: ccompare = None'') (\\<lambda>_. pred_of_set (RBT_set rbt))\n                      | Some _ \\<Rightarrow> RBT_Set2.fold (sup \\<circ> Predicate.single) rbt bot)\"\nby(auto simp add: pred_of_set_set_fold_sup fold_map DList_set_def RBT_set_def Collect_member member_conv_keys DList_Set.fold.rep_eq fold_conv_fold_keys split: option.split)\n\ntext \\<open>\n  @{typ \"'a Predicate.pred\"} is implemented as a monad, \n  so we keep the monad when converting to @{typ \"'a set\"}. \n  For this case, @{term insert_monad} and @{term union_monad} \n  avoid the unnecessary dictionary construction.\n\\<close>\n\ndefinition insert_monad :: \"'a \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\nwhere [simp]: \"insert_monad = insert\"\n\ndefinition union_monad :: \"'a set \\<Rightarrow> 'a set \\<Rightarrow> 'a set\"\nwhere [simp]: \"union_monad = (\\<union>)\"\n\nlemma insert_monad_code [code]:\n  \"insert_monad x (Set_Monad xs) = Set_Monad (x # xs)\"\nby simp\n\nlemma union_monad_code [code]:\n  \"union_monad (Set_Monad xs) (Set_Monad ys) = Set_Monad (xs @ ys)\"\nby(simp)\n\nlemma set_of_pred_code [code]:\n  \"set_of_pred (Predicate.Seq f) = \n  (case f () of seq.Empty \\<Rightarrow> Set_Monad []\n   | seq.Insert x P \\<Rightarrow> insert_monad x (set_of_pred P)\n   | seq.Join P xq \\<Rightarrow> union_monad (set_of_pred P) (set_of_seq xq))\"\nby(simp add: of_pred_code cong: seq.case_cong)\n\nlemma set_of_seq_code [code]:\n  \"set_of_seq seq.Empty = Set_Monad []\"\n  \"set_of_seq (seq.Insert x P) = insert_monad x (set_of_pred P)\"\n  \"set_of_seq (seq.Join P xq) = union_monad (set_of_pred P) (set_of_seq xq)\"\nby(simp_all add: of_seq_code)\n\nhide_const (open) insert_monad union_monad\n\nsubsection \\<open>Type class instantiations\\<close>\n\ndatatype set_impl = Set_IMPL\ndeclare\n  set_impl.eq.simps [code del]\n  set_impl.size [code del]\n  set_impl.rec [code del]\n  set_impl.case [code del]\n\n\n\ndefinition set_Choose :: set_impl where [simp]: \"set_Choose = Set_IMPL\"\ndefinition set_Collect :: set_impl where [simp]: \"set_Collect = Set_IMPL\"\ndefinition set_DList :: set_impl where [simp]: \"set_DList = Set_IMPL\"\ndefinition set_RBT :: set_impl where [simp]: \"set_RBT = Set_IMPL\"\ndefinition set_Monad :: set_impl where [simp]: \"set_Monad = Set_IMPL\"\n\ncode_datatype set_Choose set_Collect set_DList set_RBT set_Monad\n\ndefinition set_empty_choose :: \"'a set\" where [simp]: \"set_empty_choose = {}\"\n\nlemma set_empty_choose_code [code]:\n  \"(set_empty_choose :: 'a :: {ceq, ccompare} set) =\n   (case CCOMPARE('a) of Some _  \\<Rightarrow> RBT_set RBT_Set2.empty\n    | None \\<Rightarrow> case CEQ('a) of None \\<Rightarrow> Set_Monad [] | Some _ \\<Rightarrow> DList_set (DList_Set.empty))\"\nby(simp split: option.split)\n\ndefinition set_impl_choose2 :: \"set_impl \\<Rightarrow> set_impl \\<Rightarrow> set_impl\"\nwhere [simp]: \"set_impl_choose2 = (\\<lambda>_ _. Set_IMPL)\"\n\nlemma set_impl_choose2_code [code]:\n  \"set_impl_choose2 x y = set_Choose\"\n  \"set_impl_choose2 set_Collect set_Collect = set_Collect\"\n  \"set_impl_choose2 set_DList set_DList = set_DList\"\n  \"set_impl_choose2 set_RBT set_RBT = set_RBT\"\n  \"set_impl_choose2 set_Monad set_Monad = set_Monad\"\nby(simp_all)\n\ndefinition set_empty :: \"set_impl \\<Rightarrow> 'a set\"\nwhere [simp]: \"set_empty = (\\<lambda>_. {})\"\n\nlemma set_empty_code [code]:\n  \"set_empty set_Collect = Collect_set (\\<lambda>_. False)\"\n  \"set_empty set_DList = DList_set DList_Set.empty\"\n  \"set_empty set_RBT = RBT_set RBT_Set2.empty\"\n  \"set_empty set_Monad = Set_Monad []\"\n  \"set_empty set_Choose = set_empty_choose\"\nby(simp_all)\n\nclass set_impl =\n  fixes set_impl :: \"('a, set_impl) phantom\"\n\nsyntax (input)\n  \"_SET_IMPL\" :: \"type => logic\"  (\"(1SET'_IMPL/(1'(_')))\")\n\nparse_translation \\<open>\nlet\n  fun set_impl_tr [ty] =\n     (Syntax.const @{syntax_const \"_constrain\"} $ Syntax.const @{const_syntax \"set_impl\"} $\n       (Syntax.const @{type_syntax phantom} $ ty $ Syntax.const @{type_syntax set_impl}))\n    | set_impl_tr ts = raise TERM (\"set_impl_tr\", ts);\nin [(@{syntax_const \"_SET_IMPL\"}, K set_impl_tr)] end\n\\<close>\n\ndeclare [[code drop: \"{}\"]]\n\nlemma empty_code [code, code_unfold]: \n  \"({} :: 'a :: set_impl set) = set_empty (of_phantom SET_IMPL('a))\"\nby simp\n\nsubsection \\<open>Generator for the @{class set_impl}-class\\<close>\n\ntext \\<open>\nThis generator registers itself at the derive-manager for the classes @{class set_impl}.\nHere, one can choose\nthe desired implementation via the parameter.\n\n\\begin{itemize}\n\\item \\texttt{instantiation type :: (type,\\ldots,type) (rbt,dlist,collect,monad,choose, or arbitrary constant name) set-impl}\n\\end{itemize}\n\\<close>\n\n\ntext \\<open>\nThis generator can be used for arbitrary types, not just datatypes. \n\\<close>\n\nML_file \\<open>set_impl_generator.ML\\<close> \n\nderive (dlist) set_impl unit bool\nderive (rbt) set_impl nat\nderive (set_RBT) set_impl int (* shows usage of constant names *)\nderive (dlist) set_impl Enum.finite_1 Enum.finite_2 Enum.finite_3\nderive (rbt) set_impl integer natural\nderive (rbt) set_impl char\n\ninstantiation sum :: (set_impl, set_impl) set_impl begin\ndefinition \"SET_IMPL('a + 'b) = Phantom('a + 'b) \n  (set_impl_choose2 (of_phantom SET_IMPL('a)) (of_phantom SET_IMPL('b)))\"\ninstance ..\nend\n\ninstantiation prod :: (set_impl, set_impl) set_impl begin\ndefinition \"SET_IMPL('a * 'b) = Phantom('a * 'b) \n  (set_impl_choose2 (of_phantom SET_IMPL('a)) (of_phantom SET_IMPL('b)))\"\ninstance ..\nend\n\nderive (choose) set_impl list\nderive (rbt) set_impl String.literal\n\ninstantiation option :: (set_impl) set_impl begin\ndefinition \"SET_IMPL('a option) = Phantom('a option) (of_phantom SET_IMPL('a))\"\ninstance ..\nend\n\nderive (monad) set_impl \"fun\"\nderive (choose) set_impl set\n\ninstantiation phantom :: (type, set_impl) set_impl begin\ndefinition \"SET_IMPL(('a, 'b) phantom) = Phantom (('a, 'b) phantom) (of_phantom SET_IMPL('b))\"\ninstance ..\nend\n\ntext \\<open>\n  We enable automatic implementation selection for sets constructed by @{const set},\n  although they could be directly converted using @{const Set_Monad} in constant time.\n  However, then it is more likely that the parameters of binary operators have \n  different implementations, which can lead to less efficient execution.\n\n  However, we test whether automatic selection picks @{const Set_Monad} anyway and\n  take a short-cut.\n\\<close>\n\ndefinition set_aux :: \"set_impl \\<Rightarrow> 'a list \\<Rightarrow> 'a set\"\nwhere [simp, code del]: \"set_aux _ = set\"\n\nlemma set_aux_code [code]:\n  defines \"conv \\<equiv> foldl (\\<lambda>s (x :: 'a). insert x s)\"\n  shows\n  \"set_aux impl = conv (set_empty impl)\" (is \"?thesis1\")\n  \"set_aux set_Choose = \n   (case CCOMPARE('a :: {ccompare, ceq}) of Some _  \\<Rightarrow> conv (RBT_set RBT_Set2.empty)\n    | None \\<Rightarrow> case CEQ('a) of None \\<Rightarrow> Set_Monad\n              | Some _ \\<Rightarrow> conv (DList_set DList_Set.empty))\" (is \"?thesis2\")\n  \"set_aux set_Monad = Set_Monad\"\nproof -\n  have \"conv {} = set\"\n    by(rule ext)(induct_tac x rule: rev_induct, simp_all add: conv_def)\n  thus ?thesis1 ?thesis2\n    by(simp_all split: option.split)\nqed simp\n\nlemma set_code [code]:\n  fixes xs :: \"'a :: set_impl list\"\n  shows \"set xs = set_aux (of_phantom (ID SET_IMPL('a))) xs\"\nby(simp)\n\nsubsection \\<open>Pretty printing for sets\\<close>\n\ntext \\<open>\n  @{term code_post} marks contexts (as hypothesis) in which we use code\\_post as a\n  decision procedure rather than a pretty-printing engine. \n  The intended use is to enable more rules when proving assumptions of rewrite rules.\n\\<close>\n\ndefinition code_post :: bool where \"code_post = True\"\n\nlemma conj_code_post [code_post]: \n  assumes code_post\n  shows \"True & x \\<longleftrightarrow> x\" \"False & x \\<longleftrightarrow> False\"\nby simp_all\n\ntext \\<open>\n  A flag to switch post-processing of sets on and off.\n  Use \\verb$declare pretty_sets[code_post del]$ to disable pretty printing of sets in value.\n\\<close>\n\ndefinition code_post_set :: bool\nwhere pretty_sets [code_post, simp]: \"code_post_set = True\"\n\ndefinition collapse_RBT_set :: \"'a set_rbt \\<Rightarrow> 'a :: ccompare set \\<Rightarrow> 'a set\"\nwhere \"collapse_RBT_set r M = set (RBT_Set2.keys r) \\<union> M\"\n\nlemma RBT_set_collapse_RBT_set [code_post]:\n  fixes r :: \"'a :: ccompare set_rbt\"\n  assumes \"code_post \\<Longrightarrow> is_ccompare TYPE('a)\" and code_post_set\n  shows \"RBT_set r = collapse_RBT_set r {}\"\nusing assms\nby(clarsimp simp add: code_post_def is_ccompare_def RBT_set_def member_conv_keys collapse_RBT_set_def)\n\nlemma collapse_RBT_set_Branch [code_post]: \n  \"collapse_RBT_set (Mapping_RBT (Branch c l x v r)) M =\n   collapse_RBT_set (Mapping_RBT l) (insert x (collapse_RBT_set (Mapping_RBT r) M))\"\nunfolding collapse_RBT_set_def\nby(auto simp add: is_ccompare_def set_keys_Mapping_RBT)\n\nlemma collapse_RBT_set_Empty [code_post]: \n  \"collapse_RBT_set (Mapping_RBT rbt.Empty) M = M\"\nby(auto simp add: collapse_RBT_set_def set_keys_Mapping_RBT)\n\ndefinition collapse_DList_set :: \"'a :: ceq set_dlist \\<Rightarrow> 'a set\"\nwhere \"collapse_DList_set dxs = set (DList_Set.list_of_dlist dxs)\"\n\nlemma DList_set_collapse_DList_set [code_post]:\n  fixes dxs :: \"'a :: ceq set_dlist\"\n  assumes \"code_post \\<Longrightarrow> is_ceq TYPE('a)\" and code_post_set\n  shows \"DList_set dxs = collapse_DList_set dxs\"\nusing assms\nby(clarsimp simp add: code_post_def DList_set_def is_ceq_def collapse_DList_set_def Collect_member)\n\nlemma collapse_DList_set_empty [code_post]: \"collapse_DList_set (Abs_dlist []) = {}\"\nby(simp add: collapse_DList_set_def Abs_dlist_inverse)\n\nlemma collapse_DList_set_Cons [code_post]: \n  \"collapse_DList_set (Abs_dlist (x # xs)) = insert x (collapse_DList_set (Abs_dlist xs))\"\nby(simp add: collapse_DList_set_def set_list_of_dlist_Abs_dlist)\n\nlemma Set_Monad_code_post [code_post]:\n  assumes code_post_set\n  shows \"Set_Monad [] = {}\"\n  and \"Set_Monad (x#xs) = insert x (Set_Monad xs)\"\nby simp_all\n\nend\n"}
{"text": "import game.world7.level6 -- hide\n/- \n# Advanced proposition world. \n\n## Level 7: `or_symm`\n\nProving that $(P\\lor Q)\\implies(Q\\lor P)$ involves an element of danger.\n`intro h,` is the obvious start. But now,\neven though the goal is an `\u2228` statement, both `left` and `right` put\nyou in a situation with an impossible goal. Fortunately, after `intro h,`\nyou can do `cases h with p q`. Then something new happens: because\nthere are two ways to prove `P \u2228 Q` (namely, proving `P` or proving `Q`),\nthe `cases` tactic turns one goal into two, one for each case. You should\nbe able to make it home from there. \n-/\n\n\n\n/- Lemma\nIf $P$ and $Q$ are true/false statements, then\n$$P\\lor Q\\implies Q\\lor P.$$ \n-/\nlemma or_symm (P Q : Prop) : P \u2228 Q \u2192 Q \u2228 P :=\nbegin\n  intro h,\n  cases h with p q,\n    right,\n    exact p,\n  left,\n  exact q,\n\n\nend\n"}
{"text": "import m114 algebra.pi_instances rename_var\n\nlemma abs_inferieur_ssi (x y : \u211d) : |x| \u2264 y \u2194 -y \u2264 x \u2227 x \u2264 y :=\nabs_le\n\nvariables {\u03b1 : Type*} [decidable_linear_order \u03b1]\nlemma superieur_max_ssi (p q r : \u03b1) : r \u2265 max p q  \u2194 r \u2265 p \u2227 r \u2265 q :=\nmax_le_iff\n\nlemma inferieur_max_gauche (p q : \u03b1) : p \u2264 max p q :=\nle_max_left _ _\n\nlemma inferieur_max_droite (p q : \u03b1) : q \u2264 max p q :=\nle_max_right _ _\n\nlemma egal_si_abs_diff_neg {a b : \u211d} : |a - b| \u2264 0 \u2192 a = b :=\ndecidable_linear_ordered_comm_group.eq_of_abs_sub_nonpos\n-- Pour la lib\nlemma egal_si_abs_eps (x y : \u211d) : (\u2200 \u03b5 > 0, |x - y| \u2264 \u03b5) \u2192 x = y :=\nbegin\n  intro h,\n  apply egal_si_abs_diff_neg,\n  by_contradiction H,\n  push_neg at H,\n  specialize h ( |x-y|/2) (by linarith),\n  linarith,\nend\n\nlemma ineg_triangle (x y : \u211d) : |x + y| \u2264 |x| + |y| :=\nabs_add x y\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem imo_1961_p1\n  (x y z a b : \u211d)\n  (h\u2080 : 0 < x \u2227 0 < y \u2227 0 < z)\n  (h\u2081 : x \u2260 y)\n  (h\u2082 : y \u2260 z)\n  (h\u2083 : z \u2260 x)\n  (h\u2084 : x + y + z = a)\n  (h\u2085 : x^2 + y^2 + z^2 = b^2)\n  (h\u2086 : x * y = z^2) :\n  0 < a \u2227 b^2 < a^2 \u2227 a^2 < 3 * b^2 :=\nbegin\n  simp [*, sq] at *,\n  split,\n  nlinarith,\n  split,\n  apply lt_of_not_ge,\n  cases a,\n  rw add_comm at *,\n  nlinarith,\n  apply lt_of_not_ge,\n  contrapose! h\u2082,\n  apply le_antisymm,\n  contrapose! h\u2083,\n  apply eq_of_sub_eq_zero,\n  symmetry,\n  nlinarith,\n  apply le_of_not_gt,\n  intros h1,\n  apply_assumption,\n  nlinarith [h1],\nend"}
{"text": "lemma homeomorphism_empty [simp]: \"homeomorphism {} {} f g\""}
{"text": "theorem easy (P Q : Prop) (HP : P) (HPQ : P \u2192 Q) : Q :=\nbegin\n  sorry\nend\n"}
{"text": "set_option pp.analyze false\n\ndef p (x y : Nat) := x = y\n\nexample (x y : Nat) : p (x + y) (y + x + 0) := by\n  conv =>\n    whnf\n    congr\n    . skip\n    . whnf; skip\n  trace_state\n  rw [Nat.add_comm]\n  rfl\n\nexample (x y : Nat) : p (x + y) (y + x + 0) := by\n  conv =>\n    whnf\n    rhs\n    whnf\n  trace_state\n  rw [Nat.add_comm]\n  rfl\n\nexample (x y : Nat) : p (x + y) (y + x + 0) := by\n  conv =>\n    whnf\n    lhs\n    whnf\n  conv =>\n    rhs\n    whnf\n  trace_state\n  apply Nat.add_comm x y\n\nexample (x y : Nat) : p (x + y) (0 + y + x) := by\n  conv =>\n    whnf\n    rhs\n    rw [Nat.zero_add, Nat.add_comm]\n    trace_state\n    skip\n    done\n\naxiom div_self (x : Nat) : x \u2260 0 \u2192 x / x = 1\n\nexample (h : x \u2260 0) : x / x + x = x.succ := by\n  conv =>\n    lhs\n    arg 1\n    rw [div_self]\n    skip\n    tactic => assumption\n    done\n  show 1 + x = x.succ\n  rw [Nat.succ_add, Nat.zero_add]\n\nexample (h1 : x \u2260 0) (h2 : y = x / x) : y = 1 := by\n  conv at h2 =>\n    rhs\n    rw [div_self]\n    skip\n    tactic => assumption\n  assumption\n\nexample : id (fun x => 0 + x) = id := by\n  conv =>\n    lhs\n    arg 1\n    ext y\n    rw [Nat.zero_add]\n\ndef f (x : Nat) :=\n  if x > 0 then\n    x + 1\n  else\n    x + 2\n\nexample (g : Nat \u2192 Nat) (h\u2081 : g x = x + 1) (h\u2082 : x > 0) : g x = f x := by\n  conv =>\n    rhs\n    simp [f, h\u2082]\n  exact h\u2081\n\nexample (h\u2081 : f x = x + 1) (h\u2082 : x > 0) : f x = f x := by\n  conv =>\n    rhs\n    simp [f, h\u2082]\n  exact h\u2081\n\nexample (x y : Nat) (f : Nat \u2192 Nat \u2192 Nat) (g : Nat \u2192 Nat) (h\u2081 : \u2200 z, f z z = z) (h\u2082 : \u2200 x y, f (g x) (g y) = y) : f (g (0 + y)) (f (g x) (g (x + 0))) = x := by\n  conv in _ + 0 => apply Nat.add_zero\n  trace_state\n  conv in 0 + _ => apply Nat.zero_add\n  trace_state\n  simp [h\u2081, h\u2082]\n\nexample (x y : Nat) (f : Nat \u2192 Nat \u2192 Nat) (g : Nat \u2192 Nat)\n        (h\u2081 : \u2200 z, f z z = z) (h\u2082 : \u2200 x y, f (g x) (g y) = y)\n        (h\u2083 : f (g (0 + x)) (g x) = 0)\n : g x = 0 := by\n  conv at h\u2083 in 0 + x => apply Nat.zero_add\n  trace_state\n  conv at h\u2083 => lhs; apply h\u2081\n  trace_state\n  assumption\n"}
{"text": "lemma both_and (P Q : Prop) (p : P) (q : Q) : P \u2227 Q :=\nbegin\n    split,\n    {\n        exact p,\n    },\n    {\n        exact q,\n    },\nend"}
{"text": "def f (x y : Nat) := x + 2*y\n\nnamespace Foo\n\nlocal infix:65 (priority := high) \"+\" => f\n\ntheorem ex1 (x y : Nat) : x + y = f x y := rfl\n\n#check 1 + 2\n\nend Foo\n\n#check 1 + 2\ntheorem ex2 (x y : Nat) : x + y = HAdd.hAdd x y := rfl\n\nopen Foo\n\ntheorem ex3 (x y : Nat) : x + y = HAdd.hAdd x y := rfl\n#check 1 + 2\n\nsection\ndef g (x y : Nat) := 3*(x+y)\n\nlocal infix:65 (priority := high) \"  +  \" => g\n\ntheorem ex4 (x y : Nat) : x + y = g x y := rfl\n\n#check 1 + 2\n\nend\n\ntheorem ex5 (x y : Nat) : x + y = HAdd.hAdd x y := rfl\n#check 1 + 2\n"}
{"text": "@[default_instance] instance : Pow Int Nat where\n  pow m n := m ^ n\n\ninstance : @Trans Int Int Int (\u00b7 < \u00b7) (\u00b7 < \u00b7) (\u00b7 < \u00b7) where\n  trans := sorry\n\nexample {n : Int} : n ^ 2 < 1 :=\n  calc\n    n ^ 2 < 1 ^ 2 := sorry\n    _ < 1 := sorry\n"}
{"text": "[GOAL]\nS : Set \u210d\n\u22a2 S \u2208 atImInfty \u2194 \u2203 A, \u2200 (z : \u210d), A \u2264 im z \u2192 z \u2208 S\n[PROOFSTEP]\nsimp only [atImInfty_basis.mem_iff, true_and]\n[GOAL]\nS : Set \u210d\n\u22a2 (\u2203 i, im \u207b\u00b9' Set.Ici i \u2286 S) \u2194 \u2203 A, \u2200 (z : \u210d), A \u2264 im z \u2192 z \u2208 S\n[PROOFSTEP]\nrfl\n[GOAL]\nf g : \u210d \u2192 \u2102\nhf : IsBoundedAtImInfty f\nhg : IsBoundedAtImInfty g\n\u22a2 IsBoundedAtImInfty (f * g)\n[PROOFSTEP]\nsimpa only [Pi.one_apply, mul_one, norm_eq_abs] using hf.mul hg\n[GOAL]\nf : \u210d \u2192 \u2102\n\u22a2 IsBoundedAtImInfty f \u2194 \u2203 M A, \u2200 (z : \u210d), A \u2264 im z \u2192 \u2191Complex.abs (f z) \u2264 M\n[PROOFSTEP]\nsimp [IsBoundedAtImInfty, BoundedAtFilter, Asymptotics.isBigO_iff, Filter.Eventually, atImInfty_mem]\n[GOAL]\nf : \u210d \u2192 \u2102\n\u22a2 (\u2200 (ib : \u211d), 0 < ib \u2192 \u2203 ia, True \u2227 \u2200 (x : \u210d), x \u2208 im \u207b\u00b9' Set.Ici ia \u2192 f x \u2208 Metric.closedBall 0 ib) \u2194\n    \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 A, \u2200 (z : \u210d), A \u2264 im z \u2192 \u2191Complex.abs (f z) \u2264 \u03b5\n[PROOFSTEP]\nsimp only [true_and, mem_closedBall_zero_iff]\n[GOAL]\nf : \u210d \u2192 \u2102\n\u22a2 (\u2200 (ib : \u211d), 0 < ib \u2192 \u2203 ia, \u2200 (x : \u210d), x \u2208 im \u207b\u00b9' Set.Ici ia \u2192 \u2016f x\u2016 \u2264 ib) \u2194\n    \u2200 (\u03b5 : \u211d), 0 < \u03b5 \u2192 \u2203 A, \u2200 (z : \u210d), A \u2264 im z \u2192 \u2191Complex.abs (f z) \u2264 \u03b5\n[PROOFSTEP]\nrfl\n"}
{"text": "\nuniverse u\n\ndef f {\u03b1 : Type u} [BEq \u03b1] (xs : List \u03b1) (y : \u03b1) : \u03b1 := do\nfor x in xs do\n  if x == y then\n    return x\nreturn y\n\nstructure S :=\n(key val : Nat)\n\ninstance : BEq S :=\n\u27e8fun a b => a.key == b.key\u27e9\n\ntheorem ex1 : f (\u03b1 := S) [\u27e81, 2\u27e9, \u27e83, 4\u27e9, \u27e85, 6\u27e9] \u27e83, 0\u27e9 = \u27e83, 4\u27e9 :=\nrfl\n\ntheorem ex2 : f (\u03b1 := S) [\u27e81, 2\u27e9, \u27e83, 4\u27e9, \u27e85, 6\u27e9] \u27e84, 10\u27e9 = \u27e84, 10\u27e9 :=\nrfl\n"}
{"text": "lemmas continuous_Im [simp] = bounded_linear.continuous [OF bounded_linear_Im]"}
{"text": "theory deMorgan1\n  imports Main\n\nbegin \n\ntext\\<open> Apply style \\<close>\ntheorem de_morgan_1 : \"(\\<not> (p \\<or> q)) \\<longrightarrow> (\\<not> p \\<and> \\<not> q)\"\n  apply (rule impI)\n  apply (rule conjI)\n  apply (rule notI)\n  apply (erule notE)\n  apply (rule disjI1)\n  apply assumption\n  apply (rule notI)\n  apply (erule notE)\n  apply (rule disjI2)\n  apply assumption\n  done\nend"}
{"text": "/-\nCopyright \u00a9 2018 Fran\u00e7ois G. Dorais. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\n-/\n\nimport fin.choice\nimport .basic .subst .mod .prf\n\nuniverse u\nvariables {\u03c3 : Type u} {sig : \u03c3 \u2192 \u2115} {I : Type*} (ax : I \u2192 eqn sig)\ninclude sig ax\n\nlemma proof.sound {\u03b1 : Type*} (a : alg sig \u03b1) (ha : \u2200 i, sat a (ax i)) :\n\u2200 {t u : term sig}, proof ax t u \u2192 (a \u22a7 t \u2261 u)\n| ._ ._ (proof.axm ax i sub) val :=\n  let val' := \u03bb n, eval a val (sub n) in\n  calc\n  eval a val (subst sub ((ax i).fst))\n      = eval a val' ((ax i).fst)            : by rw subst_eval\n  ... = eval a val' ((ax i).snd)            : by rw ha i val' \n  ... = eval a val (subst sub ((ax i).snd)) : by rw subst_eval\n| (term.var .(n)) (term.var .(n)) (proof.var ax n) val := rfl\n| (term.app .(s) ts) (term.app .(s) us) (proof.app s ps) val :=\n  have tup.map (eval a val) ts = tup.map (eval a val) us,\n  from tup.ext (\u03bb i, proof.sound (ps i) val),\n  calc\n  eval a val (term.app s ts) \n      = a.app s (tup.map (eval a val) ts) : by rw eval_app\n  ... = a.app s (tup.map (eval a val) us) : by rw this\n  ... = eval a val (term.app s us)        : by rw eval_app\n| .(t) .(u) (proof.euc t u v ptv puv) val :=\n  calc\n  eval a val t\n      = eval a val v : by rw proof.sound ptv val\n  ... = eval a val u : by rw proof.sound puv val\n\ntheorem soundness {{t u : term sig}} : (ax \u22a2 t \u2261 u) \u2192 (ax \u22a8 t \u2261 u) := \n\u03bb p _ a ha, proof.sound ax a ha p\n"}
{"text": "[STATEMENT]\ntheorem terminates_iff_terminates_merge_guards:\n  \"\\<Gamma>\\<turnstile>c\\<down> s = \\<Gamma>\\<turnstile>merge_guards c\\<down> s\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<Gamma>\\<turnstile>c \\<down> s = \\<Gamma>\\<turnstile>merge_guards c \\<down> s\n[PROOF STEP]\nby (iprover intro: terminates_to_terminates_merge_guards\n    terminates_merge_guards_to_terminates)"}
{"text": "(* *********************************************************************)\n(*                                                                     *)\n(*            The CertiKOS Certified Kit Operating System              *)\n(*                                                                     *)\n(*                   The FLINT Group, Yale University                  *)\n(*                                                                     *)\n(*  Copyright The FLINT Group, Yale University.  All rights reserved.  *)\n(*  This file is distributed under the terms of the Yale University    *)\n(*  Non-Commercial License Agreement.                                  *)\n(*                                                                     *)\n(* *********************************************************************)\nRequire Import Coqlib.\nRequire Import Maps.\nRequire Import ASTExtra.\nRequire Import Integers.\nRequire Import Floats.\nRequire Import Values.\nRequire Import Memory.\nRequire Import Events.\nRequire Import Globalenvs.\nRequire Import Smallstep.\nRequire Import Asm.\nRequire Import Conventions.\nRequire Import Machregs.\nRequire Import Observation.\n\nRequire Import liblayers.logic.PTreeModules.\nRequire Import liblayers.logic.PTreeSemantics.\nRequire Import liblayers.compcertx.MemWithData.\nRequire Import liblayers.compcertx.Stencil.\nRequire Import liblayers.compcertx.MakeProgram.\nRequire Import liblayers.compat.CompatData.\nRequire Import liblayers.compat.CompatPrimSem.\nRequire Import liblayers.compat.CompatLayers.\nRequire Import liblayers.compat.CompatExternalCalls.\n\nRequire Import LAsmModuleSem.\nRequire Import LAsmModuleSemAux.\nRequire Import LAsmModuleSemMakeProgram.\nRequire Import LAsmModuleSemSim.\nRequire Import LAsmModuleSemInvariants.\nRequire Import LAsm.\nRequire Import CommonTactic.\nRequire Import InitMem.\nRequire Import RefinementTactic.\nRequire Import AuxLemma.\nRequire Import Behavior.\nImport LAsm.\n(*Require Import LayerModuleLemma.*)\n\nSection WITHLAYERS.\n  \n  Context `{Hobs: Observation}.\n  Context `{Hstencil: Stencil}.\n  Context `{Hmem: Mem.MemoryModelX}.\n  Context `{Hmwd: UseMemWithData mem}.\n  Context `{builtin_idents_norepet_prf: CompCertBuiltins.BuiltinIdentsNorepet}.\n\n  Context `{make_program_ops: !MakeProgramOps LAsm.function Ctypes.type LAsm.fundef unit}.\n  Context `{make_program_prf: !MakeProgram LAsm.function Ctypes.type LAsm.fundef unit}.\n\n  Inductive match_states {D1: compatdata} {D2: compatdata} {R: compatrel D1 D2}:\n    stencil -> (state (mem:= mwd D1)) -> (state (mem:= mwd D2)) -> Prop :=\n  | match_states_intro:\n      forall s f rs m d rs' m' d',\n      MatchPrimcallStates R s f rs m d rs' m' d' ->\n      high_level_invariant d ->\n      high_level_invariant d' ->\n      low_level_invariant (Mem.nextblock m') d' ->\n      asm_invariant (mem:= mwd D2) s rs' (m', d') ->\n      match_states s (State rs (m, d)) (State rs' (m', d')).\n\n  Lemma match_states_observe \n        {D1: compatdata} {D2: compatdata} {R: compatrel D1 D2} :\n    forall sten p (s1 : state (mem:= mwd D1)) (s2 : state (mem:= mwd D2)),\n      match_states sten s1 s2 -> \n      observe_lasm _ p s1 = observe_lasm _ p s2.\n  Proof.\n    intros sten p s1 s2 Hmatch; inv Hmatch; simpl.\n    inv H.\n    inv match_extcall_states.\n    destruct R.\n    destruct crel_prf; eauto.\n  Qed.\n\n  Lemma one_step_sim_monotonic_alt {D1: compatdata} {D2: compatdata}\n        {L1} {L2} {R: compatrel D1 D2}\n        `{acc_def_prf1: !AccessorsDefined L1}\n        `{names1: !LayerNamesMatch D1 L1}\n        `{acc_def_prf2: !AccessorsDefined L2}\n        `{names2: !LayerNamesMatch D2 L2}:\n    forall `{memory_model_x: !Mem.MemoryModelX mem},\n    forall `{extcall_inv_def_prf1: !ExtcallInvariantsAvailable L1},\n    forall `{primcall_inv_def_prf1: !PrimcallInvariantsAvailable L1},\n    forall `{extcall_inv_def_prf2: !ExtcallInvariantsAvailable L2},\n    forall `{primcall_inv_def_prf2: !PrimcallInvariantsAvailable L2},\n    forall `{builtin_idents_norepet_prf: CompCertBuiltins.BuiltinIdentsNorepet},\n    forall (s: stencil) ge ge' rs1 rs1' m1 m1' d1 d1' rs2 m2 d2 t, \n    forall (Hglobalenv: exists M, make_globalenv (D:=D2) s M L2 = OK ge'),\n    forall (Hge_external': \n              forall b ef, \n                Genv.find_funct_ptr ge' b = Some (External ef) ->\n                exists i sg, ef = EF_external i sg),\n    forall (OKLayer: LayerOK L2),\n    forall (ValidLayer: get_layer_prim_valid L2 s),\n      stencil_matches s ge ->\n      stencil_matches s ge' ->\n      ge \u2264 ge' ->\n      cl_sim D1 D2 (freerg_inj _ _ _ R) L1 L2 ->\n      match_states s (State rs1 (m1, d1)) (State rs2 (m2, d2)) ->\n      (step (lcfg_ops:= LC L1)) \n        ge (State rs1 (m1, d1)) t (State rs1' (m1', d1')) ->\n      exists rs2' m2' d2',\n        (step (lcfg_ops:= LC L2)) \n          ge' (State rs2 (m2, d2)) t (State rs2' (m2', d2'))\n          /\\ match_states s (State rs1' (m1', d1')) (State rs2' (m2', d2')).\n  Proof.\n    intros. inv H3.\n    exploit (one_step_sim_monotonic'_avail s ge ge'); eauto 1.\n    intros [f'[rs2'[m2'[d2'[Hstep[Hmatch[Hhigh[Hhigh'[Hlow Hasm]]]]]]]]].\n    refine_split'; eauto 2.\n    econstructor; eauto 2.\n  Qed.\n\n  Lemma get_module_function_oplus_ok_left i M1 M2 \u03ba:\n    ModuleOK (M1 \u2295 M2) ->\n    get_module_function i M1 = OK (Some \u03ba) ->\n    get_module_function i (M1 \u2295 M2) = OK (Some \u03ba).\n  Proof.\n    intros HM HM1i.\n    assert (HMi: res_le (option_le eq) (get_module_function i M1)\n                                       (get_module_function i (M1 \u2295 M2))). {\n      apply get_module_function_monotonic.\n      apply left_upper_bound.\n    }\n    destruct (HM i) as [[\u03ba' H\u03ba'] _ _].\n    destruct HMi as [_ _ [|] | ]; try discriminate.\n    congruence.\n  Qed.\n\n  Lemma get_module_function_oplus_ok_right i M1 M2 \u03ba:\n    ModuleOK (M1 \u2295 M2) ->\n    get_module_function i M1 = OK (Some \u03ba) ->\n    get_module_function i (M1 \u2295 M2) = OK (Some \u03ba).\n  Proof.\n    intros HM HM1i.\n    assert (HMi: res_le (option_le eq) (get_module_function i M1)\n                                       (get_module_function i (M1 \u2295 M2))). {\n      apply get_module_function_monotonic.\n      apply left_upper_bound.\n    }\n    destruct (HM i) as [[\u03ba' H\u03ba'] _ _].\n    destruct HMi as [_ _ [|] | ]; try discriminate.\n    congruence.\n  Qed.\n\n  Lemma res_option_oplus_none_inv {A} (x y: res (option A)):\n    x \u2295 y = OK None ->\n    x = OK None /\\ y = OK None.\n  Proof.\n    destruct x as [[|]|], y as [[|]|];\n    inversion 1;\n    split;\n    reflexivity.\n  Qed.\n\n  Lemma get_module_function_oplus_ok_either i M1 M2 \u03b4:\n    ModuleOK (M1 \u2295 M2) ->\n    get_module_function i (M1 \u2295 M2) = OK \u03b4 ->\n    (get_module_function i M1 = OK \u03b4 /\\ isOKNone (get_module_function i M2)) \\/\n    (isOKNone (get_module_function i M1) /\\ get_module_function i M2 = OK \u03b4).\n  Proof.\n    intros HM Hi.\n    destruct (HM i) as [[f Hf] [v Hv] Hdisj].\n    revert Hdisj Hf Hv Hi.\n    get_module_normalize.\n    unfold isOKNone.\n    intros [Hdisj|Hdisj] Hf Hv H\u03b4;\n    apply res_option_oplus_none_inv in Hdisj;\n    destruct Hdisj as [H1 H2];\n    rewrite H1, H2 in *.\n    * left.\n      split; [assumption|reflexivity].\n    * destruct (get_module_function i M1) as [[|]|];\n      destruct (get_module_function i M2) as [[|]|];\n      try discriminate.\n      + left.\n        split; [assumption|reflexivity].\n      + right.\n        split; [reflexivity|assumption].\n      + left.\n        split; [assumption|reflexivity].\n  Qed.\n\n  (** XXX: this is only true in the current implementation. Ultimately\n    we'll want to do something else. *)\n  Lemma get_layer_primitive_oplus_either {D} i L1 L2 \u03c3:\n    get_layer_primitive (D:=D) i (L1 \u2295 L2) = OK (Some \u03c3) ->\n    get_layer_primitive i L1 = OK (Some \u03c3) \\/\n    get_layer_primitive i L2 = OK (Some \u03c3).\n  Proof.\n    get_layer_normalize.\n    destruct (get_layer_primitive i L1) as [[|]|];\n    destruct (get_layer_primitive i L2) as [[|]|];\n    try discriminate;\n    intros H.\n    * left; assumption.\n    * right; assumption.\n  Qed.\n\n  Lemma make_globalenv_module_ok {D} s M L:\n    isOK (make_globalenv (D:=D) s M L) ->\n    ModuleOK M.\n  Proof.\n    intros [ge Hge].\n    unfold make_globalenv in Hge.\n    inv_monad Hge.\n    eapply make_program_module_ok.\n    exists x.\n    eassumption.\n  Qed.\n\n  Lemma make_globalenv_vertical' {D} `{L: compatlayer D}:\n    forall s CTXT (M: module) ge ge',\n      stencil_matches s ge ->\n      stencil_matches s ge' ->\n      make_globalenv s CTXT (\u301a M \u301b L \u2295 L) = ret ge\n      -> make_globalenv s (CTXT \u2295 M) L = ret ge'\n                     (* For internal functions *)\n      -> (forall b f, Genv.find_funct_ptr ge b = Some (Internal f)\n                      -> Genv.find_funct_ptr ge' b = Some (Internal f))\n         (* For external functions that not i*)\n         /\\ (forall b id sg, \n               isOKNone (get_module_function id M) \n               -> Genv.find_funct_ptr ge b = Some (External (EF_external id sg))\n               -> Genv.find_funct_ptr ge' b = Some (External (EF_external id sg)))\n         (* For i*)\n         /\\ (forall b id sg f, \n               get_module_function id M = OK (Some f) ->\n               Genv.find_funct_ptr ge b = Some (External (EF_external id sg))\n               -> Genv.find_funct_ptr ge' b = Some (Internal f)).\n  Proof.\n    intros until ge'.\n    intros Hsge Hsge' Hge Hge'.\n    assert (MOK: ModuleOK (CTXT \u2295 M)).\n    {\n      eapply make_globalenv_module_ok.\n      eexists; eassumption.\n    }\n    split.\n    {\n      intros.\n      exploit @make_globalenv_find_funct_ptr.\n      { eexact Hge. }\n      { eassumption. }\n      destruct 1 as (j & SYMB & K).\n      destruct K as [K | K].\n      {\n        destruct K as (? & MOD & INT).\n        exploit @make_globalenv_get_module_function.\n        { eexact Hge'. }\n        {\n          instantiate (2 := j).\n          instantiate (1 := f).\n          apply get_module_function_oplus_ok_left; eauto.\n          simpl in INT.\n          congruence.\n        }\n        { reflexivity. }\n        destruct 1 as (b' & SYMB' & FUNCT').\n        erewrite stencil_matches_symbols in SYMB by eauto using make_globalenv_stencil_matches.\n        erewrite stencil_matches_symbols in SYMB' by eauto using make_globalenv_stencil_matches.\n        replace b' with b in * by congruence.\n        assumption.\n      }\n      {\n        exfalso.\n        destruct K as (? & ? & ?). discriminate.\n      }\n    }\n    split.\n    {    \n      intros.\n      exploit @make_globalenv_find_funct_ptr.\n      { eexact Hge. }\n      { eassumption. }\n      destruct 1 as (j & SYMB & K).\n      destruct K as [K | K].\n      {\n        exfalso.\n        destruct K as (? & ? & ?). discriminate.\n      }\n      destruct K as (? & LAY & EXT).\n      edestruct (make_globalenv_get_layer_primitive s (CTXT \u2295 M) L ge'); eauto.\n      {\n        edestruct (get_layer_primitive_oplus_either j (\u301aM\u301bL) L);\n        try eassumption.\n        exfalso.\n        unfold isOKNone in H.\n        rewrite get_semof_primitive in H1.\n        unfold semof_function in H1.\n        inversion EXT; subst; clear EXT.\n        rewrite H in H1.\n        discriminate.\n      }\n      destruct H1 as [Hjx0 Hx0id].\n      erewrite stencil_matches_symbols in Hjx0 by eassumption.\n      erewrite stencil_matches_symbols in SYMB by eassumption.\n      congruence.\n    }\n    {\n      intros.\n      exploit @make_globalenv_find_funct_ptr.\n      { eexact Hge. }\n      { eassumption. }\n      destruct 1 as (j & SYMB & K).\n      destruct K as [K | K].\n      {\n        exfalso.\n        destruct K as (? & ? & ?). discriminate.\n      }\n      destruct K as (? & LAY & EXT).\n      generalize EXT.\n      inversion 1; subst.\n      exploit @make_globalenv_get_module_function.\n      { eexact Hge'. }\n      {\n        instantiate (2 := id).\n        instantiate (1 := f).\n        exploit @get_module_function_monotonic.\n        {\n          apply (right_upper_bound CTXT M).\n        }\n        instantiate (1 := id).\n        rewrite H.\n        inversion 1; subst.\n        {\n          inv H4.\n          inv H1.\n          inv H5.\n          * simpl in *.\n            congruence.\n          * destruct (MOK id) as [[a Ha] _ _].\n            simpl in *.\n            congruence.\n        }\n        exfalso.\n        symmetry in H4.\n        destruct (MOK id) as [MOK_FUN _ _].\n        generalize MOK_FUN.\n        simpl.\n        rewrite H4.\n        destruct 1; discriminate.\n      }\n      { reflexivity. }\n      destruct 1 as (b' & SYMB' & FUNCT').\n      erewrite stencil_matches_symbols in SYMB by eauto using make_globalenv_stencil_matches.\n      erewrite stencil_matches_symbols in SYMB' by eauto using make_globalenv_stencil_matches.\n      replace b' with b in * by congruence.\n      assumption.\n    }    \n  Qed.\n\n  Lemma res_option_oplus_some_inv {A} (x: A) (y: res (option A)) (z: A):\n    (OK (Some x)) \u2295 y = OK (Some z) ->\n    x = z.\n  Proof.\n    intros H.\n    destruct y as [[|]|]; inversion H.\n    reflexivity.\n  Qed.\n\n  Lemma get_layer_primitive_right_eq' {D} `{L: compatlayer D}: \n    forall i (\u03c3: compatsem D) M f,\n      get_layer_primitive i (\u301a M \u301b L \u2295 L) = OK (Some \u03c3) ->\n      get_module_function i M = OK (Some f) ->\n      LayerOK L ->\n      semof_fundef D M L i f = OK \u03c3.\n  Proof.\n    intros.\n    rewrite get_layer_primitive_oplus in H.\n    rewrite get_semof_primitive in H.\n    unfold semof_function in H.\n    rewrite H0 in H.\n    monad_norm.\n    destruct (semof_fundef _ _ _ _ _) as [\u03c3'|err]; try discriminate.\n    monad_norm.\n    apply res_option_oplus_some_inv in H.\n    congruence.\n  Qed.\n\n  Lemma get_layer_primitive_right_neq' {D} `{L: compatlayer D}: \n    forall i (\u03c3i: compatsem D) M,\n      get_layer_primitive i (\u301a M \u301b L \u2295 L) = OK (Some \u03c3i) ->\n      isOKNone (get_module_function i M) ->\n      get_layer_primitive i L = OK (Some \u03c3i).\n  Proof.\n    intros.\n    rewrite get_layer_primitive_oplus in H.\n    rewrite get_semof_primitive in H.\n    unfold isOKNone in *; rewrite H0 in H.\n    unfold semof_function in H.\n    monad_norm.\n    rewrite id_left in H.\n    assumption.\n  Qed.\n\n  Lemma one_step_vertical_composition {D} `{L: compatlayer D} {M}\n        (L_ACC_DEF: LAsm.AccessorsDefined L)\n        (L_NAMES: LayerNamesMatch D L)\n        (L_ACC_DEF': LAsm.AccessorsDefined (\u301aM \u301b L \u2295 L)):\n    forall s ge ge' CTXT r r' (m m': mem) (d d': D) t,\n    forall (extinv: ExtcallInvariantsDefined L),\n    forall (priminv: PrimcallInvariantsDefined L),\n    forall (valid_prim: get_layer_prim_valid L s),\n      make_globalenv s CTXT (\u301a M \u301b L \u2295 L) = ret ge\n      -> make_globalenv s (CTXT \u2295 M) L = ret ge'\n      -> step (lcfg_ops:= LC (\u301a M \u301b L \u2295 L)) ge (State r (m, d)) t (State r' (m', d'))\n      -> plus (step (lcfg_ops:= LC L)) ge' \n              (State r (m, d)) t (State r' (m', d')).\n  Proof.\n    intros. pose proof H0 as Hge_match'. pose proof H as Hge_match.\n    apply make_globalenv_stencil_matches in H0.\n    apply make_globalenv_stencil_matches in H.\n    pose proof H as Hge. pose proof H0 as Hge'.\n    inv H. inv H0.\n    assert (Hsymbol: forall i, Genv.find_symbol ge' i = Genv.find_symbol ge i).\n    {\n      intros; abstract congruence.\n    }\n    unfold fundef in *.\n    assert (Hgenv_next: Genv.genv_next ge' = Genv.genv_next ge).\n    {\n      unfold fundef.\n      intros; abstract congruence.\n    }\n    assert(Hvolatile: forall b1 : block, block_is_volatile ge' b1 = block_is_volatile ge b1).\n    {\n      unfold fundef.\n      intros; abstract congruence.\n    } \n\n    generalize Hge_match. intro HgeL_dup.\n    eapply make_globalenv_vertical' in HgeL_dup; eauto.\n    destruct HgeL_dup as [Hinternal [Hext Hext']].\n\n    assert (Hge_external':\n              forall b ef, \n                Genv.find_funct_ptr ge b = Some (External ef) ->\n                exists i sg, ef = EF_external i sg).\n    {\n      intros until ef; eapply ge_external_valid; eauto.\n    } \n\n    assert (mk_prog': isOK (make_program s (CTXT \u2295 M) L)).\n    {\n      unfold make_globalenv in Hge_match'.\n      inv_monad Hge_match'.\n      esplit; eauto.\n    }\n\n    assert (mk_prog: isOK(make_program s M L)).\n    {\n      destruct mk_prog' as [? mk_prog'].\n      eapply make_program_monotonic_exists; try eassumption; try reflexivity.\n      apply right_upper_bound.\n    }\n\n    assert (Hmoduleok: ModuleOK M).\n    {\n      eapply make_program_module_ok; eassumption.\n    }\n\n    assert (Hlayerok: LayerOK L).\n    {\n      eapply make_program_layer_ok; try eassumption.\n    }\n\n    assert (Hget: forall i,\n                    (exists func, get_module_function i M = OK (Some func))\n                    \\/ (isOKNone (get_module_function i M))).\n    {\n      intros.\n      destruct (Hmoduleok i) as [Hfun _ _].\n      revert Hfun.\n      destruct (get_module_function i M); eauto.\n      destruct o; eauto.\n      destruct 1.\n      discriminate.\n    }\n\n    eapply vcomp_step; try eapply H2; eauto 2; intros.\n    - assert(HW: acc_exec_load (\u301aM \u301b L \u2295 L) = acc_exec_load L).\n      {\n        unfold acc_exec_load.\n        destruct (acc_exec_load_strong (\u301aM \u301b L \u2295 L)).\n        simpl in e.\n        destruct (acc_exec_load_strong L).\n        rewrite e0 in e. abstract (inversion e; trivial).\n      }\n      rewrite <- HW.\n      erewrite exec_load_symbols_preserved; eauto.\n    - assert(HW': acc_exec_store (\u301aM \u301b L \u2295 L) = acc_exec_store L).\n      {\n        unfold acc_exec_store.\n        destruct (acc_exec_store_strong (\u301aM \u301b L \u2295 L)).\n        simpl in e.\n        destruct (acc_exec_store_strong L).\n        rewrite e0 in e. abstract (inversion e; trivial).\n      }\n      rewrite <- HW'.\n      erewrite exec_store_symbols_preserved; eauto.\n    - eapply Hge_external' in H.\n      destruct H as [?[? ?]]; subst. inv H0.\n    - (* external call *)\n      destruct (Hget i) as [?|?].\n      (* OK (Some f))*)\n      destruct H2 as [funcp ?].\n      specialize (Hext' _ _ _ _ H2 H).\n      eapply (get_layer_primitive_right_eq') in H0; eauto; subst.\n      inv H0. \n\n      (* None *)\n      split; eauto. \n      eapply get_layer_primitive_right_neq'; eauto.\n\n    - (* primitive call *)\n      destruct (Hget i) as [?|?].\n\n      + (* OK (Some f))*)\n        destruct H5 as [funcp ?].\n        specialize (Hext' _ _ _ _ H5 H).\n        eapply (get_layer_primitive_right_eq') in H0; eauto. subst.\n        exploit (compatsem_primcall_le (D:= D)); eauto.\n        * reflexivity.\n        * econstructor; eauto.\n        * inv H0. simpl.\n          intros.\n          eapply stencil_matches_unique in H0; try apply Hge. subst.\n          destruct (Decision.decide (ExtcallInvariantsDefined L)).\n          destruct (Decision.decide (PrimcallInvariantsDefined L)).\n          destruct (Decision.decide (LayerNamesMatch D L)).\n          destruct (Decision.decide (get_layer_prim_valid L s1)).\n          rewrite accessors_defined_weak; try assumption.\n          destruct mk_prog as [? mk_prog].\n          rewrite mk_prog. reflexivity.\n          elim n; assumption.\n          elim n; assumption.\n          elim n; assumption.\n          elim n; assumption.\n\n        * intros Hsem'; inv Hsem'.\n          eapply stencil_matches_unique in H2; try apply Hge. subst.\n          inv H0; simpl in H4.\n          inv H4.\n          pose proof Hge0 as Hge0'.\n          apply make_globalenv_stencil_matches in Hge0.\n          apply make_globalenv_split_module_right in Hge_match'.\n          destruct Hge_match' as [?[HgeL Hle'']].\n          unfold fundef in *.\n          rewrite Hge0' in HgeL. inv HgeL.\n          eapply one_sim_plus; eauto. intros.\n          eapply one_step_monotonic; eauto.      \n\n      + (* None *) \n        exploit Hext; eauto. intros Hfind.\n        apply plus_one. \n        eapply exec_step_prim_call; eauto.\n        eapply get_layer_primitive_right_neq' in H0; eauto.\n        econstructor; eauto.\n        refine_split'; eauto.\n        eapply stencil_matches_unique in H2; try apply Hge. subst.\n        econstructor; eauto.\n  Qed.\n\n  Remark annot_arguments_determ_with_data {D}:\n    forall rs (m: mwd D) params args1 args2,\n      annot_arguments rs m params args1 -> annot_arguments rs m params args2 -> args1 = args2.\n  Proof.\n    unfold annot_arguments. intros. revert params args1 H args2 H0. \n    induction 1; intros. \n    inv H0; auto.\n    inv H1. decEq; eauto. inv H; inv H4. auto. congruence. \n  Qed.\n\n  Remark extcall_arguments_determ_with_data {D}:\n    forall rs (m: mwd D) sg args1 args2,\n      extcall_arguments rs m sg args1 -> extcall_arguments rs m sg args2 -> args1 = args2.\n  Proof.\n    intros until m.\n    assert (forall ll vl1, list_forall2 (extcall_arg rs m) ll vl1 ->\n                           forall vl2, list_forall2 (extcall_arg rs m) ll vl2 -> vl1 = vl2).\n    induction 1; intros vl2 EA; inv EA.\n    auto.\n    f_equal; auto. \n    inv H; inv H3; congruence.\n    intros. red in H0; red in H1. eauto. \n  Qed.\n\n  Lemma external_prim_false {D} `{L: compatlayer D}\n        (acc_def_prf: LAsm.AccessorsDefined L):\n    forall ge ef WB args t1 t2 res (m m' m'0: mwd D) rs rs',\n      external_call' (external_calls_ops:= compatlayer_extcall_ops L) WB ef ge args m t1 res m' ->\n      primitive_call (LayerConfigurationOps:= LC (acc_def_prf:= acc_def_prf) L) ef ge rs m t2 rs' m'0 ->\n      False.\n  Proof.\n    intros.\n    inv H. inv H0. destruct H as [?[?[?[? ?]]]]; subst.\n    simpl in *. destruct H1 as [?[? ?]].\n    rewrite H in H0. inv H0.\n    inv H1. inv H2. destruct H0 as [?[?[?[? _]]]].\n    inv H4.\n  Qed.\n \n  Lemma make_program_ok_disjoint {D} s M L p:\n    make_program (D:=D) s M L = OK p ->\n    module_layer_disjoint M L.\n  Proof.\n    intros.\n    unfold module_layer_disjoint.\n    assert (pOK: isOK (make_program s M L)).\n    {\n      esplit. eassumption.\n    }\n    intros i.\n    pose proof (make_program_layer_ok s M L pOK) as LOK.\n    destruct (LOK i) as [Lprim Lvar _].\n    destruct Lprim as [x Lprim].\n    destruct x.\n    {\n      left. eapply make_program_get_layer_primitive_prop; eassumption.\n    }\n    {\n      destruct Lvar as [? Lvar].\n      destruct x.\n      {\n        left. eapply make_program_get_layer_globalvar_prop; eassumption.\n      }\n      right.\n      rewrite Lprim, Lvar.\n      split; constructor.\n    }\n  Qed.\n\n  Lemma get_layer_primitive_semof {D} i M (L: compatlayer D) \u03c3:\n    get_layer_primitive i (\u301aM\u301b L \u2295 L) = OK (Some \u03c3) ->\n    (exists \u03c3', get_layer_primitive i L = OK (Some \u03c3')) \\/\n    (exists \u03ba, get_module_function i M = OK (Some \u03ba)).\n  Proof.\n    intros Hi.\n    edestruct (get_layer_primitive_oplus_either i (\u301aM\u301bL) L) as [H|H].\n    + eassumption.\n    + right.\n      rewrite get_semof_primitive in H.\n      unfold semof_function in H.\n      destruct (get_module_function i M) as [[|]|]; inversion H.\n      eauto.\n    + left.\n      eauto.\n  Qed.\n  \n  (*Lemma layer_oplus_layer_ok `{D: compatdata} (L1 L2: compatlayer D):\n    layers_disjoint L1 L2 ->\n    LayerOK L1 ->\n    LayerOK L2 ->\n    LayerOK (L1 \u2295 L2).\n  Proof.*)\n\n  Lemma res_option_oplus_ok_inv {A} (x y: res (option A)) (z: option A):\n    x \u2295 y = OK z -> (isOK x /\\ isOKNone y) \\/ (isOK y /\\ isOKNone x).\n  Proof.\n    destruct x as [[|]|], y as [[|]|]; try discriminate; eauto.\n  Qed.\n\n  Lemma res_option_oplus_ok_some_inv {A} (x y: res (option A)) (z: A):\n    x \u2295 y = OK (Some z) ->\n    (x = OK (Some z) /\\ y = OK None) \\/\n    (x = OK None /\\ y = OK (Some z)).\n  Proof.\n    destruct x as [[|]|], y as [[|]|]; try discriminate; eauto.\n  Qed.\n\n  Lemma res_option_oplus_ok_none_inv {A} (x y: res (option A)):\n    isOKNone (x \u2295 y) ->\n    isOKNone x /\\ isOKNone y.\n  Proof.\n    destruct x as [[|]|], y as [[|]|]; try discriminate; eauto.\n  Qed.\n\n  Lemma make_program_vertical':\n    forall D (LL: compatlayer D)  s M  CTXT p\n      (Hlayer_mo: LayerOK (\u301a M \u301b LL \u2295 LL)),\n      make_program s (CTXT \u2295 M) LL = OK p\n      -> exists p', make_program s CTXT (\u301a M \u301b LL \u2295 LL) = OK p'.\n  Proof.\n    intros until p.\n    intros Hlayer_mo MKP.\n    assert (MKP': isOK (make_program s (CTXT \u2295 M) LL))\n      by (rewrite MKP; unfold isOK; eauto).\n    pose proof (make_program_module_ok _ _ _ MKP') as MOK.\n    pose proof (make_program_layer_ok _ _ _ MKP') as LOK'.\n    apply make_program_exists; eauto.\n\n    * eapply module_ok_antitonic; eauto.\n      unfold flip.\n      apply left_upper_bound.\n\n    * intros i fe Hi.\n      specialize (get_layer_primitive_oplus i (\u301aM \u301b LL) LL).\n      intros Hle.\n      destruct (LOK' i) as [Lprim Lvar _].\n      destruct Lprim as [? Lprim].\n      rewrite Lprim in Hle. rewrite Hi in Hle.\n      split; [eexists; reflexivity|].\n      destruct x.\n      {\n        exploit (make_program_get_layer_primitive_prop (D:=D)); eauto.\n        intros ( _ & Hmo & Hva).\n        split.\n        - eapply get_module_function_none_oplus in Hmo. eapply Hmo.\n        - eapply get_module_variable_none_oplus in Hva. eapply Hva.\n      }\n      {\n        destruct (MOK i) as [[\u03ba H\u03ba] [\u03c4 H\u03c4] _].\n        get_module_normalize_in H\u03ba.\n        get_module_normalize_in H\u03c4.\n\n        clear Hi Lprim Lvar.\n        rewrite id_right in Hle.\n        split.\n        * rewrite get_semof_primitive in Hle.\n          destruct (get_module_function i M) as [[|]|]; try discriminate.\n          destruct (res_option_oplus_ok_inv _ _ _ H\u03ba) as [[HC HM] | [HM HC]].\n          - discriminate.\n          - assumption.\n        * destruct (MOK i) as [_ _ [Hf|Hv]].\n          - rewrite get_semof_primitive in Hle.\n            rewrite get_module_function_oplus in Hf.\n            destruct (get_module_function i M) as [[|]|]; try discriminate.\n            destruct (get_module_function i CTXT) as [[|]|]; try discriminate.\n          - rewrite get_module_variable_oplus in Hv.\n            destruct (get_module_variable i M) as [[|]|];\n            destruct (get_module_variable i CTXT) as [[|]|];\n            try discriminate.\n            reflexivity.\n      }\n\n    * intros i fi Hfi.\n      split; [eexists; reflexivity|].\n      destruct (MOK i) as [[\u03ba MOK1] [\u03c4 MOK2] Mdisj].\n      specialize (get_module_function_oplus i CTXT M).\n      rewrite Hfi. rewrite MOK1.\n      destruct (get_module_function i M) as [[|]|] eqn:HMi; try discriminate.\n      intros H; inversion H; subst; clear H.\n      exploit (make_program_get_module_function_prop (D:=D)); eauto.\n      intros (Hfalse & Lprim & Lvar).\n      rewrite MOK1 in Mdisj.\n      destruct Mdisj as [Mvar|Mvar]; try discriminate.\n      get_layer_normalize.\n      unfold isOKNone in *.\n      split.\n      + rewrite get_semof_primitive.\n        rewrite HMi.\n        rewrite Lprim.\n        reflexivity.\n      + rewrite get_semof_globalvar.\n        rewrite Lvar.\n        rewrite get_module_variable_oplus in Mvar.\n        destruct (get_module_variable i M) as [[|]|];\n        destruct (get_module_variable i CTXT) as [[|]|];\n        try discriminate.\n        reflexivity.\n\n    * intros i fi Hfi.\n      rewrite get_layer_globalvar_oplus in Hfi.\n      rewrite get_semof_globalvar in Hfi.\n      apply res_option_oplus_ok_some_inv in Hfi.\n      destruct Hfi as [[HMi HLi] | [HMi HLi]].\n      + exploit (make_program_get_module_variable_prop s (CTXT \u2295 M) LL i fi); eauto.\n        - destruct (MOK i) as [_ [\u03c4 H\u03c4] _].\n          revert H\u03c4.\n          get_module_normalize.\n          rewrite HMi.\n          destruct (get_module_variable i CTXT) as [[|]|]; try discriminate.\n          reflexivity.\n        - intros (Hfi & Lprim & Lvar).\n          split;eauto.\n          split.\n          {\n            destruct (MOK i) as [_ _ CMdisj].\n            get_module_normalize_in CMdisj.\n            destruct CMdisj as [Hf|Hv].\n            - apply res_option_oplus_ok_none_inv in Hf.\n              destruct Hf.\n              assumption.\n            - apply res_option_oplus_ok_none_inv in Hv.\n              destruct Hv.\n              congruence.\n          }\n          {\n            destruct (MOK i) as [_ [\u03c4 CMvar] _].\n            get_module_normalize_in CMvar.\n            apply res_option_oplus_ok_inv in CMvar.\n            destruct CMvar as [[? ?] | [? ?]].\n            - congruence.\n            - assumption.\n          }\n      + exploit (make_program_get_layer_globalvar_prop s (CTXT \u2295 M) LL i fi); eauto.\n        get_module_normalize.\n        intros (Hgvar & Hf & Hv).\n        split; eauto.\n        split.\n        - apply res_option_oplus_ok_none_inv in Hf.\n          destruct Hf.\n          assumption.\n        - apply res_option_oplus_ok_none_inv in Hv.\n          destruct Hv.\n          assumption.\n\n    * intros i fi Hfi.\n      destruct (MOK i) as [MOK1 [? MOK2]].\n      specialize (get_module_variable_oplus i CTXT M).\n      rewrite Hfi. rewrite MOK2.\n      intros Hle.\n      specialize (get_module_variable_isOK i CTXT M).\n      rewrite MOK2. intros HW.\n      exploit HW. esplit; reflexivity.\n      intros (_ & HM). clear HW.\n      destruct HM as [? HM].\n      rewrite HM in Hle.\n      destruct x0; inv_monad Hle.\n      exploit (make_program_get_module_variable_prop (D:=D)); eauto.\n      intros (Hfalse & Lprim & Lvar).\n      split; try assumption.\n      specialize (get_module_function_variable_disjoint (CTXT \u2295 M) i).\n      rewrite MOK2.\n      intros HW.\n      destruct HW as [HF|]; try discriminate.\n      get_module_normalize_in HF.\n      apply res_option_oplus_ok_none_inv in HF.\n      destruct HF as [_ HF].\n      get_layer_normalize.\n      rewrite get_semof_primitive.\n      rewrite get_semof_globalvar.\n      unfold isOKNone in *.\n      subrewrite'.\n      split; reflexivity.\n\n    * intros i \u03c3 Hi\u03c3.\n      apply make_program_make_globalenv in MKP.\n      destruct (get_layer_primitive_semof i M LL _ Hi\u03c3) as [[\u03c3' H\u03c3']|[\u03ba H\u03ba]].\n      + exploit (make_globalenv_get_layer_primitive s (CTXT \u2295 M) LL); eauto.\n        reflexivity.\n        intros (b & Hb & _).\n        erewrite stencil_matches_symbols in Hb.\n        eexists; eassumption.\n        eapply make_globalenv_stencil_matches; eauto.\n      + exploit (make_globalenv_get_module_function s (CTXT \u2295 M) LL); eauto.\n        - instantiate (1:=\u03ba); instantiate (1:=i).\n          destruct (MOK i) as [MOK' _]; clear MOK.\n          destruct MOK' as [? MOK].\n          specialize (get_module_function_oplus i CTXT M).\n          rewrite MOK. rewrite H\u03ba.\n          intros Hle.\n          Transparent oplus.\n          destruct (get_module_function i CTXT); try destruct o;\n          inv_monad Hle. reflexivity.\n        - reflexivity.\n        - intros (b & Hb & _).\n          eapply make_globalenv_stencil_matches in MKP; eauto.\n          inv MKP. rewrite stencil_matches_symbols in Hb.\n          rewrite Hb. esplit; reflexivity.\n    * intros i \u03c3 Hi\u03c3.\n      apply make_program_make_globalenv in MKP.\n      destruct (LOK' i) as [LOK1 LOK2].\n      destruct LOK2 as [? LOK2].\n      specialize (get_layer_globalvar_oplus i (\u301aM \u301b LL) LL).\n      rewrite Hi\u03c3. rewrite LOK2.\n      intros Hle.\n      exploit (make_globalenv_stencil_matches (D:=D)); eauto.\n      intros Hsten. inv Hsten.\n      destruct x.\n      {\n        exploit (make_globalenv_get_layer_globalvar (D:=D)); eauto.\n        intros (? & Hsym & _).\n        rewrite stencil_matches_symbols in Hsym.\n        rewrite Hsym. esplit; reflexivity.\n      }\n      {\n        destruct LOK1 as [? LOK1].\n        destruct x.\n        {\n          exploit (make_globalenv_get_layer_primitive (D:=D)); eauto.\n          reflexivity.\n          intros (? & Hsym & _).\n          rewrite stencil_matches_symbols in Hsym.\n          rewrite Hsym. esplit; reflexivity.\n        }          \n        {\n          destruct (MOK i) as [MOK1 MOK2].\n          destruct MOK1 as [? MOK1].\n          destruct x.\n          {\n            exploit (make_globalenv_get_module_function (D:=D)); eauto.\n            reflexivity.\n            intros (? & Hsym & _).\n            rewrite stencil_matches_symbols in Hsym.\n            rewrite Hsym. esplit; reflexivity.\n          }\n          {\n            eapply get_module_function_none_oplus in MOK1.\n            destruct MOK1 as [MOK11 MOK12].\n            rewrite get_layer_globalvar_oplus, get_semof_globalvar in Hi\u03c3.\n            apply res_option_oplus_ok_some_inv in Hi\u03c3.\n            destruct Hi\u03c3 as [[HMi HLi] | [HMi HLi]]; try congruence.\n            destruct MOK2 as [\u03c3' H\u03c3'].\n            rewrite get_module_variable_oplus in H\u03c3'.\n            rewrite HMi in H\u03c3'.\n            destruct (get_module_variable i CTXT) as [[|]|] eqn:HCi;\n              try discriminate.\n            exploit (make_globalenv_get_module_variable (D:=D)); eauto.\n            {\n              instantiate (2:=i).\n              get_module_normalize.\n              rewrite HCi, HMi.\n              reflexivity.\n            }\n            intros (? & Hsym & _).\n            rewrite stencil_matches_symbols in Hsym.\n            rewrite Hsym. esplit; reflexivity.\n          }\n        }\n      }\n\n    * intros i \u03c3 Hi\u03c3.\n      apply make_program_make_globalenv in MKP.\n      destruct (MOK i) as [MOK1 MOK2 _].\n      destruct MOK1 as [? MOK1].\n      specialize (get_module_function_oplus i CTXT M).\n      rewrite Hi\u03c3. rewrite MOK1.\n      intros Hle.\n      destruct (get_module_function i M); try destruct o; inv_monad Hle.\n      exploit (make_globalenv_get_module_function (D:=D)); eauto.\n      reflexivity.\n      intros (? & Hsym & _).\n      exploit (make_globalenv_stencil_matches (D:=D)); eauto.\n      intros Hsten. inv Hsten.\n      rewrite stencil_matches_symbols in Hsym.\n      rewrite Hsym. esplit; reflexivity.\n\n    * intros i \u03c3 Hi\u03c3.\n      apply make_program_make_globalenv in MKP.\n      destruct (MOK i) as [_ MOK1 _].\n      destruct MOK1 as [? MOK1].\n      specialize (get_module_variable_oplus i CTXT M).\n      rewrite Hi\u03c3. rewrite MOK1.\n      intros Hle.\n      destruct (get_module_variable i M); try destruct o; inv_monad Hle.\n      exploit (make_globalenv_get_module_variable (D:=D)); eauto.\n      intros (? & Hsym & _).\n      exploit (make_globalenv_stencil_matches (D:=D)); eauto.\n      intros Hsten. inv Hsten.\n      rewrite stencil_matches_symbols in Hsym.\n      rewrite Hsym. esplit; reflexivity.\n  Qed.\n\n  Lemma accessors_monotonic_plus_none {D: compatdata}\n        {L1 L2: compatlayer D}:\n    AccessorsDefined L1 ->\n    cl_exec_load L2 = OK None ->\n    cl_exec_store L2 = OK None ->\n    AccessorsDefined (L2 \u2295 L1).\n  Proof.\n    intros.\n    apply accessors_defined_true in H.\n    econstructor.\n    unfold accessors_defined in *.\n    simpl. rewrite H0, H1.\n    caseEq (cl_exec_load L1); intros; rewrite H2 in H; simpl in *; try discriminate.\n    destruct o; simpl in *; try discriminate.\n    caseEq (cl_exec_store L1); intros; rewrite H3 in H; simpl in *; try discriminate.\n    destruct o; simpl in *; try discriminate.\n    reflexivity.\n  Qed.\n\n  Lemma LayerOK_not_None `{D: compatdata} (L: compatlayer D):\n    forall i,\n      LayerOK L ->\n      ~isOKNone (get_layer_primitive i L) ->\n      exists func, get_layer_primitive i L = OK (Some func).\n  Proof.\n    intros. destruct (H i) as [[\u03c3 H\u03c3] _ _].\n    rewrite H\u03c3 in *; clear H\u03c3.\n    destruct \u03c3 as [|]; eauto.\n    elim H0; reflexivity.\n  Qed.\n\n  Lemma LayerOK_elim `{D: compatdata} (L: compatlayer D):\n    forall i v,\n      LayerOK L ->\n      get_layer_globalvar i L = OK (Some v) ->\n      get_layer_primitive i L = OK None.\n  Proof.\n    intros. \n    destruct (H i) as [Hlayer _ Hdisj].\n    rewrite H0 in Hdisj.\n    destruct Hdisj; try discriminate.\n    assumption.\n  Qed.\n\n  Instance lasm_semantics_names_match {D} (M: module) (L: compatlayer D):\n    LayerOK (\u301aM\u301b L) ->\n    LayerNamesMatch D (\u301aM\u301b L).\n  Proof.\n    split.\n    * assumption.\n    * intros i j \u03c3 Hi Hj.\n      rewrite get_semof_primitive in Hi.\n      destruct (get_module_function i M) as [[|]|]; try discriminate.\n      inversion Hi; subst; clear Hi.\n      simpl in *.\n      congruence.\n  Qed.\n\n  Instance layer_names_match_oplus {D} (L1 L2: compatlayer D):\n    LayerOK (L1 \u2295 L2) ->\n    LayerNamesMatch D L1 ->\n    LayerNamesMatch D L2 ->\n    LayerNamesMatch D (L1 \u2295 L2).\n  Proof.\n    intros HLplus [HL1ok HL1match] [HL2ok HL2match].\n    split; try assumption.\n    intros i j \u03c3 Hi Hj.\n    specialize (HL1match i j \u03c3).\n    specialize (HL2match i j \u03c3).\n    edestruct (get_layer_primitive_oplus_either i L1 L2); eauto.\n  Qed.\n\n  Local Existing Instance extcall_invariants_oplus.\n  Local Existing Instance primcall_invariants_oplus.\n\n  Theorem soundness_simulation:\n    forall {DH DL: compatdata}\n           (R: freerg compatrel DH DL)\n           (LH: compatlayer DH)\n           (LL: compatlayer DL)\n           (LH_ACC_DEF: LAsm.AccessorsDefined LH)\n           (LL_ACC_DEF: LAsm.AccessorsDefined LL)\n           (LH_RECEPT: ExternalCallsXDefined (LH))\n           (LL_DETERM: ExternalCallsXDefined (LL))\n           (LL_DETERM': PrimitiveCallsXDefined LL)\n           (LH_INV: ExtcallInvariantsDefined LH)\n           (LL_INV: ExtcallInvariantsDefined LL)\n           (LH_PRIM_INV: PrimcallInvariantsDefined LH)\n           (LL_PRIM_INV: PrimcallInvariantsDefined LL)\n           (LH_NAMES: LayerNamesMatch DH LH)\n           (LL_NAMSE: LayerNamesMatch DL LL)\n           (M: LAsm.module)\n           (builtin_idents_norepet_prf: CompCertBuiltins.BuiltinIdentsNorepet)\n           (REFINE: cl_sim _ _ R LH (\u301a M \u301b LL \u2295 LL))\n           (INIT_SIM: cl_init_sim _ _ R LH M LL)\n           (CTXT: LAsm.module) s pl\n           (PL: make_program s (CTXT \u2295 M) LL = OK pl)\n           (prim_valid: get_layer_prim_valid LL s)\n           ph\n           (PH: make_program s CTXT LH = OK ph)\n\n           (***  XXX: We have to add this LayerOK pre-condition for now on, \n                      hopefully we can remove it in the future ***)\n           (HLayerOK': LayerOK (\u301a M \u301b LL \u2295 LL))\n           (p : principal),\n      simulation\n        (LAsm.semantics (lcfg_ops := LC LH) ph)\n        (LAsm.semantics (lcfg_ops := LC LL) pl)\n        (observe_lasm _ p) (observe_lasm _ p).\n  Proof.\n    intros; rename p into pp. \n    assert (acc_def_prf2: AccessorsDefined (\u301aM \u301b LL \u2295 LL)).\n    {\n      eapply accessors_monotonic_plus_none; try assumption; simpl; reflexivity.\n    }\n\n    (** Thanks to [INIT_SIM], we know that [R] cannot be the identity relation. *)\n    destruct R as [| DL R].\n    {\n      simpl in *.\n      elim INIT_SIM.\n    }\n\n    apply simulation_no_stutter with (sim_match:= match_states(D1:=DH)(D2:=DL) s).\n    + (* match observe *)\n      intros [rs1 [m1 d1]] [rs2 [m2 d2]] Hmatch.\n      exploit match_states_observe; eauto.\n    + (* match final state *)\n      intros. inv H0.\n      inv H. inv H4.\n      unfold Pregmap.get in *.\n      econstructor; eauto.\n      specialize (match_reg PC).\n      rewrite H1 in match_reg. inv match_reg.\n      reflexivity.\n      specialize (match_reg EAX).\n      rewrite H2 in match_reg. inv match_reg.\n      reflexivity.\n    + (* one_plus step soundness *)\n      intros. simpl in H. simpl.\n      assert (Hle: CTXT \u2264 CTXT) by reflexivity.\n      assert (Hge: make_globalenv s CTXT LH = ret (Genv.globalenv ph)).\n      {\n        unfold make_globalenv. rewrite PH.\n        reflexivity.\n      }\n      \n      assert (Hp: isOK (make_program s CTXT (\u301aM \u301b LL \u2295 LL))).\n      {\n        eapply make_program_vertical'; eassumption.\n      }            \n      assert (Hge': isOK (make_globalenv s CTXT (\u301aM \u301b LL \u2295 LL))).\n      {\n        destruct Hp as [p Hp].\n        eapply make_program_make_globalenv in Hp.\n        esplit. eauto.\n      }    \n      destruct Hge' as [ge' Hge'].\n      specialize (make_globlenv_monotonic_weak _ _ _ _ Hle REFINE Hge ge' Hge'); eauto 2.\n      intros Hle'.\n      (* INSTANCE_NOT_FOUND: The following instances are required, but currently we could not prove *)\n      (* We can add them to sprimcall_sim, or to the definition of semof_fundef of LAsm *)\n\n      pose proof Hge as Hge_match.\n      apply make_globalenv_stencil_matches in Hge.\n      pose proof Hge' as Hge_match'.\n      apply make_globalenv_stencil_matches in Hge'.\n      destruct s1, s2, s1'. destruct m, m0, m1.\n      assert (Hge_external':\n                forall b ef, \n                  Genv.find_funct_ptr ge' b = Some (External ef) ->\n                  exists i sg, ef = EF_external i sg) by\n          abstract\n            (intros until ef; eapply ge_external_valid; eauto).\n\n      assert (OKLayer: LayerOK (\u301aM \u301b LL \u2295 LL)).\n      {\n        eapply make_program_layer_ok; eassumption.\n      }\n\n      assert (Hnames: LayerNamesMatch DL (\u301aM\u301b LL \u2295 LL)). {\n        apply layer_names_match_oplus; eauto.\n        apply lasm_semantics_names_match; eauto.\n        rewrite <- left_upper_bound in OKLayer.\n        eassumption.\n      }\n      exploit (one_step_sim_monotonic_alt s (Genv.globalenv ph) ge'); eauto 2.\n\n      pose proof prim_valid as prim_valid'.\n      {\n        unfold get_layer_prim_valid in *.\n        intros.\n        specialize (get_layer_primitive_oplus i (\u301aM \u301b LL) LL). rewrite H1.\n        intros Heq.\n        caseEq (get_layer_primitive i (\u301aM \u301b LL)); intros; rewrite H2 in Heq;\n        try destruct o; caseEq (get_layer_primitive i LL); intros; rewrite H3 in Heq;\n        try destruct o; inv_monad Heq; try discriminate.\n        {\n          assert (MOK: ModuleOK M).\n          {\n            assert (HmOK: ModuleOK (CTXT \u2295 M)).\n            {\n              eapply make_program_module_ok.\n              esplit; eauto.\n            }\n            eapply module_ok_antitonic; try eassumption.\n            apply right_upper_bound.\n          }\n          destruct (MOK i) as [[[|] MOK'] _ _].\n          {\n            assert (mk_prog: isOK(make_program s M LL)).\n            {\n              eapply make_program_monotonic_exists; try eassumption; try reflexivity.\n              apply right_upper_bound.\n            }\n            rewrite get_semof_primitive in H2.\n            rewrite MOK' in H2.\n            unfold semof_function in H2; monad_norm.\n            unfold module, module_ops in *.\n            simpl in *.\n            inv_monad H2.\n            inv H2.\n            subst.\n            simpl.\n            destruct (Decision.decide (ExtcallInvariantsDefined LL)).\n            destruct (Decision.decide (PrimcallInvariantsDefined LL)).\n            destruct (Decision.decide (LayerNamesMatch DL LL)).\n            destruct (Decision.decide (get_layer_prim_valid LL s)).\n            rewrite accessors_defined_weak; try assumption.\n            destruct mk_prog as [? mk_prog].\n            unfold module, module_ops in *.\n            rewrite mk_prog. reflexivity.\n            elim n; assumption.\n            elim n; assumption.\n            elim n; assumption.\n            elim n; assumption.\n          }\n          {\n            rewrite get_semof_primitive in H2.\n            rewrite MOK' in H2.\n            discriminate.\n          }\n        }\n        eauto.\n      }\n      \n      intros [rs2' [m2'[d2'[Hstep' Hmatch']]]].\n      refine_split'; eauto 2.\n      assert (Hge'': make_globalenv s (CTXT \u2295 M) LL = ret (Genv.globalenv pl)).\n      {\n        unfold make_globalenv. rewrite PL.\n        reflexivity.\n      }\n      (*assert (Hle'': LL \u2264 \u301aM \u301b LL \u2295 LL) by apply right_upper_bound.*)\n      eapply (one_step_vertical_composition(L:=LL)); eauto.\n  Qed.\n\n  Theorem soundness_forward:\n    forall {DH DL: compatdata}\n           (R: freerg compatrel DH DL)\n           (LH: compatlayer DH)\n           (LL: compatlayer DL)\n           (LH_ACC_DEF: LAsm.AccessorsDefined LH)\n           (LL_ACC_DEF: LAsm.AccessorsDefined LL)\n           (LH_RECEPT: ExternalCallsXDefined (LH))\n           (LL_DETERM: ExternalCallsXDefined (LL))\n           (LL_DETERM': PrimitiveCallsXDefined LL)\n           (LH_INV: ExtcallInvariantsDefined LH)\n           (LL_INV: ExtcallInvariantsDefined LL)\n           (LH_PRIM_INV: PrimcallInvariantsDefined LH)\n           (LL_PRIM_INV: PrimcallInvariantsDefined LL)\n           (LH_NAMES: LayerNamesMatch DH LH)\n           (LL_NAMSE: LayerNamesMatch DL LL)\n           (M: LAsm.module)\n           (builtin_idents_norepet_prf: CompCertBuiltins.BuiltinIdentsNorepet)\n           (REFINE: cl_sim _ _ R LH (\u301a M \u301b LL \u2295 LL))\n           (INIT_SIM: cl_init_sim _ _ R LH M LL)\n           (CTXT: LAsm.module) s pl\n           (PL: make_program s (CTXT \u2295 M) LL = OK pl)\n           (prim_valid: get_layer_prim_valid LL s)\n           ph\n           (PH: make_program s CTXT LH = OK ph)\n\n           (***  XXX: We have to add this LayerOK pre-condition for now on, \nhopefully we can remove it in the future ***)\n           (HLayerOK': LayerOK (\u301a M \u301b LL \u2295 LL)),\n      forward_simulation\n        (LAsm.semantics (lcfg_ops := LC LH) ph)\n        (LAsm.semantics (lcfg_ops := LC LL) pl).\n    Proof.\n      intros. \n      assert (acc_def_prf2: AccessorsDefined (\u301aM \u301b LL \u2295 LL)).\n      {\n        eapply accessors_monotonic_plus_none; try assumption; simpl; reflexivity.\n      }\n\n      (** Thanks to [INIT_SIM], we know that [R] cannot be the identity relation. *)\n      destruct R as [| DL R].\n      {\n        simpl in *.\n        elim INIT_SIM.\n      }\n      eapply forward_simulation_plus with (match_states:= match_states s).\n      + (* find_symbol *)\n        intros.\n        assert (Hge: make_globalenv s (CTXT \u2295 M) LL = ret (Genv.globalenv pl)).\n        {\n          unfold make_globalenv. rewrite PL.\n          reflexivity.\n        }           \n        assert (Hge': make_globalenv s CTXT LH = ret (Genv.globalenv ph)).\n        {\n          unfold make_globalenv. rewrite PH.\n          reflexivity.\n        }           \n        apply make_globalenv_stencil_matches in Hge.          \n        apply make_globalenv_stencil_matches in Hge'.          \n        inv Hge. inv Hge'.\n        erewrite stencil_matches_symbols.\n        erewrite stencil_matches_symbols0.\n        trivial.\n\n      + (* initial state *)\n        intros. inv H.\n        assert (Hge: make_globalenv s CTXT LH = ret (Genv.globalenv ph)).\n        {\n          unfold make_globalenv. rewrite PH.\n          reflexivity.\n        }            \n        apply make_globalenv_stencil_matches in Hge.\n        inv Hge. \n        assert (Hge: make_globalenv s (CTXT \u2295 M) LL = ret (Genv.globalenv pl)).\n        {\n          unfold make_globalenv. rewrite PL.\n          reflexivity.\n        }            \n        apply make_globalenv_stencil_matches in Hge.\n        inv Hge.\n        \n        assert(Hprog_defs: prog_defs_le (prog_defs ph) (prog_defs pl)).\n        {\n          inv REFINE.\n          eapply cl_sim_layer_pointwise in cl_sim_layer.\n          destruct cl_sim_layer as [Hprim Hvar].\n          assert (HLayerOK: LayerOK LH).\n          {\n            eapply make_program_layer_ok.\n            esplit. eassumption.\n          }\n          (*assert (HLayerOK': LayerOK (\u301aM \u301b LL \u2295 LL)).\n            {\n              assert (Hp: isOK (make_program s CTXT (\u301aM \u301b LL \u2295 LL))).\n              {\n                eapply make_program_vertical'; eassumption.\n              }    \n              eapply make_program_layer_ok; eassumption.\n            }*)\n          eapply make_program_init_mem_le; try eassumption;\n          intros.\n          - destruct H.\n            + eapply LayerOK_not_None in HLayerOK; eauto.\n              destruct HLayerOK as [func Hprim'].\n              specialize (Hprim i).\n              rewrite Hprim' in Hprim.\n              specialize (get_layer_primitive_oplus i (\u301aM \u301b LL) LL). \n              intros Heq.\n              destruct (HLayerOK' i) as [HLayerOK _ _].\n              destruct HLayerOK as [? HLayerOK].\n              rewrite HLayerOK in Hprim. rewrite HLayerOK in Heq.\n              Opaque mapsto semof.\n              inv Hprim. inv H3.\n              simpl in Heq.\n              caseEq (get_layer_primitive i LL); intros; simpl in H1; rewrite H1 in *.\n              destruct o.\n              * (*get_layer_primitive i LL = OK Some*)\n                left. red; intros. inv H3.\n              * (*get_layer_primitive i LL = OK None*)\n                right. red; intros.\n                specialize (get_module_function_oplus i CTXT M).\n                unfold isOKNone in H3.\n                rewrite H3. intros Hle. simpl in Hle.\n                caseEq (get_module_function i M); intros; rewrite H4 in *;\n                try destruct o; destruct (get_module_function i CTXT);\n                try destruct o; inv_monad Hle; try discriminate.\n                rewrite get_layer_primitive_oplus in HLayerOK.\n                rewrite get_semof_primitive in HLayerOK.\n                rewrite H4 in HLayerOK.\n                simpl in HLayerOK.\n                rewrite H1 in HLayerOK.\n                discriminate.\n              * left; discriminate.\n            + right. red; intros. elim H.\n              specialize (get_module_function_oplus i CTXT M).\n              unfold isOKNone in H1. rewrite H1.\n              intros Hle. simpl in Hle.\n              destruct (get_module_function i CTXT).\n              destruct o. destruct (get_module_function i M); try destruct o; inv_monad Hle; try discriminate.\n              reflexivity.\n              destruct (get_module_function i M); try destruct o; inv_monad Hle; try discriminate.\n          - destruct H.\n            + clear HLayerOK.\n              (*destruct HLayerOK as [_ Hvar'].*)\n              specialize (Hvar i).\n              (*specialize (Hvar' i).\n                destruct Hvar' as [? Hvar'].\n                rewrite Hvar' in Hvar.*)\n              rewrite H in Hvar.\n              specialize (get_layer_globalvar_oplus i (\u301aM \u301b LL) LL). \n              intros Heq.\n              specialize (LayerOK_elim _ i v HLayerOK'). intros Him.\n              destruct (HLayerOK' i) as [_ HLayerOK _].\n              destruct HLayerOK as [? HLayerOK].\n              rewrite HLayerOK in Hvar. rewrite HLayerOK in Heq.\n              Opaque mapsto semof.\n              inv Hvar. inv H3. specialize (Him HLayerOK).\n              simpl in Heq.\n              caseEq (get_layer_globalvar i LL); intros; simpl in H1; rewrite H1 in *.\n              destruct o.\n              * (*get_layer_globalvar i LL = OK Some*)\n                caseEq (get_layer_globalvar i (\u301aM \u301b LL)); intros; simpl in H2; rewrite H2 in Heq;\n                try destruct o; inv_monad Heq.\n                discriminate.\n                inv H4. left; reflexivity.\n              * (*get_layer_globalvar i LL = OK None*)\n                right.\n                rewrite get_layer_globalvar_oplus in HLayerOK.\n                rewrite get_semof_globalvar in HLayerOK.\n                setoid_rewrite H1 in HLayerOK.\n                rewrite id_right in HLayerOK.\n                assert (MCOK: ModuleOK (CTXT \u2295 M)).\n                {\n                  eapply make_program_module_ok.\n                  eexists.\n                  eassumption.\n                }\n                destruct (MCOK i) as [_ [y' Hy'] _].\n                get_module_normalize_in Hy'.\n                apply res_option_oplus_ok_inv in Hy'.\n                destruct Hy' as [[HC HM] | [HM HC]]; try congruence.\n                get_module_normalize.\n                rewrite HC.\n                rewrite id_left.\n                assumption.\n              * (*get_layer_globalvar i LL = OK None*)\n                caseEq (get_layer_globalvar i (\u301aM \u301b LL)); intros; simpl in H2;\n                rewrite H2 in Heq; try destruct o; inv_monad Heq.\n            + right. \n              specialize (get_module_variable_oplus i CTXT M).\n              intros Hle.\n              exploit (make_program_module_ok s (CTXT \u2295 M) LL).\n              esplit; eassumption.\n              intros [_ Hmo _].\n              destruct Hmo as [? Hmo]. rewrite Hmo in Hle.\n              simpl in *. unfold module in *. \n              rewrite H in Hle.\n              destruct (get_module_variable i M); try destruct o;\n              inv_monad Hle.\n              * discriminate.\n              * inv H2.\n                assumption.\n        }\n        \n        (* Are there any lemmas to prove the init_mem exists*)\n        assert (Hinit_mem_exists: exists m': mwd DL, Genv.init_mem pl = Some m').\n        {\n          (*This is the only lemma that I can find*)\n          eapply (Genv.init_mem_exists pl).\n          intros.\n          exploit (make_program_gvar (D:=DL)); try eassumption.\n          intros [vi[Hg Hor]].\n          inv INIT_SIM.\n          destruct Hor as [Hor|Hor].\n          - specialize (get_module_variable_oplus i CTXT M).\n            rewrite Hor. intros Hle. \n            simpl in Hle.\n            caseEq (get_module_variable i CTXT); intros;\n            rewrite H1 in Hle; try destruct o; \n            caseEq (get_module_variable i M); intros;\n            rewrite H2 in Hle; try destruct o; inv_monad Hle;\n            try discriminate; inv H4.\n            + rewrite (Genv.init_data_list_valid_symbols_preserved _ (Genv.globalenv ph)).\n              * specialize (Genv.init_mem_valid _ _ H0).\n                intros HW. specialize (HW i (globvar_map make_varinfo vi)).\n                apply HW. \n                eapply make_program_get_module_variable; try eassumption.\n              * intros. congruence.\n            + simpl. eauto 2.\n          - specialize (cl_init_sim_low i). \n            congruence.\n        }\n\n        destruct Hinit_mem_exists as [? ?].\n        destruct m0, x. erewrite init_mem_with_data in H0.\n        (* It is required to prove the relate and match empty data *)\n        assert(Hcl_init_mem: cl_init_sim_mem DH DL R s m0).\n        {\n          inv INIT_SIM. \n          eapply cl_init_sim_init_mem with (CTXT:= CTXT) ; eauto.\n          erewrite PL. erewrite init_mem_with_data in H.\n          caseEq (Genv.init_mem pl); intros; rewrite H1 in H; try discriminate. \n          inv H. rewrite <- H1.\n          reflexivity.\n        }\n\n        assert(Hprog_main: (prog_main ph) = (prog_main pl)).\n        {\n          erewrite make_program_prog_main; try eassumption.\n          erewrite make_program_prog_main; try eassumption.\n          reflexivity.\n        }\n\n        pose proof H as Hinit_mem'.\n        erewrite init_mem_with_data in H.          \n        caseEq (Genv.init_mem ph); intros; rewrite H1 in H0; contra_inv.\n        caseEq (Genv.init_mem pl); intros; rewrite H2 in H; contra_inv.\n        inv H. inv H0.\n        exploit (Genv.init_mem_le_genv_next _ _ Hprog_defs); eauto.\n        intros Hnextblock.\n        assert(Hgenv_next: Mem.nextblock m = genv_next s).\n        {\n          eapply Genv.init_mem_genv_next in H1.\n          rewrite <- H1.\n          assumption.\n        }\n        assert(Hgenv_next': Mem.nextblock m0 = genv_next s).\n        {\n          eapply Genv.init_mem_genv_next in H2.\n          rewrite <- H2.\n          assumption.\n        }\n        assert (Hval_inj: forall reg,\n                            val_inject (Mem.flat_inj (genv_next s)) (Pregmap.get reg (Pregmap.init Vundef))\n                                       (Pregmap.get reg (Pregmap.init Vundef))).\n        {\n          intros. unfold Pregmap.get. rewrite Pregmap.gi.\n          constructor.\n        }\n        esplit. split; eauto.\n        econstructor; eauto.\n        subst rs0 ge.\n        econstructor; eauto.\n        econstructor; eauto.\n        econstructor; eauto.\n        * (* Mem.inject *)\n          rewrite <- Hgenv_next.\n          exploit (Genv.init_mem_le_inject _ _ Hprog_defs); eauto.\n        * (* relate_AbData *)\n          eapply cl_init_sim_relate; eauto.\n        * (* match_AbData *)\n          eapply cl_init_sim_match; eauto.\n        * (* flat_inj *)\n          unfold Mem.flat_inj. intros.\n          destruct (plt b1 (genv_next s)); contra_inv.\n          inv H. split; reflexivity.\n        * (* nextblock *)\n          rewrite Hnextblock. xomega.\n        * (* no perm *)\n          inv INIT_SIM.\n          red; intros. specialize (cl_init_sim_glbl _ H).\n\n          (* XXXX: How to prove the new_glbl identifiers has no permission on the init_mem??*)\n          (* XXX: We have to prove the Genv.find_func_ptr and Genv_find_var_info are none*)\n          (* XXX: How to guarrantee that new_glbl is not defined in the module M ?????*)\n          apply make_program_make_globalenv in PH.\n          assert (HmOK: ModuleOK (CTXT \u2295 M)).\n          {\n            eapply make_program_module_ok.\n            esplit; eauto.\n          }\n          rename HLayerOK' into HLOK.\n          (*assert (HLOK: LayerOK (\u301aM \u301b LL \u2295 LL)).\n            {\n              eapply make_program_layer_ok.\n              eapply make_program_vertical'; eassumption.\n            }*)\n          assert (MOK: ModuleOK M).\n          {\n            eapply module_ok_antitonic; try eassumption.\n            apply right_upper_bound.\n          }\n\n          eapply Genv.init_mem_no_perm; eauto.\n          erewrite stencil_matches_symbols; now eauto.\n          (* Genv.find_funct_ptr (Genv.globalenv ph) b = None *)\n\n          {\n            caseEq (Genv.find_funct_ptr (Genv.globalenv ph) b); intros; try reflexivity.\n            { \n              eapply make_globalenv_find_funct_ptr in H4; eauto.\n              destruct H4 as [i0[Hf Hmo]].\n              erewrite stencil_matches_symbols in Hf.\n              specialize (genv_vars_inj _ _ _ _ H0 Hf).\n              intros; subst.\n              specialize (cl_init_sim_glbl_module _ H).\n              destruct cl_init_sim_glbl_module as [vi Hmo'].\n              destruct Hmo as [ Hmo| Hmo].\n              {\n                destruct Hmo as [i'[Hmo _]].\n                destruct (HmOK i0) as [Hmog Hmov HNone].\n                destruct HNone.\n                {\n                  unfold isOKNone in *.\n                  rewrite get_module_function_oplus in H4.\n                  rewrite Hmo in H4.\n                  destruct (get_module_function i0 M) as [[|]|]; discriminate.\n                }\n                {\n                  specialize (get_module_variable_oplus i0 CTXT M).\n                  unfold isOKNone in H4. rewrite H4.\n                  rewrite Hmo'. intros Hle. simpl in Hle. \n                  destruct (get_module_variable i0 CTXT) as [[|]|]; discriminate.\n                }\n              }\n              inv REFINE.\n              eapply cl_sim_layer_pointwise in cl_sim_layer.\n              destruct Hmo as [fe[Hmo _]].\n              destruct cl_sim_layer as [cl_layer _].\n              specialize (cl_layer i0).\n              rewrite Hmo in cl_layer.\n              assert (~ isOKNone (get_layer_primitive i0 (\u301aM \u301b LL \u2295 LL))).\n              {\n                simpl; inv cl_layer; try discriminate.\n                inv H6. discriminate.\n              }\n              exploit (LayerOK_not_None (D:= DL)); eauto.\n              intros [func Hl].\n              specialize (get_layer_primitive_oplus i0 (\u301aM \u301b LL) LL). \n              rewrite Hl. intros Hle.\n              caseEq (get_layer_primitive i0 LL); intros;\n              rewrite H5 in Hle; try destruct o;\n              caseEq (get_layer_primitive i0 (\u301aM \u301b LL)); intros;\n              rewrite H6 in Hle; try destruct o; inv Hle.\n              {\n                specialize (cl_init_sim_glbl_prim _ H).\n                rewrite Hmo in cl_init_sim_glbl_prim.\n                inv cl_init_sim_glbl_prim.\n              }\n              {\n                destruct (MOK i0) as [MOK1 MOK2 _].\n                exploit get_module_function_variable_disjoint; eauto.\n                intros HT. inv HT.\n                {\n                  rewrite get_semof_primitive in H6.\n                  unfold isOKNone in H7; rewrite H7 in H6.\n                  discriminate.\n                }\n                {\n                  rewrite Hmo' in H7. inv H7.\n                }\n              }\n            }\n          }\n          (* Genv.find_var_info (Genv.globalenv ph) b = None *)\n          {\n            caseEq (Genv.find_var_info (Genv.globalenv ph) b); intros; try reflexivity.\n            { \n              eapply make_globalenv_find_var_info in H4; eauto.\n              destruct H4 as [i0[Hf Hmo]].\n              destruct Hmo as [vi0[_ Hmo]].\n              erewrite stencil_matches_symbols in Hf.\n              specialize (genv_vars_inj _ _ _ _ H0 Hf).\n              intros; subst.\n              specialize (cl_init_sim_glbl_module _ H).\n              destruct cl_init_sim_glbl_module as [vi Hmo'].\n              destruct Hmo as [ Hmo| Hmo].\n              {\n                destruct (HmOK i0) as [_ Hmov _].\n                specialize (get_module_variable_oplus i0 CTXT M).\n                rewrite Hmo. rewrite Hmo'.\n                destruct Hmov as [? Hmov]. rewrite Hmov.\n                intros Hle. inv Hle.\n              }\n              rewrite Hmo in cl_init_sim_glbl.\n              inv cl_init_sim_glbl.\n            }\n          }\n\n        * (* b< Mem.nextblock m *)\n          intros. rewrite Hgenv_next.\n          eapply genv_symb_range in H0.\n          xomega.\n        * (* val_inject *)\n          val_inject_simpl.\n          unfold symbol_offset.\n          erewrite stencil_matches_symbols.\n          erewrite stencil_matches_symbols0.\n          rewrite Hprog_main.\n          caseEq (find_symbol s (prog_main pl)); intros.\n          assert (Mem.flat_inj (genv_next s) b = Some (b, 0%Z)).\n          {\n            eapply stencil_find_symbol_inject'; eauto.\n          }\n          econstructor; eauto.\n          constructor.\n        * (* high_level_inv *)\n          eapply empty_data_high_level_invariant.            \n        * (* high_level_inv *)\n          eapply empty_data_high_level_invariant.            \n        * (* low_level_invariant *)\n          eapply empty_data_low_level_invariant.\n        * (* asm_inv *)\n          split; eauto.\n          econstructor; eauto.\n          lift_unfold. rewrite Hgenv_next'. xomega.\n          lift_unfold. eapply Genv.initmem_inject_neutral; eauto.\n          lift_unfold. rewrite Hgenv_next'.\n          val_inject_simpl.\n          unfold symbol_offset.\n          erewrite stencil_matches_symbols0.\n          caseEq (find_symbol s (prog_main pl)); intros.\n          assert (Mem.flat_inj (genv_next s) b = Some (b, 0%Z)).\n          {\n            eapply stencil_find_symbol_inject'; eauto.\n          }\n          econstructor; eauto.\n          constructor.\n          repeat (eapply AsmX.set_reg_wt; try constructor).\n          unfold symbol_offset.\n          destruct (Genv.find_symbol (Genv.globalenv pl) (prog_main pl)); constructor.\n      + (* final state *)\n        intros. inv H0.\n        inv H. inv H4.\n        unfold Pregmap.get in *.\n        econstructor; eauto.\n        specialize (match_reg PC).\n        rewrite H1 in match_reg. inv match_reg.\n        reflexivity.\n        specialize (match_reg EAX).\n        rewrite H2 in match_reg. inv match_reg.\n        reflexivity.\n\n      + (* one_plus step soundness *)\n        intros. simpl in H. simpl.\n        assert (Hle: CTXT \u2264 CTXT) by reflexivity.\n        assert (Hge: make_globalenv s CTXT LH = ret (Genv.globalenv ph)).\n        {\n          unfold make_globalenv. rewrite PH.\n          reflexivity.\n        }\n        \n        assert (Hp: isOK (make_program s CTXT (\u301aM \u301b LL \u2295 LL))).\n        {\n          eapply make_program_vertical'; eassumption.\n        }            \n        assert (Hge': isOK (make_globalenv s CTXT (\u301aM \u301b LL \u2295 LL))).\n        {\n          destruct Hp as [p Hp].\n          eapply make_program_make_globalenv in Hp.\n          esplit. eauto.\n        }    \n        destruct Hge' as [ge' Hge'].\n        specialize (make_globlenv_monotonic_weak _ _ _ _ Hle REFINE Hge ge' Hge'); eauto 2.\n        intros Hle'.\n        (* INSTANCE_NOT_FOUND: The following instances are required, but currently we could not prove *)\n        (* We can add them to sprimcall_sim, or to the definition of semof_fundef of LAsm *)\n\n        pose proof Hge as Hge_match.\n        apply make_globalenv_stencil_matches in Hge.\n        pose proof Hge' as Hge_match'.\n        apply make_globalenv_stencil_matches in Hge'.\n        destruct s1, s2, s1'. destruct m, m0, m1.\n        assert (Hge_external':\n                  forall b ef, \n                    Genv.find_funct_ptr ge' b = Some (External ef) ->\n                    exists i sg, ef = EF_external i sg) by\n            abstract\n              (intros until ef; eapply ge_external_valid; eauto).\n\n        assert (OKLayer: LayerOK (\u301aM \u301b LL \u2295 LL)).\n        {\n          eapply make_program_layer_ok; eassumption.\n        }\n\n        assert (Hnames: LayerNamesMatch DL (\u301aM\u301b LL \u2295 LL)). {\n          apply layer_names_match_oplus; eauto.\n          apply lasm_semantics_names_match; eauto.\n          rewrite <- left_upper_bound in OKLayer.\n          eassumption.\n        }\n\n        exploit (one_step_sim_monotonic_alt s (Genv.globalenv ph) ge'); eauto 2.\n\n        pose proof prim_valid as prim_valid'.\n        {\n          unfold get_layer_prim_valid in *.\n          intros.\n          specialize (get_layer_primitive_oplus i (\u301aM \u301b LL) LL). rewrite H1.\n          intros Heq.\n          caseEq (get_layer_primitive i (\u301aM \u301b LL)); intros; rewrite H2 in Heq;\n          try destruct o; caseEq (get_layer_primitive i LL); intros; rewrite H3 in Heq;\n          try destruct o; inv_monad Heq; try discriminate.\n          {\n            assert (MOK: ModuleOK M).\n            {\n              assert (HmOK: ModuleOK (CTXT \u2295 M)).\n              {\n                eapply make_program_module_ok.\n                esplit; eauto.\n              }\n              eapply module_ok_antitonic; try eassumption.\n              apply right_upper_bound.\n            }\n            destruct (MOK i) as [[[|] MOK'] _ _].\n            {\n              assert (mk_prog: isOK(make_program s M LL)).\n              {\n                eapply make_program_monotonic_exists; try eassumption; try reflexivity.\n                apply right_upper_bound.\n              }\n              rewrite get_semof_primitive in H2.\n              rewrite MOK' in H2.\n              unfold semof_function in H2; monad_norm.\n              unfold module, module_ops in *.\n              simpl in *.\n              inv_monad H2.\n              inv H2.\n              subst.\n              simpl.\n              destruct (Decision.decide (ExtcallInvariantsDefined LL)).\n              destruct (Decision.decide (PrimcallInvariantsDefined LL)).\n              destruct (Decision.decide (LayerNamesMatch DL LL)).\n              destruct (Decision.decide (get_layer_prim_valid LL s)).\n              rewrite accessors_defined_weak; try assumption.\n              destruct mk_prog as [? mk_prog].\n              unfold module, module_ops in *.\n              rewrite mk_prog. reflexivity.\n              elim n; assumption.\n              elim n; assumption.\n              elim n; assumption.\n              elim n; assumption.\n            }\n            {\n              rewrite get_semof_primitive in H2.\n              rewrite MOK' in H2.\n              discriminate.\n            }\n          }\n          eauto.\n        }\n        \n        intros [rs2' [m2'[d2'[Hstep' Hmatch']]]].\n        refine_split'; eauto 2.\n        assert (Hge'': make_globalenv s (CTXT \u2295 M) LL = ret (Genv.globalenv pl)).\n        {\n          unfold make_globalenv. rewrite PL.\n          reflexivity.\n        }\n        (*assert (Hle'': LL \u2264 \u301aM \u301b LL \u2295 LL) by apply right_upper_bound.*)\n        eapply one_step_vertical_composition; eauto.\n    (** eapply cl_le_invs_ext; try eassumption.\n     * eapply cl_le_invs_prim; try eassumption.\n     * eapply cl_le_get_layer_prim_valid; try eassumption.*)\n    Qed.\n\n  Theorem soundness_determinate :\n    forall {DL: compatdata}\n           (LL: compatlayer DL)\n           (LL_ACC_DEF: LAsm.AccessorsDefined LL)\n           (LL_DETERM: ExternalCallsXDefined LL)\n           (LL_DETERM': PrimitiveCallsXDefined LL)\n           M s pl\n           (PL: make_program s M LL = OK pl),\n      determinate (LAsm.semantics (lcfg_ops := LC LL) pl).\n  Proof.\n    intros.\n    assert(externalcall_prf: ExternalCalls (mwd DL) \n                                           (external_calls_ops:= compatlayer_extcall_ops LL)).\n    {\n      eapply compatlayer_extcall_strong; assumption.\n    }\n    intros; constructor; simpl; intros.\n    - (* determ *)\n      inv H; inv H0; Equalities.\n      + split. constructor. auto.\n      + discriminate.\n      + discriminate.\n      + inv H11. \n      + inv H4. inv H9.\n        specialize (Events.external_call_determ (external_calls_ops:= compatlayer_extcall_ops LL)\n                                                _ _ _ _ _ _ _ _ _ _ _ H H0).\n        intros [? ?]. esplit; eauto.\n        intros. destruct H4 as [? ?]; subst; trivial.\n      + discriminate.\n      + inv H5. inv H13.\n        assert (vargs0 = vargs) by (eapply annot_arguments_determ_with_data; eauto). subst.\n        specialize (Events.external_call_determ (external_calls_ops:= compatlayer_extcall_ops LL)\n                                                _ _ _ _ _ _ _ _ _ _ _ H H0).\n        intros [? ?]. esplit; eauto.\n        intros. destruct H5 as [? ?]; subst; trivial.\n      + inv H4. inv H9.\n        assert (args0 = args) by (eapply extcall_arguments_determ_with_data; eauto). subst.\n        specialize (Events.external_call_determ (external_calls_ops:= compatlayer_extcall_ops LL)\n                                                _ _ _ _ _ _ _ _ _ _ _ H H0).\n        intros [? ?]. esplit; eauto.\n        intros. destruct H4 as [? ?]; subst; trivial.\n      + specialize (external_prim_false _ _ _ _ _ _ _ _ _ _ _ _ _ H4 H10).\n        intros HF; inv HF.\n      + specialize (external_prim_false _ _ _ _ _ _ _ _ _ _ _ _ _ H8 H3).\n        intros HF; inv HF.\n      +\n        inv H3. inv H9.\n        destruct H as [?[?[?[? Hsem]]]]; subst.\n        destruct H0 as [?[?[?[? Hsem']]]]; subst.\n        inv H. rewrite H0 in H2. inv H2.\n        inv Hsem. inv Hsem'. \n        eapply stencil_matches_unique in H4; try apply H. subst.\n        unfold PrimitiveCallsXDefined in *.\n        specialize (LL_DETERM' x0).\n        rewrite H0 in LL_DETERM'. simpl in LL_DETERM'.\n        caseEq (sprimcall_props DL \u03c3); intros; rewrite H3 in *; try discriminate.\n        specialize (primitive_call_determ _ _ _ _ _ _ _ H2 H5).\n        intros [? ?]; subst.\n        split; eauto. constructor.\n    - (* trace length *)\n      red; intros; inv H; simpl.\n      omega.\n      inv H3. eapply external_call_trace_length; eauto.\n      inv H4. eapply external_call_trace_length; eauto.\n      inv H3. eapply external_call_trace_length; eauto.\n      inv H2. destruct H as [?[?[?[? Hsem]]]]; subst.\n      inv Hsem. simpl. omega.\n    - (* initial states *)\n      inv H; inv H0. f_equal. congruence.\n    - (* final no step *)\n      inv H. unfold Vzero in H0. red; intros; red; intros. inv H; congruence.\n    - (* final states *)\n      inv H; inv H0. congruence.\n  Qed.\n\n  Theorem soundness_receptive :\n    forall {DH: compatdata}\n           (LH: compatlayer DH)\n           (LH_ACC_DEF: LAsm.AccessorsDefined LH)\n           (LH_EXT: ExternalCallsXDefined LH)\n           M s ph\n           (PL: make_program s M LH = OK ph),\n      receptive (LAsm.semantics (lcfg_ops := LC LH) ph).\n  Proof.\n    intros.\n    assert(externalcall_prf: ExternalCalls (mwd DH) \n                                             (external_calls_ops:= compatlayer_extcall_ops LH)).\n    {\n      eapply compatlayer_extcall_strong; assumption.\n    }\n    split.\n    inversion 1; subst.\n    - inversion 1; subst; eauto.\n    - intros. inv H3.\n      exploit (external_call_receptive \n                 (mem:= mwd DH) \n                 (external_calls_ops:= compatlayer_extcall_ops LH)); eauto.\n      intros [? [? ?]]. esplit. econstructor; eauto. econstructor; eauto. \n    - intros. inv H4.\n      exploit (external_call_receptive \n                 (mem:= mwd DH) \n                 (external_calls_ops:= compatlayer_extcall_ops LH)); eauto.\n      intros [? [? ?]]. esplit. eapply exec_step_annot; eauto. econstructor; eauto. \n    - intros. inv H3.\n      exploit (external_call_receptive \n                 (mem:= mwd DH) \n                 (external_calls_ops:= compatlayer_extcall_ops LH)); eauto.\n      intros [? [? ?]]. esplit. eapply exec_step_external; eauto. econstructor; eauto. \n    - intros. pose proof H2 as Hprim.  inv Hprim.\n      destruct H4 as [?[?[?[? Hsem]]]]; subst.\n      inv Hsem. inv H3.\n      esplit. eapply exec_step_prim_call; eauto.\n    - (* single event *)\n      red; intros; inv H; simpl.\n      omega.\n      inv H3. eapply external_call_trace_length; eauto.\n      inv H4. eapply external_call_trace_length; eauto.\n      inv H3. eapply external_call_trace_length; eauto.\n      inv H2. destruct H as [?[?[?[? Hsem]]]]; subst.\n      inv Hsem. simpl. omega.\n  Qed.\n\n  Theorem soundness:\n    forall {DH DL: compatdata}\n           (R: freerg compatrel DH DL)\n           (LH: compatlayer DH)\n           (LL: compatlayer DL)\n           (LH_ACC_DEF: LAsm.AccessorsDefined LH)\n           (LL_ACC_DEF: LAsm.AccessorsDefined LL)\n           (LH_RECEPT: ExternalCallsXDefined (LH))\n           (LL_DETERM: ExternalCallsXDefined (LL))\n           (LL_DETERM': PrimitiveCallsXDefined LL)\n           (LH_INV: ExtcallInvariantsDefined LH)\n           (LL_INV: ExtcallInvariantsDefined LL)\n           (LH_PRIM_INV: PrimcallInvariantsDefined LH)\n           (LL_PRIM_INV: PrimcallInvariantsDefined LL)\n           (LH_NAMES: LayerNamesMatch DH LH)\n           (LL_NAMSE: LayerNamesMatch DL LL)\n           (M: LAsm.module)\n           (builtin_idents_norepet_prf: CompCertBuiltins.BuiltinIdentsNorepet)\n           (REFINE: cl_sim _ _ R LH (\u301a M \u301b LL \u2295 LL))\n           (INIT_SIM: cl_init_sim _ _ R LH M LL)\n           (CTXT: LAsm.module) s pl\n           (PL: make_program s (CTXT \u2295 M) LL = OK pl)\n           (prim_valid: get_layer_prim_valid LL s)\n           ph\n           (PH: make_program s CTXT LH = OK ph)\n\n           (***  XXX: We have to add this LayerOK pre-condition for now on, \nhopefully we can remove it in the future ***)\n           (HLayerOK': LayerOK (\u301a M \u301b LL \u2295 LL)),\n      backward_simulation\n        (LAsm.semantics (lcfg_ops := LC LH) ph)\n        (LAsm.semantics (lcfg_ops := LC LL) pl).\n  Proof.\n\n    intros. \n    assert (acc_def_prf2: AccessorsDefined (\u301aM \u301b LL \u2295 LL)).\n    {\n      eapply accessors_monotonic_plus_none; try assumption; simpl; reflexivity.\n    }\n\n    (** Thanks to [INIT_SIM], we know that [R] cannot be the identity relation. *)\n    destruct R as [| DL R].\n    {\n      simpl in *.\n      elim INIT_SIM.\n    }\n\n    eapply forward_to_backward_simulation; eauto.\n    - eapply soundness_forward; eauto.\n    - eapply soundness_receptive; eauto.\n    - eapply soundness_determinate; eauto.\n  Qed.\n\nEnd WITHLAYERS.\n"}
{"text": "import algebra.group algebra.group_power\n\n\nvariables {G: Type*} (a b : G)\n\ntheorem Q_24 [group G] (H1 : \u2200 a b : G, (a * b)^3 = a^3 * b^3) (H2 : \u2200 x : G, x^3 = 1 \u2192 x = 1) : \n\u2200 a b : G, a * b = b * a :=\n\u03bb a b : G,\n\nhave Lem1 : \u2200 x y : G, (y * x)^2 = x^2 * y^2, from \n    \u03bb x y : G, \n    have H10 : (a * b) * (a * b) * (a * b) = (a * a^2) * b^3, from sorry, \n    have H11 : a * (b * (a * b) * (a * b)) = a * (a^2 * b^3), from sorry, \n    have H12 : b * (a * b) * (a * b) = a^2 * (b^2 * b), from sorry,\n    have H13 : (b * (a * b) * a) * b = (a^2 * b^2) * b, from sorry, \n    have H14 : b * (a * b) * a = a^2 * b^2, from sorry, \nsorry, \n\nhave Lem2 : b^2 * a^3 = a^3 * b^2, from \n    have H20 : a * ((b * a) * (b * a)) = a * (a^2 * b^2), from sorry, \n    have H21 : (a * b) * (a * b) * a = (a * a^2) * b^2, from sorry, \n    have H22 : (a * b)^2 * a = a^3 * b^2, from sorry,\n    have H23 : b^2 * a^2 * a = a^3 * b^2, from sorry, \nsorry, \n \nlet h : G := a * b * a^(-1 : \u2124) * b^(-1 : \u2124) in\nhave Lem3 : (h^2)^3 = 1, from \ncalc (h^2)^3\n    = ((a * b * a^(-1 : \u2124) * b^(-1 : \u2124))^2)^3 : sorry\n... = (b^(-2 : \u2124) * ((a * b * a^(-1 : \u2124))^2))^3 : sorry\n... = (b^(-2 : \u2124) * (a^(-2 : \u2124)) * (a * b)^2)^3 : sorry\n... = (b^(-2 : \u2124) * ((a^(-2 : \u2124)) * (a^2 * b^2)))^3 : sorry\n... = ( b^(-2 : \u2124) * (a^(-2 : \u2124) * (b^2 * a^2)) )^3 : sorry\n... = (b^(-2 : \u2124))^3 * (a^(-2 : \u2124))^3 * b^6 * a^6 : sorry\n... = (b^(-3 : \u2124))^2 * (a^(-2 : \u2124))^3 * b^6 * a^6 : sorry\n... = (a^(-2 : \u2124))^3 * (b^(-3 : \u2124))^2 * b^6 * a^6 : sorry\n... = a^(-6 : \u2124) * b^(-6 : \u2124) * b^6 * a^6 : sorry\n... = a^(-6 : \u2124) * b^(-6 : \u2124) * b^6 * a^6 : sorry\n... = 1 : sorry, \n\nhave Lem4 : h^2 = 1, from sorry, \n\nshow a * b = b * a, from sorry\n\n"}
{"text": "my_f(x,y) = 2x + y\nmy_derivative(x,y) = ForwardDiff.derivative(x->my_f(x,y),x)"}
{"text": "theory Scratch\n  imports Main\nbegin\nlemma a:\n  assumes \"A\"\n  assumes \"B\"\n  shows \"A \\<and> B \\<Longrightarrow> True\"\n  using [[simp_trace]]\n  apply auto\n  done\nend"}
{"text": "/-\nCopyright (c) 2020 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\n\nimport field_theory.splitting_field\nimport field_theory.perfect_closure\nimport field_theory.separable\n\n/-!\n# Algebraically Closed Field\n\nIn this file we define the typeclass for algebraically closed fields and algebraic closures,\nand prove some of their properties.\n\n## Main Definitions\n\n- `is_alg_closed k` is the typeclass saying `k` is an algebraically closed field, i.e. every\npolynomial in `k` splits.\n\n- `is_alg_closure R K` is the typeclass saying `K` is an algebraic closure of `R`, where `R` is a\n  commutative ring. This means that the map from `R` to `K` is injective, and `K` is\n  algebraically closed and algebraic over `R`\n\n- `is_alg_closed.lift` is a map from an algebraic extension `L` of `R`, into any algebraically\n  closed extension of `R`.\n\n- `is_alg_closure.equiv` is a proof that any two algebraic closures of the\n  same field are isomorphic.\n\n## Tags\n\nalgebraic closure, algebraically closed\n\n-/\nuniverses u v w\n\nopen_locale classical big_operators polynomial\nopen polynomial\n\nvariables (k : Type u) [field k]\n\n/-- Typeclass for algebraically closed fields.\n\nTo show `polynomial.splits p f` for an arbitrary ring homomorphism `f`,\nsee `is_alg_closed.splits_codomain` and `is_alg_closed.splits_domain`.\n-/\nclass is_alg_closed : Prop :=\n(splits : \u2200 p : k[X], p.splits $ ring_hom.id k)\n\n/-- Every polynomial splits in the field extension `f : K \u2192+* k` if `k` is algebraically closed.\n\nSee also `is_alg_closed.splits_domain` for the case where `K` is algebraically closed.\n-/\ntheorem is_alg_closed.splits_codomain {k K : Type*} [field k] [is_alg_closed k] [field K]\n  {f : K \u2192+* k} (p : K[X]) : p.splits f :=\nby { convert is_alg_closed.splits (p.map f), simp [splits_map_iff] }\n\n/-- Every polynomial splits in the field extension `f : K \u2192+* k` if `K` is algebraically closed.\n\nSee also `is_alg_closed.splits_codomain` for the case where `k` is algebraically closed.\n-/\ntheorem is_alg_closed.splits_domain {k K : Type*} [field k] [is_alg_closed k] [field K]\n  {f : k \u2192+* K} (p : k[X]) : p.splits f :=\npolynomial.splits_of_splits_id _ $ is_alg_closed.splits _\n\nnamespace is_alg_closed\n\nvariables {k}\n\ntheorem exists_root [is_alg_closed k] (p : k[X]) (hp : p.degree \u2260 0) : \u2203 x, is_root p x :=\nexists_root_of_splits _ (is_alg_closed.splits p) hp\n\nlemma exists_pow_nat_eq [is_alg_closed k] (x : k) {n : \u2115} (hn : 0 < n) : \u2203 z, z ^ n = x :=\nbegin\n  rcases exists_root (X ^ n - C x) _ with \u27e8z, hz\u27e9, swap,\n  { rw degree_X_pow_sub_C hn x,\n    exact ne_of_gt (with_bot.coe_lt_coe.2 hn) },\n  use z,\n  simp only [eval_C, eval_X, eval_pow, eval_sub, is_root.def] at hz,\n  exact sub_eq_zero.1 hz\nend\n\nlemma exists_eq_mul_self [is_alg_closed k] (x : k) : \u2203 z, x = z * z :=\nbegin\n  rcases exists_pow_nat_eq x zero_lt_two with \u27e8z, rfl\u27e9,\n  exact \u27e8z, sq z\u27e9\nend\n\n\n\ntheorem exists_eval\u2082_eq_zero_of_injective {R : Type*} [ring R] [is_alg_closed k] (f : R \u2192+* k)\n  (hf : function.injective f) (p : R[X]) (hp : p.degree \u2260 0) : \u2203 x, p.eval\u2082 f x = 0 :=\nlet \u27e8x, hx\u27e9 := exists_root (p.map f) (by rwa [degree_map_eq_of_injective hf]) in\n\u27e8x, by rwa [eval\u2082_eq_eval_map, \u2190 is_root]\u27e9\n\ntheorem exists_eval\u2082_eq_zero {R : Type*} [field R] [is_alg_closed k] (f : R \u2192+* k)\n  (p : R[X]) (hp : p.degree \u2260 0) : \u2203 x, p.eval\u2082 f x = 0 :=\nexists_eval\u2082_eq_zero_of_injective f f.injective p hp\n\nvariables (k)\n\ntheorem exists_aeval_eq_zero_of_injective {R : Type*} [comm_ring R] [is_alg_closed k] [algebra R k]\n  (hinj : function.injective (algebra_map R k)) (p : R[X]) (hp : p.degree \u2260 0) :\n  \u2203 x : k, aeval x p = 0 :=\nexists_eval\u2082_eq_zero_of_injective (algebra_map R k) hinj p hp\n\ntheorem exists_aeval_eq_zero {R : Type*} [field R] [is_alg_closed k] [algebra R k]\n  (p : R[X]) (hp : p.degree \u2260 0) : \u2203 x : k, aeval x p = 0 :=\nexists_eval\u2082_eq_zero (algebra_map R k) p hp\n\ntheorem of_exists_root (H : \u2200 p : k[X], p.monic \u2192 irreducible p \u2192 \u2203 x, p.eval x = 0) :\n  is_alg_closed k :=\n\u27e8\u03bb p, or.inr $ \u03bb q hq hqp,\n have irreducible (q * C (leading_coeff q)\u207b\u00b9),\n   by { rw \u2190 coe_norm_unit_of_ne_zero hq.ne_zero,\n        exact (associated_normalize _).irreducible hq },\n let \u27e8x, hx\u27e9 := H (q * C (leading_coeff q)\u207b\u00b9) (monic_mul_leading_coeff_inv hq.ne_zero) this in\n degree_mul_leading_coeff_inv q hq.ne_zero \u25b8 degree_eq_one_of_irreducible_of_root this hx\u27e9\n\nlemma degree_eq_one_of_irreducible [is_alg_closed k] {p : k[X]}\n  (hp : irreducible p) :\n  p.degree = 1 :=\ndegree_eq_one_of_irreducible_of_splits hp (is_alg_closed.splits_codomain _)\n\nlemma algebra_map_surjective_of_is_integral {k K : Type*} [field k] [ring K] [is_domain K]\n  [hk : is_alg_closed k] [algebra k K] (hf : algebra.is_integral k K) :\n  function.surjective (algebra_map k K) :=\nbegin\n  refine \u03bb x, \u27e8-((minpoly k x).coeff 0), _\u27e9,\n  have hq : (minpoly k x).leading_coeff = 1 := minpoly.monic (hf x),\n  have h : (minpoly k x).degree = 1 := degree_eq_one_of_irreducible k\n    (minpoly.irreducible (hf x)),\n  have : (aeval x (minpoly k x)) = 0 := minpoly.aeval k x,\n  rw [eq_X_add_C_of_degree_eq_one h, hq, C_1, one_mul,\n    aeval_add, aeval_X, aeval_C, add_eq_zero_iff_eq_neg] at this,\n  exact (ring_hom.map_neg (algebra_map k K) ((minpoly k x).coeff 0)).symm \u25b8 this.symm,\nend\n\nlemma algebra_map_surjective_of_is_integral'\n  {k K : Type*} [field k] [comm_ring K] [is_domain K]\n  [hk : is_alg_closed k] (f : k \u2192+* K) (hf : f.is_integral) : function.surjective f :=\n@algebra_map_surjective_of_is_integral k K _ _ _ _ f.to_algebra hf\n\nlemma algebra_map_surjective_of_is_algebraic {k K : Type*} [field k] [ring K] [is_domain K]\n  [hk : is_alg_closed k] [algebra k K] (hf : algebra.is_algebraic k K) :\n  function.surjective (algebra_map k K) :=\nalgebra_map_surjective_of_is_integral (algebra.is_algebraic_iff_is_integral.mp hf)\n\nend is_alg_closed\n\n/-- Typeclass for an extension being an algebraic closure. -/\nclass is_alg_closure (R : Type u) (K : Type v) [comm_ring R]\n  [field K] [algebra R K] [no_zero_smul_divisors R K] : Prop :=\n(alg_closed : is_alg_closed K)\n(algebraic : algebra.is_algebraic R K)\n\ntheorem is_alg_closure_iff (K : Type v) [field K] [algebra k K] :\n  is_alg_closure k K \u2194 is_alg_closed K \u2227 algebra.is_algebraic k K :=\n\u27e8\u03bb h, \u27e8h.1, h.2\u27e9, \u03bb h, \u27e8h.1, h.2\u27e9\u27e9\n\nnamespace lift\n\n/- In this section, the homomorphism from any algebraic extension into an algebraically\n  closed extension is proven to exist. The assumption that M is algebraically closed could probably\n  easily be switched to an assumption that M contains all the roots of polynomials in K -/\nvariables {K : Type u} {L : Type v} {M : Type w} [field K] [field L] [algebra K L]\n  [field M] [algebra K M] [is_alg_closed M] (hL : algebra.is_algebraic K L)\n\nvariables (K L M)\ninclude hL\nopen subalgebra alg_hom function\n\n/-- This structure is used to prove the existence of a homomorphism from any algebraic extension\ninto an algebraic closure -/\nstructure subfield_with_hom :=\n(carrier : subalgebra K L)\n(emb : carrier \u2192\u2090[K] M)\n\nvariables {K L M hL}\n\nnamespace subfield_with_hom\nvariables {E\u2081 E\u2082 E\u2083 : subfield_with_hom K L M hL}\n\ninstance : has_le (subfield_with_hom K L M hL) :=\n{ le := \u03bb E\u2081 E\u2082, \u2203 h : E\u2081.carrier \u2264 E\u2082.carrier, \u2200 x, E\u2082.emb (inclusion h x) = E\u2081.emb x }\n\nnoncomputable instance : inhabited (subfield_with_hom K L M hL) :=\n\u27e8{ carrier := \u22a5,\n   emb := (algebra.of_id K M).comp (algebra.bot_equiv K L).to_alg_hom }\u27e9\n\nlemma le_def : E\u2081 \u2264 E\u2082 \u2194 \u2203 h : E\u2081.carrier \u2264 E\u2082.carrier, \u2200 x, E\u2082.emb (inclusion h x) = E\u2081.emb x :=\niff.rfl\n\nlemma compat (h : E\u2081 \u2264 E\u2082) : \u2200 x, E\u2082.emb (inclusion h.fst x) = E\u2081.emb x :=\nby { rw le_def at h, cases h, assumption }\n\ninstance : preorder (subfield_with_hom K L M hL) :=\n{ le := (\u2264),\n  le_refl := \u03bb E, \u27e8le_rfl, by simp\u27e9,\n  le_trans := \u03bb E\u2081 E\u2082 E\u2083 h\u2081\u2082 h\u2082\u2083,\n    \u27e8le_trans h\u2081\u2082.fst h\u2082\u2083.fst,\n    \u03bb _, by erw [\u2190 inclusion_inclusion h\u2081\u2082.fst h\u2082\u2083.fst, compat, compat]\u27e9 }\n\nopen lattice\n\nlemma maximal_subfield_with_hom_chain_bounded (c : set (subfield_with_hom K L M hL))\n  (hc : is_chain (\u2264) c) :\n  \u2203 ub : subfield_with_hom K L M hL, \u2200 N, N \u2208 c \u2192 N \u2264 ub :=\nif hcn : c.nonempty then\nlet ub : subfield_with_hom K L M hL :=\nby haveI : nonempty c := set.nonempty.to_subtype hcn; exact\n{ carrier := \u2a06 i : c, (i : subfield_with_hom K L M hL).carrier,\n  emb := subalgebra.supr_lift\n    (\u03bb i : c, (i : subfield_with_hom K L M hL).carrier)\n    (\u03bb i j, let \u27e8k, hik, hjk\u27e9 := directed_on_iff_directed.1 hc.directed_on i j in\n      \u27e8k, hik.fst, hjk.fst\u27e9)\n    (\u03bb i, (i : subfield_with_hom K L M hL).emb)\n    begin\n      assume i j h,\n      ext x,\n      cases hc.total i.prop j.prop with hij hji,\n      { simp [\u2190 hij.snd x] },\n      { erw [alg_hom.comp_apply, \u2190 hji.snd (inclusion h x),\n          inclusion_inclusion, inclusion_self, alg_hom.id_apply x] }\n    end _ rfl } in\n\u27e8ub, \u03bb N hN, \u27e8(le_supr (\u03bb i : c, (i : subfield_with_hom K L M hL).carrier) \u27e8N, hN\u27e9 : _),\n  begin\n    intro x,\n    simp [ub],\n    refl\n  end\u27e9\u27e9\nelse by { rw [set.not_nonempty_iff_eq_empty] at hcn, simp [hcn], }\n\nvariables (hL M)\n\nlemma exists_maximal_subfield_with_hom : \u2203 E : subfield_with_hom K L M hL,\n  \u2200 N, E \u2264 N \u2192 N \u2264 E :=\nexists_maximal_of_chains_bounded\n  maximal_subfield_with_hom_chain_bounded (\u03bb _ _ _, le_trans)\n\n/-- The maximal `subfield_with_hom`. We later prove that this is equal to `\u22a4`. -/\nnoncomputable def maximal_subfield_with_hom : subfield_with_hom K L M hL :=\nclassical.some (exists_maximal_subfield_with_hom M hL)\n\nlemma maximal_subfield_with_hom_is_maximal :\n  \u2200 (N : subfield_with_hom K L M hL),\n    (maximal_subfield_with_hom M hL) \u2264 N \u2192 N \u2264 (maximal_subfield_with_hom M hL) :=\nclassical.some_spec (exists_maximal_subfield_with_hom M hL)\n\nlemma maximal_subfield_with_hom_eq_top :\n  (maximal_subfield_with_hom M hL).carrier = \u22a4 :=\nbegin\n  rw [eq_top_iff],\n  intros x _,\n  let p := minpoly K x,\n  let N : subalgebra K L := (maximal_subfield_with_hom M hL).carrier,\n  letI : field N := (subalgebra.is_field_of_algebraic N hL).to_field,\n  letI : algebra N M := (maximal_subfield_with_hom M hL).emb.to_ring_hom.to_algebra,\n  cases is_alg_closed.exists_aeval_eq_zero M (minpoly N x)\n    (ne_of_gt (minpoly.degree_pos\n      (is_algebraic_iff_is_integral.1\n        (algebra.is_algebraic_of_larger_base _ _ hL x)))) with y hy,\n  let O : subalgebra N L := algebra.adjoin N {(x : L)},\n  let larger_emb := ((adjoin_root.lift_hom (minpoly N x) y hy).comp\n     (alg_equiv.adjoin_singleton_equiv_adjoin_root_minpoly N x).to_alg_hom),\n  have hNO : N \u2264 O.restrict_scalars K,\n  { intros z hz,\n    show algebra_map N L \u27e8z, hz\u27e9 \u2208 O,\n    exact O.algebra_map_mem _ },\n  let O' : subfield_with_hom K L M hL :=\n  { carrier := O.restrict_scalars K,\n    emb := larger_emb.restrict_scalars K },\n  have hO' : maximal_subfield_with_hom M hL \u2264 O',\n  { refine \u27e8hNO, _\u27e9,\n    intros z,\n    show O'.emb (algebra_map N O z) = algebra_map N M z,\n    simp only [O', restrict_scalars_apply, alg_hom.commutes] },\n  refine (maximal_subfield_with_hom_is_maximal M hL O' hO').fst _,\n  exact algebra.subset_adjoin (set.mem_singleton x),\nend\n\nend subfield_with_hom\nend lift\n\nnamespace is_alg_closed\n\nvariables {K : Type u} [field K] {L : Type v} {M : Type w} [field L] [algebra K L]\n  [field M] [algebra K M] [is_alg_closed M] (hL : algebra.is_algebraic K L)\n\nvariables (K L M)\ninclude hL\n\n/-- Less general version of `lift`. -/\n@[irreducible] private noncomputable def lift_aux : L \u2192\u2090[K] M :=\n(lift.subfield_with_hom.maximal_subfield_with_hom M hL).emb.comp $\n  eq.rec_on (lift.subfield_with_hom.maximal_subfield_with_hom_eq_top M hL).symm algebra.to_top\n\nomit hL\n\nvariables {R : Type u} [comm_ring R]\nvariables {S : Type v} [comm_ring S] [is_domain S] [algebra R S]\n  [algebra R M] [no_zero_smul_divisors R S]\n  [no_zero_smul_divisors R M]\n  (hS : algebra.is_algebraic R S)\nvariables {M}\n\ninclude hS\n\n/-- A (random) homomorphism from an algebraic extension of R into an algebraically\n  closed extension of R. -/\n\n@[irreducible] noncomputable def lift : S \u2192\u2090[R] M :=\nbegin\n  letI : is_domain R := (no_zero_smul_divisors.algebra_map_injective R S).is_domain _,\n  have hfRfS : algebra.is_algebraic (fraction_ring R) (fraction_ring S),\n    from \u03bb x, (is_fraction_ring.is_algebraic_iff R (fraction_ring R) (fraction_ring S)).1\n      ((is_fraction_ring.is_algebraic_iff' R S (fraction_ring S)).1 hS x),\n  let f : fraction_ring S \u2192\u2090[fraction_ring R] M :=\n    lift_aux (fraction_ring R) (fraction_ring S) M hfRfS,\n  exact (f.restrict_scalars R).comp ((algebra.of_id S (fraction_ring S)).restrict_scalars R),\nend\n\nomit hS\n@[priority 100]\nnoncomputable instance perfect_ring (p : \u2115) [fact p.prime] [char_p k p]\n  [is_alg_closed k] : perfect_ring k p :=\nperfect_ring.of_surjective k p $ \u03bb x, is_alg_closed.exists_pow_nat_eq _ $ fact.out _\n\n/-- Algebraically closed fields are infinite since `X\u207f\u207a\u00b9 - 1` is separable when `#K = n` -/\n@[priority 500]\ninstance {K : Type*} [field K] [is_alg_closed K] : infinite K :=\nbegin\n  apply infinite.mk,\n  introsI hfin,\n  set n := fintype.card K with hn,\n  set f := (X : K[X]) ^ (n + 1) - 1 with hf,\n  have hfsep : separable f := separable_X_pow_sub_C 1 (by simp) one_ne_zero,\n  apply nat.not_succ_le_self (fintype.card K),\n  have hroot : n.succ = fintype.card (f.root_set K),\n  { erw [card_root_set_eq_nat_degree hfsep (is_alg_closed.splits_domain _),\n         nat_degree_X_pow_sub_C] },\n  rw hroot,\n  exact fintype.card_le_of_injective coe subtype.coe_injective,\nend\n\nend is_alg_closed\n\nnamespace is_alg_closure\n\nvariables (K : Type*) (J : Type*) (R : Type u) (S : Type*) [field K] [field J] [comm_ring R]\n  (L : Type v) (M : Type w) [field L] [field M] [algebra R M] [no_zero_smul_divisors R M]\n  [is_alg_closure R M] [algebra K M] [is_alg_closure K M]\n  [comm_ring S] [algebra S L] [no_zero_smul_divisors S L] [is_alg_closure S L]\n\nlocal attribute [instance] is_alg_closure.alg_closed\n\nsection\nvariables [algebra R L] [no_zero_smul_divisors R L] [is_alg_closure R L]\n\n/-- A (random) isomorphism between two algebraic closures of `R`. -/\nnoncomputable def equiv : L \u2243\u2090[R] M :=\nlet f : L \u2192\u2090[R] M := is_alg_closed.lift is_alg_closure.algebraic in\nalg_equiv.of_bijective f\n  \u27e8ring_hom.injective f.to_ring_hom,\n    begin\n      letI : algebra L M := ring_hom.to_algebra f,\n      letI : is_scalar_tower R L M :=\n        is_scalar_tower.of_algebra_map_eq (by simp [ring_hom.algebra_map_to_algebra]),\n      show function.surjective (algebra_map L M),\n      exact is_alg_closed.algebra_map_surjective_of_is_algebraic\n        (algebra.is_algebraic_of_larger_base_of_injective\n          (no_zero_smul_divisors.algebra_map_injective R _) is_alg_closure.algebraic),\n    end\u27e9\n\nend\n\nsection equiv_of_algebraic\n\nvariables [algebra R S] [algebra R L] [is_scalar_tower R S L]\nvariables [algebra K J] [algebra J L] [is_alg_closure J L] [algebra K L]\n  [is_scalar_tower K J L]\n\n\n/-- A (random) isomorphism between an algebraic closure of `R` and an algebraic closure of\n  an algebraic extension of `R` -/\nnoncomputable def equiv_of_algebraic' [nontrivial S] [no_zero_smul_divisors R S]\n  (hRL : algebra.is_algebraic R L) : L \u2243\u2090[R] M :=\nbegin\n  letI : no_zero_smul_divisors R L :=\n    no_zero_smul_divisors.of_algebra_map_injective begin\n      rw [is_scalar_tower.algebra_map_eq R S L],\n      exact function.injective.comp\n        (no_zero_smul_divisors.algebra_map_injective _ _)\n        (no_zero_smul_divisors.algebra_map_injective _ _)\n    end,\n  letI : is_alg_closure R L :=\n  { alg_closed := by apply_instance,\n    algebraic := hRL },\n  exact is_alg_closure.equiv _ _ _\nend\n\n/-- A (random) isomorphism between an algebraic closure of `K` and an algebraic closure\n  of an algebraic extension of `K` -/\nnoncomputable def equiv_of_algebraic (hKJ : algebra.is_algebraic K J) : L \u2243\u2090[K] M :=\nequiv_of_algebraic' K J _ _ (algebra.is_algebraic_trans hKJ is_alg_closure.algebraic)\n\nend equiv_of_algebraic\n\nsection equiv_of_equiv\n\nvariables {R S}\n\n/-- Used in the definition of `equiv_of_equiv` -/\nnoncomputable def equiv_of_equiv_aux (hSR : S \u2243+* R) :\n  { e : L \u2243+* M // e.to_ring_hom.comp (algebra_map S L) =\n    (algebra_map R M).comp hSR.to_ring_hom }:=\nbegin\n  letI : algebra R S := ring_hom.to_algebra hSR.symm.to_ring_hom,\n  letI : algebra S R := ring_hom.to_algebra hSR.to_ring_hom,\n  letI : is_domain R := (no_zero_smul_divisors.algebra_map_injective R M).is_domain _,\n  letI : is_domain S := (no_zero_smul_divisors.algebra_map_injective S L).is_domain _,\n  have : algebra.is_algebraic R S,\n    from \u03bb x, begin\n      rw [\u2190 ring_equiv.symm_apply_apply hSR x],\n      exact is_algebraic_algebra_map _\n    end,\n  letI : algebra R L := ring_hom.to_algebra ((algebra_map S L).comp (algebra_map R S)),\n  haveI : is_scalar_tower R S L := is_scalar_tower.of_algebra_map_eq (\u03bb _, rfl),\n  haveI : is_scalar_tower S R L := is_scalar_tower.of_algebra_map_eq\n    (by simp [ring_hom.algebra_map_to_algebra]),\n  haveI : no_zero_smul_divisors R S :=\n    no_zero_smul_divisors.of_algebra_map_injective hSR.symm.injective,\n  refine \u27e8equiv_of_algebraic' R S L M (algebra.is_algebraic_of_larger_base_of_injective\n      (show function.injective (algebra_map S R), from hSR.injective)\n      is_alg_closure.algebraic) , _\u27e9,\n  ext,\n  simp only [ring_equiv.to_ring_hom_eq_coe, function.comp_app, ring_hom.coe_comp,\n    alg_equiv.coe_ring_equiv, ring_equiv.coe_to_ring_hom],\n  conv_lhs { rw [\u2190 hSR.symm_apply_apply x] },\n  show equiv_of_algebraic' R S L M _ (algebra_map R L (hSR x)) = _,\n  rw [alg_equiv.commutes]\nend\n\n/-- Algebraic closure of isomorphic fields are isomorphic -/\nnoncomputable def equiv_of_equiv (hSR : S \u2243+* R) : L \u2243+* M :=\nequiv_of_equiv_aux L M hSR\n\n@[simp] lemma equiv_of_equiv_comp_algebra_map (hSR : S \u2243+* R) :\n  (\u2191(equiv_of_equiv L M hSR) : L \u2192+* M).comp (algebra_map S L) =\n  (algebra_map R M).comp hSR :=\n(equiv_of_equiv_aux L M hSR).2\n\n@[simp] lemma equiv_of_equiv_algebra_map (hSR : S \u2243+* R) (s : S):\n  equiv_of_equiv L M hSR (algebra_map S L s) =\n  algebra_map R M (hSR s) :=\nring_hom.ext_iff.1 (equiv_of_equiv_comp_algebra_map L M hSR) s\n\n@[simp] lemma equiv_of_equiv_symm_algebra_map (hSR : S \u2243+* R) (r : R):\n  (equiv_of_equiv L M hSR).symm (algebra_map R M r) =\n  algebra_map S L (hSR.symm r) :=\n(equiv_of_equiv L M hSR).injective (by simp)\n\n@[simp] lemma equiv_of_equiv_symm_comp_algebra_map (hSR : S \u2243+* R) :\n  ((equiv_of_equiv L M hSR).symm : M \u2192+* L).comp (algebra_map R M) =\n  (algebra_map S L).comp hSR.symm :=\nring_hom.ext_iff.2 (equiv_of_equiv_symm_algebra_map L M hSR)\n\nend equiv_of_equiv\n\nend is_alg_closure\n"}
{"text": "example : 2 + 3 = 5 :=\nbegin\n  generalize h : 3 = x,\n  rw \u2190h\nend\n"}
{"text": "[GOAL]\n\u22a2 \u2200 (x y : ZMod 4),\n    OneHom.toFun\n        { toFun := ![0, 1, 0, -1], map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, -1] 1) }\n        (x * y) =\n      OneHom.toFun\n          { toFun := ![0, 1, 0, -1], map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, -1] 1) }\n          x *\n        OneHom.toFun\n          { toFun := ![0, 1, 0, -1], map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, -1] 1) }\n          y\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 \u2200 (a : ZMod 4),\n    \u00acIsUnit a \u2192\n      OneHom.toFun\n          (\u2191{\n              toOneHom :=\n                { toFun := ![0, 1, 0, -1],\n                  map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, -1] 1) },\n              map_mul' :=\n                (_ :\n                  \u2200 (x y : ZMod 4),\n                    OneHom.toFun\n                        { toFun := ![0, 1, 0, -1],\n                          map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, -1] 1) }\n                        (x * y) =\n                      OneHom.toFun\n                          { toFun := ![0, 1, 0, -1],\n                            map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, -1] 1) }\n                          x *\n                        OneHom.toFun\n                          { toFun := ![0, 1, 0, -1],\n                            map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, -1] 1) }\n                          y) })\n          a =\n        0\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 MulChar.IsQuadratic \u03c7\u2084\n[PROOFSTEP]\nintro a\n[GOAL]\na : ZMod 4\n\u22a2 \u2191\u03c7\u2084 a = 0 \u2228 \u2191\u03c7\u2084 a = 1 \u2228 \u2191\u03c7\u2084 a = -1\n[PROOFSTEP]\nfin_cases a\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2084 { val := 0, isLt := (_ : 0 < 3 + 1) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 0, isLt := (_ : 0 < 3 + 1) } = 1 \u2228 \u2191\u03c7\u2084 { val := 0, isLt := (_ : 0 < 3 + 1) } = -1\ncase tail.head\n\u22a2 \u2191\u03c7\u2084 { val := 1, isLt := (_ : (fun a => a < 3 + 1) 1) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 1, isLt := (_ : (fun a => a < 3 + 1) 1) } = 1 \u2228\n      \u2191\u03c7\u2084 { val := 1, isLt := (_ : (fun a => a < 3 + 1) 1) } = -1\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2084 { val := 2, isLt := (_ : (fun a => (fun a => a < 3 + 1) a) 2) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 2, isLt := (_ : (fun a => (fun a => a < 3 + 1) a) 2) } = 1 \u2228\n      \u2191\u03c7\u2084 { val := 2, isLt := (_ : (fun a => (fun a => a < 3 + 1) a) 2) } = -1\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2084 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 3 + 1) a) a) 3) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 3 + 1) a) a) 3) } = 1 \u2228\n      \u2191\u03c7\u2084 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 3 + 1) a) a) 3) } = -1\n[PROOFSTEP]\nall_goals decide\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2084 { val := 0, isLt := (_ : 0 < 3 + 1) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 0, isLt := (_ : 0 < 3 + 1) } = 1 \u2228 \u2191\u03c7\u2084 { val := 0, isLt := (_ : 0 < 3 + 1) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.head\n\u22a2 \u2191\u03c7\u2084 { val := 1, isLt := (_ : (fun a => a < 3 + 1) 1) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 1, isLt := (_ : (fun a => a < 3 + 1) 1) } = 1 \u2228\n      \u2191\u03c7\u2084 { val := 1, isLt := (_ : (fun a => a < 3 + 1) 1) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2084 { val := 2, isLt := (_ : (fun a => (fun a => a < 3 + 1) a) 2) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 2, isLt := (_ : (fun a => (fun a => a < 3 + 1) a) 2) } = 1 \u2228\n      \u2191\u03c7\u2084 { val := 2, isLt := (_ : (fun a => (fun a => a < 3 + 1) a) 2) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2084 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 3 + 1) a) a) 3) } = 0 \u2228\n    \u2191\u03c7\u2084 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 3 + 1) a) a) 3) } = 1 \u2228\n      \u2191\u03c7\u2084 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 3 + 1) a) a) 3) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2115\n\u22a2 \u2191\u03c7\u2084 \u2191n = \u2191\u03c7\u2084 \u2191(n % 4)\n[PROOFSTEP]\nrw [\u2190 ZMod.nat_cast_mod n 4]\n[GOAL]\nn : \u2124\n\u22a2 \u2191\u03c7\u2084 \u2191n = \u2191\u03c7\u2084 \u2191(n % 4)\n[PROOFSTEP]\nrw [\u2190 ZMod.int_cast_mod n 4]\n[GOAL]\nn : \u2124\n\u22a2 \u2191\u03c7\u2084 \u2191(n % \u21914) = \u2191\u03c7\u2084 \u2191(n % 4)\n[PROOFSTEP]\nnorm_cast\n[GOAL]\nn : \u2124\n\u22a2 \u2191\u03c7\u2084 \u2191n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1\n[PROOFSTEP]\nhave help : \u2200 m : \u2124, 0 \u2264 m \u2192 m < 4 \u2192 \u03c7\u2084 m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1 := by decide\n[GOAL]\nn : \u2124\n\u22a2 \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 4 \u2192 \u2191\u03c7\u2084 \u2191m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 4 \u2192 \u2191\u03c7\u2084 \u2191m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1\n\u22a2 \u2191\u03c7\u2084 \u2191n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1\n[PROOFSTEP]\nrw [\u2190 Int.emod_emod_of_dvd n (by norm_num : (2 : \u2124) \u2223 4), \u2190 ZMod.int_cast_mod n 4]\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 4 \u2192 \u2191\u03c7\u2084 \u2191m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1\n\u22a2 2 \u2223 4\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 4 \u2192 \u2191\u03c7\u2084 \u2191m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1\n\u22a2 \u2191\u03c7\u2084 \u2191(n % \u21914) = if n % 4 % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1\n[PROOFSTEP]\nexact help (n % 4) (Int.emod_nonneg n (by norm_num)) (Int.emod_lt n (by norm_num))\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 4 \u2192 \u2191\u03c7\u2084 \u2191m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1\n\u22a2 4 \u2260 0\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 4 \u2192 \u2191\u03c7\u2084 \u2191m = if m % 2 = 0 then 0 else if m = 1 then 1 else -1\n\u22a2 4 \u2260 0\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2115\n\u22a2 \u2191\u03c7\u2084 \u2191n = if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1\n[PROOFSTEP]\nexact_mod_cast \u03c7\u2084_int_eq_if_mod_four n\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 \u2191\u03c7\u2084 \u2191n = (-1) ^ (n / 2)\n[PROOFSTEP]\nrw [\u03c7\u2084_nat_eq_if_mod_four]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 (if n % 2 = 0 then 0 else if n % 4 = 1 then 1 else -1) = (-1) ^ (n / 2)\n[PROOFSTEP]\nsimp only [hn, Nat.one_ne_zero, if_false]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 (if n % 4 = 1 then 1 else -1) = (-1) ^ (n / 2)\n[PROOFSTEP]\nconv_rhs =>\n  -- Porting note: was `nth_rw`\n  arg 2; rw [\u2190 Nat.div_add_mod n 4]\n  enter [1, 1, 1]; rw [(by norm_num : 4 = 2 * 2)]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n| (-1) ^ (n / 2)\n[PROOFSTEP]\n  arg 2; rw [\u2190 Nat.div_add_mod n 4]\n  enter [1, 1, 1]; rw [(by norm_num : 4 = 2 * 2)]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n| (-1) ^ (n / 2)\n[PROOFSTEP]\n  arg 2; rw [\u2190 Nat.div_add_mod n 4]\n  enter [1, 1, 1]; rw [(by norm_num : 4 = 2 * 2)]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n| (-1) ^ (n / 2)\n[PROOFSTEP]\narg 2\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n| n / 2\n[PROOFSTEP]\nrw [\u2190 Nat.div_add_mod n 4]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n| (4 * (n / 4) + n % 4) / 2\n[PROOFSTEP]\nenter [1, 1, 1]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n| 4\n[PROOFSTEP]\nrw [(by norm_num : 4 = 2 * 2)]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 4 = 2 * 2\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 (if n % 4 = 1 then 1 else -1) = (-1) ^ ((2 * 2 * (n / 4) + n % 4) / 2)\n[PROOFSTEP]\nrw [mul_assoc, add_comm, Nat.add_mul_div_left _ _ (by norm_num : 0 < 2), pow_add, pow_mul, neg_one_sq, one_pow, mul_one]\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 0 < 2\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 (if n % 4 = 1 then 1 else -1) = (-1) ^ (n % 4 / 2)\n[PROOFSTEP]\nhave help : \u2200 m : \u2115, m < 4 \u2192 m % 2 = 1 \u2192 ite (m = 1) (1 : \u2124) (-1) = (-1) ^ (m / 2) := by decide\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\n\u22a2 \u2200 (m : \u2115), m < 4 \u2192 m % 2 = 1 \u2192 (if m = 1 then 1 else -1) = (-1) ^ (m / 2)\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\nhelp : \u2200 (m : \u2115), m < 4 \u2192 m % 2 = 1 \u2192 (if m = 1 then 1 else -1) = (-1) ^ (m / 2)\n\u22a2 (if n % 4 = 1 then 1 else -1) = (-1) ^ (n % 4 / 2)\n[PROOFSTEP]\nexact help (n % 4) (Nat.mod_lt n (by norm_num)) ((Nat.mod_mod_of_dvd n (by norm_num : 2 \u2223 4)).trans hn)\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\nhelp : \u2200 (m : \u2115), m < 4 \u2192 m % 2 = 1 \u2192 (if m = 1 then 1 else -1) = (-1) ^ (m / 2)\n\u22a2 4 > 0\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2115\nhn : n % 2 = 1\nhelp : \u2200 (m : \u2115), m < 4 \u2192 m % 2 = 1 \u2192 (if m = 1 then 1 else -1) = (-1) ^ (m / 2)\n\u22a2 2 \u2223 4\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2115\nhn : n % 4 = 1\n\u22a2 \u2191\u03c7\u2084 \u2191n = 1\n[PROOFSTEP]\nrw [\u03c7\u2084_nat_mod_four, hn]\n[GOAL]\nn : \u2115\nhn : n % 4 = 1\n\u22a2 \u2191\u03c7\u2084 \u21911 = 1\n[PROOFSTEP]\nrfl\n[GOAL]\nn : \u2115\nhn : n % 4 = 3\n\u22a2 \u2191\u03c7\u2084 \u2191n = -1\n[PROOFSTEP]\nrw [\u03c7\u2084_nat_mod_four, hn]\n[GOAL]\nn : \u2115\nhn : n % 4 = 3\n\u22a2 \u2191\u03c7\u2084 \u21913 = -1\n[PROOFSTEP]\nrfl\n[GOAL]\nn : \u2124\nhn : n % 4 = 1\n\u22a2 \u2191\u03c7\u2084 \u2191n = 1\n[PROOFSTEP]\nrw [\u03c7\u2084_int_mod_four, hn]\n[GOAL]\nn : \u2124\nhn : n % 4 = 1\n\u22a2 \u2191\u03c7\u2084 \u21911 = 1\n[PROOFSTEP]\nrfl\n[GOAL]\nn : \u2124\nhn : n % 4 = 3\n\u22a2 \u2191\u03c7\u2084 \u2191n = -1\n[PROOFSTEP]\nrw [\u03c7\u2084_int_mod_four, hn]\n[GOAL]\nn : \u2124\nhn : n % 4 = 3\n\u22a2 \u2191\u03c7\u2084 \u21913 = -1\n[PROOFSTEP]\nrfl\n[GOAL]\nn : \u2115\nhn : n % 4 = 1\n\u22a2 (-1) ^ (n / 2) = 1\n[PROOFSTEP]\nrw [\u2190 \u03c7\u2084_eq_neg_one_pow (Nat.odd_of_mod_four_eq_one hn), \u2190 nat_cast_mod, hn]\n[GOAL]\nn : \u2115\nhn : n % 4 = 1\n\u22a2 \u2191\u03c7\u2084 \u21911 = 1\n[PROOFSTEP]\nrfl\n[GOAL]\nn : \u2115\nhn : n % 4 = 3\n\u22a2 (-1) ^ (n / 2) = -1\n[PROOFSTEP]\nrw [\u2190 \u03c7\u2084_eq_neg_one_pow (Nat.odd_of_mod_four_eq_three hn), \u2190 nat_cast_mod, hn]\n[GOAL]\nn : \u2115\nhn : n % 4 = 3\n\u22a2 \u2191\u03c7\u2084 \u21913 = -1\n[PROOFSTEP]\nrfl\n[GOAL]\n\u22a2 \u2200 (x y : ZMod 8),\n    OneHom.toFun\n        { toFun := ![0, 1, 0, -1, 0, -1, 0, 1],\n          map_one' := (_ : Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1 = Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1) }\n        (x * y) =\n      OneHom.toFun\n          { toFun := ![0, 1, 0, -1, 0, -1, 0, 1],\n            map_one' :=\n              (_ : Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1 = Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1) }\n          x *\n        OneHom.toFun\n          { toFun := ![0, 1, 0, -1, 0, -1, 0, 1],\n            map_one' :=\n              (_ : Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1 = Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1) }\n          y\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 \u2200 (a : ZMod 8),\n    \u00acIsUnit a \u2192\n      OneHom.toFun\n          (\u2191{\n              toOneHom :=\n                { toFun := ![0, 1, 0, -1, 0, -1, 0, 1],\n                  map_one' :=\n                    (_ : Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1 = Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1) },\n              map_mul' :=\n                (_ :\n                  \u2200 (x y : ZMod 8),\n                    OneHom.toFun\n                        { toFun := ![0, 1, 0, -1, 0, -1, 0, 1],\n                          map_one' :=\n                            (_ :\n                              Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1 =\n                                Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1) }\n                        (x * y) =\n                      OneHom.toFun\n                          { toFun := ![0, 1, 0, -1, 0, -1, 0, 1],\n                            map_one' :=\n                              (_ :\n                                Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1 =\n                                  Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1) }\n                          x *\n                        OneHom.toFun\n                          { toFun := ![0, 1, 0, -1, 0, -1, 0, 1],\n                            map_one' :=\n                              (_ :\n                                Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1 =\n                                  Matrix.vecCons 0 ![1, 0, -1, 0, -1, 0, 1] 1) }\n                          y) })\n          a =\n        0\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 MulChar.IsQuadratic \u03c7\u2088\n[PROOFSTEP]\nintro a\n[GOAL]\na : ZMod 8\n\u22a2 \u2191\u03c7\u2088 a = 0 \u2228 \u2191\u03c7\u2088 a = 1 \u2228 \u2191\u03c7\u2088 a = -1\n[PROOFSTEP]\nfin_cases a\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) } = 1 \u2228 \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) } = -1\ncase tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = -1\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = -1\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = -1\ncase tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = -1\ncase tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = -1\ncase tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088\n        { val := 6,\n          isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n      0 \u2228\n    \u2191\u03c7\u2088\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        1 \u2228\n      \u2191\u03c7\u2088\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        -1\ncase tail.tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088\n        { val := 7,\n          isLt :=\n            (_ :\n              (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) } =\n      0 \u2228\n    \u2191\u03c7\u2088\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        1 \u2228\n      \u2191\u03c7\u2088\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        -1\n[PROOFSTEP]\nall_goals decide\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) } = 1 \u2228 \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 0 \u2228\n    \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 1 \u2228\n      \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088\n        { val := 6,\n          isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n      0 \u2228\n    \u2191\u03c7\u2088\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        1 \u2228\n      \u2191\u03c7\u2088\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088\n        { val := 7,\n          isLt :=\n            (_ :\n              (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) } =\n      0 \u2228\n    \u2191\u03c7\u2088\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        1 \u2228\n      \u2191\u03c7\u2088\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        -1\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2115\n\u22a2 \u2191\u03c7\u2088 \u2191n = \u2191\u03c7\u2088 \u2191(n % 8)\n[PROOFSTEP]\nrw [\u2190 ZMod.nat_cast_mod n 8]\n[GOAL]\nn : \u2124\n\u22a2 \u2191\u03c7\u2088 \u2191n = \u2191\u03c7\u2088 \u2191(n % 8)\n[PROOFSTEP]\nrw [\u2190 ZMod.int_cast_mod n 8]\n[GOAL]\nn : \u2124\n\u22a2 \u2191\u03c7\u2088 \u2191(n % \u21918) = \u2191\u03c7\u2088 \u2191(n % 8)\n[PROOFSTEP]\nnorm_cast\n[GOAL]\nn : \u2124\n\u22a2 \u2191\u03c7\u2088 \u2191n = if n % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 7 then 1 else -1\n[PROOFSTEP]\nhave help : \u2200 m : \u2124, 0 \u2264 m \u2192 m < 8 \u2192 \u03c7\u2088 m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1 := by decide\n[GOAL]\nn : \u2124\n\u22a2 \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088 \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088 \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1\n\u22a2 \u2191\u03c7\u2088 \u2191n = if n % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 7 then 1 else -1\n[PROOFSTEP]\nrw [\u2190 Int.emod_emod_of_dvd n (by norm_num : (2 : \u2124) \u2223 8), \u2190 ZMod.int_cast_mod n 8]\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088 \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1\n\u22a2 2 \u2223 8\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088 \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1\n\u22a2 \u2191\u03c7\u2088 \u2191(n % \u21918) = if n % 8 % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 7 then 1 else -1\n[PROOFSTEP]\nexact help (n % 8) (Int.emod_nonneg n (by norm_num)) (Int.emod_lt n (by norm_num))\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088 \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1\n\u22a2 8 \u2260 0\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088 \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 7 then 1 else -1\n\u22a2 8 \u2260 0\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2115\n\u22a2 \u2191\u03c7\u2088 \u2191n = if n % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 7 then 1 else -1\n[PROOFSTEP]\nexact_mod_cast \u03c7\u2088_int_eq_if_mod_eight n\n[GOAL]\n\u22a2 \u2200 (x y : ZMod 8),\n    OneHom.toFun\n        { toFun := ![0, 1, 0, 1, 0, -1, 0, -1],\n          map_one' := (_ : Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1) }\n        (x * y) =\n      OneHom.toFun\n          { toFun := ![0, 1, 0, 1, 0, -1, 0, -1],\n            map_one' :=\n              (_ : Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1) }\n          x *\n        OneHom.toFun\n          { toFun := ![0, 1, 0, 1, 0, -1, 0, -1],\n            map_one' :=\n              (_ : Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1) }\n          y\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 \u2200 (a : ZMod 8),\n    \u00acIsUnit a \u2192\n      OneHom.toFun\n          (\u2191{\n              toOneHom :=\n                { toFun := ![0, 1, 0, 1, 0, -1, 0, -1],\n                  map_one' :=\n                    (_ : Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1 = Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1) },\n              map_mul' :=\n                (_ :\n                  \u2200 (x y : ZMod 8),\n                    OneHom.toFun\n                        { toFun := ![0, 1, 0, 1, 0, -1, 0, -1],\n                          map_one' :=\n                            (_ :\n                              Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1 =\n                                Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1) }\n                        (x * y) =\n                      OneHom.toFun\n                          { toFun := ![0, 1, 0, 1, 0, -1, 0, -1],\n                            map_one' :=\n                              (_ :\n                                Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1 =\n                                  Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1) }\n                          x *\n                        OneHom.toFun\n                          { toFun := ![0, 1, 0, 1, 0, -1, 0, -1],\n                            map_one' :=\n                              (_ :\n                                Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1 =\n                                  Matrix.vecCons 0 ![1, 0, 1, 0, -1, 0, -1] 1) }\n                          y) })\n          a =\n        0\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 MulChar.IsQuadratic \u03c7\u2088'\n[PROOFSTEP]\nintro a\n[GOAL]\na : ZMod 8\n\u22a2 \u2191\u03c7\u2088' a = 0 \u2228 \u2191\u03c7\u2088' a = 1 \u2228 \u2191\u03c7\u2088' a = -1\n[PROOFSTEP]\nfin_cases a\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } = 1 \u2228 \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } = -1\ncase tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = -1\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = -1\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = -1\ncase tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = -1\ncase tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = -1\ncase tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n        { val := 6,\n          isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n      0 \u2228\n    \u2191\u03c7\u2088'\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        1 \u2228\n      \u2191\u03c7\u2088'\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        -1\ncase tail.tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n        { val := 7,\n          isLt :=\n            (_ :\n              (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) } =\n      0 \u2228\n    \u2191\u03c7\u2088'\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        1 \u2228\n      \u2191\u03c7\u2088'\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        -1\n[PROOFSTEP]\nall_goals decide\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } = 1 \u2228 \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 0 \u2228\n    \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = 1 \u2228\n      \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } = -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n        { val := 6,\n          isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n      0 \u2228\n    \u2191\u03c7\u2088'\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        1 \u2228\n      \u2191\u03c7\u2088'\n          { val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n        -1\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n        { val := 7,\n          isLt :=\n            (_ :\n              (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) } =\n      0 \u2228\n    \u2191\u03c7\u2088'\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        1 \u2228\n      \u2191\u03c7\u2088'\n          { val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } =\n        -1\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2124\n\u22a2 \u2191\u03c7\u2088' \u2191n = if n % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 3 then 1 else -1\n[PROOFSTEP]\nhave help : \u2200 m : \u2124, 0 \u2264 m \u2192 m < 8 \u2192 \u03c7\u2088' m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1 := by decide\n[GOAL]\nn : \u2124\n\u22a2 \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088' \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088' \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1\n\u22a2 \u2191\u03c7\u2088' \u2191n = if n % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 3 then 1 else -1\n[PROOFSTEP]\nrw [\u2190 Int.emod_emod_of_dvd n (by norm_num : (2 : \u2124) \u2223 8), \u2190 ZMod.int_cast_mod n 8]\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088' \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1\n\u22a2 2 \u2223 8\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088' \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1\n\u22a2 \u2191\u03c7\u2088' \u2191(n % \u21918) = if n % 8 % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 3 then 1 else -1\n[PROOFSTEP]\nexact help (n % 8) (Int.emod_nonneg n (by norm_num)) (Int.emod_lt n (by norm_num))\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088' \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1\n\u22a2 8 \u2260 0\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2124\nhelp : \u2200 (m : \u2124), 0 \u2264 m \u2192 m < 8 \u2192 \u2191\u03c7\u2088' \u2191m = if m % 2 = 0 then 0 else if m = 1 \u2228 m = 3 then 1 else -1\n\u22a2 8 \u2260 0\n[PROOFSTEP]\nnorm_num\n[GOAL]\nn : \u2115\n\u22a2 \u2191\u03c7\u2088' \u2191n = if n % 2 = 0 then 0 else if n % 8 = 1 \u2228 n % 8 = 3 then 1 else -1\n[PROOFSTEP]\nexact_mod_cast \u03c7\u2088'_int_eq_if_mod_eight n\n[GOAL]\na : ZMod 8\n\u22a2 \u2191\u03c7\u2088' a = \u2191\u03c7\u2084 \u2191a * \u2191\u03c7\u2088 a\n[PROOFSTEP]\nfin_cases a\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } =\n    \u2191\u03c7\u2084 \u2191{ val := 0, isLt := (_ : 0 < 7 + 1) } * \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) }\ncase tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } =\n    \u2191\u03c7\u2084 \u2191{ val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } * \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) }\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } =\n    \u2191\u03c7\u2084 \u2191{ val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } *\n      \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) }\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } =\n    \u2191\u03c7\u2084 \u2191{ val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } *\n      \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) }\ncase tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } =\n    \u2191\u03c7\u2084 \u2191{ val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } *\n      \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) }\ncase tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } =\n    \u2191\u03c7\u2084 \u2191{ val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } *\n      \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) }\ncase tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n      { val := 6,\n        isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n    \u2191\u03c7\u2084\n        \u2191{ val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } *\n      \u2191\u03c7\u2088\n        { val := 6,\n          isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) }\ncase tail.tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n      { val := 7,\n        isLt :=\n          (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) } =\n    \u2191\u03c7\u2084\n        \u2191{ val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } *\n      \u2191\u03c7\u2088\n        { val := 7,\n          isLt :=\n            (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) }\n[PROOFSTEP]\nall_goals decide\n[GOAL]\ncase head\n\u22a2 \u2191\u03c7\u2088' { val := 0, isLt := (_ : 0 < 7 + 1) } =\n    \u2191\u03c7\u2084 \u2191{ val := 0, isLt := (_ : 0 < 7 + 1) } * \u2191\u03c7\u2088 { val := 0, isLt := (_ : 0 < 7 + 1) }\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } =\n    \u2191\u03c7\u2084 \u2191{ val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) } * \u2191\u03c7\u2088 { val := 1, isLt := (_ : (fun a => a < 7 + 1) 1) }\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } =\n    \u2191\u03c7\u2084 \u2191{ val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) } *\n      \u2191\u03c7\u2088 { val := 2, isLt := (_ : (fun a => (fun a => a < 7 + 1) a) 2) }\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } =\n    \u2191\u03c7\u2084 \u2191{ val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) } *\n      \u2191\u03c7\u2088 { val := 3, isLt := (_ : (fun a => (fun a => (fun a => a < 7 + 1) a) a) 3) }\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } =\n    \u2191\u03c7\u2084 \u2191{ val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) } *\n      \u2191\u03c7\u2088 { val := 4, isLt := (_ : (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) 4) }\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088' { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } =\n    \u2191\u03c7\u2084 \u2191{ val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) } *\n      \u2191\u03c7\u2088 { val := 5, isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) 5) }\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n      { val := 6,\n        isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } =\n    \u2191\u03c7\u2084\n        \u2191{ val := 6,\n            isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) } *\n      \u2191\u03c7\u2088\n        { val := 6,\n          isLt := (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) 6) }\n[PROOFSTEP]\ndecide\n[GOAL]\ncase tail.tail.tail.tail.tail.tail.tail.head\n\u22a2 \u2191\u03c7\u2088'\n      { val := 7,\n        isLt :=\n          (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) } =\n    \u2191\u03c7\u2084\n        \u2191{ val := 7,\n            isLt :=\n              (_ :\n                (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a)\n                  7) } *\n      \u2191\u03c7\u2088\n        { val := 7,\n          isLt :=\n            (_ : (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => (fun a => a < 7 + 1) a) a) a) a) a) a) 7) }\n[PROOFSTEP]\ndecide\n[GOAL]\na : \u2124\n\u22a2 \u2191\u03c7\u2088' \u2191a = \u2191\u03c7\u2084 \u2191a * \u2191\u03c7\u2088 \u2191a\n[PROOFSTEP]\nrw [\u2190 @cast_int_cast 8 (ZMod 4) _ 4 _ (by norm_num) a]\n[GOAL]\na : \u2124\n\u22a2 4 \u2223 8\n[PROOFSTEP]\nnorm_num\n[GOAL]\na : \u2124\n\u22a2 \u2191\u03c7\u2088' \u2191a = \u2191\u03c7\u2084 \u2191\u2191a * \u2191\u03c7\u2088 \u2191a\n[PROOFSTEP]\nexact \u03c7\u2088'_eq_\u03c7\u2084_mul_\u03c7\u2088 a\n"}
{"text": "%% Copyright (C) 2014, 2016 Colin B. Macdonald\n%%\n%% This file is part of OctSymPy.\n%%\n%% OctSymPy is free software; you can redistribute it and/or modify\n%% it under the terms of the GNU General Public License as published\n%% by the Free Software Foundation; either version 3 of the License,\n%% or (at your option) any later version.\n%%\n%% This software is distributed in the hope that it will be useful,\n%% but WITHOUT ANY WARRANTY; without even the implied warranty\n%% of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See\n%% the GNU General Public License for more details.\n%%\n%% You should have received a copy of the GNU General Public\n%% License along with this software; see the file COPYING.\n%% If not, see <http://www.gnu.org/licenses/>.\n\n%% -*- texinfo -*-\n%% @documentencoding UTF-8\n%% @defop  Method   @@symfun ldivide {(@var{f}, @var{g})}\n%% @defopx Operator @@symfun {@var{f} .\\ @var{g}} {}\n%% Component-wise backslash division of symbolic functions.\n%%\n%% Simple example:\n%% @example\n%% @group\n%% syms x\n%% f(x) = [1 x sin(x)];\n%% g(x) = [x x pi];\n%% @end group\n%%\n%% @group\n%% h = f .\\ g\n%%   @result{} h(x) = (symfun)\n%%       \u23a1        \u03c0   \u23a4\n%%       \u23a2x  1  \u2500\u2500\u2500\u2500\u2500\u2500\u23a5\n%%       \u23a3      sin(x)\u23a6\n%% @end group\n%% @end example\n%%\n%% @seealso{@@symfun/rdivide}\n%% @end defop\n\nfunction h = ldivide(f, g)\n  [vars, s1, s2] = helper_symfun_binops(f, g);\n  h = symfun(s1 .\\ s2, vars);\nend\n\n\n%!test\n%! syms x\n%! f(x) = x^2;\n%! assert( isa(f .\\ f, 'symfun'))\n%! assert( isa(f .\\ x, 'symfun'))\n"}
{"text": "/-\n  This type bundles together a value of a certain type \n  together with a proof that it satisfies a certain property.\n\n  It can be used to write algorithms that return values \n  that must satisfy certain defining properties.\n-/\n@[class] structure Prover {\u03b1 : Type _} (p : \u03b1 \u2192 Prop) :=\n  value : \u03b1\n  proof : p value\n\n-- easier notation\nnotation \"#[\" v \":\" T \"]\" \" ~ \" p => Prover (\u03bb (v : T) => p)\n\n-- examples\n#check #[x : Nat] ~ (x + 5 > 0)\n\nexample : #[x : Nat] ~ (x + 5 = 10) :=\n  {\n    value := 5, \n    proof := rfl\n  }\n\n-- connection with existential quantifier\ntheorem valueWitness {\u03b1 : Type _} {p : \u03b1 \u2192 Prop} : (#[v : \u03b1] ~ p v) \u2192 (\u2203 v : \u03b1, p v) :=\n  \u03bb valPrf => \u27e8valPrf.value, valPrf.proof\u27e9"}
{"text": "\nimport unitb.decomposition.component\n\nuniverse variables u\n\nnamespace decomposition\nsection\n\nopen predicate unitb function scheduling\n\nparameter {\u03b1  : Type}\nparameter {t : Type}\nparameter [sched t]\nparameter {s : t \u2192 program \u03b1}\nparameter {s\u2080 : \u03b1}\nparameter (asm : \u03b1 \u2192 \u03b1 \u2192 Prop)\nparameter (h\u2080 : \u2200 i, (s i).mch.first s\u2080)\nparameter (h : compatible asm s)\nnoncomputable def s' := compose s asm h\u2080 h\n\nparameters {asm h\u2080 h}\n\nvariables {i : t}\nvariables {p q : pred' \u03b1}\n\nlemma local_reasoning.transient\n  (T : transient' (s i) p q)\n: transient' s' p q :=\nbegin\n  unfold transient' system.transient nondet.program.transient comp,\n  unfold transient' system.transient nondet.program.transient comp at T,\n  cases T with e Te,\n  cases e,\n  case some e\n  { existsi some (\u27e8i,e\u27e9 : \u03a3 i, (s i).mch.lbl),\n    apply nondet.program.falsify.mk,\n    { apply Te.enable },\n    { apply Te.schedule },\n    { apply Te.negate' } },\n  case none\n  { existsi none,\n    apply nondet.program.falsify.mk,\n    { apply Te.enable },\n    { apply Te.schedule },\n    { apply Te.negate' } },\nend\n\nlemma local_reasoning.unless\n  (S : unless (s i) p q)\n: unless s' p q :=\nbegin\n  unfold unless,\n  intros \u03c3 \u03c3' STEP,\n  apply S,\n  unfold unitb.step has_safety.step step,\n  unfold unitb.step has_safety.step step at STEP,\n  unfold program.mch program.asm nondet.is_step nondet.program.lbl at STEP,\n  unfold program.mch program.asm nondet.is_step nondet.program.lbl,\n  cases STEP,\n  case or.inl STEP\n  { cases STEP with ev STEP,\n    cases ev,\n    case some ev\n    { cases ev with j Hj,\n      cases classical.em (i = j) with Heq Hne,\n      { subst j,\n        left, existsi some Hj,\n        apply STEP },\n      { right, apply h.step _ _ Hne,\n        unfold nondet.is_step,\n        existsi some Hj,\n        apply STEP, }, },\n    case none\n    { left, existsi none, apply STEP } },\n  case or.inr STEP\n  { right, apply h.asm, apply STEP, },\nend\n\ntheorem leads_to.subst {p q}\n  (H : p \u21a6 q in s i)\n: p \u21a6 q in s' :=\nunitb.leads_to.subst id _ _\n(@local_reasoning.transient i) (@local_reasoning.unless i) H\n\ntheorem often_imp_often.subst {p q}\n  (H : p >~> q in s i)\n: p >~> q in s' :=\nunitb.often_imp_often.subst id _ _\n(@local_reasoning.transient i) (@local_reasoning.unless i) H\n\nend\nend decomposition\n"}
{"text": "lemma synthetic_div_0 [simp]: \"synthetic_div 0 c = 0\""}
{"text": "import data.nat.basic\n\ndef is_even (a : nat) := \u2203 b, a = 2 * b\n\ntheorem even_plus_even {a b : nat}\n  (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=\n  exists.elim h1 (assume w1, assume hw1 : a = 2 * w1,\n  exists.elim h2 (assume w2, assume hw2 : b = 2 * w2,\n    exists.intro (w1 + w2)\n      (calc\n        a + b = 2 * w1 + 2 * w2 : by rw [hw1, hw2]\n        ...   = 2 * (w1 + w2)   : by rw mul_add)))\n\ntheorem even_plus_even' {a b : nat}\n  (h1 : is_even a) (h2 : is_even b) : is_even (a + b) :=\nmatch h1, h2 with\n  \u27e8 w1, hw1\u27e9, \u27e8 w2, hw2\u27e9 := \u27e8 w1 + w2, by rw [hw1, hw2, mul_add]\u27e9\nend\n"}
{"text": "import data.list algebra.ring tactic.omega defs\n\nlemma single_complete: almost_complete [\u25cf] := \nbegin\n  apply almost_complete.cmp_rule,\n  existsi ([]), \n  intros t h, \n  exfalso, apply h, apply grow_list.head_grow, \n  apply grow.single_grow\nend  \n\nlemma single_grow : \u2200 t : bintree, (t \u21a3 \u25cf) \u2192 t = \u25cf := \nbegin\n  intros t H1,\n  destruct t,\n  begin intros, assumption end,\n  repeat { \n    intros a H2, \n    rewrite H2 at H1,\n    cases H1,\n  }, -- this proves the first two goals\n  begin\n    intros a a1 H2,\n    rewrite H2 at H1,\n    cases H1,\n  end -- this proves the last two goals\nend\n\n"}
{"text": "informal statement Let $G=\\left\\{g_{1}, \\ldots, g_{n}\\right\\}$ be a finite group. Prove that the element $N=g_{1}+g_{2}+\\ldots+g_{n}$ is in the center of the group ring $R G$.formal statement theorem exercise_7_3_37 {R : Type*} {p m : \u2115} (hp : p.prime) \n  (N : ideal $ zmod $ p^m) : \n  is_nilpotent N \u2194  is_nilpotent (ideal.span ({p} : set $ zmod $ p^m)) :="}
{"text": "Formal statement is: lemma closure_empty [simp]: \"closure {} = {}\" Informal statement is: The closure of the empty set is the empty set."}
{"text": "module Examples\n\nimport Data.Vect\nimport ProcessLib\nimport Proto\nimport HoriComp\nimport VertComp\nimport Primitives\nimport SumWire\nimport Dualise\nimport SumWire\nimport CupCap\nimport Util\n\n%flag C \"-O3\"\n\ngt5: Hom [Down Int] [Down Int, Down Int]\ngt5 = mkPure \"gt5: \" (\\n => if n > 5 then Left n else Right n) -*- splitEither\n\ninc: Hom [Down Int] [Down Int]\ninc = mkPure \"inc: \" (\\i => i + 1)\n\ndownIntWire: Hom [Down Int] [Down Int]\ndownIntWire = mkPure \"down int: \" id\n\nupIntWire: Hom [Up Int] [Up Int]\nupIntWire = dualise downIntWire\n\nmyProc: Hom [Down Int] []\nmyProc =     downIntWire + cap\n         -*- (splice -*- inc -*- gt5) + upIntWire\n         -*- downPrinter + cup\n\ntest: Client ()\ntest = do Just proc <- Spawn myProc | _ => Action (putStrLn \"failed to spawn the process\")\n          val_resp <- Request proc (Val (TopInWire Here) 1)\n          Action $ putStrLn $ \"result: \" ++ show val_resp\n          Util.dot_sleeper 20\n\nnamespace Main\n  main: IO ()\n  main = runProc test\n"}
{"text": "import Smt\n\ntheorem verum : true := by\n  smt\n  simp_all\n"}
{"text": "(*\n  Authors: Asta Halkj\u00e6r From, Agnes Moesg\u00e5rd Eschen & J\u00f8rgen Villadsen, DTU Compute\n*)\n\ntheory LT1 imports System_L1 begin\n\ntext \\<open>System from Jan Lukasiewicz and Alfred Tarski (1930): Untersuchungen \u00fcber den Aussagenkalk\u00fcl\\<close>\n\ntext \\<open>Inspired by Shotaro Tanaka (1965): On Axiom Systems of Propositional Calculi. XIII\\<close>\n\ninductive LT (\\<open>\\<tturnstile>\\<close>) where\n  LT_MP: \\<open>\\<tturnstile> q\\<close> if \\<open>\\<tturnstile> p\\<close> and \\<open>\\<tturnstile> (p \\<rightarrow> q)\\<close> |\n  LT_1:  \\<open>\\<tturnstile> (((p \\<rightarrow> (q \\<rightarrow> p))\n              \\<rightarrow> (((\\<sim> r \\<rightarrow> (s \\<rightarrow> \\<sim> t)) \\<rightarrow> ((r \\<rightarrow> (s \\<rightarrow> u)) \\<rightarrow> ((t \\<rightarrow> s) \\<rightarrow> (t \\<rightarrow> u)))) \\<rightarrow> v))\n             \\<rightarrow> (w \\<rightarrow> v))\\<close>\n\nlemma LT_3: \\<open>\\<tturnstile> (p \\<rightarrow> (q \\<rightarrow> p))\\<close>\n  using LT_1 LT_MP by metis\n\nlemma LT_5: \\<open>\\<tturnstile> ((p \\<rightarrow> (q \\<rightarrow> r)) \\<rightarrow> ((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using LT_1 LT_MP by metis\n\nlemma LT_13: \\<open>\\<tturnstile> (((p \\<rightarrow> q) \\<rightarrow> (p \\<rightarrow> r)) \\<rightarrow> (q \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using LT_1 LT_5 LT_MP by metis\n\nlemma LT_11: \\<open>\\<tturnstile> ((p \\<rightarrow> q) \\<rightarrow> ((q \\<rightarrow> r) \\<rightarrow> (p \\<rightarrow> r)))\\<close>\n  using LT_3 LT_5 LT_MP by metis\n\nlemma LT_20: \\<open>\\<tturnstile> ((\\<sim> p \\<rightarrow> p) \\<rightarrow> p)\\<close>\n  using LT_1 LT_3 LT_13 LT_MP by metis\n\nlemma LT_21: \\<open>\\<tturnstile> (p \\<rightarrow> (\\<sim> p \\<rightarrow> q))\\<close>\n  using LT_1 LT_3 LT_13 LT_MP by metis\n\ntheorem LT_iff_L1: \\<open>\\<tturnstile> p \\<longleftrightarrow> \\<turnstile> p\\<close>\nproof\n  have L1_LT_1:\n    \\<open>\\<turnstile> (((p \\<rightarrow> (q \\<rightarrow> p))\n          \\<rightarrow> (((\\<sim> r \\<rightarrow> (s \\<rightarrow> \\<sim> t)) \\<rightarrow> ((r \\<rightarrow> (s \\<rightarrow> u)) \\<rightarrow> ((t \\<rightarrow> s) \\<rightarrow> (t \\<rightarrow> u)))) \\<rightarrow> v))\n         \\<rightarrow> (w \\<rightarrow> v))\\<close> for p q r s t u v w\n    using L1_completeness by simp\n  show \\<open>\\<turnstile> p\\<close> if \\<open>\\<tturnstile> p\\<close>\n    using that by (induct) (metis MP, metis L1_LT_1)\n  show \\<open>\\<tturnstile> p\\<close> if \\<open>\\<turnstile> p\\<close>\n    using that by (induct) (metis LT_MP, metis LT_11, metis LT_20, metis LT_21)\nqed\n\ntheorem LT_soundness: \\<open>\\<tturnstile> p \\<Longrightarrow> I \\<Turnstile> p\\<close>\n  by (induct rule: LT.induct) auto\n\ntheorem LT_completeness: \\<open>\\<forall>I. (I \\<Turnstile> p) \\<Longrightarrow> \\<tturnstile> p\\<close>\n  using LT_iff_L1 by (simp add: L1_completeness)\n\nsection \\<open>Soundness and Completeness\\<close>\n\ntheorem main: \\<open>valid p = \\<tturnstile> p\\<close>\n  unfolding valid_def using LT_soundness LT_completeness by blast\n\nlemmas LT = LT.intros main\n\nend\n"}
{"text": "[STATEMENT]\nlemma \n  iNext_iEx_iff_singleton   : \"(\\<circle> t t0 I. P t) = (\\<diamond> t {inext t0 I}. P t)\" and\n  iLast_iEx_iff_singleton   : \"(\\<ominus> t t0 I. P t) = (\\<diamond> t {iprev t0 I}. P t)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. iNext t0 I P = (\\<diamond> t {inext t0 I}. P t) &&& iLast t0 I P = (\\<diamond> t {iprev t0 I}. P t)\n[PROOF STEP]\nby (fastforce simp: iTL_Next_defs iT_add iIN_0)+"}
{"text": "lemma to_fract_eq_0_iff [simp]: \"to_fract x = 0 \\<longleftrightarrow> x = 0\""}
{"text": "/-\nCopyright (c) 2018 Chris Hughes. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Chris Hughes, Joey van Langen, Casper Putz\n-/\nimport tactic.apply_fun\nimport data.equiv.ring\nimport data.zmod.basic\nimport linear_algebra.basis\nimport ring_theory.integral_domain\nimport field_theory.separable\n\n/-!\n# Finite fields\n\nThis file contains basic results about finite fields.\nThroughout most of this file, `K` denotes a finite field\nand `q` is notation for the cardinality of `K`.\n\nSee `ring_theory.integral_domain` for the fact that the unit group of a finite field is a\ncyclic group, as well as the fact that every finite integral domain is a field\n(`field_of_integral_domain`).\n\n## Main results\n\n1. `card_units`: The unit group of a finite field is has cardinality `q - 1`.\n2. `sum_pow_units`: The sum of `x^i`, where `x` ranges over the units of `K`, is\n   - `q-1` if `q-1 \u2223 i`\n   - `0`   otherwise\n3. `finite_field.card`: The cardinality `q` is a power of the characteristic of `K`.\n   See `card'` for a variant.\n\n## Notation\n\nThroughout most of this file, `K` denotes a finite field\nand `q` is notation for the cardinality of `K`.\n\n-/\n\nvariables {K : Type*} [field K] [fintype K]\nvariables {R : Type*} [integral_domain R]\nlocal notation `q` := fintype.card K\n\nopen_locale big_operators\n\nnamespace finite_field\nopen finset function\n\nsection polynomial\n\nopen polynomial\n\n/-- The cardinality of a field is at most `n` times the cardinality of the image of a degree `n`\n  polynomial -/\nlemma card_image_polynomial_eval [decidable_eq R] [fintype R] {p : polynomial R}\n  (hp : 0 < p.degree) : fintype.card R \u2264 nat_degree p * (univ.image (\u03bb x, eval x p)).card :=\nfinset.card_le_mul_card_image _ _\n  (\u03bb a _, calc _ = (p - C a).roots.to_finset.card : congr_arg card\n    (by simp [finset.ext_iff, mem_roots_sub_C hp])\n    ... \u2264 (p - C a).roots.card : multiset.to_finset_card_le _\n    ... \u2264 _ : card_roots_sub_C' hp)\n\n/-- If `f` and `g` are quadratic polynomials, then the `f.eval a + g.eval b = 0` has a solution. -/\nlemma exists_root_sum_quadratic [fintype R] {f g : polynomial R} (hf2 : degree f = 2)\n  (hg2 : degree g = 2) (hR : fintype.card R % 2 = 1) : \u2203 a b, f.eval a + g.eval b = 0 :=\nby letI := classical.dec_eq R; exact\nsuffices \u00ac disjoint (univ.image (\u03bb x : R, eval x f)) (univ.image (\u03bb x : R, eval x (-g))),\nbegin\n  simp only [disjoint_left, mem_image] at this,\n  push_neg at this,\n  rcases this with \u27e8x, \u27e8a, _, ha\u27e9, \u27e8b, _, hb\u27e9\u27e9,\n  exact \u27e8a, b, by rw [ha, \u2190 hb, eval_neg, neg_add_self]\u27e9\nend,\nassume hd : disjoint _ _,\nlt_irrefl (2 * ((univ.image (\u03bb x : R, eval x f)) \u222a (univ.image (\u03bb x : R, eval x (-g)))).card) $\ncalc 2 * ((univ.image (\u03bb x : R, eval x f)) \u222a (univ.image (\u03bb x : R, eval x (-g)))).card\n    \u2264 2 * fintype.card R : nat.mul_le_mul_left _ (finset.card_le_univ _)\n... = fintype.card R + fintype.card R : two_mul _\n... < nat_degree f * (univ.image (\u03bb x : R, eval x f)).card +\n      nat_degree (-g) * (univ.image (\u03bb x : R, eval x (-g))).card :\n    add_lt_add_of_lt_of_le\n      (lt_of_le_of_ne\n        (card_image_polynomial_eval (by rw hf2; exact dec_trivial))\n        (mt (congr_arg (%2)) (by simp [nat_degree_eq_of_degree_eq_some hf2, hR])))\n      (card_image_polynomial_eval (by rw [degree_neg, hg2]; exact dec_trivial))\n... = 2 * (univ.image (\u03bb x : R, eval x f) \u222a univ.image (\u03bb x : R, eval x (-g))).card :\n  by rw [card_disjoint_union hd]; simp [nat_degree_eq_of_degree_eq_some hf2,\n    nat_degree_eq_of_degree_eq_some hg2, bit0, mul_add]\n\nend polynomial\n\nlemma card_units : fintype.card (units K) = fintype.card K - 1 :=\nbegin\n  classical,\n  rw [eq_comm, nat.sub_eq_iff_eq_add (fintype.card_pos_iff.2 \u27e8(0 : K)\u27e9)],\n  haveI := set_fintype {a : K | a \u2260 0},\n  haveI := set_fintype (@set.univ K),\n  rw [fintype.card_congr (equiv.units_equiv_ne_zero _),\n    \u2190 @set.card_insert _ _ {a : K | a \u2260 0} _ (not_not.2 (eq.refl (0 : K)))\n    (set.fintype_insert _ _), fintype.card_congr (equiv.set.univ K).symm],\n  congr; simp [set.ext_iff, classical.em]\nend\n\nlemma prod_univ_units_id_eq_neg_one :\n  (\u220f x : units K, x) = (-1 : units K) :=\nbegin\n  classical,\n  have : (\u220f x in (@univ (units K) _).erase (-1), x) = 1,\n  from prod_involution (\u03bb x _, x\u207b\u00b9) (by simp)\n    (\u03bb a, by simp [units.inv_eq_self_iff] {contextual := tt})\n    (\u03bb a, by simp [@inv_eq_iff_inv_eq _ _ a, eq_comm] {contextual := tt})\n    (by simp),\n  rw [\u2190 insert_erase (mem_univ (-1 : units K)), prod_insert (not_mem_erase _ _),\n      this, mul_one]\nend\n\nlemma pow_card_sub_one_eq_one (a : K) (ha : a \u2260 0) : a ^ (q - 1) = 1 :=\ncalc a ^ (fintype.card K - 1) = (units.mk0 a ha ^ (fintype.card K - 1) : units K) :\n    by rw [units.coe_pow, units.coe_mk0]\n  ... = 1 : by { classical, rw [\u2190 card_units, pow_card_eq_one], refl }\n\nlemma pow_card (a : K) : a ^ q = a :=\nbegin\n  have hp : fintype.card K > 0 := fintype.card_pos_iff.2 (by apply_instance),\n  by_cases h : a = 0, { rw h, apply zero_pow hp },\n  rw [\u2190 nat.succ_pred_eq_of_pos hp, pow_succ, nat.pred_eq_sub_one,\n    pow_card_sub_one_eq_one a h, mul_one],\nend\n\nvariable (K)\n\ntheorem card (p : \u2115) [char_p K p] : \u2203 (n : \u2115+), nat.prime p \u2227 q = p^(n : \u2115) :=\nbegin\n  haveI hp : fact p.prime := \u27e8char_p.char_is_prime K p\u27e9,\n  letI : module (zmod p) K := { .. (zmod.cast_hom (dvd_refl _) K).to_module },\n  obtain \u27e8n, h\u27e9 := vector_space.card_fintype (zmod p) K,\n  rw zmod.card at h,\n  refine \u27e8\u27e8n, _\u27e9, hp.1, h\u27e9,\n  apply or.resolve_left (nat.eq_zero_or_pos n),\n  rintro rfl,\n  rw pow_zero at h,\n  have : (0 : K) = 1, { apply fintype.card_le_one_iff.mp (le_of_eq h) },\n  exact absurd this zero_ne_one,\nend\n\ntheorem card' : \u2203 (p : \u2115) (n : \u2115+), nat.prime p \u2227 q = p^(n : \u2115) :=\nlet \u27e8p, hc\u27e9 := char_p.exists K in \u27e8p, @finite_field.card K _ _ p hc\u27e9\n\n@[simp] lemma cast_card_eq_zero : (q : K) = 0 :=\nbegin\n  rcases char_p.exists K with \u27e8p, _char_p\u27e9, resetI,\n  rcases card K p with \u27e8n, hp, hn\u27e9,\n  simp only [char_p.cast_eq_zero_iff K p, hn],\n  conv { congr, rw [\u2190 pow_one p] },\n  exact pow_dvd_pow _ n.2,\nend\n\nlemma forall_pow_eq_one_iff (i : \u2115) :\n  (\u2200 x : units K, x ^ i = 1) \u2194 q - 1 \u2223 i :=\nbegin\n  obtain \u27e8x, hx\u27e9 := is_cyclic.exists_generator (units K),\n  classical,\n  rw [\u2190 card_units, \u2190 order_of_eq_card_of_forall_mem_gpowers hx, order_of_dvd_iff_pow_eq_one],\n  split,\n  { intro h, apply h },\n  { intros h y,\n    simp_rw \u2190 mem_powers_iff_mem_gpowers at hx,\n    rcases hx y with \u27e8j, rfl\u27e9,\n    rw [\u2190 pow_mul, mul_comm, pow_mul, h, one_pow], }\nend\n\n/-- The sum of `x ^ i` as `x` ranges over the units of a finite field of cardinality `q`\nis equal to `0` unless `(q - 1) \u2223 i`, in which case the sum is `q - 1`. -/\nlemma sum_pow_units (i : \u2115) :\n  \u2211 x : units K, (x ^ i : K) = if (q - 1) \u2223 i then -1 else 0 :=\nbegin\n  let \u03c6 : units K \u2192* K :=\n  { to_fun   := \u03bb x, x ^ i,\n    map_one' := by rw [units.coe_one, one_pow],\n    map_mul' := by { intros, rw [units.coe_mul, mul_pow] } },\n  haveI : decidable (\u03c6 = 1) := by { classical, apply_instance },\n  calc \u2211 x : units K, \u03c6 x = if \u03c6 = 1 then fintype.card (units K) else 0 : sum_hom_units \u03c6\n                      ... = if (q - 1) \u2223 i then -1 else 0 : _,\n  suffices : (q - 1) \u2223 i \u2194 \u03c6 = 1,\n  { simp only [this],\n    split_ifs with h h, swap, refl,\n    rw [card_units, nat.cast_sub, cast_card_eq_zero, nat.cast_one, zero_sub],\n    show 1 \u2264 q, from fintype.card_pos_iff.mpr \u27e80\u27e9 },\n  rw [\u2190 forall_pow_eq_one_iff, monoid_hom.ext_iff],\n  apply forall_congr, intro x,\n  rw [units.ext_iff, units.coe_pow, units.coe_one, monoid_hom.one_apply],\n  refl,\nend\n\n/-- The sum of `x ^ i` as `x` ranges over a finite field of cardinality `q`\nis equal to `0` if `i < q - 1`. -/\nlemma sum_pow_lt_card_sub_one (i : \u2115) (h : i < q - 1) :\n  \u2211 x : K, x ^ i = 0 :=\nbegin\n  by_cases hi : i = 0,\n  { simp only [hi, nsmul_one, sum_const, pow_zero, card_univ, cast_card_eq_zero], },\n  classical,\n  have hiq : \u00ac (q - 1) \u2223 i, { contrapose! h,  exact nat.le_of_dvd (nat.pos_of_ne_zero hi) h },\n  let \u03c6 : units K \u21aa K := \u27e8coe, units.ext\u27e9,\n  have : univ.map \u03c6 = univ \\ {0},\n  { ext x,\n    simp only [true_and, embedding.coe_fn_mk, mem_sdiff, units.exists_iff_ne_zero,\n               mem_univ, mem_map, exists_prop_of_true, mem_singleton] },\n  calc \u2211 x : K, x ^ i = \u2211 x in univ \\ {(0 : K)}, x ^ i :\n    by rw [\u2190 sum_sdiff ({0} : finset K).subset_univ, sum_singleton,\n           zero_pow (nat.pos_of_ne_zero hi), add_zero]\n    ... = \u2211 x : units K, x ^ i : by { rw [\u2190 this, univ.sum_map \u03c6], refl }\n    ... = 0 : by { rw [sum_pow_units K i, if_neg], exact hiq, }\nend\n\nvariables {K}\n\ntheorem frobenius_pow {p : \u2115} [fact p.prime] [char_p K p] {n : \u2115} (hcard : q = p^n) :\n  (frobenius K p) ^ n = 1 :=\nbegin\n  ext, conv_rhs { rw [ring_hom.one_def, ring_hom.id_apply, \u2190 pow_card x, hcard], }, clear hcard,\n  induction n, {simp},\n  rw [pow_succ, pow_succ', pow_mul, ring_hom.mul_def, ring_hom.comp_apply, frobenius_def, n_ih]\nend\n\nopen polynomial\n\nlemma expand_card (f : polynomial K) :\n  expand K q f = f ^ q :=\nbegin\n  cases char_p.exists K with p hp, letI := hp,\n  rcases finite_field.card K p with \u27e8\u27e8n, npos\u27e9, \u27e8hp, hn\u27e9\u27e9, haveI : fact p.prime := \u27e8hp\u27e9,\n  dsimp at hn, rw hn at *,\n  rw \u2190 map_expand_pow_char,\n  rw [frobenius_pow hn, ring_hom.one_def, map_id],\nend\n\nend finite_field\n\nnamespace zmod\n\nopen finite_field polynomial\n\nlemma sq_add_sq (p : \u2115) [hp : fact p.prime] (x : zmod p) :\n  \u2203 a b : zmod p, a^2 + b^2 = x :=\nbegin\n  cases hp.1.eq_two_or_odd with hp2 hp_odd,\n  { substI p, change fin 2 at x, fin_cases x, { use 0, simp }, { use [0, 1], simp } },\n  let f : polynomial (zmod p) := X^2,\n  let g : polynomial (zmod p) := X^2 - C x,\n  obtain \u27e8a, b, hab\u27e9 : \u2203 a b, f.eval a + g.eval b = 0 :=\n    @exists_root_sum_quadratic _ _ _ f g\n      (degree_X_pow 2) (degree_X_pow_sub_C dec_trivial _) (by rw [zmod.card, hp_odd]),\n  refine \u27e8a, b, _\u27e9,\n  rw \u2190 sub_eq_zero,\n  simpa only [eval_C, eval_X, eval_pow, eval_sub, \u2190 add_sub_assoc] using hab,\nend\n\nend zmod\n\nnamespace char_p\n\nlemma sq_add_sq (R : Type*) [integral_domain R] (p : \u2115) [fact (0 < p)] [char_p R p] (x : \u2124) :\n  \u2203 a b : \u2115, (a^2 + b^2 : R) = x :=\nbegin\n  haveI := char_is_prime_of_pos R p,\n  obtain \u27e8a, b, hab\u27e9 := zmod.sq_add_sq p x,\n  refine \u27e8a.val, b.val, _\u27e9,\n  simpa using congr_arg (zmod.cast_hom (dvd_refl _) R) hab\nend\n\nend char_p\n\nopen_locale nat\nopen zmod\n\n/-- The Fermat-Euler totient theorem. `nat.modeq.pow_totient` is an alternative statement\n  of the same theorem. -/\n@[simp] lemma zmod.pow_totient {n : \u2115} [fact (0 < n)] (x : units (zmod n)) : x ^ \u03c6 n = 1 :=\nby rw [\u2190 card_units_eq_totient, pow_card_eq_one]\n\n/-- The Fermat-Euler totient theorem. `zmod.pow_totient` is an alternative statement\n  of the same theorem. -/\nlemma nat.modeq.pow_totient {x n : \u2115} (h : nat.coprime x n) : x ^ \u03c6 n \u2261 1 [MOD n] :=\nbegin\n  cases n, {simp},\n  rw \u2190 zmod.eq_iff_modeq_nat,\n  let x' : units (zmod (n+1)) := zmod.unit_of_coprime _ h,\n  have := zmod.pow_totient x',\n  apply_fun (coe : units (zmod (n+1)) \u2192 zmod (n+1)) at this,\n  simpa only [-zmod.pow_totient, nat.succ_eq_add_one, nat.cast_pow, units.coe_one,\n    nat.cast_one, coe_unit_of_coprime, units.coe_pow],\nend\n\nopen finite_field\nnamespace zmod\n\n/-- A variation on Fermat's little theorem. See `zmod.pow_card_sub_one_eq_one` -/\n@[simp] lemma pow_card {p : \u2115} [fact p.prime] (x : zmod p) : x ^ p = x :=\nby { have h := finite_field.pow_card x, rwa zmod.card p at h }\n\n@[simp] lemma frobenius_zmod (p : \u2115) [fact p.prime] :\n  frobenius (zmod p) p = ring_hom.id _ :=\nby { ext a, rw [frobenius_def, zmod.pow_card, ring_hom.id_apply] }\n\n@[simp] lemma card_units (p : \u2115) [fact p.prime] : fintype.card (units (zmod p)) = p - 1 :=\nby rw [card_units, card]\n\n/-- Fermat's Little Theorem: for every unit `a` of `zmod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem units_pow_card_sub_one_eq_one (p : \u2115) [fact p.prime] (a : units (zmod p)) :\n  a ^ (p - 1) = 1 :=\nby rw [\u2190 card_units p, pow_card_eq_one]\n\n/-- Fermat's Little Theorem: for all nonzero `a : zmod p`, we have `a ^ (p - 1) = 1`. -/\ntheorem pow_card_sub_one_eq_one {p : \u2115} [fact p.prime] {a : zmod p} (ha : a \u2260 0) :\n  a ^ (p - 1) = 1 :=\nby { have h := pow_card_sub_one_eq_one a ha, rwa zmod.card p at h }\n\nopen polynomial\n\nlemma expand_card {p : \u2115} [fact p.prime] (f : polynomial (zmod p)) :\n  expand (zmod p) p f = f ^ p :=\nby { have h := finite_field.expand_card f, rwa zmod.card p at h }\n\nend zmod\n"}
{"text": "/-\nCopyright (c) 2022 Jireh Loreaux. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jireh Loreaux\n-/\nimport analysis.normed_space.star.basic\nimport analysis.normed_space.spectrum\nimport analysis.normed_space.star.exponential\nimport analysis.special_functions.exponential\nimport algebra.star.star_alg_hom\n\n/-! # Spectral properties in C\u22c6-algebras\nIn this file, we establish various properties related to the spectrum of elements in C\u22c6-algebras.\n-/\n\nlocal postfix `\u22c6`:std.prec.max_plus := star\n\nsection\n\nopen_locale topology ennreal\nopen filter ennreal spectrum cstar_ring\n\nsection unitary_spectrum\n\nvariables\n{\ud835\udd5c : Type*} [normed_field \ud835\udd5c]\n{E : Type*} [normed_ring E] [star_ring E] [cstar_ring E]\n[normed_algebra \ud835\udd5c E] [complete_space E]\n\nlemma unitary.spectrum_subset_circle (u : unitary E) :\n  spectrum \ud835\udd5c (u : E) \u2286 metric.sphere 0 1 :=\nbegin\n  nontriviality E,\n  refine \u03bb k hk, mem_sphere_zero_iff_norm.mpr (le_antisymm _ _),\n  { simpa only [cstar_ring.norm_coe_unitary u] using norm_le_norm_of_mem hk },\n  { rw \u2190unitary.coe_to_units_apply u at hk,\n    have hnk := ne_zero_of_mem_of_unit hk,\n    rw [\u2190inv_inv (unitary.to_units u), \u2190spectrum.map_inv, set.mem_inv] at hk,\n    have : \u2016k\u2016\u207b\u00b9 \u2264 \u2016\u2191((unitary.to_units u)\u207b\u00b9)\u2016, simpa only [norm_inv] using norm_le_norm_of_mem hk,\n    simpa using inv_le_of_inv_le (norm_pos_iff.mpr hnk) this }\nend\n\nlemma spectrum.subset_circle_of_unitary {u : E} (h : u \u2208 unitary E) :\n  spectrum \ud835\udd5c u \u2286 metric.sphere 0 1 :=\nunitary.spectrum_subset_circle \u27e8u, h\u27e9\n\nend unitary_spectrum\n\nsection complex_scalars\n\nopen complex\n\nvariables {A : Type*}\n[normed_ring A] [normed_algebra \u2102 A] [complete_space A] [star_ring A] [cstar_ring A]\n\nlocal notation `\u2191\u2090` := algebra_map \u2102 A\n\nlemma is_self_adjoint.spectral_radius_eq_nnnorm {a : A}\n  (ha : is_self_adjoint a) :\n  spectral_radius \u2102 a = \u2016a\u2016\u208a :=\nbegin\n  have hconst : tendsto (\u03bb n : \u2115, (\u2016a\u2016\u208a : \u211d\u22650\u221e)) at_top _ := tendsto_const_nhds,\n  refine tendsto_nhds_unique _ hconst,\n  convert (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius (a : A)).comp\n      (nat.tendsto_pow_at_top_at_top_of_one_lt one_lt_two),\n  refine funext (\u03bb n, _),\n  rw [function.comp_app, ha.nnnorm_pow_two_pow, ennreal.coe_pow, \u2190rpow_nat_cast,\n    \u2190rpow_mul],\n  simp,\nend\n\nlemma is_star_normal.spectral_radius_eq_nnnorm (a : A) [is_star_normal a] :\n  spectral_radius \u2102 a = \u2016a\u2016\u208a :=\nbegin\n  refine (ennreal.pow_strict_mono two_ne_zero).injective _,\n  have heq : (\u03bb n : \u2115, ((\u2016(a\u22c6 * a) ^ n\u2016\u208a ^ (1 / n : \u211d)) : \u211d\u22650\u221e))\n    = (\u03bb x, x ^ 2) \u2218 (\u03bb n : \u2115, ((\u2016a ^ n\u2016\u208a ^ (1 / n : \u211d)) : \u211d\u22650\u221e)),\n  { funext,\n    rw [function.comp_apply, \u2190rpow_nat_cast, \u2190rpow_mul, mul_comm, rpow_mul, rpow_nat_cast,\n      \u2190coe_pow, sq, \u2190nnnorm_star_mul_self, commute.mul_pow (star_comm_self' a), star_pow], },\n  have h\u2082 := ((ennreal.continuous_pow 2).tendsto (spectral_radius \u2102 a)).comp\n    (spectrum.pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius a),\n  rw \u2190heq at h\u2082,\n  convert tendsto_nhds_unique h\u2082 (pow_nnnorm_pow_one_div_tendsto_nhds_spectral_radius (a\u22c6 * a)),\n  rw [(is_self_adjoint.star_mul_self a).spectral_radius_eq_nnnorm, sq, nnnorm_star_mul_self,\n    coe_mul],\nend\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem is_self_adjoint.mem_spectrum_eq_re [star_module \u2102 A] {a : A}\n  (ha : is_self_adjoint a) {z : \u2102} (hz : z \u2208 spectrum \u2102 a) : z = z.re :=\nbegin\n  have hu := exp_mem_unitary_of_mem_skew_adjoint \u2102 (ha.smul_mem_skew_adjoint conj_I),\n  let Iu := units.mk0 I I_ne_zero,\n  have : exp \u2102 (I \u2022 z) \u2208 spectrum \u2102 (exp \u2102 (I \u2022 a)),\n    by simpa only [units.smul_def, units.coe_mk0]\n      using spectrum.exp_mem_exp (Iu \u2022 a) (smul_mem_smul_iff.mpr hz),\n  exact complex.ext (of_real_re _)\n    (by simpa only [\u2190complex.exp_eq_exp_\u2102, mem_sphere_zero_iff_norm, norm_eq_abs, abs_exp,\n      real.exp_eq_one_iff, smul_eq_mul, I_mul, neg_eq_zero]\n      using spectrum.subset_circle_of_unitary hu this),\nend\n\n/-- Any element of the spectrum of a selfadjoint is real. -/\ntheorem self_adjoint.mem_spectrum_eq_re [star_module \u2102 A]\n  (a : self_adjoint A) {z : \u2102} (hz : z \u2208 spectrum \u2102 (a : A)) : z = z.re :=\na.prop.mem_spectrum_eq_re hz\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem is_self_adjoint.coe_re_map_spectrum [star_module \u2102 A] {a : A}\n  (ha : is_self_adjoint a) : spectrum \u2102 a = (coe \u2218 re '' (spectrum \u2102 a) : set \u2102) :=\nle_antisymm (\u03bb z hz, \u27e8z, hz, (ha.mem_spectrum_eq_re hz).symm\u27e9) (\u03bb z, by\n  { rintros \u27e8z, hz, rfl\u27e9,\n    simpa only [(ha.mem_spectrum_eq_re hz).symm, function.comp_app] using hz })\n\n/-- The spectrum of a selfadjoint is real -/\ntheorem self_adjoint.coe_re_map_spectrum [star_module \u2102 A] (a : self_adjoint A) :\n  spectrum \u2102 (a : A) = (coe \u2218 re '' (spectrum \u2102 (a : A)) : set \u2102) :=\na.property.coe_re_map_spectrum\n\nend complex_scalars\n\nnamespace star_alg_hom\n\nvariables {F A B : Type*}\n[normed_ring A] [normed_algebra \u2102 A] [complete_space A] [star_ring A] [cstar_ring A]\n[normed_ring B] [normed_algebra \u2102 B] [complete_space B] [star_ring B] [cstar_ring B]\n[hF : star_alg_hom_class F \u2102 A B] (\u03c6 : F)\ninclude hF\n\n/-- A star algebra homomorphism of complex C\u22c6-algebras is norm contractive. -/\nlemma nnnorm_apply_le (a : A) : \u2016(\u03c6 a : B)\u2016\u208a \u2264 \u2016a\u2016\u208a :=\nbegin\n  suffices : \u2200 s : A, is_self_adjoint s \u2192 \u2016\u03c6 s\u2016\u208a \u2264 \u2016s\u2016\u208a,\n  { exact nonneg_le_nonneg_of_sq_le_sq zero_le'\n      (by simpa only [nnnorm_star_mul_self, map_star, map_mul]\n      using this _ (is_self_adjoint.star_mul_self a)) },\n  { intros s hs,\n    simpa only [hs.spectral_radius_eq_nnnorm, (hs.star_hom_apply \u03c6).spectral_radius_eq_nnnorm,\n      coe_le_coe] using (show spectral_radius \u2102 (\u03c6 s) \u2264 spectral_radius \u2102 s,\n      from supr_le_supr_of_subset (alg_hom.spectrum_apply_subset \u03c6 s)) }\nend\n\n/-- A star algebra homomorphism of complex C\u22c6-algebras is norm contractive. -/\nlemma norm_apply_le (a : A) : \u2016(\u03c6 a : B)\u2016 \u2264 \u2016a\u2016 := nnnorm_apply_le \u03c6 a\n\n/-- Star algebra homomorphisms between C\u22c6-algebras are continuous linear maps.\nSee note [lower instance priority] -/\n@[priority 100]\nnoncomputable instance : continuous_linear_map_class F \u2102 A B :=\n{ map_continuous := \u03bb \u03c6, add_monoid_hom_class.continuous_of_bound \u03c6 1\n    (by simpa only [one_mul] using nnnorm_apply_le \u03c6),\n  .. alg_hom_class.linear_map_class }\n\nend star_alg_hom\n\nend\n\nnamespace weak_dual\n\nopen continuous_map complex\nopen_locale complex_star_module\n\nvariables {F A : Type*} [normed_ring A] [normed_algebra \u2102 A] [complete_space A]\n  [star_ring A] [cstar_ring A] [star_module \u2102 A] [hF : alg_hom_class F \u2102 A \u2102]\n\ninclude hF\n\n/-- This instance is provided instead of `star_alg_hom_class` to avoid type class inference loops.\nSee note [lower instance priority] -/\n@[priority 100]\nnoncomputable instance : star_hom_class F A \u2102 :=\n{ coe := \u03bb \u03c6, \u03c6,\n  coe_injective' := fun_like.coe_injective',\n  map_star := \u03bb \u03c6 a,\n  begin\n    suffices hsa : \u2200 s : self_adjoint A, (\u03c6 s)\u22c6 = \u03c6 s,\n    { rw \u2190real_part_add_I_smul_imaginary_part a,\n      simp only [map_add, map_smul, star_add, star_smul, hsa, self_adjoint.star_coe_eq] },\n    { intros s,\n      have := alg_hom.apply_mem_spectrum \u03c6 (s : A),\n      rw self_adjoint.coe_re_map_spectrum s at this,\n      rcases this with \u27e8\u27e8_, _\u27e9, _, heq\u27e9,\n      rw [\u2190heq, is_R_or_C.star_def, is_R_or_C.conj_of_real] }\n  end }\n\n/-- This is not an instance to avoid type class inference loops. See\n`weak_dual.complex.star_hom_class`. -/\nnoncomputable def _root_.alg_hom_class.star_alg_hom_class : star_alg_hom_class F \u2102 A \u2102 :=\n{ coe := \u03bb f, f,\n  .. weak_dual.complex.star_hom_class,\n  .. hF }\n\nomit hF\n\nnamespace character_space\n\nnoncomputable instance : star_alg_hom_class (character_space \u2102 A) \u2102 A \u2102 :=\n{ coe := \u03bb f, f,\n  .. alg_hom_class.star_alg_hom_class }\n\nend character_space\n\nend weak_dual\n"}
{"text": "import data.list.basic\nopen list\nuniverse u\nvariables {\u03b1 : Type} (x y z : \u03b1) (xs ys zs : list \u03b1)\n\ndef mk_symm (xs : list \u03b1) := xs ++ reverse xs\n\ntheorem reverse_mk_symm (xs : list \u03b1) :\n  reverse (mk_symm xs) = mk_symm xs :=\n  by simp [mk_symm]\n"}
{"text": "informal statement Let $X$ be a compact Hausdorff space. Let $\\mathcal{A}$ be a collection of closed connected subsets of $X$ that is simply ordered by proper inclusion. Then $Y=\\bigcap_{A \\in \\mathcal{A}} A$ is connected.formal statement theorem exercise_27_4\n  {X : Type*} [metric_space X] [connected_space X] (hX : \u2203 x y : X, x \u2260 y) :\n  \u00ac countable (univ : set X) :="}
{"text": "import SciLean.Algebra\nimport SciLean.Quot.Monomial\n\nnamespace SciLean\n\nnamespace Algebra \n\n  -- M monomials  \n  -- K ring\n  inductive Repr (M K X : Type u) : Type u where\n  | mon (m : M) : Repr M K X\n  | add (x y : Repr M K X) : Repr M K X\n  | mul (x y : Repr M K X) : Repr M K X\n  | lmul (c : K) (x : Repr M K X) : Repr M K X\n  -- | rmul (x : Repr M K) (c : K) : Repr M K\n\n  instance {M K X} : Mul (Repr M K X) := \u27e8\u03bb x y => Repr.mul x y\u27e9\n  instance {M K X} : Add (Repr M K X) := \u27e8\u03bb x y => Repr.add x y\u27e9\n  instance {M K X} : HMul K (Repr M K X) (Repr M K X) := \u27e8\u03bb x y => Repr.lmul x y\u27e9\n  -- instance {M K} : HMul (Repr M K) K (Repr M K) := \u27e8\u03bb x y => Repr.rmul x y\u27e9\n\n  instance {M K X} [Zero M] : Zero (Repr M K X) := \u27e8Repr.mon 0\u27e9\n  instance {M K X} [One M]  : One (Repr M K X)  := \u27e8Repr.mon 1\u27e9\n\n  namespace Repr\n\n    def toString {M K X} (s_add s_mul s_lmul : String) [ToString M] [ToString K] (x : Repr M K X) : String :=\n      match x with\n      | mon m => s!\"{m}\"\n      | add x y => s!\"({toString s_add s_mul s_lmul x}{s_add}{toString s_add s_mul s_lmul y})\"\n      | mul x y => s!\"{toString s_add s_mul s_lmul x}{s_mul}{toString s_add s_mul s_lmul y}\"\n      | lmul c x => s!\"{c}{s_lmul}{toString s_add s_mul s_lmul x}\"\n    \n    instance {M K X} [ToString M] [ToString K] : ToString (Repr M K X) := \n    \u27e8 \u03bb x => x.toString \" + \" \" * \" \" * \"\u27e9\n\n    def RedFormFromNot {M K X} (notForm : Repr M K X \u2192 Prop) (x : Repr M K X) : Prop :=\n      match x with\n      | mon x => \u00ac (notForm (mon x))\n      | x + y => \u00ac (notForm x) \u2227 \u00ac (notForm y) \u2227 \u00ac (notForm (x + y))\n      | x * y => \u00ac (notForm x) \u2227 \u00ac (notForm y) \u2227 \u00ac (notForm (x * y))\n      | lmul c x => \u00ac (notForm x) \u2227 \u00ac (notForm (c * x))\n\n    -- Rather defining reduced form we define what can't occur in reduced form\n    inductive NotRed1Form {M K X} : Repr M K X \u2192 Prop where\n    -- monomials should be multiplied together\n    | red1_mon (m m' : M)                         : NotRed1Form ((mon m) * (mon m'))\n    -- left multiplication association\n    | red1_mul_assoc (x y z : Repr M K X)         : NotRed1Form (x*(y*z))\n    -- scalar multiplication always on the left\n    | red1_mul_lmul (x y : Repr M K X) (c : K)    : NotRed1Form (x * (c * y))\n    -- no scalar multiplication on monomial\n    | red1_lmul_mon (m : M) (c : K)               : NotRed1Form (c * (mon m : Repr M K X))\n    -- no double scalar multiplication\n    | red1_lmul_lmul (x : Repr M K X) (c c' : K)  : NotRed1Form (c * (c' * x))\n    -- left addition association \n    | red1_add_assoc (x y z : Repr M K X)         : NotRed1Form (x + (y + z))\n\n    def Red1Form {M K X} : Repr M K X \u2192 Prop := RedFormFromNot NotRed1Form\n\n    partial def reduce1 {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] -- [DecidableEq M] --[Monomial M X K]\n      (x : Repr M K X) : Repr M K X\n      := \n      match x with\n      | x * y => \n        match reduce1 x, reduce1 y with\n        | mon x, mon y => mon (x*y)\n        | x, lmul c y' => reduce1 $ (reduce1 $ lmul c x) * y'\n        | x, y' * y'' => reduce1 $ x * y' * y''\n        | x, y => x * y\n      | lmul c x => \n        match reduce1 x with\n        | mon x => mon (c*x)\n        | x * y => reduce1 (c*x)*y\n        | lmul d x => (c*d)*x\n        | x => c * x\n      | x + y =>\n        match reduce1 x, reduce1 y with\n        | x, y' + y'' => reduce1 $ (x + y') + y''\n        | x, y => x + y\n      | x => x\n\n    @[simp]\n    theorem reduce1_idempotent {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X]\n      (x : Repr M K X) : reduce1 (reduce1 x) = reduce1 x := sorry\n\n    theorem reduce1_sound {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X]\n      (x : Repr M K X) : Red1Form (reduce1 x) := sorry\n\n    inductive NotRed2Form {M K X} [Zero M] [LT X] [Monomial M K X] : Repr M K X \u2192 Prop where\n    -- reduced2 implies reduce1\n    | red2_red1 (x : Repr M K X) (h : NotRed1Form x) : NotRed2Form x\n    -- addition of monomials of the same base not allowed\n    | red2_mon_base (m m' : M) (h : Monomial.base K m = (Monomial.base K m' : X)) : NotRed2Form (mon m + mon m')\n    -- addition of monomials has to be in correct order\n    | red2_mon_order (m m' : M) (h : Monomial.base K m > (Monomial.base K m' : X)) : NotRed2Form (mon m + mon m')\n    -- can't add zero\n    | red2_add_zero (x : Repr M K X) : NotRed2Form (x + 0)\n    -- can't add to zero\n    | red2_zero_add (x : Repr M K X) : NotRed2Form (0 + x)\n    -- TODO: Finish the definition\n    -- | red2_add_base (x y : Repr M K X) :\n\n    def Red2Form {M K X} [Zero M] [LT X] [Monomial M K X] : Repr M K X \u2192 Prop := RedFormFromNot NotRed2Form\n\n    open Monomial\n    partial def reduce2 {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      (x : Repr M K X) : Repr M K X\n      :=\n      match reduce1 x with\n      | x + y => \n        match reduce2 x, reduce2 y with\n        | mon x', mon y' => \n          match decCp (base K x') ((base K y') : X) with\n          | cpEq h => reduce2 $ mon $ intro ((coef X x' + coef X y') : K) ((base K x') : X)\n          | cpLt h => if x' = 0 then mon y' else mon x' + mon y'\n          | cpGt h => if y' = 0 then mon x' else mon y' + mon x'\n        | x'' + mon x', mon y' => \n          match decCp (base K x') ((base K y') : X) with\n          | cpEq h => reduce2 $ x'' + (mon $ intro ((coef X x' + coef X y') : K) ((base K x') : X))\n          | cpLt h => if x' = 0 then x'' + mon y' else x'' + mon x' + mon y'\n          | cpGt h => reduce2 $ if y' = 0 then x'' + mon x' else x'' + mon y' + mon x'\n        | x', y' => x' + y'\n      | x * y =>\n        match reduce2 x, reduce2 y with\n        | mon x', mon y' => mon (x'*y')\n        | mon x', y' => \n          if x' = 0 \n          then mon 0\n          else if x' = 1 \n          then y'\n          else mon x' * y'\n        | x', mon y' =>\n          if y' = 0 \n          then mon 0\n          else if y' = 1 \n          then x'\n          else x' * mon y'\n        | x', y' => x' * y'\n      | lmul c x =>\n        if c = 0 then\n          mon 0 \n        else\n          reduce1 $ lmul c (reduce2 x) \n      | x => x\n\n    @[simp]\n    theorem reduce2_idempotent  {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      (x : Repr M K X) : reduce2 (reduce2 x) = reduce2 x := sorry\n\n    theorem reduce2_sound  {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      (x : Repr M K X) : Red2Form (reduce2 x) := sorry\n\n    -- Normalized form is fully expanded polynomial where terms are ordered by their degree\n    inductive NotNormForm {M K X} [Zero M] [LT X] [Monomial M K X] : Repr M K X \u2192 Prop where\n    -- reduced2 implies reduce1\n    | norm_red2 (x : Repr M K X) (h : NotRed2Form x) : NotNormForm x\n    -- addition of monomials of the same base not allowed\n    | norm_mul (x y : Repr M K X) : NotNormForm (x * y)\n\n    def NormForm {M K X} [Zero M] [LT X] [Monomial M K X] : Repr M K X \u2192 Prop := RedFormFromNot NotNormForm\n\n    open Monomial\n    partial def normalize {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      (x : Repr M K X) : Repr M K X\n      :=\n    match reduce2 x with\n    | x * y => \n      match normalize x, normalize y with\n      | x', y' + y'' => normalize (x' * y' + x' * y'')\n      | x' + x'', y' => normalize (x' * y' + x'' * y')\n      | x', y' => reduce2 $ x' * y'\n    -- | x * (y + z) => normalize (x * y + x * z)\n    -- | (x + y) * z => normalize (x * z + y * z)\n    | x + y => reduce2 $ normalize x + normalize y\n    | lmul c (x + y) => normalize (c * x + c * y)\n    | x => x\n\n    @[simp]\n    theorem normalize_idempotent  {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      (x : Repr M K X) : normalize (normalize x) = normalize x := sorry\n\n    theorem normalize_sound  {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      (x : Repr M K X) : NormForm (normalize x) := sorry\n\n    open Monomial in\n    inductive AlgEq (M K X) [Zero M] [One M] [Add K] [LT X] [Monomial M K X] : Repr M K X \u2192 Repr M K X \u2192 Prop where\n    | add_assoc (x y z : Repr M K X) : AlgEq M K X ((x + y) + z) (x + (y + z))\n    | add_comm  (x y : Repr M K X) : AlgEq M K X (x + y) (y + x)\n    | add_mon  (m m' : M) (h : base K m = (base K m' : X))\n      : AlgEq M K X (mon m + mon m') (mon $ intro (coef X m + coef X m' : K) (base K m : X))\n    | add_zero  (x : Repr M K X) : AlgEq M K X (x + 0) x\n\n    | mul_assoc (x y z : Repr M K X) : AlgEq M K X ((x * y) * z) (x * (y * z))\n    | mul_mon   (m m' : M) : AlgEq M K X (mon m * mon m') (mon (m * m'))\n    | mul_zero  (x y : Repr M K X) : AlgEq M K X (1 * x) x\n\n    | mul_add  (x y z : Repr M K X) : AlgEq M K X (x * (y + z)) (x * y + x * z)\n    | lmul_add  (c : K )(x y : Repr M K X) : AlgEq M K X (c * (x + y)) (c * x + c * y)\n\n    | lmul_mon  (c : K) (m : M) : AlgEq M K X (lmul c (mon m)) (mon (c * m))\n    -- TODO: Am I missing something here?\n  \n    open Quot' in\n    instance {M K X} [Zero M] [One M] [Add K] [LT X] [Monomial M K X] : QForm (AlgEq M K X) :=\n    {\n      RedForm  := \u03bb lvl x => \n        match lvl with\n        | redLvl 0 => True\n        | redLvl 1 => Red1Form x\n        | redLvl n => Red2Form x\n        | normLvl  => NormForm x\n      redform_norm := sorry\n      redform_zero := sorry\n      redform_succ := sorry\n      redform_inf  := sorry\n    }\n\n    open Quot'\n\n    instance {M K X} [Zero M] [One M] [Add K] [Mul K] [Zero K] [LT X] [Monomial M K X] : QReduce (AlgEq M K X) (redLvl 1) :=\n    {\n      reduce := \u03bb x => x.reduce1\n      is_reduce := sorry\n      eq_reduce := sorry\n      preserve_stronger := sorry\n    }\n\n    instance {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      [Monomial M K X] : QReduce (AlgEq M K X) (redLvl 2) :=\n    {\n      reduce := \u03bb x => x.reduce2\n      is_reduce := sorry\n      eq_reduce := sorry\n      preserve_stronger := sorry\n    }\n\n    instance {M K X} [Add K] [Mul K] [Zero K] [Monomial M K X] \n      [DecidableEq M] [Zero M] [One M]\n      [DecidableEq K] [LT X] [DecidableCp X]\n      [Monomial M K X] : QReduce (AlgEq M K X) (normLvl) :=\n    {\n      reduce := \u03bb x => x.normalize\n      is_reduce := sorry\n      eq_reduce := sorry\n      preserve_stronger := sorry\n    }\n\n  end Repr\n\n  namespace Test\n\n    open Quot'\n\n    abbrev Rep := Repr (SymMonomial Int Nat) Int (FreeMonoid Nat)\n\n    def one : Rep := Repr.mon (\u27e6\u27e8\u27e81, \u27e8[]\u27e9\u27e9, normLvl, sorry\u27e9\u27e7)\n    def x : Rep := Repr.mon (\u27e6\u27e8\u27e81, \u27e8[0]\u27e9\u27e9, normLvl, sorry\u27e9\u27e7)\n    def y : Rep := Repr.mon (\u27e6\u27e8\u27e81, \u27e8[1]\u27e9\u27e9, normLvl, sorry\u27e9\u27e7)\n\n    example : (x * (x * y) * x |>.reduce1 |> toString) = \"[0]*[0]*[0]*[1]\" := by native_decide\n    example : (y * ((2:\u2124)*x) * ((3:\u2124)*x) |>.reduce1 |> toString) = \"6*[0]*[0]*[1]\" := by native_decide\n    example : ((x*y + ((x + y*x) + x) + y) |>.reduce1 |> toString) = \"(((([0]*[1] + [0]) + [0]*[1]) + [0]) + [1])\" := by native_decide\n    example : ((2:\u2124)*x + (3:\u2124)*x*((5:\u2124)*(x + y)) |>.reduce1 |> toString) = \"(2*[0] + 15*[0] * ([0] + [1]))\" := by native_decide\n\n    example : ((x + x) |>.reduce2 |> toString) = \"2*[0]\" := by native_decide\n    example : ((x + y + x) |>.reduce2 |> toString) = \"(2*[0] + [1])\" := by native_decide\n    example : (x + (x + y) |>.reduce2 |> toString) = \"(2*[0] + [1])\" := by native_decide\n    example : (x + x + y + (-1:\u2124)*x |>.reduce2 |> toString) = \"([0] + [1])\" := by native_decide\n    example : ((2:\u2124)*x + x*((0:\u2124)*x + (0:\u2124)*y) |>.reduce2 |> toString) = \"2*[0]\" := by native_decide\n    example : ((2:\u2124)*x + x*((0:\u2124)*x + (0:\u2124)*y + one) |>.reduce2 |> toString) = \"3*[0]\" := by native_decide\n    example : ((2:\u2124)*x + (5:\u2124)*((2:\u2124)*x + x + (0:\u2124)*y) |>.reduce2 |> toString) = \"17*[0]\" := by native_decide\n    example : (((2:\u2124)*x + y)*((2:\u2124)*x + (1:\u2124)*y + (10:\u2124)*one + x*y) |>.reduce2 |> toString) \n              = \"(2*[0] + [1]) * (((10*1 + 2*[0]) + [1]) + [0]*[1])\" := by native_decide\n\n    example : ((5:\u2124)*(x + y)*((2:\u2124)*x + x + (3:\u2124)*y) |>.normalize |> toString) \n              = \"((15*[0]*[0] + 30*[0]*[1]) + 15*[1]*[1])\" := by native_decide\n    example : (((2:\u2124)*x + y)*((2:\u2124)*x + (1:\u2124)*y + (10:\u2124)*one + x*y) |>.normalize |> toString) \n              = \"((((((20*[0] + 10*[1]) + 4*[0]*[0]) + 4*[0]*[1]) + [1]*[1]) + 2*[0]*[0]*[1]) + [0]*[1]*[1])\" := by native_decide\n    example : ((2:\u2124)*x + (3:\u2124)*x*((5:\u2124)*(x + y)) |>.normalize |> toString) \n              = \"((2*[0] + 15*[0]*[0]) + 15*[0]*[1])\" := by native_decide\n\n  end Test\n\nend Algebra\n\n-- Algebra that reduces to specified level\nabbrev Algebra (M K X) (lvl := Quot'.redLvl 1) [MonoidWithZero M] [Ring K] [LT X] [Monomial M K X] := Quot' (Algebra.Repr.AlgEq M K X)\n\nnamespace Algebra\n\n  open Quot'\n\n  variable {M K X lvl} [MonoidWithZero M] [Ring K] [LT X] [Monomial M K X] [QReduce (Algebra.Repr.AlgEq M K X) lvl]\n\n  instance : Add (Algebra M K X lvl) := \u27e8\u03bb x' y' => reduce lvl <| Quot'.lift\u2082 (\u03bb x y => x + y) (hom := sorry) x' y'\u27e9\n  instance [One K] [Neg K] : Neg (Algebra M K X lvl) := \u27e8\u03bb x' => reduce lvl <| Quot'.lift (\u03bb x => (-1 : K)*x) (hom := sorry) x'\u27e9\n  instance [One K] [Neg K] : Sub (Algebra M K X lvl) := \u27e8\u03bb x' y' => reduce lvl <| Quot'.lift\u2082 (\u03bb x y => x + (-1 : K)*y) (hom := sorry) x' y'\u27e9\n  instance : Mul (Algebra M K X lvl) := \u27e8\u03bb x' y' => reduce lvl <| Quot'.lift\u2082 (\u03bb x y => x * y) (hom := sorry) x' y'\u27e9\n  instance : HMul K (Algebra M K X lvl) (Algebra M K X lvl) := \u27e8\u03bb c x' => reduce lvl <| Quot'.lift (\u03bb x => c * x) (hom := sorry) x'\u27e9\n\n  instance : One (Algebra M K X lvl) := \u27e8\u27e6\u27e8Repr.mon 1, normLvl, sorry\u27e9\u27e7\u27e9\n  instance : Zero (Algebra M K X lvl) := \u27e8\u27e6\u27e8Repr.mon 0, normLvl, sorry\u27e9\u27e7\u27e9\n\n  -- instance (n : Nat) : OfNat (Algebra M K X lvl) n := \u27e8(n : K)*(1 : Algebra M K X lvl)\u27e9\n\n  -- instance : Numeric (Algebra M K X lvl) := \u27e8\u03bb n => (OfNat.ofNat n : K)*(1 : Algebra M K X lvl)\u27e9\n\n  instance : AddSemigroup (Algebra M K X lvl) :=\n  {\n    add_assoc := sorry\n  }\n\n  instance : AddCommSemigroup (Algebra M K X lvl) :=\n  {\n    add_comm := sorry\n  }\n\n  instance : Semigroup (Algebra M K X lvl) :=\n  {\n    mul_assoc := sorry\n  }\n\n  instance : Semiring (Algebra M K X lvl) where\n    add_zero := sorry\n    zero_add := sorry\n    nsmul_zero' := sorry\n    nsmul_succ' := sorry\n    zero_mul := sorry\n    mul_zero := sorry\n    one_mul := sorry\n    mul_one := sorry\n    npow_zero' := sorry\n    npow_succ' := sorry\n\n    add_comm := sorry\n    left_distrib := sorry\n    right_distrib := sorry\n\n    mul_assoc := sorry\n\n    natCast n := (n : K)*(1 : Algebra M K X lvl)\n    natCast_zero := sorry\n    natCast_succ := sorry\n\n    -- mul_add := sorry\n    -- add_mul := sorry\n    -- ofNat_succ := sorry\n\n  instance : Ring (Algebra M K X lvl) where\n    sub_eq_add_neg := sorry\n    gsmul_zero' := sorry\n    gsmul_succ' := sorry\n    gsmul_neg' := sorry\n    add_left_neg := sorry\n    \n    intCast n := (n : K)*(1 : Algebra M K X lvl)\n    intCast_ofNat := sorry\n    intCast_negSucc := sorry\n\nend Algebra\n\nabbrev Polynomial (K \u03b9) [Ring K] [DecidableEq K] [LT \u03b9] [DecidableCp \u03b9] \n  := Algebra (SymMonomial K \u03b9) K (FreeMonoid \u03b9) (lvl := Quot'.redLvl 2)\n\nabbrev AltPolynomial (K \u03b9) [Ring K] [DecidableEq K] [LT \u03b9] [DecidableCp \u03b9] \n  := Algebra (AltMonomial K \u03b9) K (FreeMonoid \u03b9) (lvl := Quot'.redLvl 2)\n\nnamespace Polynomial\n\n  open Algebra.Repr\n  \n  open Quot'\n\n  def x : Polynomial Int Nat := \u27e6\u27e8mon \u27e6\u27e8\u27e81, \u27e8[0]\u27e9\u27e9, normLvl, sorry\u27e9\u27e7, normLvl, sorry\u27e9\u27e7\n  def xx : Polynomial Int Nat := \u27e6\u27e8mon \u27e6\u27e8\u27e81, \u27e8[0,0]\u27e9\u27e9, normLvl, sorry\u27e9\u27e7, normLvl, sorry\u27e9\u27e7\n  def y : Polynomial Int Nat := \u27e6\u27e8mon \u27e6\u27e8\u27e81, \u27e8[1]\u27e9\u27e9, normLvl, sorry\u27e9\u27e7, normLvl, sorry\u27e9\u27e7\n\n  set_option synthInstance.maxHeartbeats 5000\n  #eval ((x + y + x - y + 1*x*x) * x).toDebugString\n\n  #eval (x -y + (x + y - x) + (x + y + x - y + 1*x*x) * x) |> Quot'.normalize |>.toDebugString\n  #eval (x -y + (x + y - x) + (x + y + x - y + 1*x*x) * x) |>.toDebugString\n\n  #eval (-y + (x + y - x) + (x + y ) * x).toDebugString\n\nend Polynomial\n"}
{"text": "Formal statement is: lemma two_is_prime_nat [simp]: \"prime (2::nat)\" Informal statement is: The number 2 is prime."}
{"text": "{- This example goes through now that we allow instantiation of\n   blocked terms #-}\nmodule Issue439 where\n\nrecord \u03a3 (A : Set) (B : A \u2192 Set) : Set where\n constructor _,_\n field\n   p\u2081 : A\n   p\u2082 : B p\u2081\n\nopen \u03a3\n\nrecord \u22a4 : Set where\n\ndata Tree : Set where\n leaf : Tree\n node : Tree \u2192 Tree \u2192 Tree\n\nmutual\n\n U : Tree \u2192 Set\n U leaf           = \u22a4\n U (node tr\u2081 tr\u2082) = \u03a3 (U tr\u2081) \u03bb a \u2192 El a \u2192 U tr\u2082\n\n El : \u2200 {tr} \u2192 U tr \u2192 Set\n El {leaf}         _       = \u22a4\n El {node tr\u2081 tr\u2082} (a , b) = (x : El a) \u2192 El (b x)\n\nmutual\n\n data C : Set where\n   c : (\u0393 : C) \u2192 T \u0393 \u2192 C\n\n T : C \u2192 Set\n T \u0393 = \u03a3 Tree (\u03bb tr \u2192 E \u0393 \u2192 U tr)\n\n E : C \u2192 Set\n E (c \u0393 \u03c3) = \u03a3 (E \u0393) \u03bb \u03b3 \u2192 El (p\u2082 \u03c3 \u03b3)\n\npostulate\n e : C\n M : (\u0393 : C) \u2192 T \u0393 \u2192 Set\n z : \u2200 {\u0393 \u03c3} \u2192 M (c \u0393 \u03c3) (p\u2081 \u03c3 , \u03bb \u03b3 \u2192 p\u2082 \u03c3 (p\u2081 \u03b3))\n l : \u2200 {\u0393} \u03c3 {\u03c4} \u2192 M (c \u0393 \u03c3) \u03c4 \u2192\n     M \u0393 (_ , \u03bb \u03b3 \u2192 p\u2082 \u03c3 \u03b3 , \u03bb v \u2192 p\u2082 \u03c4 (\u03b3 , v))\n a : \u2200 {\u0393 tr\u2081 tr\u2082 \u03c3} \u2192\n     M \u0393 (node tr\u2081 tr\u2082 , \u03c3) \u2192 M \u0393 (tr\u2081 , \u03bb \u03b3 \u2192 p\u2081 (\u03c3 \u03b3)) \u2192\n     M \u0393 (leaf , _)\n s : \u2200 {\u0393} \u2192 M \u0393 (leaf , _)\n\nt : \u2200 {\u0393 \u03c3} \u2192 M \u0393 \u03c3 \u2192 T \u0393\nt {\u03c3 = \u03c3} _ = \u03c3\n\nfoo : M (c e (leaf , _)) (leaf , _)\nfoo = a (l (t s) z) z\n"}
{"text": "def p (x : Nat := 0) : Nat \u00d7 Nat :=\n(x, x)\n\ntheorem ex1 : p.1 = 0 :=\nrfl\n\ntheorem ex2 : (p (x := 1) |>.2) = 1 :=\nrfl\n\ndef c {\u03b1 : Type} [Inhabited \u03b1] : \u03b1 \u00d7 \u03b1 :=\n(default, default)\n\ntheorem ex3 {\u03b1} [Inhabited \u03b1] : c.1 = default (\u03b1 := \u03b1) :=\nrfl\n\ntheorem ex4 {\u03b1} [Inhabited \u03b1] : c.2 = default (\u03b1 := \u03b1) :=\nrfl\n"}
{"text": "[STATEMENT]\nlemma orthogonal_complement_antimono_iff[simp]:\n  fixes  A B :: \\<open>('a::chilbert_space) set\\<close>\n  assumes \\<open>closed_csubspace A\\<close> and  \\<open>closed_csubspace B\\<close>\n  shows \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B \\<longleftrightarrow> A \\<supseteq> B\\<close>\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. (orthogonal_complement A \\<subseteq> orthogonal_complement B) = (B \\<subseteq> A)\n[PROOF STEP]\nproof (rule iffI)\n[PROOF STATE]\nproof (state)\ngoal (2 subgoals):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B \\<Longrightarrow> B \\<subseteq> A\n 2. B \\<subseteq> A \\<Longrightarrow> orthogonal_complement A \\<subseteq> orthogonal_complement B\n[PROOF STEP]\nshow \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B\\<close> if \\<open>A \\<supseteq> B\\<close>\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B\n[PROOF STEP]\nusing that\n[PROOF STATE]\nproof (prove)\nusing this:\nB \\<subseteq> A\n\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B\n[PROOF STEP]\nby auto\n[PROOF STATE]\nproof (state)\nthis:\nB \\<subseteq> A \\<Longrightarrow> orthogonal_complement A \\<subseteq> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B \\<Longrightarrow> B \\<subseteq> A\n[PROOF STEP]\nassume \\<open>orthogonal_complement A \\<subseteq> orthogonal_complement B\\<close>\n[PROOF STATE]\nproof (state)\nthis:\northogonal_complement A \\<subseteq> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B \\<Longrightarrow> B \\<subseteq> A\n[PROOF STEP]\nthen\n[PROOF STATE]\nproof (chain)\npicking this:\northogonal_complement A \\<subseteq> orthogonal_complement B\n[PROOF STEP]\nhave \\<open>orthogonal_complement (orthogonal_complement A) \\<supseteq> orthogonal_complement (orthogonal_complement B)\\<close>\n[PROOF STATE]\nproof (prove)\nusing this:\northogonal_complement A \\<subseteq> orthogonal_complement B\n\ngoal (1 subgoal):\n 1. orthogonal_complement (orthogonal_complement B) \\<subseteq> orthogonal_complement (orthogonal_complement A)\n[PROOF STEP]\nby simp\n[PROOF STATE]\nproof (state)\nthis:\northogonal_complement (orthogonal_complement B) \\<subseteq> orthogonal_complement (orthogonal_complement A)\n\ngoal (1 subgoal):\n 1. orthogonal_complement A \\<subseteq> orthogonal_complement B \\<Longrightarrow> B \\<subseteq> A\n[PROOF STEP]\nthen\n[PROOF STATE]\nproof (chain)\npicking this:\northogonal_complement (orthogonal_complement B) \\<subseteq> orthogonal_complement (orthogonal_complement A)\n[PROOF STEP]\nshow \\<open>A \\<supseteq> B\\<close>\n[PROOF STATE]\nproof (prove)\nusing this:\northogonal_complement (orthogonal_complement B) \\<subseteq> orthogonal_complement (orthogonal_complement A)\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A\n[PROOF STEP]\nusing assms\n[PROOF STATE]\nproof (prove)\nusing this:\northogonal_complement (orthogonal_complement B) \\<subseteq> orthogonal_complement (orthogonal_complement A)\nclosed_csubspace A\nclosed_csubspace B\n\ngoal (1 subgoal):\n 1. B \\<subseteq> A\n[PROOF STEP]\nby auto\n[PROOF STATE]\nproof (state)\nthis:\nB \\<subseteq> A\n\ngoal:\nNo subgoals!\n[PROOF STEP]\nqed"}
{"text": "State Before: \u22a2 ord \u2218 aleph = enumOrd {b | ord (card b) = b \u2227 \u03c9 \u2264 b} State After: \u22a2 StrictMono (ord \u2218 aleph) \u2227 range (ord \u2218 aleph) = {b | ord (card b) = b \u2227 \u03c9 \u2264 b} Tactic: rw [\u2190 eq_enumOrd _ ord_card_unbounded'] State Before: \u22a2 StrictMono (ord \u2218 aleph) \u2227 range (ord \u2218 aleph) = {b | ord (card b) = b \u2227 \u03c9 \u2264 b} State After: \u22a2 range (ord \u2218 aleph) = {b | ord (card b) = b \u2227 \u03c9 \u2264 b} Tactic: use aleph_isNormal.strictMono State Before: \u22a2 range (ord \u2218 aleph) = {b | ord (card b) = b \u2227 \u03c9 \u2264 b} State After: \u22a2 (\u2200 (a : Ordinal), (ord \u2218 aleph) a \u2208 {b | ord (card b) = b \u2227 \u03c9 \u2264 b}) \u2227\n    \u2200 (b : Ordinal), b \u2208 {b | ord (card b) = b \u2227 \u03c9 \u2264 b} \u2192 \u2203 a, (ord \u2218 aleph) a = b Tactic: rw [range_eq_iff] State Before: \u22a2 (\u2200 (a : Ordinal), (ord \u2218 aleph) a \u2208 {b | ord (card b) = b \u2227 \u03c9 \u2264 b}) \u2227\n    \u2200 (b : Ordinal), b \u2208 {b | ord (card b) = b \u2227 \u03c9 \u2264 b} \u2192 \u2203 a, (ord \u2218 aleph) a = b State After: case refine'_1\na : Ordinal\n\u22a2 ord (card ((ord \u2218 aleph) a)) = (ord \u2218 aleph) a\n\ncase refine'_2\na : Ordinal\n\u22a2 \u03c9 \u2264 (ord \u2218 aleph) a Tactic: refine' \u27e8fun a => \u27e8_, _\u27e9, fun b hb => eq_aleph_of_eq_card_ord hb.1 hb.2\u27e9 State Before: case refine'_1\na : Ordinal\n\u22a2 ord (card ((ord \u2218 aleph) a)) = (ord \u2218 aleph) a State After: no goals Tactic: rw [Function.comp_apply, card_ord] State Before: case refine'_2\na : Ordinal\n\u22a2 \u03c9 \u2264 (ord \u2218 aleph) a State After: case refine'_2\na : Ordinal\n\u22a2 \u2135\u2080 \u2264 aleph a Tactic: rw [\u2190 ord_aleph0, Function.comp_apply, ord_le_ord] State Before: case refine'_2\na : Ordinal\n\u22a2 \u2135\u2080 \u2264 aleph a State After: no goals Tactic: exact aleph0_le_aleph _"}
{"text": "[STATEMENT]\nlemma currentLevelPrefixToLevel_aux: \n  assumes \"l \\<ge> i\"\n  shows \"currentLevel (prefixToLevel_aux M l i) <= l - i\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M l i) \\<le> l - i\n[PROOF STEP]\nusing assms\n[PROOF STATE]\nproof (prove)\nusing this:\ni \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux M l i) \\<le> l - i\n[PROOF STEP]\nproof (induct M arbitrary: i)\n[PROOF STATE]\nproof (state)\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\ncase (Cons m M')\n[PROOF STATE]\nproof (state)\nthis:\n?i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) \\<le> l - ?i\ni \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\n{\n[PROOF STATE]\nproof (state)\nthis:\n?i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) \\<le> l - ?i\ni \\<le> l\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nassume \"marked m\" \"i = l\"\n[PROOF STATE]\nproof (state)\nthis:\nmarked m\ni = l\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nhence ?case\n[PROOF STATE]\nproof (prove)\nusing this:\nmarked m\ni = l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nunfolding currentLevel_def\n[PROOF STATE]\nproof (prove)\nusing this:\nmarked m\ni = l\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\<le> l - i\n[PROOF STEP]\nby simp\n[PROOF STATE]\nproof (state)\nthis:\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\n}\n[PROOF STATE]\nproof (state)\nthis:\n\\<lbrakk>marked m; i = l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nmoreover\n[PROOF STATE]\nproof (state)\nthis:\n\\<lbrakk>marked m; i = l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\n{\n[PROOF STATE]\nproof (state)\nthis:\n\\<lbrakk>marked m; i = l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nassume \"marked m\" \"i < l\"\n[PROOF STATE]\nproof (state)\nthis:\nmarked m\ni < l\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nhence ?case\n[PROOF STATE]\nproof (prove)\nusing this:\nmarked m\ni < l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nusing Cons(1) [of \"i+1\"]\n[PROOF STATE]\nproof (prove)\nusing this:\nmarked m\ni < l\ni + 1 \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l (i + 1)) \\<le> l - (i + 1)\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nunfolding currentLevel_def\n[PROOF STATE]\nproof (prove)\nusing this:\nmarked m\ni < l\ni + 1 \\<le> l \\<Longrightarrow> length (markedElements (prefixToLevel_aux M' l (i + 1))) \\<le> l - (i + 1)\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\<le> l - i\n[PROOF STEP]\nby simp\n[PROOF STATE]\nproof (state)\nthis:\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\n}\n[PROOF STATE]\nproof (state)\nthis:\n\\<lbrakk>marked m; i < l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nmoreover\n[PROOF STATE]\nproof (state)\nthis:\n\\<lbrakk>marked m; i < l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\n{\n[PROOF STATE]\nproof (state)\nthis:\n\\<lbrakk>marked m; i < l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nassume \"\\<not> marked m\"\n[PROOF STATE]\nproof (state)\nthis:\n\\<not> marked m\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nhence ?case\n[PROOF STATE]\nproof (prove)\nusing this:\n\\<not> marked m\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nusing Cons\n[PROOF STATE]\nproof (prove)\nusing this:\n\\<not> marked m\n?i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M' l ?i) \\<le> l - ?i\ni \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nunfolding currentLevel_def\n[PROOF STATE]\nproof (prove)\nusing this:\n\\<not> marked m\n?i \\<le> l \\<Longrightarrow> length (markedElements (prefixToLevel_aux M' l ?i)) \\<le> l - ?i\ni \\<le> l\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux (m # M') l i)) \\<le> l - i\n[PROOF STEP]\nby simp\n[PROOF STATE]\nproof (state)\nthis:\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\n}\n[PROOF STATE]\nproof (state)\nthis:\n\\<not> marked m \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (2 subgoals):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n 2. \\<And>a M i. \\<lbrakk>\\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux M l i) \\<le> l - i; i \\<le> l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (a # M) l i) \\<le> l - i\n[PROOF STEP]\nultimately\n[PROOF STATE]\nproof (chain)\npicking this:\n\\<lbrakk>marked m; i = l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\\<lbrakk>marked m; i < l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\\<not> marked m \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nshow ?case\n[PROOF STATE]\nproof (prove)\nusing this:\n\\<lbrakk>marked m; i = l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\\<lbrakk>marked m; i < l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\\<not> marked m \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nusing \\<open>i <= l\\<close>\n[PROOF STATE]\nproof (prove)\nusing this:\n\\<lbrakk>marked m; i = l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\\<lbrakk>marked m; i < l\\<rbrakk> \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\\<not> marked m \\<Longrightarrow> currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\ni \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n[PROOF STEP]\nby auto\n[PROOF STATE]\nproof (state)\nthis:\ncurrentLevel (prefixToLevel_aux (m # M') l i) \\<le> l - i\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n[PROOF STEP]\nnext\n[PROOF STATE]\nproof (state)\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n[PROOF STEP]\ncase Nil\n[PROOF STATE]\nproof (state)\nthis:\ni \\<le> l\n\ngoal (1 subgoal):\n 1. \\<And>i. i \\<le> l \\<Longrightarrow> currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n[PROOF STEP]\nthus ?case\n[PROOF STATE]\nproof (prove)\nusing this:\ni \\<le> l\n\ngoal (1 subgoal):\n 1. currentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n[PROOF STEP]\nunfolding currentLevel_def\n[PROOF STATE]\nproof (prove)\nusing this:\ni \\<le> l\n\ngoal (1 subgoal):\n 1. length (markedElements (prefixToLevel_aux [] l i)) \\<le> l - i\n[PROOF STEP]\nby simp\n[PROOF STATE]\nproof (state)\nthis:\ncurrentLevel (prefixToLevel_aux [] l i) \\<le> l - i\n\ngoal:\nNo subgoals!\n[PROOF STEP]\nqed"}
{"text": "[GOAL]\nx y : Path PUnit.unit PUnit.unit\n\u22a2 x = y\n[PROOFSTEP]\next\n[GOAL]\nx y : FundamentalGroupoid PUnit\n\u22a2 Subsingleton (x \u27f6 y)\n[PROOFSTEP]\nconvert_to Subsingleton (Path.Homotopic.Quotient PUnit.unit PUnit.unit)\n[GOAL]\nx y : FundamentalGroupoid PUnit\n\u22a2 Subsingleton (Path.Homotopic.Quotient PUnit.unit PUnit.unit)\n[PROOFSTEP]\napply Quotient.instSubsingletonQuotient\n[GOAL]\nx\u271d : FundamentalGroupoid PUnit\n\u22a2 (\ud835\udfed (FundamentalGroupoid PUnit)).obj x\u271d =\n    (Functor.star (FundamentalGroupoid PUnit) \u22d9 (Functor.const (Discrete PUnit)).obj PUnit.unit).obj x\u271d\n[PROOFSTEP]\nsimp\n"}
{"text": "corollary fps_coeff_residues_bigo': fixes f :: \"complex \\<Rightarrow> complex\" and r :: real assumes exp: \"f has_fps_expansion F\" assumes \"open A\" \"connected A\" \"cball 0 r \\<subseteq> A\" \"r > 0\" assumes \"f holomorphic_on A - S\" \"S \\<subseteq> ball 0 r\" \"finite S\" \"0 \\<notin> S\" assumes \"eventually (\\<lambda>n. g n = -(\\<Sum>z\\<in>S. residue (\\<lambda>z. f z / z ^ Suc n) z)) sequentially\" (is \"eventually (\\<lambda>n. _ = -?g' n) _\") shows \"(\\<lambda>n. fps_nth F n - g n) \\<in> O(\\<lambda>n. 1 / r ^ n)\" (is \"(\\<lambda>n. ?c n - _) \\<in> O(_)\")"}
{"text": "State Before: m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nf : \u03b1 \u2192 m \u03b2\nl : List \u03b1\n\u22a2 mapM' f l = mapM f l State After: no goals Tactic: simp [go, mapM] State Before: m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nf : \u03b1 \u2192 m \u03b2\nl : List \u03b1\nacc : List \u03b2\n\u22a2 mapM.loop f [] acc = do\n    let __do_lift \u2190 mapM' f []\n    pure (reverse acc ++ __do_lift) State After: no goals Tactic: simp State Before: m : Type u_1 \u2192 Type u_2\n\u03b1 : Type u_3\n\u03b2 : Type u_1\ninst\u271d\u00b9 : Monad m\ninst\u271d : LawfulMonad m\nf : \u03b1 \u2192 m \u03b2\nl\u271d : List \u03b1\na : \u03b1\nl : List \u03b1\nacc : List \u03b2\n\u22a2 mapM.loop f (a :: l) acc = do\n    let __do_lift \u2190 mapM' f (a :: l)\n    pure (reverse acc ++ __do_lift) State After: no goals Tactic: simp [go l]"}
{"text": "\n/--\nFrom Sets to Relations\n\nTake-away message. Whereas we represent a set\nas a one-place predicate, we will represent a\nbinary relation as a two-place predicate. Just\nas a set is a collection of individual objects\nthat satisfy a predicate, a relation is a set\nof *pairs* of objects, each of which satisfies\nthe pair membership predicate for the relation. \n--/\n\n/-\nExample: negation_as_a_binary_relation on bool.\n-/\n\ndef negation : bool \u2192 bool \u2192 Prop\n| tt ff := true\n| ff tt := true\n| _ _ := false\n\n/-\nThis predicate specifies the binary \nrelation, {(tt, ff), (ff, tt)}. Each\nmember of the relation is an ordered\npair of Boolean values. The relation\ncomprises the set of all of the pairs \nthat satisfy the predicate: make the\nresulting proposition true. Other pairs \nof Booleans do not satisfy the predicate\nand so are not in the relation that it\nspecifies. \n-/\n\n/-\n\nNote that unlike with the Boolean\nnegation function, bnot, we cannot\n\"compute\" with predicates; we can\nonly try to prove that a pair of \nvalues (in this case) satisfy them.\n-/\n\n-- functions compute\n#eval bnot tt   -- (tt, ff)\n#eval bnot ff   -- (ff, tt)\n-- takes a single bool, returns a bool\n\nexample : negation tt ff := \nbegin\nunfold negation,\nend \n\nexample : negation ff tt := by unfold negation -- Lean syntax\n\n-- takes two bools, returns a proposition\n-- that proposition then has to be proved \n-- can use \"by\" when script is a single tactic\n\nexample : \u00ac negation tt tt :=\nbegin\nassume h,\ncases h,\nend \n\n/-\nExercise: Formally state and prove the proposition\nthat for all Boolean values, b1 and b2, negation b1 \nb2 \u2194 bnot b1 = b2. This proposition claims that the\nbnot function applied to a Boolean value, b1, equals\nb2, if and only if the pair, (b1,b2), is \"in\" the\nnegation relation.   \n-/\n\n\nexample : \u2200 (b1 b2), negation b1 b2 \u2194 bnot b1 = b2 :=\nbegin\nassume b1 b2,\nsplit,\n\n-- forwards\nintro h,\n\ncases b1,\ncases b2,\n\n-- ff ff\ncases h,\n\n-- tt ff\nexact rfl,\n\ncases b2,\n\n-- tt ff\nexact rfl,\n\n-- tt tt\ncases h,\n\n-- backwards\n\nassume h,\n\n-- again by case analysis on b1 b2\n\ncases b1,\ncases b2,\n\ncases h,\nunfold negation,\n\ncases b2,\nunfold negation,\n\ncases h,\n\n\nend\n\n\n\nexample: \u2200 (b1 b2), negation b1 b2 \u2194 bnot b1 = b2 :=\nbegin\nassume b1 b2,\nsplit,\n-- What should be our proof strategy from here?\n-- Exercise: complete this proof.\nend \n\n\n/-\nNext idea: A binary relation can relate objects of \ndifferent types types. The last example was of a\nbinary relation relating bools to bools. Not let's\nintroduce a new data type, call it bit, with values\nbit.zero and bit.one, and the consider a relation\n\"between\" bools and bits, where a bool is either\ntt or ff and a bit is either zero or one. \n-/\n\ninductive bit \n| zero \n| one \n\n/-\nHere for fun is a function that takes a bit\nand returns the other bit. It's like bnot but\nfor bits.\n-/\n\ndef bit_flip : bit \u2192 bit \n| bit.zero := bit.one\n| bit.one := bit.zero\n\n/-\nNow let's define a relation from bool to bit\nthat associates tt with one and ff with zero.\n-/\n\ndef bool_to_bit_relation : bool \u2192 bit \u2192 Prop\n| tt bit.one := true\n| ff bit.zero := true\n| _ _ := false\n\n/-\nExercise: Draw a picture of this relation.\nExercise: Draw an adjacency matrix for this relation\n-/\n\n/-\nAs another concrete example, let's define the relation\nbetween natural numbers and their squares. We'll start\nby defining the square function. Then we'll define the\ncorresponding relation. They represent the same set of\nordered pairs, but the first computes and the second is\n\"declarative\" (computational vs. logical).\n-/\n\ndef square (n : \u2115) := n * n\n#eval square 25\n\n/-\nNow we specific the relevant set of pairs.\n-/\ndef squares (n m : \u2115) : Prop := square n = m \n\n/-\nWe can prove pairs that bear this relationship and\nnot ones that don't.\n-/\n\nexample : squares 0 0 := rfl\nexample : squares 1 1 := rfl\nexample : squares 2 3 := rfl    -- no can, dude\nexample : squares 2 4 := rfl\nexample : squares 25 625 := rfl\n\n/-\nExercise: define a predicate, call it \nstring2len,on strings and nats, such \nthat (s, n) \u2208 string2len iff length \nof s is n.\n-/\n\ndef string2len : string \u2192 nat \u2192 Prop := \n  \u03bb s n,          -- arguments\n  s.length = n    -- result (here a proposition)\n\n/-\nExercise: prove the proposition that the pair of\narguments, \"Lean!\" and 5, taken together, satisfy\nthe string2len predicate, and are thus considered\nto be a pair that in (a member of) the string2len\nrelation.  \n-/\nexample : string2len \"Lean!\" 5 :=   \nbegin\nunfold string2len,\nexact rfl,\nend\n/-\nThese ideas are prominent in database theory and\npractice. For example, the SELECT statement in a\nSQL database, e.g., mySQL, MariaDB, or PostgreSQL,\nselects the subset of records from a database with\nfield values that satisfy such a selection predicate.\n-/\n"}
{"text": "import tactic\n\n-- True or false? n = 3 \u2194 n^2-2n-3=0. If you think it's false\n-- then you'll have to modify the statement by putting it in brackets\n-- and adding a \u00ac in front of it. \nlemma part_a : \u2200 n : \u2124, n = 3 \u2192 n ^ 2 - 2 * n - 3 = 0 :=\nbegin\n  norm_num,\nend\n\nlemma part_b : \u00ac (\u2200 n : \u2124, n ^ 2 - 2 * n - 3 = 0 \u2192 n = 3) := \nbegin\n  intro h,\n  specialize h(-1),\n  norm_num at h,\nend\n\nlemma part_c : \u00ac (\u2200 n : \u2124, n ^ 2 - 2 * n - 3 = 0 \u2192 n = 3) :=\nbegin\n  intro h,\n  specialize h(-1),\n  norm_num at h,\nend\n\n\nlemma part_d : \u00ac (\u2200 a b : \u2124, is_square (a * b) \u2192 is_square a \u2227 is_square b) :=\nbegin\n  intro h,\n  specialize h (-1) (-1),\n  norm_num at h,\n  unfold is_square at h,\n  cases h with m hm,\n  nlinarith,\nend\n\nlemma part_e : \u2200 a b : \u2124, (is_square a \u2227 is_square b) \u2192 is_square (a * b) :=\nbegin\n  intros a b h,\n  unfold is_square at h,\n  rcases h with \u27e8\u27e8x, hx\u27e9,\u27e8y, hy\u27e9\u27e9,\n  unfold is_square,\n  use x*y,\n  rw hx,\n  rw hy,\n  ring,\nend\n\n\n"}
{"text": "(*\n\n   Benedikt Ahrens and R\u00e9gis Spadotti\n\n   Terminal semantics for codata types in intensional Martin-L\u00f6f type theory\n\n   http://arxiv.org/abs/1401.1053\n\n*)\n\n(*\n\n  Content of this file:\n\n  - definition of pushforward of comodules along a comonad morphism\n  - definition of comodule morphism induced by a comonad morphism\n  - commutativity of pushforward with precomposition w. product\n\n*)\n\nRequire Import Category.RComonad.\nRequire Import Category.RComod.\nRequire Import Category.RComonadWithCut.\nRequire Import Theory.Category.\nRequire Import Theory.Isomorphism.\nRequire Import Theory.Functor.\nRequire Import Theory.RelativeComonad.\nRequire Import Theory.RelativeComonadWithCut.\nRequire Import Theory.Comodule.\nRequire Import Theory.Product.\nRequire Import Theory.ProductPreservingFunctor.\nRequire Import Theory.PrecompositionWithProduct.\n\nGeneralizable All Variables.\n\n(*------------------------------------------------------------------------------\n  -- \uff30\uff35\uff33\uff28\uff26\uff2f\uff32\uff37\uff21\uff32\uff24  \uff23\uff2f\uff2d\uff2f\uff24\uff35\uff2c\uff25\n  ----------------------------------------------------------------------------*)\n(** * Pushforward comodule **)\n\n(** ** Definition **)\nSection Pushforward_construction.\n\n  Context `{F : Functor \ud835\udc9e \ud835\udc9f} {T S : RelativeComonad F}\n           (\u03c4 : T \u21d2 S) `(M : Comodule T \u2130).\n\n  Program Definition pushforward : Comodule S \u2130 :=\n    Comodule.make  \u2983 M        \u2254 M\n                   ; mcobind  \u2254 \u03bb C D \u2219 \u03bb f \u21a6 M\u22c5mcobind (f \u2218 \u03c4(C)) \u2984.\n  Next Obligation. (* mcobind_cong *)\n    solve_proper.\n  Qed.\n  Next Obligation. (* mcobind_counit *)\n    rewrite <- \u03c4_counit. now rewrite mcobind_counit.\n  Qed.\n  Next Obligation. (* mcobind_mcobind *)\n    now rewrite compose_assoc,\n                <- \u03c4_commutes,\n                mcobind_mcobind,\n                <- compose_assoc.\n  Qed.\n\nEnd Pushforward_construction.\n\n(*------------------------------------------------------------------------------\n  -- \uff26\uff35N\uff23\uff34\uff2f\uff32\uff29\uff21\uff2c\uff29\uff34\uff39\n  ----------------------------------------------------------------------------*)\n(** ** Functoriality of pushforward **)\n\nSection Functoriality.\n\n  Context `{F : Functor \ud835\udc9e \ud835\udc9f} {T S : RelativeComonad F} {\u2130 : Category} {M N : Comodule S \u2130}\n          (\u03c4 : S \u21d2 T) (\u03b1 : M \u21d2 N).\n\n  Infix \"\u204e\" := pushforward (at level 0).\n\n  Program Definition pushforward_mor : \u2035 \u03c4\u204eM \u21d2 \u03c4\u204eN \u2032 :=\n    Comodule.make \u2983 \u03b1 \u2254 \u03b1 \u2984.\n  Next Obligation. (* \u03b1_commutes *)\n    now rewrite \u03b1_commutes.\n  Qed.\n\nEnd Functoriality.\n\nProgram Definition Pushforward\n             `{F : Functor \ud835\udc9e \ud835\udc9f} {T S : RelativeComonad F} (\u03c4 : T \u21d2 S) {\u2130} : Functor (\ud835\udc79\ud835\udc6a\ud835\udc90\ud835\udc8e\ud835\udc90\ud835\udc85 T \u2130) (\ud835\udc79\ud835\udc6a\ud835\udc90\ud835\udc8e\ud835\udc90\ud835\udc85 S \u2130) :=\n  Functor.make  \u2983 F    \u2254 pushforward \u03c4\n                ; map  \u2254 \u03bb A B \u2219 \u03bb f \u21a6 pushforward_mor \u03c4 f \u2984.\nNext Obligation.\n  intros f g eq_fg x. simpl. now apply eq_fg.\nQed.\nNext Obligation.\n  reflexivity.\nQed.\nNext Obligation.\n  reflexivity.\nQed.\n\nNotation \"\u03c4 \u204e\" := (Pushforward \u03c4) (at level 0).\n\n(** ** Tautological comodule **)\nSection tautological_comodule.\n\n  Context `{F : Functor \ud835\udc9e \ud835\udc9f} (T : RelativeComonad F).\n\n  Program Definition tcomod : Comodule T \ud835\udc9f :=\n    Comodule.make  \u2983 M        \u2254 T\n                   ; mcobind  \u2254 \u03bb C D \u2219 T\u22c5cobind \u2984.\n  (** mcobind-counit *)\n  Next Obligation.\n    now rewrite cobind_counit.\n  Qed.\n  (** mcobind-mcobind *)\n  Next Obligation.\n    now rewrite cobind_cobind.\n  Qed.\n\nEnd tautological_comodule.\n\nLocal Coercion tcomod : RelativeComonad >-> Comodule.\nNotation \"[ T ]\" := (tcomod T) (only parsing).\n\n(** ** Induced morphism **)\n\nSection induced_morphism.\n\n  Context `{F : Functor \ud835\udc9e \ud835\udc9f} {T S : RelativeComonad F}\n          (\u03c4 : T \u21d2 S).\n\n  Program Definition induced_morphism : \u2035 \u03c4\u204eT \u21d2 S \u2032 :=\n    Comodule.make \u2983 \u03b1 \u2254 \u03bb C \u2219 \u03c4(C) \u2984.\n  (** \u03b1-commutes **)\n  Next Obligation.\n    now rewrite \u03c4_commutes.\n  Qed.\n\nEnd induced_morphism.\n\nNotation \"\u27e8 \u03c4 \u27e9\" := (induced_morphism \u03c4) (at level 0).\n\nSection Commutes.\n\n  Context `{BinaryProduct \ud835\udc9e} `{BinaryProduct \ud835\udc9f} {F : Functor \ud835\udc9e \ud835\udc9f}\n          {E : \ud835\udc9e} `{!ProductPreservingFunctor F} {T S : RelativeComonadWithCut F E}\n          {\u03c4 : T \u21d2 S} `{M : Comodule T \u2130}.\n\n  Program Definition \u03a6 : \u2035 \u03c4\u204e(M[E\u00d7\u2500]) \u21d2 (\u03c4\u204eM)[E\u00d7\u2500] \u2032 :=\n    Comodule.make \u2983 \u03b1 \u2254 \u03bb X \u2219 id[M (E \u00d7 X)] \u2984.\n  Next Obligation.\n    rewrite left_id, right_id.\n    apply \u03a0.cong.\n    repeat rewrite compose_assoc.\n    apply \u03a0\u2082.cong; [ reflexivity |].\n    rewrite \u2218-\u00d7; apply \u03a0\u2082.cong.\n    rewrite compose_assoc; apply \u03a0\u2082.cong; [ reflexivity |].\n    apply \u03c4_counit.\n    rewrite compose_assoc. apply \u03a0\u2082.cong; [ reflexivity |].\n    symmetry. apply \u03c4_cut.\n  Qed.\n\nEnd Commutes.\n"}
{"text": "State Before: p : \u2115\nq : \u211a\nhq : q = 0\n\u22a2 padicNorm p (-q) = padicNorm p q State After: no goals Tactic: simp [hq] State Before: p : \u2115\nq : \u211a\nhq : \u00acq = 0\n\u22a2 padicNorm p (-q) = padicNorm p q State After: no goals Tactic: simp [padicNorm, hq]"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_142\n  (m b : \u211d)\n  (h\u2080 : m * 7 + b = -1)\n  (h\u2081 : m * (-1) + b = 7) :\n  m + b = 5 :=\nbegin\n  linarith,\nend"}
{"text": "[STATEMENT]\nlemma defined_Integer_simps [simp]:\n  \"defined (MkI\\<cdot>i)\"\n  \"defined (0::Integer)\"\n  \"defined (1::Integer)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. defined (MkI\\<cdot>i) &&& defined 0 &&& defined 1\n[PROOF STEP]\nby (simp_all add: defined_def)"}
{"text": "lemma is_unit_content_iff [simp]: \"is_unit (content p) \\<longleftrightarrow> content p = 1\""}
{"text": "/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n\nDefinitions and properties of gcd, lcm, and coprime.\n-/\nimport .div data.nat.gcd\nopen eq.ops\n\nnamespace int\n\n/- gcd -/\n\ndefinition gcd (a b : \u2124) : \u2124 := of_nat (nat.gcd (nat_abs a) (nat_abs b))\n\ntheorem gcd_nonneg (a b : \u2124) : gcd a b \u2265 0 :=\nof_nat_nonneg (nat.gcd (nat_abs a) (nat_abs b))\n\ntheorem gcd.comm (a b : \u2124) : gcd a b = gcd b a :=\nby rewrite [\u2191gcd, nat.gcd.comm]\n\ntheorem gcd_zero_right (a : \u2124) : gcd a 0 = abs a :=\nby rewrite [\u2191gcd, nat_abs_zero, nat.gcd_zero_right, of_nat_nat_abs]\n\ntheorem gcd_zero_left (a : \u2124) : gcd 0 a = abs a :=\nby rewrite [gcd.comm, gcd_zero_right]\n\ntheorem gcd_one_right (a : \u2124) : gcd a 1 = 1 :=\nby rewrite [\u2191gcd, nat_abs_one, nat.gcd_one_right]\n\ntheorem gcd_one_left (a : \u2124) : gcd 1 a = 1 :=\nby rewrite [gcd.comm, gcd_one_right]\n\ntheorem gcd_abs_left (a b : \u2124) : gcd (abs a) b = gcd a b :=\nby rewrite [\u2191gcd, *nat_abs_abs]\n\ntheorem gcd_abs_right (a b : \u2124) : gcd (abs a) b = gcd a b :=\nby rewrite [\u2191gcd, *nat_abs_abs]\n\ntheorem gcd_abs_abs (a b : \u2124) : gcd (abs a) (abs b) = gcd a b :=\nby rewrite [\u2191gcd, *nat_abs_abs]\n\nsection\nopen nat\ntheorem gcd_of_ne_zero (a : \u2124) {b : \u2124} (H : b \u2260 0) : gcd a b = gcd b (abs a % abs b) :=\nhave nat_abs b \u2260 0,  from assume H', H (eq_zero_of_nat_abs_eq_zero H'),\nhave nat_abs b > 0,  from pos_of_ne_zero this,\nhave nat.gcd (nat_abs a) (nat_abs b) = (nat.gcd (nat_abs b) (nat_abs a % nat_abs b)),\n  from @nat.gcd_of_pos (nat_abs a) (nat_abs b) this,\ncalc\n gcd a b = nat.gcd (nat_abs b) (nat_abs a % nat_abs b) : by rewrite [\u2191gcd, this]\n     ... = gcd (abs b) (abs a % abs b)                 : by rewrite [\u2191gcd, -*of_nat_nat_abs, of_nat_mod]\n     ... = gcd b (abs a % abs b)                       : by rewrite [\u2191gcd, *nat_abs_abs]\nend\n\ntheorem gcd_of_pos (a : \u2124) {b : \u2124} (H : b > 0) : gcd a b = gcd b (abs a % b) :=\nby rewrite [!gcd_of_ne_zero (ne_of_gt H), abs_of_pos H]\n\ntheorem gcd_of_nonneg_of_pos {a b : \u2124} (H1 : a \u2265 0) (H2 : b > 0) : gcd a b = gcd b (a % b) :=\nby rewrite [!gcd_of_pos H2, abs_of_nonneg H1]\n\ntheorem gcd_self (a : \u2124) : gcd a a = abs a :=\nby rewrite [\u2191gcd, nat.gcd_self, of_nat_nat_abs]\n\ntheorem gcd_dvd_left (a b : \u2124) : gcd a b \u2223 a :=\nhave gcd a b \u2223 abs a,\n  by rewrite [\u2191gcd, -of_nat_nat_abs, of_nat_dvd_of_nat_iff]; apply nat.gcd_dvd_left,\niff.mp !dvd_abs_iff this\n\ntheorem gcd_dvd_right (a b : \u2124) : gcd a b \u2223 b :=\nby rewrite gcd.comm; apply gcd_dvd_left\n\ntheorem dvd_gcd {a b c : \u2124} : a \u2223 b \u2192 a \u2223 c \u2192 a \u2223 gcd b c :=\nbegin\n  rewrite [\u2191gcd, -*(abs_dvd_iff a), -(dvd_abs_iff _ b), -(dvd_abs_iff _ c), -*of_nat_nat_abs],\n  rewrite [*of_nat_dvd_of_nat_iff] ,\n  apply nat.dvd_gcd\nend\n\ntheorem gcd.assoc (a b c : \u2124) : gcd (gcd a b) c = gcd a (gcd b c) :=\ndvd.antisymm !gcd_nonneg !gcd_nonneg\n  (dvd_gcd\n    (dvd.trans !gcd_dvd_left !gcd_dvd_left)\n    (dvd_gcd (dvd.trans !gcd_dvd_left !gcd_dvd_right) !gcd_dvd_right))\n  (dvd_gcd\n    (dvd_gcd !gcd_dvd_left (dvd.trans !gcd_dvd_right !gcd_dvd_left))\n    (dvd.trans !gcd_dvd_right !gcd_dvd_right))\n\ntheorem gcd_mul_left (a b c : \u2124) : gcd (a * b) (a * c) = abs a * gcd b c :=\nby rewrite [\u2191gcd, *nat_abs_mul, nat.gcd_mul_left, of_nat_mul, of_nat_nat_abs]\n\ntheorem gcd_mul_right (a b c : \u2124) : gcd (a * b) (c * b) = gcd a c * abs b :=\nby rewrite [mul.comm a, mul.comm c, mul.comm (gcd a c), gcd_mul_left]\n\ntheorem gcd_pos_of_ne_zero_left {a : \u2124} (b : \u2124) (H : a \u2260 0) : gcd a b > 0 :=\nhave gcd a b \u2260 0, from\n  suppose gcd a b = 0,\n  have 0 \u2223 a,    from this \u25b8 gcd_dvd_left a b,\n  show false,    from H (eq_zero_of_zero_dvd this),\nlt_of_le_of_ne (gcd_nonneg a b) (ne.symm this)\n\ntheorem gcd_pos_of_ne_zero_right (a : \u2124) {b : \u2124} (H : b \u2260 0) : gcd a b > 0 :=\nby rewrite gcd.comm; apply !gcd_pos_of_ne_zero_left H\n\ntheorem eq_zero_of_gcd_eq_zero_left {a b : \u2124} (H : gcd a b = 0) : a = 0 :=\ndecidable.by_contradiction\n  (suppose a \u2260 0,\n    have gcd a b > 0, from !gcd_pos_of_ne_zero_left this,\n    ne_of_lt this H\u207b\u00b9)\n\ntheorem eq_zero_of_gcd_eq_zero_right {a b : \u2124} (H : gcd a b = 0) : b = 0 :=\nby rewrite gcd.comm at H; apply !eq_zero_of_gcd_eq_zero_left H\n\ntheorem gcd_div {a b c : \u2124} (H1 : c \u2223 a) (H2 : c \u2223 b) :\n  gcd (a / c) (b / c) = gcd a b / (abs c) :=\ndecidable.by_cases\n  (suppose c = 0,\n    calc\n      gcd (a / c) (b / c) = gcd 0 0               : by subst c; rewrite *int.div_zero\n                          ... = 0                 : gcd_zero_left\n                          ... = gcd a b / 0       : int.div_zero\n                          ... = gcd a b / (abs c) : by subst c)\n  (suppose c \u2260 0,\n    have abs c \u2260 0, from assume H', this (eq_zero_of_abs_eq_zero H'),\n    eq.symm (int.div_eq_of_eq_mul_left this\n      (eq.symm (calc\n        gcd (a / c) (b / c) * abs c = gcd (a / c * c) (b / c * c) : gcd_mul_right\n                               ... = gcd a (b / c * c)            : int.div_mul_cancel H1\n                               ... = gcd a b                      : int.div_mul_cancel H2))))\n\ntheorem gcd_dvd_gcd_mul_left (a b c : \u2124) : gcd a b \u2223 gcd (c * a) b :=\ndvd_gcd (dvd.trans !gcd_dvd_left !dvd_mul_left) !gcd_dvd_right\n\ntheorem gcd_dvd_gcd_mul_right (a b c : \u2124) : gcd a b \u2223 gcd (a * c) b :=\n!mul.comm \u25b8 !gcd_dvd_gcd_mul_left\n\ntheorem div_gcd_eq_div_gcd_of_nonneg {a\u2081 b\u2081 a\u2082 b\u2082 : \u2124} (H : a\u2081 * b\u2082 = a\u2082 * b\u2081)\n    (H1 : b\u2081 \u2260 0) (H2 : b\u2082 \u2260 0) (H3 : a\u2081 \u2265 0) (H4 : a\u2082 \u2265 0) :\n  a\u2081 / (gcd a\u2081 b\u2081) = a\u2082 / (gcd a\u2082 b\u2082) :=\nbegin\n  apply div_eq_div_of_dvd_of_dvd,\n  repeat (apply gcd_dvd_left),\n  intro H', apply H1, apply eq_zero_of_gcd_eq_zero_right H',\n  intro H', apply H2, apply eq_zero_of_gcd_eq_zero_right H',\n  rewrite [-abs_of_nonneg H3 at {1}, -abs_of_nonneg H4 at {2}],\n  rewrite [-gcd_mul_left, -gcd_mul_right, H, mul.comm b\u2081]\nend\n\ntheorem div_gcd_eq_div_gcd {a\u2081 b\u2081 a\u2082 b\u2082 : \u2124} (H : a\u2081 * b\u2082 = a\u2082 * b\u2081) (H1 : b\u2081 > 0) (H2 : b\u2082 > 0) :\n  a\u2081 / (gcd a\u2081 b\u2081) = a\u2082 / (gcd a\u2082 b\u2082) :=\nor.elim (le_or_gt 0 a\u2081)\n  (assume H3 : a\u2081 \u2265 0,\n    have H4 : a\u2082 * b\u2081 \u2265 0, by rewrite -H; apply mul_nonneg H3 (le_of_lt H2),\n    have H5 : a\u2082 \u2265 0, from nonneg_of_mul_nonneg_right H4 H1,\n    div_gcd_eq_div_gcd_of_nonneg H (ne_of_gt H1) (ne_of_gt H2) H3 H5)\n  (assume H3 : a\u2081 < 0,\n    have H4 : a\u2082 * b\u2081 < 0, by rewrite -H; apply mul_neg_of_neg_of_pos H3 H2,\n    have H5 : a\u2082 < 0, from neg_of_mul_neg_right H4 (le_of_lt H1),\n    have H6 : abs a\u2081 / (gcd (abs a\u2081) (abs b\u2081)) = abs a\u2082 / (gcd (abs a\u2082) (abs b\u2082)),\n      begin\n        apply div_gcd_eq_div_gcd_of_nonneg,\n        rewrite [abs_of_pos H1, abs_of_pos H2, abs_of_neg H3, abs_of_neg H5],\n        rewrite [-*neg_mul_eq_neg_mul, H],\n        apply ne_of_gt (abs_pos_of_pos H1),\n        apply ne_of_gt (abs_pos_of_pos H2),\n        repeat (apply abs_nonneg)\n      end,\n    have H7 : -a\u2081 / (gcd a\u2081 b\u2081) = -a\u2082 / (gcd a\u2082 b\u2082),\n      begin\n        rewrite [-abs_of_neg H3, -abs_of_neg H5, -gcd_abs_abs a\u2081],\n        rewrite [-gcd_abs_abs a\u2082 b\u2082],\n        exact H6\n      end,\n    calc\n      a\u2081 / (gcd a\u2081 b\u2081) = -(-a\u2081 / (gcd a\u2081 b\u2081))   :\n                             by rewrite [neg_div_of_dvd !gcd_dvd_left, neg_neg]\n                     ... = -(-a\u2082 / (gcd a\u2082 b\u2082)) : H7\n                     ... = a\u2082 / (gcd a\u2082 b\u2082)     :\n                             by rewrite [neg_div_of_dvd !gcd_dvd_left, neg_neg])\n\n/- lcm -/\n\ndefinition lcm (a b : \u2124) : \u2124 := of_nat (nat.lcm (nat_abs a) (nat_abs b))\n\ntheorem lcm_nonneg (a b : \u2124) : lcm a b \u2265 0 :=\nof_nat_nonneg (nat.lcm (nat_abs a) (nat_abs b))\n\ntheorem lcm.comm (a b : \u2124) : lcm a b = lcm b a :=\nby rewrite [\u2191lcm, nat.lcm.comm]\n\ntheorem lcm_zero_left (a : \u2124) : lcm 0 a = 0 :=\nby rewrite [\u2191lcm, nat_abs_zero, nat.lcm_zero_left]\n\ntheorem lcm_zero_right (a : \u2124) : lcm a 0 = 0 :=\n!lcm.comm \u25b8 !lcm_zero_left\n\ntheorem lcm_one_left (a : \u2124) : lcm 1 a = abs a :=\nby rewrite [\u2191lcm, nat_abs_one, nat.lcm_one_left, of_nat_nat_abs]\n\ntheorem lcm_one_right (a : \u2124) : lcm a 1 = abs a :=\n!lcm.comm \u25b8 !lcm_one_left\n\ntheorem lcm_abs_left (a b : \u2124) : lcm (abs a) b = lcm a b :=\nby rewrite [\u2191lcm, *nat_abs_abs]\n\ntheorem lcm_abs_right (a b : \u2124) : lcm (abs a) b = lcm a b :=\nby rewrite [\u2191lcm, *nat_abs_abs]\n\ntheorem lcm_abs_abs (a b : \u2124) : lcm (abs a) (abs b) = lcm a b :=\nby rewrite [\u2191lcm, *nat_abs_abs]\n\ntheorem lcm_self (a : \u2124) : lcm a a = abs a :=\nby rewrite [\u2191lcm, nat.lcm_self, of_nat_nat_abs]\n\ntheorem dvd_lcm_left (a b : \u2124) : a \u2223 lcm a b :=\nby rewrite [\u2191lcm, -abs_dvd_iff, -of_nat_nat_abs, of_nat_dvd_of_nat_iff]; apply nat.dvd_lcm_left\n\ntheorem dvd_lcm_right (a b : \u2124) : b \u2223 lcm a b :=\n!lcm.comm \u25b8 !dvd_lcm_left\n\ntheorem gcd_mul_lcm (a b : \u2124) : gcd a b * lcm a b = abs (a * b) :=\nbegin\n  rewrite [\u2191gcd, \u2191lcm, -of_nat_nat_abs, -of_nat_mul, of_nat_eq_of_nat_iff, nat_abs_mul],\n  apply nat.gcd_mul_lcm\nend\n\ntheorem lcm_dvd {a b c : \u2124} : a \u2223 c \u2192 b \u2223 c \u2192 lcm a b \u2223 c :=\nbegin\n  rewrite [\u2191lcm, -(abs_dvd_iff a), -(abs_dvd_iff b), -*(dvd_abs_iff _ c), -*of_nat_nat_abs],\n  rewrite [*of_nat_dvd_of_nat_iff] ,\n  apply nat.lcm_dvd\nend\n\ntheorem lcm_assoc (a b c : \u2124) : lcm (lcm a b) c = lcm a (lcm b c) :=\ndvd.antisymm !lcm_nonneg !lcm_nonneg\n  (lcm_dvd\n    (lcm_dvd !dvd_lcm_left (dvd.trans !dvd_lcm_left !dvd_lcm_right))\n    (dvd.trans !dvd_lcm_right !dvd_lcm_right))\n  (lcm_dvd\n    (dvd.trans !dvd_lcm_left !dvd_lcm_left)\n    (lcm_dvd (dvd.trans !dvd_lcm_right !dvd_lcm_left) !dvd_lcm_right))\n\n/- coprime -/\n\nabbreviation coprime (a b : \u2124) : Prop := gcd a b = 1\n\ntheorem coprime_swap {a b : \u2124} (H : coprime b a) : coprime a b :=\n!gcd.comm \u25b8 H\n\ntheorem dvd_of_coprime_of_dvd_mul_right {a b c : \u2124} (H1 : coprime c b) (H2 : c \u2223 a * b) : c \u2223 a :=\nhave H3 : gcd (a * c) (a * b) = abs a, from\n  calc\n    gcd (a * c) (a * b) = abs a * gcd c b : gcd_mul_left\n                    ... = abs a * 1       : H1\n                    ... = abs a           : mul_one,\nhave H4 : (c \u2223 gcd (a * c) (a * b)), from dvd_gcd !dvd_mul_left H2,\nby rewrite [-dvd_abs_iff, -H3]; apply H4\n\ntheorem dvd_of_coprime_of_dvd_mul_left {a b c : \u2124} (H1 : coprime c a) (H2 : c \u2223 a * b) : c \u2223 b :=\ndvd_of_coprime_of_dvd_mul_right H1 (!mul.comm \u25b8 H2)\n\ntheorem gcd_mul_left_cancel_of_coprime {c : \u2124} (a : \u2124) {b : \u2124} (H : coprime c b) :\n   gcd (c * a) b = gcd a b :=\nbegin\n  revert H, unfold [coprime, gcd],\n  rewrite [-of_nat_one],\n  rewrite [+of_nat_eq_of_nat_iff, nat_abs_mul],\n  apply nat.gcd_mul_left_cancel_of_coprime,\nend\n\ntheorem gcd_mul_right_cancel_of_coprime (a : \u2124) {c b : \u2124} (H : coprime c b) :\n   gcd (a * c) b = gcd a b :=\n!mul.comm \u25b8 !gcd_mul_left_cancel_of_coprime H\n\ntheorem gcd_mul_left_cancel_of_coprime_right {c a : \u2124} (b : \u2124) (H : coprime c a) :\n   gcd a (c * b) = gcd a b :=\n!gcd.comm \u25b8 !gcd.comm \u25b8 !gcd_mul_left_cancel_of_coprime H\n\ntheorem gcd_mul_right_cancel_of_coprime_right {c a : \u2124} (b : \u2124) (H : coprime c a) :\n   gcd a (b * c) = gcd a b :=\n!gcd.comm \u25b8 !gcd.comm \u25b8 !gcd_mul_right_cancel_of_coprime H\n\ntheorem coprime_div_gcd_div_gcd {a b : \u2124} (H : gcd a b \u2260 0) :\n  coprime (a / gcd a b) (b / gcd a b) :=\ncalc\n  gcd (a / gcd a b) (b / gcd a b)\n         = gcd a b / abs (gcd a b) : gcd_div !gcd_dvd_left !gcd_dvd_right\n     ... = 1                       : by rewrite [abs_of_nonneg !gcd_nonneg, int.div_self H]\n\ntheorem not_coprime_of_dvd_of_dvd {m n d : \u2124} (dgt1 : d > 1) (Hm : d \u2223 m) (Hn : d \u2223 n) :\n  \u00ac coprime m n :=\nassume co : coprime m n,\nhave d \u2223 gcd m n, from dvd_gcd Hm Hn,\nhave d \u2223 1, by rewrite [\u2191coprime at co, co at this]; apply this,\nhave d \u2264 1, from le_of_dvd dec_trivial this,\nshow false, from not_lt_of_ge `d \u2264 1` `d > 1`\n\ntheorem exists_coprime {a b : \u2124} (H : gcd a b \u2260 0) :\n  exists a' b', coprime a' b' \u2227 a = a' * gcd a b \u2227 b = b' * gcd a b :=\nhave H1 : a = (a / gcd a b) * gcd a b, from (int.div_mul_cancel !gcd_dvd_left)\u207b\u00b9,\nhave H2 : b = (b / gcd a b) * gcd a b, from (int.div_mul_cancel !gcd_dvd_right)\u207b\u00b9,\nexists.intro _ (exists.intro _ (and.intro (coprime_div_gcd_div_gcd H) (and.intro H1 H2)))\n\ntheorem coprime_mul {a b c : \u2124} (H1 : coprime a c) (H2 : coprime b c) : coprime (a * b) c :=\ncalc\n  gcd (a * b) c = gcd b c : !gcd_mul_left_cancel_of_coprime H1\n            ... = 1       : H2\n\ntheorem coprime_mul_right {c a b : \u2124} (H1 : coprime c a) (H2 : coprime c b) : coprime c (a * b) :=\ncoprime_swap (coprime_mul (coprime_swap H1) (coprime_swap H2))\n\ntheorem coprime_of_coprime_mul_left {c a b : \u2124} (H : coprime (c * a) b) : coprime a b :=\nhave H1 : (gcd a b \u2223 gcd (c * a) b), from !gcd_dvd_gcd_mul_left,\neq_one_of_dvd_one !gcd_nonneg (H \u25b8 H1)\n\ntheorem coprime_of_coprime_mul_right {c a b : \u2124} (H : coprime (a * c) b) : coprime a b :=\ncoprime_of_coprime_mul_left (!mul.comm \u25b8 H)\n\ntheorem coprime_of_coprime_mul_left_right {c a b : \u2124} (H : coprime a (c * b)) : coprime a b :=\ncoprime_swap (coprime_of_coprime_mul_left (coprime_swap H))\n\ntheorem coprime_of_coprime_mul_right_right {c a b : \u2124} (H : coprime a (b * c)) : coprime a b :=\ncoprime_of_coprime_mul_left_right (!mul.comm \u25b8 H)\n\ntheorem exists_eq_prod_and_dvd_and_dvd {a b c : \u2124} (H : c \u2223 a * b) :\n  \u2203 a' b', c = a' * b' \u2227 a' \u2223 a \u2227 b' \u2223 b :=\ndecidable.by_cases\n (suppose gcd c a = 0,\n    have c = 0, from eq_zero_of_gcd_eq_zero_left `gcd c a = 0`,\n    have a = 0, from eq_zero_of_gcd_eq_zero_right `gcd c a = 0`,\n    have c = 0 * b, from `c = 0` \u2b1d !zero_mul\u207b\u00b9,\n    have 0 \u2223 a, from `a = 0`\u207b\u00b9 \u25b8 !dvd.refl,\n    have b \u2223 b, from !dvd.refl,\n    exists.intro _ (exists.intro _ (and.intro `c = 0 * b` (and.intro `0 \u2223 a` `b \u2223 b`))))\n  (suppose gcd c a \u2260 0,\n    have gcd c a \u2223 c, from !gcd_dvd_left,\n    have H3 : c / gcd c a \u2223 (a * b) / gcd c a, from div_dvd_div this H,\n    have H4 : (a * b) / gcd c a = (a / gcd c a) * b, from\n      calc\n        a * b / gcd c a = b * a / gcd c a     : mul.comm\n                      ... = b * (a / gcd c a) : !int.mul_div_assoc !gcd_dvd_right\n                      ... = a / gcd c a * b   : mul.comm,\n    have H5 : c / gcd c a \u2223 (a / gcd c a) * b, from H4 \u25b8 H3,\n    have H6 : coprime (c / gcd c a) (a / gcd c a), from coprime_div_gcd_div_gcd `gcd c a \u2260 0`,\n    have H7 : c / gcd c a \u2223 b, from dvd_of_coprime_of_dvd_mul_left H6 H5,\n    have H8 : c = gcd c a * (c / gcd c a), from (int.mul_div_cancel' `gcd c a \u2223 c`)\u207b\u00b9,\n    exists.intro _ (exists.intro _ (and.intro H8 (and.intro !gcd_dvd_right H7))))\n\nend int\n"}
{"text": "import algebra.big_operators.basic\nimport data.int.gcd\nimport data.real.basic\nimport data.finset.basic\nimport number_theory.divisors\n\n#check int.lcm 42 47\nopen_locale big_operators\n\ntheorem AIME_2021_I_14 (n1:\u2115)(sigma:\u2115 \u2192 \u2115 )(hs:\u2200(n:pnat), sigma n = \u2211 i in nat.divisors n, i)\n(h:\u2200 (a:pnat),2021\u2208 nat.divisors (sigma (a^n1) -1) ):\nn1\u2265 2*3*7*23*43*47:=\nbegin\n  sorry\nend"}
{"text": "(** * Facts about Static Expressions *)\n\nRequire Import hvhdl.Environment.\nRequire Import hvhdl.StaticExpressions.\nRequire Import hvhdl.AbstractSyntax.\nRequire Import hvhdl.SemanticalDomains.\n\nRequire Import hvhdl.proofs.EnvironmentFacts.\n\n(** ** Facts about Locally Static Expressions *)\n\nSection LStatic.\n\nEnd LStatic.\n\n(** ** Facts about Globally Static Expressions *)\n\nSection GStatic.\n\n  Lemma IGStaticExpr_eq_iff_eq_gens :\n    forall {\u03941 \u03942 e},\n      EqGens \u03941 \u03942 ->\n      IGStaticExpr \u03941 e <->\n      IGStaticExpr \u03942 e.\n  Proof.\n    split.\n    (* CASE A -> B *)\n    - induction 1; eauto with hvhdl.\n      eapply IsGStaticGeneric with (t := t) (v := v);\n        rewrite <- H; assumption.\n    (* CASE B -> A *)\n    - induction 1; eauto with hvhdl.\n      eapply IsGStaticGeneric with (t := t) (v := v);\n        rewrite H; assumption.\n  Qed.\n  \nEnd GStatic.\n"}
{"text": "function [fit] = compare_new(varargin)\n\n% Determine list of inputs.\ninpn = cell(1, length(varargin));\nfor kn = 1:length(varargin);\n    inpn{kn} = inputname(kn);\nend\n\nv = {varargin{:} inpn};\nth = idss(v{2});\nth = th('y1', cell(0));\n\nz = v{1};\nz = iddata(z(:, 1), z(:, 2:end), 1);\ny = pvget(z, 'OutputData');\nz1 = z(:, 'y1', cell(0));\n\n[yh, x01] = predict(th, z1, 1, 'e');\nyhh = pvget(yh, 'OutputData');\n\n%Compute fit.\nerr = norm(yhh{1} - y{1});\nmeanerr = norm(y{1} - mean(y{1}));\nfit = 100*(1-err/meanerr);\n"}
{"text": "import data.list.basic\n\nopen list\n\nvariables {\u03b1 : Type*} (x y z : \u03b1) (xs ys zs : list \u03b1)\n\ndef mk_symm (xs : list \u03b1) := xs ++ reverse xs\n\ntheorem reverse_mk_symm (xs : list \u03b1) :\n  reverse (mk_symm xs) = mk_symm xs :=\nby simp [mk_symm]\n\nsection\nlocal attribute [simp] reverse_mk_symm\n\nexample (xs ys : list \u2115) :\n  reverse (xs ++ mk_symm ys) = mk_symm ys ++ reverse xs :=\nby simp\n\nexample (xs ys : list \u2115) (p : list \u2115 \u2192 Prop)\n    (h : p (reverse (xs ++ (mk_symm ys)))) :\n  p (mk_symm ys ++ reverse xs) :=\nby simp at h; assumption\n\nend\n\nrun_cmd mk_simp_attr `my_simps\n\nattribute [my_simps] reverse_mk_symm\n\nexample (xs ys : list \u2115) :\n  reverse (xs ++ mk_symm ys) = mk_symm ys ++ reverse xs :=\nby {simp with my_simps}\n\nexample (xs ys : list \u2115) (p : list \u2115 \u2192 Prop)\n  (h : p (reverse (xs ++ (mk_symm ys)))) :\n    p (mk_symm ys ++ reverse xs) :=\nby simp with my_simps at h; assumption\n"}
{"text": "import data.real.basic\nimport game.functions.bothInjective game.functions.bothSurjective\nopen function\n\n/-\n# Chapter 6 : Functions\n\n## Level 3\n\nBe sure to make use of the results in the previous two levels.\n-/\n\n/- Lemma\nIf $f : X \\to Y$ and $g : Y \\to Z$ are both bijective functions, then\nthe function resulting from their composition is also bijective.\n-/\ntheorem both_bijective\n    (X Y Z : set \u211d) (f : X \u2192 Y) (g : Y \u2192 Z) : \n    bijective f \u2227 bijective g \u2192 bijective (g \u2218 f) :=\nbegin\n    -- Since $f$ and $g$ are bijective, they are also both injective and surjective.\n    rintro \u27e8\u27e8hfi, hfs\u27e9, hgi, hgs\u27e9,\n    split,\n    -- Since $f$ and $g$ are injective, $g \u2218 f$ is injective by a previous result.\n    apply both_injective,\n    split,\n    repeat {assumption},\n    -- Similarly, since $f$ and $g$ are surjective, $g \u2218 f$ is surjective.\n    apply both_surjective,\n    split,\n    -- Hence, since $g \u2218 f$ is injective and surjective, $g \u2218 f$ is bijective.\n    repeat {assumption}, done\nend\n\n"}
{"text": "theory Exercise2\n  imports Main\nbegin\n\ninductive palindrome :: \"'a list \\<Rightarrow> bool\" where\npdrmNil:  \"palindrome []\" |\npdrmSing: \"palindrome [x]\" |\npdrmRec:  \"palindrome xs \\<Longrightarrow> palindrome (x # xs @ [x])\"\n\ntheorem \"(palindrome xs) \\<Longrightarrow> (rev xs = xs)\"\n  apply (induction rule: palindrome.induct)\n  by simp_all\n\nend"}
{"text": "[STATEMENT]\nlemma list_of_lazy_sequence_append [simp]:\n  \"list_of_lazy_sequence (append xq yq) = list_of_lazy_sequence xq @ list_of_lazy_sequence yq\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. list_of_lazy_sequence (Lazy_Sequence.append xq yq) = list_of_lazy_sequence xq @ list_of_lazy_sequence yq\n[PROOF STEP]\nby (simp add: append_def)"}
{"text": "[STATEMENT]\nlemma assert_gpv_simps [simp]:\n  \"assert_gpv True = Done ()\"\n  \"assert_gpv False = Fail\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. assert_gpv True = Generative_Probabilistic_Value.Done () &&& assert_gpv False = Fail\n[PROOF STEP]\nby(simp_all add: assert_gpv_def)"}
{"text": "From Coq Require Import\n     List\n     ssreflect\n.\n\nFrom ExtensibleCompiler.Theory Require Import\n     Algebra\n     Environment\n     Eval\n     Functor\n     ProgramAlgebra\n     SubFunctor\n     Sum1\n     Types\n     UniversalProperty\n.\n\nLocal Open Scope SubFunctor.\n\nInductive Closure\n          L\n          `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\n          E\n  : Set :=\n| MkClosure (closure : WellFormedValue (L nat)) (environment : Environment E)\n.\nArguments MkClosure {L F FL E}.\n\nGlobal Instance Functor__Closure\n       {L} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\n  : Functor (Closure L).\nProof.\n  refine {| fmap := fun A B f '(MkClosure c e) => MkClosure c (map f e) |}.\n  - move => ? [] c e.\n    rewrite map_id //.\n  - move => ????? [] c e.\n    rewrite map_map //.\nDefined.\n\nDefinition closure\n           {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\n           `{(L V) supports (Closure L)}\n           c e\n  : WellFormedValue (L V)\n  := injectUP' (MkClosure c e).\n\nDefinition closureF\n           {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\n           `{(L V) supports (Closure L)}\n           c e\n  : Fix (L V)\n  := proj1_sig (closure c e).\n\nGlobal Instance FoldUP'__closure\n       {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\n       `{(L V) supports (Closure L)}\n       c e\n  : FoldUP' (closureF c e)\n  := proj2_sig (closure c e).\n\nDefinition isClosure\n           {L V} `{F : forall V, Functor (L V)} `{FL : forall V, Functor (L V)}\n           `{(L V) supports (Closure L)}\n  : Fix (L V) -> option _\n  := fun v =>\n       match projectUP' (F := Closure L) v with\n       | Some (MkClosure f e) => Some (f, e)\n       | None                 => None\n       end.\n"}
{"text": "subsection \\<open>Implementation of Division on Multivariate Polynomials\\<close>\n\ntheory MPoly_Divide_Code\n  imports \n    MPoly_Divide \n    Polynomials.MPoly_Type_Class_FMap\n    Polynomials.MPoly_Type_Univariate\nbegin\n\ntext \\<open>\n  We now set up code equations for some of the operations that we will need, such as division,\n  \\<^const>\\<open>mpoly_to_poly\\<close>, and \\<^const>\\<open>mpoly_to_mpoly_poly\\<close>.\n\\<close>\n\nlemma mapping_of_MPoly[code]: \"mapping_of (MPoly p) = p\"\n  by (simp add: MPoly_inverse)\n\nlift_definition filter_pm :: \"('a \\<Rightarrow> bool) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b :: zero) \\<Rightarrow> ('a \\<Rightarrow>\\<^sub>0 'b)\" is\n  \"\\<lambda>P f x. if P x then f x else 0\"\n  by (erule finite_subset[rotated]) auto\n\nlemma lookup_filter_pm: \"lookup (filter_pm P f) x = (if P x then lookup f x else 0)\"\n  by transfer auto\n\n\nlemma filter_pm_code [code]: \"filter_pm P (Pm_fmap m) = Pm_fmap (fmfilter P m)\"\n  by (auto intro!: poly_mapping_eqI simp: fmlookup_default_def lookup_filter_pm)\n\nlemma remove_key_conv_filter_pm [code]: \"remove_key x m = filter_pm (\\<lambda>y. y \\<noteq> x) m\"\n  by transfer auto\n\nlemma finite_poly_coeff_nonzero: \"finite {n. poly.coeff p n \\<noteq> 0}\"\n  by (metis MOST_coeff_eq_0 eventually_cofinite)\n\nlemma poly_degree_conv_Max:\n  assumes \"p \\<noteq> 0\"\n  shows   \"Polynomial.degree p = Max {n. poly.coeff p n \\<noteq> 0}\"\n  using assms\nproof (intro antisym degree_le Max.boundedI)\n  fix n assume \"n \\<in> {n. poly.coeff p n \\<noteq> 0}\"\n  thus \"n \\<le> Polynomial.degree p\"\n    by (simp add: le_degree)\nqed (auto simp: poly_eq_iff finite_poly_coeff_nonzero)\n\nlemma mpoly_to_poly_code_aux:\n  fixes p :: \"'a :: comm_monoid_add mpoly\" and x :: nat\n  defines \"I \\<equiv> (\\<lambda>m. lookup m x) ` Set.filter (\\<lambda>m. \\<forall>y\\<in>keys m. y = x) (keys (mapping_of p))\"\n  shows   \"I = {n. poly.coeff (mpoly_to_poly x p) n \\<noteq> 0}\"\n    and   \"mpoly_to_poly x p = 0 \\<longleftrightarrow> I = {}\"\n    and   \"I \\<noteq> {} \\<Longrightarrow> Polynomial.degree (mpoly_to_poly x p) = Max I\"\nproof -\n  have \"n \\<in> I \\<longleftrightarrow> poly.coeff (mpoly_to_poly x p) n \\<noteq> 0\" for n\n  proof -\n    have \"I = (\\<lambda>m. lookup m x) ` (keys (mapping_of p) \\<inter> {m. \\<forall>y\\<in>keys m. y = x})\"\n      by (auto simp: I_def Set.filter_def)\n    also have \"{m. \\<forall>y\\<in>keys m. y = x} = range (\\<lambda>n. monomial n x)\" (is \"?lhs = ?rhs\")\n    proof (intro equalityI subsetI)\n      fix m assume \"m \\<in> ?lhs\"\n      hence \"m = monomial (lookup m x) x\"\n        by transfer (auto simp: fun_eq_iff when_def)\n      thus \"m \\<in> ?rhs\" by auto\n    qed (auto split: if_splits)\n    also have \"n \\<in> (\\<lambda>m. lookup m x) ` (keys (mapping_of p) \\<inter> \\<dots>) \\<longleftrightarrow>\n               monomial n x \\<in> keys (mapping_of p)\" by force\n    also have \"\\<dots> \\<longleftrightarrow> poly.coeff (mpoly_to_poly x p) n \\<noteq> 0\"\n      by (simp add: coeff_def in_keys_iff)\n    finally show ?thesis .\n  qed\n  thus I: \"I = {n. poly.coeff (mpoly_to_poly x p) n \\<noteq> 0}\"\n    by blast\n  show eq_0_iff: \"mpoly_to_poly x p = 0 \\<longleftrightarrow> I = {}\"\n    unfolding I by (auto simp: poly_eq_iff)\n  show \"I \\<noteq> {} \\<Longrightarrow> Polynomial.degree (mpoly_to_poly x p) = Max I\"\n    by (subst poly_degree_conv_Max) (use eq_0_iff I in auto)\nqed\n\n\nlemma mpoly_to_poly_code [code]:\n  \"Polynomial.coeffs (mpoly_to_poly x p) =\n     (let I = (\\<lambda>m. lookup m x) ` Set.filter (\\<lambda>m. \\<forall>y\\<in>keys m. y = x) (keys (mapping_of p))\n      in  if I = {} then [] else map (\\<lambda>n. MPoly_Type.coeff p (Poly_Mapping.single x n)) [0..<Max I + 1])\"\n  (is \"?lhs = ?rhs\")\nproof -\n  define I where \"I = (\\<lambda>m. lookup m x) ` Set.filter (\\<lambda>m. \\<forall>y\\<in>keys m. y = x) (keys (mapping_of p))\"\n  show ?thesis\n  proof (cases \"I = {}\")\n    case True\n    thus ?thesis using mpoly_to_poly_code_aux(2)[of x p]\n      by (simp add: I_def)\n  next\n    case False\n    have [simp]: \"mpoly_to_poly x p \\<noteq> 0\"\n      using mpoly_to_poly_code_aux(2)[of x p] False by (simp add: I_def)\n    from False have \"?rhs = map (\\<lambda>n. MPoly_Type.coeff p (Poly_Mapping.single x n)) [0..<Max I + 1]\"\n      (is \"_ = ?rhs'\")\n      by (simp add: I_def Let_def)\n    also have \"\\<dots> = ?lhs\"\n    proof (rule nth_equalityI)\n      show \"length ?rhs' = length ?lhs\"\n        using mpoly_to_poly_code_aux(3)[of x p] False\n        by (simp add: I_def length_coeffs_degree)\n      thus \"?rhs' ! n = ?lhs ! n\" if \"n < length ?rhs'\" for n using that\n        by (auto simp del: upt_Suc simp: nth_coeffs_coeff)\n    qed\n    finally show ?thesis ..\n  qed\nqed\n\n\nfun mpoly_to_mpoly_poly_impl_aux1 :: \"nat \\<Rightarrow> ((nat \\<Rightarrow>\\<^sub>0 nat) \\<times> 'a) list \\<Rightarrow> nat \\<Rightarrow> ((nat \\<Rightarrow>\\<^sub>0 nat) \\<times> 'a) list\" where\n  \"mpoly_to_mpoly_poly_impl_aux1 i [] j = []\"\n| \"mpoly_to_mpoly_poly_impl_aux1 i ((mon', c) # xs) j =\n     (if lookup mon' i = j then [(remove_key i mon', c)] else []) @ mpoly_to_mpoly_poly_impl_aux1 i xs j\"\n\nlemma mpoly_to_mpoly_poly_impl_aux1_altdef:\n  \"mpoly_to_mpoly_poly_impl_aux1 i xs j =\n     map (\\<lambda>(mon, c). (remove_key i mon, c)) (filter (\\<lambda>(mon, c). lookup mon i = j) xs)\"\n  by (induction xs) auto\n\nlemma map_of_mpoly_to_mpoly_poly_impl_aux1:\n  \"map_of (mpoly_to_mpoly_poly_impl_aux1 i xs j) = (\\<lambda>mon.\n     (if lookup mon i > 0 then None\n      else map_of xs (mon + Poly_Mapping.single i j)))\"\n  apply (rule ext)\n  apply (induction i xs j rule: mpoly_to_mpoly_poly_impl_aux1.induct)\n   apply (auto simp: remove_key_lookup)\n    apply (meson remove_key_sum)\n   apply (metis add_left_cancel lookup_single_eq remove_key_sum)\n  apply (metis remove_key_add remove_key_single remove_key_sum single_zero)\n  done\n\nlemma lookup0_fmap_of_list_mpoly_to_mpoly_poly_impl_aux1:\n  \"lookup0 (fmap_of_list (mpoly_to_mpoly_poly_impl_aux1 i xs j)) = (\\<lambda>mon.\n     lookup0 (fmap_of_list xs) (mon + Poly_Mapping.single i j) when lookup mon i = 0)\"\n  by (auto simp add: fmlookup_default_def fmlookup_of_list map_of_mpoly_to_mpoly_poly_impl_aux1)\n\ndefinition mpoly_to_mpoly_poly_impl_aux2 where\n  \"mpoly_to_mpoly_poly_impl_aux2 i p j = poly.coeff (mpoly_to_mpoly_poly i p) j\"\n\nlemma coeff_MPoly: \"MPoly_Type.coeff (MPoly f) m = lookup f m\"\n  by (simp add: coeff_def mpoly.MPoly_inverse)\n\nlemma mpoly_to_mpoly_poly_impl_aux2_code [code]:\n  \"mpoly_to_mpoly_poly_impl_aux2 i (MPoly (Pm_fmap (fmap_of_list xs))) j =\n     MPoly (Pm_fmap (fmap_of_list (mpoly_to_mpoly_poly_impl_aux1 i xs j)))\"\n  unfolding mpoly_to_mpoly_poly_impl_aux2_def\n  by (rule mpoly_eqI)\n     (simp add: coeff_coeff_mpoly_to_mpoly_poly coeff_MPoly\n                lookup0_fmap_of_list_mpoly_to_mpoly_poly_impl_aux1)\n\ndefinition mpoly_to_mpoly_poly_impl :: \"nat \\<Rightarrow> 'a :: comm_ring_1 mpoly \\<Rightarrow> 'a mpoly list\" where\n  \"mpoly_to_mpoly_poly_impl x p = (if p = 0 then [] else\n     map (mpoly_to_mpoly_poly_impl_aux2 x p) [0..<Suc (MPoly_Type.degree p x)])\"\n\nlemma mpoly_to_mpoly_poly_eq_0_iff [simp]: \"mpoly_to_mpoly_poly x p = 0 \\<longleftrightarrow> p = 0\"\nproof -\n  interpret transfer_mpoly_to_mpoly_poly x .\n  define p' where \"p' = mpoly_to_mpoly_poly x p\"\n  have [transfer_rule]: \"R p' p\"\n    by (auto simp: R_def p'_def)\n  show ?thesis\n    unfolding p'_def [symmetric] by transfer_prover\nqed\n\nlemma mpoly_to_mpoly_poly_code [code]:\n  \"Polynomial.coeffs (mpoly_to_mpoly_poly x p) = mpoly_to_mpoly_poly_impl x p\"\n  by (intro nth_equalityI)\n     (auto simp: mpoly_to_mpoly_poly_impl_def length_coeffs_degree\n                 mpoly_to_mpoly_poly_impl_aux2_def coeffs_nth simp del: upt_Suc)\n\nvalue \"mpoly_to_mpoly_poly 0 (Var 0 ^ 2 + Var 0 * Var 1 + Var 1 ^ 2 :: int mpoly)\"\n\nvalue \"Rings.divide (Var 0 ^ 2 * Var 1 + Var 0 * Var 1 ^ 2 :: int mpoly) (Var 1)\"\n\nend"}
{"text": "lemma succ_le_succ (a b : mynat) (h : a \u2264 b) : succ a \u2264 succ b :=\nbegin\ncases h with c hc,\nuse c,\nrwa [hc, succ_add],\nend\n"}
{"text": "import linear_algebra.finite_dimensional\nimport missing_mathlib.linear_algebra.dimension\n\nuniverses u v v' w\nopen_locale classical\n\nopen vector_space cardinal submodule module function\n\nvariables {K : Type u} {V : Type v} [field K] [add_comm_group V] [vector_space K V]\n{V\u2082 : Type v'} [add_comm_group V\u2082] [vector_space K V\u2082]\n\nnamespace finite_dimensional\n\nlemma findim_bot [finite_dimensional K V] : \n  findim K (\u22a5 : submodule K V) = 0 :=\nbegin\n  apply cardinal.nat_cast_inj.1,\n  rw findim_eq_dim,\n  rw dim_bot,\n  refl,\nend\n\nlemma bot_of_findim_zero [finite_dimensional K V]\n  (s : submodule K V) (h : findim K s = 0) : s = \u22a5 :=\nbegin\n  apply submodule.bot_of_dim_zero,\n  rw \u2190findim_eq_dim,\n  apply cardinal.nat_cast_inj.2 h,\nend\n\n@[simp] lemma findim_top [finite_dimensional K V] : \n  findim K (\u22a4 : submodule K V) = findim K V :=\nbegin\n  apply cardinal.nat_cast_inj.1,\n  rw [findim_eq_dim, findim_eq_dim, dim_top]\nend\n\nlemma exists_mem_ne_zero_of_findim_pos\n  [finite_dimensional K V] (h_dim : 0 < findim K V) : \u2203 x : V, x \u2260 0 :=\nbegin\n  apply @exists_mem_ne_zero_of_dim_pos' K V (by apply_instance),\n  rw \u2190findim_eq_dim,\n  rw \u2190cardinal.nat_cast_lt at h_dim,\n  apply h_dim\nend\n\nlemma findim_sup_add_findim_inf_eq [finite_dimensional K V] (s t : submodule K V) :\n  findim K (s \u2294 t : submodule K V) + findim K (s \u2293 t : submodule K V) \n    = findim K s + findim K t :=\nbegin\n  have := s.dim_sup_add_dim_inf_eq t,\n  repeat { rw \u2190findim_eq_dim at this },\n  exact this,\nend\n\nlemma eq_top_of_disjoint [finite_dimensional K V] (s t : submodule K V) \n  (hdim : findim K s + findim K t = findim K V)\n  (hdisjoint : disjoint s t) : s \u2294 t = \u22a4 :=\nbegin\n  have h_findim_inf : findim K \u21a5(s \u2293 t) = 0,\n  { rw [disjoint, le_bot_iff] at hdisjoint,\n    rw [hdisjoint, findim_bot] },\n  apply eq_top_of_findim_eq,\n  rw \u2190hdim,\n  convert findim_sup_add_findim_inf_eq s t,\n  rw h_findim_inf,\n  refl,\nend\n\nlemma lt_omega_of_linear_independent {\u03b9 : Type w} [finite_dimensional K V]\n  {v : \u03b9 \u2192 V} (h : linear_independent K v) : \n  cardinal.mk \u03b9 < cardinal.omega :=\nbegin\n  apply cardinal.lift_lt.1,\n  apply lt_of_le_of_lt,\n  apply linear_independent_le_dim h,\n  rw [\u2190findim_eq_dim, cardinal.lift_omega, cardinal.lift_nat_cast],\n  apply cardinal.nat_lt_omega,\nend\n\nend finite_dimensional"}
{"text": "Formal statement is: lemma emeasure_lfp'[consumes 1, case_names cont measurable]: assumes \"P M\" assumes cont: \"sup_continuous F\" assumes *: \"\\<And>M A. P M \\<Longrightarrow> (\\<And>N. P N \\<Longrightarrow> Measurable.pred N A) \\<Longrightarrow> Measurable.pred M (F A)\" shows \"emeasure M {x\\<in>space M. lfp F x} = (SUP i. emeasure M {x\\<in>space M. (F ^^ i) (\\<lambda>x. False) x})\" Informal statement is: If $F$ is a sup-continuous operator on the set of measurable predicates on a measure space $M$, then the measure of the set of points $x$ such that the least fixed point of $F$ at $x$ is true is equal to the supremum of the measures of the sets of points $x$ such that the $i$th iterate of $F$ at $x$ is true."}
{"text": "      write (*,*)\n!    !\"AA\"\n      end"}
{"text": "variables p q : Prop\n\ntheorem t1 : p \u2192 q \u2192 p := \u03bb (hp : p) (hq : q), hp\n"}
{"text": "\n--Proof: a -> b -> a\n\n\ntheorem Ex002(a b : Prop) : a -> b -> a :=\nassume H1 : a,\nassume H2 : b,\nshow a, from H1\n"}
{"text": "variable {\u03b1} (p : \u03b1 \u2192 Prop) [DecidablePred p]\n\ndef filter : List \u03b1 \u2192 List \u03b1\n| []    => []\n| a::as => if p a then a :: filter as else filter as\n\ntheorem filter_nil : filter p [] = [] :=\nrfl\n\ntheorem filter_cons (a : \u03b1) (as : List \u03b1) : filter p (a :: as) = if p a then a :: filter p as else filter p as :=\nrfl\n\ntheorem filter_cons_of_pos {a : \u03b1} (as : List \u03b1) (h : p a) : filter p (a :: as) = a :: filter p as := by\nrw [filter_cons];\nrw [ifPos h]\n\ntheorem filter_cons_of_neg {a : \u03b1} (as : List \u03b1) (h : \u00ac p a) : filter p (a :: as) = filter p as := by\nrw [filter_cons];\nrw [ifNeg h]\n"}
{"text": "/-\nThis in-class exercise requires solutions to two problems\n-/\n\n/-\nPROBLEM #1. \n\nIn Lean, define pf1 to be a proof of the proposition\nthat, \"for any proposition, Q, (Q \u2227 \u00ac Q) \u2192 false. \n\nHere is a start on an answer. We use \u03bb to \nintroduce the assumption that Q is some proposition. \nThe underscore is what you have to fill in. \n\nIf you need hints, continue reading the comment\nbelow. Once you're done with this problem, move\nonto the second problem in this quiz\n-/\n\ntheorem pf1 : \u2200 Q : Prop, \u00ac (Q \u2227 \u00ac Q)  :=\n    \u03bb (Q : Prop),\n        ( _ )\n\n/-\nHint #1: Remember that, assuming that A is any\nproposition, \u00ac A simply means (A \u2192 false).\n\nHint #2: Hover your mouse cursor over the underscore\nin the preceding code. You will see that what you \nneed to replace  it is a proof of (Q \u2227 \u00ac Q) \u2192 false. \nLean writes this as \u00ac (Q \u2227 \u00ac Q), but as you know,\nthe two expressions are equivalent.\n\nHint #3: (Q \u2227 \u00ac Q) \u2192 false is an implication. \nRemember what a proof of an implication looks like. \nUse a corresponding expression in place of the _.\n\nHint #4: Remember your elimination rules for \u2227 (and).\n\nHint #5: Remember again: \u00ac Q  means (Q \u2192 false).\nIf you have a proof of Q \u2192 false, then you have\na function that if it is given an assumed proof\nof Q it reduces to a proof of false. Look for a\nway to give this function a proof of Q!\n-/\n\n/-\nPROBLEM #2.\n\nProduce a proof, pf2, of the proposition, that \nfor any propositions, P and Q, (P \u2227 Q) \u2227 (P \u2227 \u00ac Q) \n\u2192 false. You can use the partial solution that we\ngave for the last problem as a model. You'll have \nto change the name, pf1, the proposition to be \nproved, and the lambda expressions to at least\ntake (P Q : Prop) as an argument. Your code goes\nbelow. Hint: Remember your and elimination rules.\nAlso, for this problme, you might want, but are \nnot required, to use a tactic script.\n-/\n\n\n\n\n"}
{"text": "informal statement Show that 2 is divisible by $(1+i)^{2}$ in $\\mathbb{Z}[i]$.formal statement theorem exercise_1_31  : (\u27e81, 1\u27e9 : gaussian_int) ^ 2 \u2223 2 :="}
{"text": "lemma or_symm (P Q : Prop) : (P \u2228 Q) \u2192 (Q \u2228 P) :=\nbegin\n    intro pq,\n    cases pq with p q,\n    {\n        right,\n        exact p,\n    },\n    {\n        left,\n        exact q,\n    },\nend"}
{"text": "record R : Set\u2081 where\n  field\n    A : Set\n\n  B : Set\n  B = A\n\n  field\n    C : Set\n\n  D : Set\n  D = A \u2192 B \u2192 C\n"}
{"text": "/-\nCopyright (c) 2020 Joseph Myers. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Joseph Myers\n\n! This file was ported from Lean 3 source module geometry.euclidean.angle.unoriented.right_angle\n! leanprover-community/mathlib commit 46b633fd842bef9469441c0209906f6dddd2b4f5\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Analysis.SpecialFunctions.Trigonometric.Arctan\nimport Mathbin.Geometry.Euclidean.Angle.Unoriented.Affine\n\n/-!\n# Right-angled triangles\n\nThis file proves basic geometrical results about distances and angles in (possibly degenerate)\nright-angled triangles in real inner product spaces and Euclidean affine spaces.\n\n## Implementation notes\n\nResults in this file are generally given in a form with only those non-degeneracy conditions\nneeded for the particular result, rather than requiring affine independence of the points of a\ntriangle unnecessarily.\n\n## References\n\n* https://en.wikipedia.org/wiki/Pythagorean_theorem\n\n-/\n\n\nnoncomputable section\n\nopen BigOperators\n\nopen EuclideanGeometry\n\nopen Real\n\nopen RealInnerProductSpace\n\nnamespace InnerProductGeometry\n\nvariable {V : Type _} [NormedAddCommGroup V] [InnerProductSpace \u211d V]\n\n/-- Pythagorean theorem, if-and-only-if vector angle form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n    \u2016x + y\u2016 * \u2016x + y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 \u2194 angle x y = \u03c0 / 2 :=\n  by\n  rw [norm_add_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]\n  exact inner_eq_zero_iff_angle_eq_pi_div_two x y\n#align inner_product_geometry.norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two InnerProductGeometry.norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two\n\n/-- Pythagorean theorem, vector angle form. -/\ntheorem norm_add_sq_eq_norm_sq_add_norm_sq' (x y : V) (h : angle x y = \u03c0 / 2) :\n    \u2016x + y\u2016 * \u2016x + y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 :=\n  (norm_add_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two x y).2 h\n#align inner_product_geometry.norm_add_sq_eq_norm_sq_add_norm_sq' InnerProductGeometry.norm_add_sq_eq_norm_sq_add_norm_sq'\n\n/-- Pythagorean theorem, subtracting vectors, if-and-only-if vector angle form. -/\ntheorem norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two (x y : V) :\n    \u2016x - y\u2016 * \u2016x - y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 \u2194 angle x y = \u03c0 / 2 :=\n  by\n  rw [norm_sub_sq_eq_norm_sq_add_norm_sq_iff_real_inner_eq_zero]\n  exact inner_eq_zero_iff_angle_eq_pi_div_two x y\n#align inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two\n\n/-- Pythagorean theorem, subtracting vectors, vector angle form. -/\ntheorem norm_sub_sq_eq_norm_sq_add_norm_sq' (x y : V) (h : angle x y = \u03c0 / 2) :\n    \u2016x - y\u2016 * \u2016x - y\u2016 = \u2016x\u2016 * \u2016x\u2016 + \u2016y\u2016 * \u2016y\u2016 :=\n  (norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two x y).2 h\n#align inner_product_geometry.norm_sub_sq_eq_norm_sq_add_norm_sq' InnerProductGeometry.norm_sub_sq_eq_norm_sq_add_norm_sq'\n\n/-- An angle in a right-angled triangle expressed using `arccos`. -/\ntheorem angle_add_eq_arccos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x + y) = Real.arccos (\u2016x\u2016 / \u2016x + y\u2016) :=\n  by\n  rw [angle, inner_add_right, h, add_zero, real_inner_self_eq_norm_mul_norm]\n  by_cases hx : \u2016x\u2016 = 0; \u00b7 simp [hx]\n  rw [div_mul_eq_div_div, mul_self_div_self]\n#align inner_product_geometry.angle_add_eq_arccos_of_inner_eq_zero InnerProductGeometry.angle_add_eq_arccos_of_inner_eq_zero\n\n/-- An angle in a right-angled triangle expressed using `arcsin`. -/\ntheorem angle_add_eq_arcsin_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    angle x (x + y) = Real.arcsin (\u2016y\u2016 / \u2016x + y\u2016) :=\n  by\n  have hxy : \u2016x + y\u2016 ^ 2 \u2260 0 :=\n    by\n    rw [pow_two, norm_add_sq_eq_norm_sq_add_norm_sq_real h, ne_comm]\n    refine' ne_of_lt _\n    rcases h0 with (h0 | h0)\n    \u00b7\n      exact\n        Left.add_pos_of_pos_of_nonneg (mul_self_pos.2 (norm_ne_zero_iff.2 h0)) (mul_self_nonneg _)\n    \u00b7\n      exact\n        Left.add_pos_of_nonneg_of_pos (mul_self_nonneg _) (mul_self_pos.2 (norm_ne_zero_iff.2 h0))\n  rw [angle_add_eq_arccos_of_inner_eq_zero h,\n    Real.arccos_eq_arcsin (div_nonneg (norm_nonneg _) (norm_nonneg _)), div_pow, one_sub_div hxy]\n  nth_rw 1 [pow_two]\n  rw [norm_add_sq_eq_norm_sq_add_norm_sq_real h, pow_two, add_sub_cancel', \u2190 pow_two, \u2190 div_pow,\n    Real.sqrt_sq (div_nonneg (norm_nonneg _) (norm_nonneg _))]\n#align inner_product_geometry.angle_add_eq_arcsin_of_inner_eq_zero InnerProductGeometry.angle_add_eq_arcsin_of_inner_eq_zero\n\n/-- An angle in a right-angled triangle expressed using `arctan`. -/\ntheorem angle_add_eq_arctan_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x + y) = Real.arctan (\u2016y\u2016 / \u2016x\u2016) :=\n  by\n  rw [angle_add_eq_arcsin_of_inner_eq_zero h (Or.inl h0), Real.arctan_eq_arcsin, \u2190\n    div_mul_eq_div_div, norm_add_eq_sqrt_iff_real_inner_eq_zero.2 h]\n  nth_rw 3 [\u2190 Real.sqrt_sq (norm_nonneg x)]\n  rw [\u2190 Real.sqrt_mul (sq_nonneg _), div_pow, pow_two, pow_two, mul_add, mul_one, mul_div,\n    mul_comm (\u2016x\u2016 * \u2016x\u2016), \u2190 mul_div, div_self (mul_self_pos.2 (norm_ne_zero_iff.2 h0)).ne', mul_one]\n#align inner_product_geometry.angle_add_eq_arctan_of_inner_eq_zero InnerProductGeometry.angle_add_eq_arctan_of_inner_eq_zero\n\n/-- An angle in a non-degenerate right-angled triangle is positive. -/\ntheorem angle_add_pos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    0 < angle x (x + y) :=\n  by\n  rw [angle_add_eq_arccos_of_inner_eq_zero h, Real.arccos_pos,\n    norm_add_eq_sqrt_iff_real_inner_eq_zero.2 h]\n  by_cases hx : x = 0; \u00b7 simp [hx]\n  rw [div_lt_one\n      (Real.sqrt_pos.2\n        (Left.add_pos_of_pos_of_nonneg (mul_self_pos.2 (norm_ne_zero_iff.2 hx))\n          (mul_self_nonneg _))),\n    Real.lt_sqrt (norm_nonneg _), pow_two]\n  simpa [hx] using h0\n#align inner_product_geometry.angle_add_pos_of_inner_eq_zero InnerProductGeometry.angle_add_pos_of_inner_eq_zero\n\n/-- An angle in a right-angled triangle is at most `\u03c0 / 2`. -/\ntheorem angle_add_le_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x + y) \u2264 \u03c0 / 2 :=\n  by\n  rw [angle_add_eq_arccos_of_inner_eq_zero h, Real.arccos_le_pi_div_two]\n  exact div_nonneg (norm_nonneg _) (norm_nonneg _)\n#align inner_product_geometry.angle_add_le_pi_div_two_of_inner_eq_zero InnerProductGeometry.angle_add_le_pi_div_two_of_inner_eq_zero\n\n/-- An angle in a non-degenerate right-angled triangle is less than `\u03c0 / 2`. -/\ntheorem angle_add_lt_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x + y) < \u03c0 / 2 :=\n  by\n  rw [angle_add_eq_arccos_of_inner_eq_zero h, Real.arccos_lt_pi_div_two,\n    norm_add_eq_sqrt_iff_real_inner_eq_zero.2 h]\n  exact\n    div_pos (norm_pos_iff.2 h0)\n      (Real.sqrt_pos.2\n        (Left.add_pos_of_pos_of_nonneg (mul_self_pos.2 (norm_ne_zero_iff.2 h0))\n          (mul_self_nonneg _)))\n#align inner_product_geometry.angle_add_lt_pi_div_two_of_inner_eq_zero InnerProductGeometry.angle_add_lt_pi_div_two_of_inner_eq_zero\n\n/-- The cosine of an angle in a right-angled triangle as a ratio of sides. -/\ntheorem cos_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x + y)) = \u2016x\u2016 / \u2016x + y\u2016 :=\n  by\n  rw [angle_add_eq_arccos_of_inner_eq_zero h,\n    Real.cos_arccos (le_trans (by norm_num) (div_nonneg (norm_nonneg _) (norm_nonneg _)))\n      (div_le_one_of_le _ (norm_nonneg _))]\n  rw [mul_self_le_mul_self_iff (norm_nonneg _) (norm_nonneg _),\n    norm_add_sq_eq_norm_sq_add_norm_sq_real h]\n  exact le_add_of_nonneg_right (mul_self_nonneg _)\n#align inner_product_geometry.cos_angle_add_of_inner_eq_zero InnerProductGeometry.cos_angle_add_of_inner_eq_zero\n\n/-- The sine of an angle in a right-angled triangle as a ratio of sides. -/\ntheorem sin_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    Real.sin (angle x (x + y)) = \u2016y\u2016 / \u2016x + y\u2016 :=\n  by\n  rw [angle_add_eq_arcsin_of_inner_eq_zero h h0,\n    Real.sin_arcsin (le_trans (by norm_num) (div_nonneg (norm_nonneg _) (norm_nonneg _)))\n      (div_le_one_of_le _ (norm_nonneg _))]\n  rw [mul_self_le_mul_self_iff (norm_nonneg _) (norm_nonneg _),\n    norm_add_sq_eq_norm_sq_add_norm_sq_real h]\n  exact le_add_of_nonneg_left (mul_self_nonneg _)\n#align inner_product_geometry.sin_angle_add_of_inner_eq_zero InnerProductGeometry.sin_angle_add_of_inner_eq_zero\n\n/-- The tangent of an angle in a right-angled triangle as a ratio of sides. -/\ntheorem tan_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.tan (angle x (x + y)) = \u2016y\u2016 / \u2016x\u2016 :=\n  by\n  by_cases h0 : x = 0; \u00b7 simp [h0]\n  rw [angle_add_eq_arctan_of_inner_eq_zero h h0, Real.tan_arctan]\n#align inner_product_geometry.tan_angle_add_of_inner_eq_zero InnerProductGeometry.tan_angle_add_of_inner_eq_zero\n\n/-- The cosine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nadjacent side. -/\ntheorem cos_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x + y)) * \u2016x + y\u2016 = \u2016x\u2016 :=\n  by\n  rw [cos_angle_add_of_inner_eq_zero h]\n  by_cases hxy : \u2016x + y\u2016 = 0\n  \u00b7 have h' := norm_add_sq_eq_norm_sq_add_norm_sq_real h\n    rw [hxy, MulZeroClass.zero_mul, eq_comm,\n      add_eq_zero_iff' (mul_self_nonneg \u2016x\u2016) (mul_self_nonneg \u2016y\u2016), mul_self_eq_zero] at h'\n    simp [h'.1]\n  \u00b7 exact div_mul_cancel _ hxy\n#align inner_product_geometry.cos_angle_add_mul_norm_of_inner_eq_zero InnerProductGeometry.cos_angle_add_mul_norm_of_inner_eq_zero\n\n/-- The sine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nopposite side. -/\ntheorem sin_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.sin (angle x (x + y)) * \u2016x + y\u2016 = \u2016y\u2016 :=\n  by\n  by_cases h0 : x = 0 \u2227 y = 0; \u00b7 simp [h0]\n  rw [not_and_or] at h0\n  rw [sin_angle_add_of_inner_eq_zero h h0, div_mul_cancel]\n  rw [\u2190 mul_self_ne_zero, norm_add_sq_eq_norm_sq_add_norm_sq_real h]\n  refine' (ne_of_lt _).symm\n  rcases h0 with (h0 | h0)\n  \u00b7 exact Left.add_pos_of_pos_of_nonneg (mul_self_pos.2 (norm_ne_zero_iff.2 h0)) (mul_self_nonneg _)\n  \u00b7 exact Left.add_pos_of_nonneg_of_pos (mul_self_nonneg _) (mul_self_pos.2 (norm_ne_zero_iff.2 h0))\n#align inner_product_geometry.sin_angle_add_mul_norm_of_inner_eq_zero InnerProductGeometry.sin_angle_add_mul_norm_of_inner_eq_zero\n\n/-- The tangent of an angle in a right-angled triangle multiplied by the adjacent side equals\nthe opposite side. -/\ntheorem tan_angle_add_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    Real.tan (angle x (x + y)) * \u2016x\u2016 = \u2016y\u2016 :=\n  by\n  rw [tan_angle_add_of_inner_eq_zero h]\n  rcases h0 with (h0 | h0) <;> simp [h0]\n#align inner_product_geometry.tan_angle_add_mul_norm_of_inner_eq_zero InnerProductGeometry.tan_angle_add_mul_norm_of_inner_eq_zero\n\n/-- A side of a right-angled triangle divided by the cosine of the adjacent angle equals the\nhypotenuse. -/\ntheorem norm_div_cos_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    \u2016x\u2016 / Real.cos (angle x (x + y)) = \u2016x + y\u2016 :=\n  by\n  rw [cos_angle_add_of_inner_eq_zero h]\n  rcases h0 with (h0 | h0)\n  \u00b7 rw [div_div_eq_mul_div, mul_comm, div_eq_mul_inv, mul_inv_cancel_right\u2080 (norm_ne_zero_iff.2 h0)]\n  \u00b7 simp [h0]\n#align inner_product_geometry.norm_div_cos_angle_add_of_inner_eq_zero InnerProductGeometry.norm_div_cos_angle_add_of_inner_eq_zero\n\n/-- A side of a right-angled triangle divided by the sine of the opposite angle equals the\nhypotenuse. -/\ntheorem norm_div_sin_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.sin (angle x (x + y)) = \u2016x + y\u2016 :=\n  by\n  rcases h0 with (h0 | h0); \u00b7 simp [h0]\n  rw [sin_angle_add_of_inner_eq_zero h (Or.inr h0), div_div_eq_mul_div, mul_comm, div_eq_mul_inv,\n    mul_inv_cancel_right\u2080 (norm_ne_zero_iff.2 h0)]\n#align inner_product_geometry.norm_div_sin_angle_add_of_inner_eq_zero InnerProductGeometry.norm_div_sin_angle_add_of_inner_eq_zero\n\n/-- A side of a right-angled triangle divided by the tangent of the opposite angle equals the\nadjacent side. -/\ntheorem norm_div_tan_angle_add_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.tan (angle x (x + y)) = \u2016x\u2016 :=\n  by\n  rw [tan_angle_add_of_inner_eq_zero h]\n  rcases h0 with (h0 | h0)\n  \u00b7 simp [h0]\n  \u00b7 rw [div_div_eq_mul_div, mul_comm, div_eq_mul_inv, mul_inv_cancel_right\u2080 (norm_ne_zero_iff.2 h0)]\n#align inner_product_geometry.norm_div_tan_angle_add_of_inner_eq_zero InnerProductGeometry.norm_div_tan_angle_add_of_inner_eq_zero\n\n/-- An angle in a right-angled triangle expressed using `arccos`, version subtracting vectors. -/\ntheorem angle_sub_eq_arccos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x - y) = Real.arccos (\u2016x\u2016 / \u2016x - y\u2016) :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg, angle_add_eq_arccos_of_inner_eq_zero h]\n#align inner_product_geometry.angle_sub_eq_arccos_of_inner_eq_zero InnerProductGeometry.angle_sub_eq_arccos_of_inner_eq_zero\n\n/-- An angle in a right-angled triangle expressed using `arcsin`, version subtracting vectors. -/\ntheorem angle_sub_eq_arcsin_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    angle x (x - y) = Real.arcsin (\u2016y\u2016 / \u2016x - y\u2016) :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  nth_rw 2 [\u2190 neg_ne_zero] at h0\n  rw [sub_eq_add_neg, angle_add_eq_arcsin_of_inner_eq_zero h h0, norm_neg]\n#align inner_product_geometry.angle_sub_eq_arcsin_of_inner_eq_zero InnerProductGeometry.angle_sub_eq_arcsin_of_inner_eq_zero\n\n/-- An angle in a right-angled triangle expressed using `arctan`, version subtracting vectors. -/\ntheorem angle_sub_eq_arctan_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x - y) = Real.arctan (\u2016y\u2016 / \u2016x\u2016) :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg, angle_add_eq_arctan_of_inner_eq_zero h h0, norm_neg]\n#align inner_product_geometry.angle_sub_eq_arctan_of_inner_eq_zero InnerProductGeometry.angle_sub_eq_arctan_of_inner_eq_zero\n\n/-- An angle in a non-degenerate right-angled triangle is positive, version subtracting\nvectors. -/\ntheorem angle_sub_pos_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    0 < angle x (x - y) := by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [\u2190 neg_ne_zero] at h0\n  rw [sub_eq_add_neg]\n  exact angle_add_pos_of_inner_eq_zero h h0\n#align inner_product_geometry.angle_sub_pos_of_inner_eq_zero InnerProductGeometry.angle_sub_pos_of_inner_eq_zero\n\n/-- An angle in a right-angled triangle is at most `\u03c0 / 2`, version subtracting vectors. -/\ntheorem angle_sub_le_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    angle x (x - y) \u2264 \u03c0 / 2 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg]\n  exact angle_add_le_pi_div_two_of_inner_eq_zero h\n#align inner_product_geometry.angle_sub_le_pi_div_two_of_inner_eq_zero InnerProductGeometry.angle_sub_le_pi_div_two_of_inner_eq_zero\n\n/-- An angle in a non-degenerate right-angled triangle is less than `\u03c0 / 2`, version subtracting\nvectors. -/\ntheorem angle_sub_lt_pi_div_two_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0) :\n    angle x (x - y) < \u03c0 / 2 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg]\n  exact angle_add_lt_pi_div_two_of_inner_eq_zero h h0\n#align inner_product_geometry.angle_sub_lt_pi_div_two_of_inner_eq_zero InnerProductGeometry.angle_sub_lt_pi_div_two_of_inner_eq_zero\n\n/-- The cosine of an angle in a right-angled triangle as a ratio of sides, version subtracting\nvectors. -/\ntheorem cos_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x - y)) = \u2016x\u2016 / \u2016x - y\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg, cos_angle_add_of_inner_eq_zero h]\n#align inner_product_geometry.cos_angle_sub_of_inner_eq_zero InnerProductGeometry.cos_angle_sub_of_inner_eq_zero\n\n/-- The sine of an angle in a right-angled triangle as a ratio of sides, version subtracting\nvectors. -/\ntheorem sin_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y \u2260 0) :\n    Real.sin (angle x (x - y)) = \u2016y\u2016 / \u2016x - y\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  nth_rw 2 [\u2190 neg_ne_zero] at h0\n  rw [sub_eq_add_neg, sin_angle_add_of_inner_eq_zero h h0, norm_neg]\n#align inner_product_geometry.sin_angle_sub_of_inner_eq_zero InnerProductGeometry.sin_angle_sub_of_inner_eq_zero\n\n/-- The tangent of an angle in a right-angled triangle as a ratio of sides, version subtracting\nvectors. -/\ntheorem tan_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.tan (angle x (x - y)) = \u2016y\u2016 / \u2016x\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg, tan_angle_add_of_inner_eq_zero h, norm_neg]\n#align inner_product_geometry.tan_angle_sub_of_inner_eq_zero InnerProductGeometry.tan_angle_sub_of_inner_eq_zero\n\n/-- The cosine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nadjacent side, version subtracting vectors. -/\ntheorem cos_angle_sub_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.cos (angle x (x - y)) * \u2016x - y\u2016 = \u2016x\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg, cos_angle_add_mul_norm_of_inner_eq_zero h]\n#align inner_product_geometry.cos_angle_sub_mul_norm_of_inner_eq_zero InnerProductGeometry.cos_angle_sub_mul_norm_of_inner_eq_zero\n\n/-- The sine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nopposite side, version subtracting vectors. -/\ntheorem sin_angle_sub_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) :\n    Real.sin (angle x (x - y)) * \u2016x - y\u2016 = \u2016y\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [sub_eq_add_neg, sin_angle_add_mul_norm_of_inner_eq_zero h, norm_neg]\n#align inner_product_geometry.sin_angle_sub_mul_norm_of_inner_eq_zero InnerProductGeometry.sin_angle_sub_mul_norm_of_inner_eq_zero\n\n/-- The tangent of an angle in a right-angled triangle multiplied by the adjacent side equals\nthe opposite side, version subtracting vectors. -/\ntheorem tan_angle_sub_mul_norm_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    Real.tan (angle x (x - y)) * \u2016x\u2016 = \u2016y\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [\u2190 neg_eq_zero] at h0\n  rw [sub_eq_add_neg, tan_angle_add_mul_norm_of_inner_eq_zero h h0, norm_neg]\n#align inner_product_geometry.tan_angle_sub_mul_norm_of_inner_eq_zero InnerProductGeometry.tan_angle_sub_mul_norm_of_inner_eq_zero\n\n/-- A side of a right-angled triangle divided by the cosine of the adjacent angle equals the\nhypotenuse, version subtracting vectors. -/\ntheorem norm_div_cos_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x \u2260 0 \u2228 y = 0) :\n    \u2016x\u2016 / Real.cos (angle x (x - y)) = \u2016x - y\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [\u2190 neg_eq_zero] at h0\n  rw [sub_eq_add_neg, norm_div_cos_angle_add_of_inner_eq_zero h h0]\n#align inner_product_geometry.norm_div_cos_angle_sub_of_inner_eq_zero InnerProductGeometry.norm_div_cos_angle_sub_of_inner_eq_zero\n\n/-- A side of a right-angled triangle divided by the sine of the opposite angle equals the\nhypotenuse, version subtracting vectors. -/\ntheorem norm_div_sin_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.sin (angle x (x - y)) = \u2016x - y\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [\u2190 neg_ne_zero] at h0\n  rw [sub_eq_add_neg, \u2190 norm_neg, norm_div_sin_angle_add_of_inner_eq_zero h h0]\n#align inner_product_geometry.norm_div_sin_angle_sub_of_inner_eq_zero InnerProductGeometry.norm_div_sin_angle_sub_of_inner_eq_zero\n\n/-- A side of a right-angled triangle divided by the tangent of the opposite angle equals the\nadjacent side, version subtracting vectors. -/\ntheorem norm_div_tan_angle_sub_of_inner_eq_zero {x y : V} (h : \u27eax, y\u27eb = 0) (h0 : x = 0 \u2228 y \u2260 0) :\n    \u2016y\u2016 / Real.tan (angle x (x - y)) = \u2016x\u2016 :=\n  by\n  rw [\u2190 neg_eq_zero, \u2190 inner_neg_right] at h\n  rw [\u2190 neg_ne_zero] at h0\n  rw [sub_eq_add_neg, \u2190 norm_neg, norm_div_tan_angle_add_of_inner_eq_zero h h0]\n#align inner_product_geometry.norm_div_tan_angle_sub_of_inner_eq_zero InnerProductGeometry.norm_div_tan_angle_sub_of_inner_eq_zero\n\nend InnerProductGeometry\n\nnamespace EuclideanGeometry\n\nopen InnerProductGeometry\n\nvariable {V : Type _} {P : Type _} [NormedAddCommGroup V] [InnerProductSpace \u211d V] [MetricSpace P]\n  [NormedAddTorsor V P]\n\ninclude V\n\n/-- **Pythagorean theorem**, if-and-only-if angle-at-point form. -/\ntheorem dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two (p1 p2 p3 : P) :\n    dist p1 p3 * dist p1 p3 = dist p1 p2 * dist p1 p2 + dist p3 p2 * dist p3 p2 \u2194\n      \u2220 p1 p2 p3 = \u03c0 / 2 :=\n  by\n  erw [dist_comm p3 p2, dist_eq_norm_vsub V p1 p3, dist_eq_norm_vsub V p1 p2,\n    dist_eq_norm_vsub V p2 p3, \u2190 norm_sub_sq_eq_norm_sq_add_norm_sq_iff_angle_eq_pi_div_two,\n    vsub_sub_vsub_cancel_right p1, \u2190 neg_vsub_eq_vsub_rev p2 p3, norm_neg]\n#align euclidean_geometry.dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two EuclideanGeometry.dist_sq_eq_dist_sq_add_dist_sq_iff_angle_eq_pi_div_two\n\n/-- An angle in a right-angled triangle expressed using `arccos`. -/\ntheorem angle_eq_arccos_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    \u2220 p\u2082 p\u2083 p\u2081 = Real.arccos (dist p\u2083 p\u2082 / dist p\u2081 p\u2083) :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [angle, dist_eq_norm_vsub' V p\u2083 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, angle_add_eq_arccos_of_inner_eq_zero h]\n#align euclidean_geometry.angle_eq_arccos_of_angle_eq_pi_div_two EuclideanGeometry.angle_eq_arccos_of_angle_eq_pi_div_two\n\n/-- An angle in a right-angled triangle expressed using `arcsin`. -/\ntheorem angle_eq_arcsin_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 = Real.arcsin (dist p\u2081 p\u2082 / dist p\u2081 p\u2083) :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [\u2190 @vsub_ne_zero V, @ne_comm _ p\u2083, \u2190 @vsub_ne_zero V _ _ _ p\u2082, or_comm'] at h0\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, angle_add_eq_arcsin_of_inner_eq_zero h h0]\n#align euclidean_geometry.angle_eq_arcsin_of_angle_eq_pi_div_two EuclideanGeometry.angle_eq_arcsin_of_angle_eq_pi_div_two\n\n/-- An angle in a right-angled triangle expressed using `arctan`. -/\ntheorem angle_eq_arctan_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 = Real.arctan (dist p\u2081 p\u2082 / dist p\u2083 p\u2082) :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [ne_comm, \u2190 @vsub_ne_zero V] at h0\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub' V p\u2083 p\u2082, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, angle_add_eq_arctan_of_inner_eq_zero h h0]\n#align euclidean_geometry.angle_eq_arctan_of_angle_eq_pi_div_two EuclideanGeometry.angle_eq_arctan_of_angle_eq_pi_div_two\n\n/-- An angle in a non-degenerate right-angled triangle is positive. -/\ntheorem angle_pos_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 = p\u2082) : 0 < \u2220 p\u2082 p\u2083 p\u2081 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [\u2190 @vsub_ne_zero V, eq_comm, \u2190 @vsub_eq_zero_iff_eq V, or_comm'] at h0\n  rw [angle, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083, add_comm]\n  exact angle_add_pos_of_inner_eq_zero h h0\n#align euclidean_geometry.angle_pos_of_angle_eq_pi_div_two EuclideanGeometry.angle_pos_of_angle_eq_pi_div_two\n\n/-- An angle in a right-angled triangle is at most `\u03c0 / 2`. -/\ntheorem angle_le_pi_div_two_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    \u2220 p\u2082 p\u2083 p\u2081 \u2264 \u03c0 / 2 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [angle, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083, add_comm]\n  exact angle_add_le_pi_div_two_of_inner_eq_zero h\n#align euclidean_geometry.angle_le_pi_div_two_of_angle_eq_pi_div_two EuclideanGeometry.angle_le_pi_div_two_of_angle_eq_pi_div_two\n\n/-- An angle in a non-degenerate right-angled triangle is less than `\u03c0 / 2`. -/\ntheorem angle_lt_pi_div_two_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2083 \u2260 p\u2082) : \u2220 p\u2082 p\u2083 p\u2081 < \u03c0 / 2 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [ne_comm, \u2190 @vsub_ne_zero V] at h0\n  rw [angle, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083, add_comm]\n  exact angle_add_lt_pi_div_two_of_inner_eq_zero h h0\n#align euclidean_geometry.angle_lt_pi_div_two_of_angle_eq_pi_div_two EuclideanGeometry.angle_lt_pi_div_two_of_angle_eq_pi_div_two\n\n/-- The cosine of an angle in a right-angled triangle as a ratio of sides. -/\ntheorem cos_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.cos (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2083 p\u2082 / dist p\u2081 p\u2083 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [angle, dist_eq_norm_vsub' V p\u2083 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, cos_angle_add_of_inner_eq_zero h]\n#align euclidean_geometry.cos_angle_of_angle_eq_pi_div_two EuclideanGeometry.cos_angle_of_angle_eq_pi_div_two\n\n/-- The sine of an angle in a right-angled triangle as a ratio of sides. -/\ntheorem sin_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 \u2260 p\u2082) : Real.sin (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2082 / dist p\u2081 p\u2083 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [\u2190 @vsub_ne_zero V, @ne_comm _ p\u2083, \u2190 @vsub_ne_zero V _ _ _ p\u2082, or_comm'] at h0\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, sin_angle_add_of_inner_eq_zero h h0]\n#align euclidean_geometry.sin_angle_of_angle_eq_pi_div_two EuclideanGeometry.sin_angle_of_angle_eq_pi_div_two\n\n/-- The tangent of an angle in a right-angled triangle as a ratio of sides. -/\ntheorem tan_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.tan (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2082 / dist p\u2083 p\u2082 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub' V p\u2083 p\u2082, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, tan_angle_add_of_inner_eq_zero h]\n#align euclidean_geometry.tan_angle_of_angle_eq_pi_div_two EuclideanGeometry.tan_angle_of_angle_eq_pi_div_two\n\n/-- The cosine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nadjacent side. -/\ntheorem cos_angle_mul_dist_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.cos (\u2220 p\u2082 p\u2083 p\u2081) * dist p\u2081 p\u2083 = dist p\u2083 p\u2082 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [angle, dist_eq_norm_vsub' V p\u2083 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, cos_angle_add_mul_norm_of_inner_eq_zero h]\n#align euclidean_geometry.cos_angle_mul_dist_of_angle_eq_pi_div_two EuclideanGeometry.cos_angle_mul_dist_of_angle_eq_pi_div_two\n\n/-- The sine of an angle in a right-angled triangle multiplied by the hypotenuse equals the\nopposite side. -/\ntheorem sin_angle_mul_dist_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2) :\n    Real.sin (\u2220 p\u2082 p\u2083 p\u2081) * dist p\u2081 p\u2083 = dist p\u2081 p\u2082 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, sin_angle_add_mul_norm_of_inner_eq_zero h]\n#align euclidean_geometry.sin_angle_mul_dist_of_angle_eq_pi_div_two EuclideanGeometry.sin_angle_mul_dist_of_angle_eq_pi_div_two\n\n/-- The tangent of an angle in a right-angled triangle multiplied by the adjacent side equals\nthe opposite side. -/\ntheorem tan_angle_mul_dist_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 = p\u2082 \u2228 p\u2083 \u2260 p\u2082) : Real.tan (\u2220 p\u2082 p\u2083 p\u2081) * dist p\u2083 p\u2082 = dist p\u2081 p\u2082 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [ne_comm, \u2190 @vsub_ne_zero V, \u2190 @vsub_eq_zero_iff_eq V, or_comm'] at h0\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub' V p\u2083 p\u2082, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, tan_angle_add_mul_norm_of_inner_eq_zero h h0]\n#align euclidean_geometry.tan_angle_mul_dist_of_angle_eq_pi_div_two EuclideanGeometry.tan_angle_mul_dist_of_angle_eq_pi_div_two\n\n/-- A side of a right-angled triangle divided by the cosine of the adjacent angle equals the\nhypotenuse. -/\ntheorem dist_div_cos_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 = p\u2082 \u2228 p\u2083 \u2260 p\u2082) : dist p\u2083 p\u2082 / Real.cos (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2083 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [ne_comm, \u2190 @vsub_ne_zero V, \u2190 @vsub_eq_zero_iff_eq V, or_comm'] at h0\n  rw [angle, dist_eq_norm_vsub' V p\u2083 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, norm_div_cos_angle_add_of_inner_eq_zero h h0]\n#align euclidean_geometry.dist_div_cos_angle_of_angle_eq_pi_div_two EuclideanGeometry.dist_div_cos_angle_of_angle_eq_pi_div_two\n\n/-- A side of a right-angled triangle divided by the sine of the opposite angle equals the\nhypotenuse. -/\ntheorem dist_div_sin_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 = p\u2082) : dist p\u2081 p\u2082 / Real.sin (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2081 p\u2083 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [eq_comm, \u2190 @vsub_ne_zero V, \u2190 @vsub_eq_zero_iff_eq V, or_comm'] at h0\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub V p\u2081 p\u2083, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, norm_div_sin_angle_add_of_inner_eq_zero h h0]\n#align euclidean_geometry.dist_div_sin_angle_of_angle_eq_pi_div_two EuclideanGeometry.dist_div_sin_angle_of_angle_eq_pi_div_two\n\n/-- A side of a right-angled triangle divided by the tangent of the opposite angle equals the\nadjacent side. -/\ntheorem dist_div_tan_angle_of_angle_eq_pi_div_two {p\u2081 p\u2082 p\u2083 : P} (h : \u2220 p\u2081 p\u2082 p\u2083 = \u03c0 / 2)\n    (h0 : p\u2081 \u2260 p\u2082 \u2228 p\u2083 = p\u2082) : dist p\u2081 p\u2082 / Real.tan (\u2220 p\u2082 p\u2083 p\u2081) = dist p\u2083 p\u2082 :=\n  by\n  rw [angle, \u2190 inner_eq_zero_iff_angle_eq_pi_div_two, real_inner_comm, \u2190 neg_eq_zero, \u2190\n    inner_neg_left, neg_vsub_eq_vsub_rev] at h\n  rw [eq_comm, \u2190 @vsub_ne_zero V, \u2190 @vsub_eq_zero_iff_eq V, or_comm'] at h0\n  rw [angle, dist_eq_norm_vsub V p\u2081 p\u2082, dist_eq_norm_vsub' V p\u2083 p\u2082, \u2190 vsub_add_vsub_cancel p\u2081 p\u2082 p\u2083,\n    add_comm, norm_div_tan_angle_add_of_inner_eq_zero h h0]\n#align euclidean_geometry.dist_div_tan_angle_of_angle_eq_pi_div_two EuclideanGeometry.dist_div_tan_angle_of_angle_eq_pi_div_two\n\nend EuclideanGeometry\n\n"}
{"text": "(* @SUITE seq *)\n\ntheory seq\nimports \"../Hoare_Tactics\"\nbegin\n\nlemma \n  assumes \"hoare {P &m} x:=1; x:=2 {x=2}\"\n  assumes \"hoare {x=2} x:=3; x:=4; x:=5; x:=6 {x<10}\"\n  shows \"hoare {P &m} x:=1; x:=2; x:=3; x:=4; x:=5; x:=6 {x<10}\"\n  apply (seq 2)\n  apply (fact assms(1))\n  by (fact assms(2))\n\nlemma \n  assumes \"hoare {P &m} x:=1; x:=2 {x=2}\"\n  assumes \"hoare {x=2} x:=3; x:=4; x:=5; x:=6 {x<10}\"\n  shows \"hoare {P &m} x:=1; x:=2; x:=3; x:=4; x:=5; x:=6 {x<10}\"\n  apply (seq 2 invariant: \"$x=2\")\n  apply (fact assms(1))\n  by (fact assms(2))\n\nlemma \n  assumes \"hoare {P &m} x:=1; x:=2; x:=3; x:=4; x:=5; x:=6 {$x>5}\"\n  assumes \"hoare {$x>5} skip {$x<10}\"\n  shows \"hoare {P &m} x:=1; x:=2; x:=3; x:=4; x:=5; x:=6 {$x<10}\"\n  apply (seq 6)\n  apply (fact assms(1))\n  by (fact assms(2))\n\nlemma \n  assumes \"hoare {P &m} skip {True}\"\n  assumes \"hoare {True} x:=1; x:=2; x:=3; x:=4; x:=5; x:=6 {$x<10}\"\n  shows \"hoare {P &m} x:=1; x:=2; x:=3; x:=4; x:=5; x:=6 {$x<10}\"\n  apply (seq 0)\n  apply (fact assms(1))\n  by (fact assms(2))\n\n\nend\n\n"}
{"text": "--\n\naxiom p {\u03b1 \u03b2} : \u03b1 \u2192 \u03b2 \u2192 Prop\naxiom foo {\u03b1 \u03b2} (a : \u03b1) (b : \u03b2) : p a b\n\nexample : p 0 0 := by simp [foo]\nexample (a : Nat) : p a a := by simp [foo a]\nexample : p 0 0 := by simp [foo 0]\nexample : p 0 0 := by simp [foo 0 0]\nexample : p 0 0 := by\n  simp [foo 1] -- will not simplify\n  simp [foo 0]\nexample : p 0 0 \u2227 p 1 1 := by\n  simp [foo 1]\n  traceState\n  simp [foo 0]\n\nnamespace Foo\n\naxiom p {\u03b1} : \u03b1 \u2192 Prop\naxiom foo {\u03b1} [ToString \u03b1] (n : Nat) (a : \u03b1) : p a\n\nexample : p 0 := by simp [foo 0]\nexample : p 0 \u2227 True := by simp [foo 0]\n\nend Foo\n"}
{"text": "lemma multiplicity_characterization'_int [rule_format]: \"finite {p. p \\<ge> 0 \\<and> 0 < f (p::int)} \\<Longrightarrow> (\\<forall>p. 0 < f p \\<longrightarrow> prime p) \\<Longrightarrow> prime p \\<Longrightarrow> multiplicity p (\\<Prod>p | p \\<ge> 0 \\<and> 0 < f p. p ^ f p) = f p\""}
{"text": "import Smt\n\ntheorem modus_ponens {p q : Prop} : p \u2192 (p \u2192 q) \u2192 q := by\n  smt\n"}
{"text": "structure S where\n  x : Bool\n  y : Nat\n\ndef S.Z (s : S) : Type :=\n  if s.x then Nat else Int\n\ndef S.z : (s : S) \u2192 s.Z\n  | s@{ x := true, .. } => s.y\n  | s@{ x := false, .. } => Int.ofNat s.y\n\ndef S.a : (s : S) \u2192 s.Z\n  | s => s.z\n\ndef S.b : (s : S) \u2192 s.Z\n  | s@h:{ x := true, .. } => h \u25b8 s.z\n  | s => s.z\n\n#check @S.b.match_1\n\ntheorem zeropow : \u2200 {m : Nat}, m > 0 \u2192 0 ^ m = 0\n  | 0,   h => by cases h\n  | _+1, _ => rfl\n\ntheorem pow_nonneg : \u2200 m : Nat, 0 ^ m \u2265 0\n  | 0 => by decide\n  | m@(_+1) => by\n    rw [zeropow]\n    . decide\n    . apply Nat.zero_lt_succ\n"}
{"text": "informal statement Prove that the multiplicative groups $\\mathbb{R}-\\{0\\}$ and $\\mathbb{C}-\\{0\\}$ are not isomorphic.formal statement theorem exercise_1_6_4 : \n  is_empty (multiplicative \u211d \u2243* multiplicative \u2102) :="}
{"text": "[STATEMENT]\nlemma or_nonnegative_int_iff [simp]:\n  \\<open>k OR l \\<ge> 0 \\<longleftrightarrow> k \\<ge> 0 \\<and> l \\<ge> 0\\<close> for k l :: int\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. (0 \\<le> k OR l) = (0 \\<le> k \\<and> 0 \\<le> l)\n[PROOF STEP]\nby (simp only: or_eq_not_not_and not_nonnegative_int_iff) simp"}
{"text": "open import Agda.Builtin.Unit\nopen import Agda.Builtin.List\nopen import Agda.Builtin.Nat\nopen import Agda.Builtin.Equality\nopen import Agda.Builtin.Reflection\nopen import Agda.Builtin.Sigma\n\nmacro\n  @0 trivial : Term \u2192 TC \u22a4\n  trivial = unify (con (quote refl) [])\n\ntest : 42 \u2261 42\ntest = trivial\n\n@0 m : Name \u2192 TC \u22a4\nm F = defineFun F\n  (clause\n     (( \"A\"\n      , arg (arg-info visible (modality relevant quantity-0))\n          (agda-sort (lit 0))) \u2237\n      [])\n     (arg (arg-info visible (modality relevant quantity-0)) (var 0) \u2237\n      [])\n     (var 0 []) \u2237\n   [])\n\nF : Set \u2192 Set\nunquoteDef F = m F\n"}
{"text": "lemma coeffs_0_eq_Nil [simp]: \"coeffs 0 = []\""}
{"text": "import Mathlib.Tactic.TypeCheck\n\n/-- A term where `inferType` returns `Prop`, but which does not type check. -/\nelab \"wrong\" : term =>\n  return Lean.mkApp2 (.const ``id [.zero]) (.sort .zero) (.app (.sort .zero) (.sort .zero))\n\nexample : True := by\n  type_check Nat -- Type\n  type_check Bool.true -- Bool\n  type_check nat_lit 1 -- Nat\n  type_check (1 : Nat) -- Nat\n  type_check (True : _) -- Prop\n  type_check \u2200 x y : Nat, x = y -- Prop\n  type_check fun x : Nat => 2 * x + 1 -- Nat -> Nat\n  fail_if_success type_check wrong\n  trivial\n"}
{"text": " Support that requires grown children to offer material and moral support for their aging parents , particularly at times of \" illness , loneliness , or distress \" . \n"}
{"text": "From st.prelude Require Import autosubst.\nFrom st.STLCmuVS Require Import lang typing tactics.\nFrom st.STLCmu Require Import types.\nFrom st.STLCmuVS.lib Require Import fixarrow omega.\nFrom st.backtranslations.un_syn Require Import universe.base.\n\nInductive direction :=\n  | Embed\n  | Project.\n\nDefinition FstSnd (ep : direction) : expr \u2192 expr :=\n  match ep with\n  | Embed => Fst\n  | Project => Snd\n  end.\n\nDefinition opp_direction (ep : direction) :=\n  match ep with\n  | Embed => Project\n  | Project => Embed\n  end.\n\nDefinition fixgenTRec (eb pb : val) : val :=\n  (LamV (* 1 \u2192 ((\u03c4 \u2192 U) \u00d7 (U \u2192 \u03c4)) *) (\n       LamV (* 1 *) (\n           ( LamV (inject TCRec (Fold (eb.{ren (+2)} (Unfold %0)))) , (* \u03c4 \u2192 U *)\n             LamV (Fold (pb.{ren (+2)} (Unfold (extract TCRec %0)))) (* U \u2192 \u03c4 *)\n           )\n         )\n     )\n  )%E\u2099\u2092.\n\nLemma fixgenTRec_subst (eb pb : val) (\u03c3 : var \u2192 expr) : (fixgenTRec eb pb).{\u03c3} = fixgenTRec eb.{up \u03c3} pb.{up \u03c3}.\nProof. rewrite /fixgenTRec. simpl. rewrite inject_Closed extract_Closed. repeat rewrite -val_subst_valid. by asimpl. Qed.\n\nLemma fixgenTRec_typed (eb pb : val) \u0393 \u03c4b\n      (peb : (TUnit \u27f6 ((TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b)))%T\u2099\u2092 :: \u0393 \u22a2\u2099\u2092 eb : \u03c4b.[TRec \u03c4b/] \u27f6 TUniverse)\n      (ppb : (TUnit \u27f6 ((TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b)))%T\u2099\u2092 :: \u0393 \u22a2\u2099\u2092 pb : TUniverse \u27f6 \u03c4b.[TRec \u03c4b/]) :\n  \u0393 \u22a2\u2099\u2092 fixgenTRec eb pb :\n    (TUnit \u27f6 ((TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b))) \u27f6 (TUnit \u27f6 ((TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b))).\nProof.\n  assert (TUniverse = TUniverse.[TRec TUniverse/]) as eq; first by asimpl.\n  constructor. constructor. constructor. constructor. apply App_typed with (\u03c41 := TRec TUniverse). apply inject_typed.\n  constructor. apply App_typed with (\u03c41 := \u03c4b.[TRec \u03c4b/]).\n  change (TRec \u03c4b :: TUnit :: (TUnit \u27f6 (TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b))%T\u2099\u2092 :: \u0393) with\n      ([TRec \u03c4b ; TUnit] ++ ((TUnit \u27f6 (TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b))%T\u2099\u2092 :: \u0393)).\n  rewrite -val_subst_valid. apply context_weakening. rewrite -eq. apply peb.\n  constructor. by constructor.\n  constructor. constructor. apply App_typed with (\u03c41 := TUniverse).\n  change (TUniverse :: TUnit :: (TUnit \u27f6 (TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b))%T\u2099\u2092 :: \u0393) with\n      ([TUniverse ; TUnit] ++ ((TUnit \u27f6 (TRec \u03c4b \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 TRec \u03c4b))%T\u2099\u2092 :: \u0393)).\n  rewrite -val_subst_valid. apply context_weakening. apply ppb.\n  rewrite eq. constructor. apply App_typed with (\u03c41 := TUniverse).\n  apply extract_typed. rewrite -eq. by constructor.\nQed.\n\nGlobal Opaque fixgenTRec.\n\nFixpoint ep_pair (dir : direction) (\u03c4 : type) : val :=\n  (match \u03c4 with\n   | TUnit => match dir with\n             | Embed => inject TCUnit\n             | Project => extract TCUnit\n             end\n   | TBool => match dir with\n             | Embed => inject TCBool\n             | downward => extract TCBool\n             end\n   | TInt => match dir with\n            | Embed => inject TCInt\n            | Project => extract TCInt\n            end\n   | TProd \u03c41 \u03c42 => match dir with\n                   | Embed => LamV (LetIn (Fst %0)\n                                        (LetIn (Snd %1)\n                                               (inject TCProd ((ep_pair Embed \u03c41).{ren (+3)} %1, (ep_pair Embed \u03c42).{ren (+3)} %0))))\n                   | Project => LamV (LetIn (extract TCProd %0)\n                                          (LetIn (Fst %0)\n                                                 (LetIn (Snd %1)\n                                                        ((ep_pair Project \u03c41).{ren (+4)} %1 , (ep_pair Project \u03c42).{ren (+4)} %0))))\n     end\n   | TSum \u03c41 \u03c42 => match dir with\n                  | Embed => LamV (Case %0\n                                      (inject TCSum (InjL ((ep_pair Embed \u03c41).{ren (+2)} %0)))\n                                      (inject TCSum (InjR ((ep_pair Embed \u03c42).{ren (+2)} %0))))\n                  | Project => LamV (Case (extract TCSum %0)\n                                        (InjL ((ep_pair Project \u03c41).{ren (+2)} %0))\n                                        (InjR ((ep_pair Project \u03c42).{ren (+2)} %0)))\n                  end\n   | TArrow \u03c41 \u03c42 => match dir with\n                    | Embed => LamV (inject TCArrow (Lam ((ep_pair Embed \u03c42).{ren (+2)} (%1 ((ep_pair Project \u03c41).{ren (+2)} %0)))))\n                    | Project => LamV (Lam ((ep_pair Project \u03c42).{ren (+2)} (extract TCArrow %1 ((ep_pair Embed \u03c41).{ren (+2)} %0))))\n                    end\n   | TRec \u03c4b => let \u03b2 := fixgenTRec (ep_pair Embed \u03c4b) (ep_pair Project \u03c4b) in\n               LamV (FstSnd dir (LamV (FixArrow \u03b2.{ren (+2)} %0(*_*)) ()) %0)\n   | TVar X => LamV (FstSnd dir (Var (S X) ()) %0)\n  end)%E\u2099\u2092.\n\nDefinition direction_type dir \u03c4 :=\n  match dir with\n  | Embed => TArrow \u03c4 TUniverse\n  | Project => TArrow TUniverse \u03c4\n  end.\n\nLemma ep_pair_typed_gen (\u03c4 : type) (\u03c4s : list type) (p\u03c4n : Closed_n (length \u03c4s) \u03c4) (dir : direction) :\n  map (fun \u03c4 => (TUnit \u27f6 (\u03c4 \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 \u03c4))%T\u2099\u2092) \u03c4s \u22a2\u2099\u2092 (ep_pair dir \u03c4) : (direction_type dir \u03c4.[subst_list \u03c4s]).\nProof.\n  generalize dependent dir.\n  generalize dependent \u03c4s.\n  induction \u03c4 as [ | | | \u03c41 IH\u03c41 \u03c42 IH\u03c42 | \u03c41 IH\u03c41 \u03c42 IH\u03c42 | \u03c41 IH\u03c41 \u03c42 IH\u03c42 | \u03c4b IH\u03c4b | X ];\n    intros \u03c4s Cn\u03c4 dir; try by (destruct dir; (apply inject_typed || apply extract_typed)).\n  - (* TProd *) destruct dir.\n    + repeat ((rewrite -val_subst_valid; apply context_weakening3) || apply IH\u03c41 with (dir := Embed) || apply IH\u03c42 with (dir := Embed) || closed_solver || apply inject_typed || econstructor).\n    + repeat ((rewrite -val_subst_valid; apply context_weakening4) || apply IH\u03c41 with (dir := Project) || apply IH\u03c42 with (dir := Project) || closed_solver || apply extract_typed || econstructor).\n  - (* TSum *) destruct dir.\n    + repeat ((rewrite -val_subst_valid; apply context_weakening2) || apply IH\u03c41 with (dir := Embed) || apply IH\u03c42 with (dir := Embed) || closed_solver || apply inject_typed || econstructor).\n    + repeat ((rewrite -val_subst_valid; apply context_weakening2) || apply IH\u03c41 with (dir := Project) || apply IH\u03c42 with (dir := Project) || closed_solver || apply (extract_typed TCSum) || econstructor).\n  - (* TArrow *) destruct dir.\n    + repeat ((rewrite -val_subst_valid; apply context_weakening2) || apply IH\u03c41 with (dir := Project) || apply IH\u03c42 with (dir := Embed) || closed_solver || apply inject_typed || econstructor).\n    + repeat ((rewrite -val_subst_valid; apply context_weakening2) || apply IH\u03c41 with (dir := Embed) || apply IH\u03c42 with (dir := Project) || closed_solver || apply (extract_typed TCArrow) || econstructor).\n  - (* TRec *) destruct dir.\n    + constructor. fold ep_pair.\n      apply App_typed with (\u03c41 := (TRec \u03c4b).[subst_list \u03c4s]). 2: by constructor.\n      apply Fst_typed with (\u03c42 := (TUniverse \u27f6 (TRec \u03c4b).[subst_list \u03c4s])%T\u2099\u2092).\n      apply App_typed with (\u03c41 := TUnit). 2: by constructor. apply Lam_typed.\n      apply App_typed with (\u03c41 := TUnit). 2: by constructor.\n      apply FixArrow_typed.\n      rewrite -val_subst_valid. apply context_weakening2.\n      apply fixgenTRec_typed.\n      * asimpl. change (TRec \u03c4b.[up (subst_list \u03c4s)] .: subst_list \u03c4s) with (subst_list (TRec \u03c4b.[up (subst_list \u03c4s)] :: \u03c4s)).\n        rewrite -map_cons. apply IH\u03c4b with (dir := Embed). closed_solver.\n      * asimpl. change (TRec \u03c4b.[up (subst_list \u03c4s)] .: subst_list \u03c4s) with (subst_list (TRec \u03c4b.[up (subst_list \u03c4s)] :: \u03c4s)).\n        rewrite -map_cons. apply IH\u03c4b with (dir := Project). closed_solver.\n    + constructor. fold ep_pair.\n      apply App_typed with (\u03c41 := TUniverse). 2: by constructor.\n      apply Snd_typed with (\u03c41 := ((TRec \u03c4b).[subst_list \u03c4s] \u27f6 TUniverse)%T\u2099\u2092).\n      apply App_typed with (\u03c41 := TUnit). 2: by constructor. apply Lam_typed.\n      apply App_typed with (\u03c41 := TUnit). 2: by constructor.\n      apply FixArrow_typed.\n      rewrite -val_subst_valid. apply context_weakening2.\n      apply fixgenTRec_typed.\n      * asimpl. change (TRec \u03c4b.[up (subst_list \u03c4s)] .: subst_list \u03c4s) with (subst_list (TRec \u03c4b.[up (subst_list \u03c4s)] :: \u03c4s)).\n        rewrite -map_cons. apply IH\u03c4b with (dir := Embed). closed_solver.\n      * asimpl. change (TRec \u03c4b.[up (subst_list \u03c4s)] .: subst_list \u03c4s) with (subst_list (TRec \u03c4b.[up (subst_list \u03c4s)] :: \u03c4s)).\n        rewrite -map_cons. apply IH\u03c4b with (dir := Project). closed_solver.\n  - (* TVar *)\n    destruct (TVar_subst_list_closed_n_length _ _ Cn\u03c4) as [\u03c4 [eq ->]].\n    destruct dir; repeat econstructor; simpl; by rewrite list_lookup_fmap eq /=.\nQed.\n\nLemma ep_pair_typed (\u03c4 : type) (p\u03c4 : Closed \u03c4) dir :\n  [] \u22a2\u2099\u2092 (ep_pair dir \u03c4) : (direction_type dir \u03c4).\nProof. cut (fmap (fun \u03c4 => (TUnit \u27f6 (\u03c4 \u27f6 TUniverse) \u00d7 (TUniverse \u27f6 \u03c4))%T\u2099\u2092) [] \u22a2\u2099\u2092 ep_pair dir \u03c4 : direction_type dir \u03c4.[subst_list []]). by asimpl. by apply ep_pair_typed_gen. Qed.\n\nLemma ep_pair_Closed (\u03c4 : type) (p\u03c4 : Closed \u03c4) dir :\n  Closed (of_val $ ep_pair dir \u03c4).\nProof.\n  intro \u03c3. replace (of_val $ ep_pair dir \u03c4) with (of_val $ ep_pair dir \u03c4).[ids] at 2 by by asimpl.\n  erewrite (typed_subst_invariant [] _ _ \u03c3 ids). auto. apply ep_pair_typed.\n  auto. simpl. lia.\nQed.\n"}
{"text": "/-\nCopyright (c) 2014 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Leonardo de Moura\n-/\nimport algebra.group_power.order\nimport algebra.big_operators.basic\n\n/-!\n# Definitions and properties of `gcd`, `lcm`, and `coprime`\n\n-/\n\nnamespace nat\n\n/-! ### `gcd` -/\n\ntheorem gcd_dvd (m n : \u2115) : (gcd m n \u2223 m) \u2227 (gcd m n \u2223 n) :=\ngcd.induction m n\n  (\u03bbn, by rw gcd_zero_left; exact \u27e8dvd_zero n, dvd_refl n\u27e9)\n  (\u03bbm n npos, by rw \u2190gcd_rec; exact \u03bb \u27e8IH\u2081, IH\u2082\u27e9, \u27e8IH\u2082, (dvd_mod_iff IH\u2082).1 IH\u2081\u27e9)\n\ntheorem gcd_dvd_left (m n : \u2115) : gcd m n \u2223 m := (gcd_dvd m n).left\n\ntheorem gcd_dvd_right (m n : \u2115) : gcd m n \u2223 n := (gcd_dvd m n).right\n\ntheorem gcd_le_left {m} (n) (h : 0 < m) : gcd m n \u2264 m := le_of_dvd h $ gcd_dvd_left m n\n\ntheorem gcd_le_right (m) {n} (h : 0 < n) : gcd m n \u2264 n := le_of_dvd h $ gcd_dvd_right m n\n\ntheorem dvd_gcd {m n k : \u2115} : k \u2223 m \u2192 k \u2223 n \u2192 k \u2223 gcd m n :=\ngcd.induction m n (\u03bbn _ kn, by rw gcd_zero_left; exact kn)\n  (\u03bbn m mpos IH H1 H2, by rw gcd_rec; exact IH ((dvd_mod_iff H1).2 H2) H1)\n\ntheorem dvd_gcd_iff {m n k : \u2115} : k \u2223 gcd m n \u2194 k \u2223 m \u2227 k \u2223 n :=\niff.intro (\u03bb h, \u27e8h.trans (gcd_dvd m n).left, h.trans (gcd_dvd m n).right\u27e9)\n          (\u03bb h, dvd_gcd h.left h.right)\n\ntheorem gcd_comm (m n : \u2115) : gcd m n = gcd n m :=\ndvd_antisymm\n  (dvd_gcd (gcd_dvd_right m n) (gcd_dvd_left m n))\n  (dvd_gcd (gcd_dvd_right n m) (gcd_dvd_left n m))\n\ntheorem gcd_eq_left_iff_dvd {m n : \u2115} : m \u2223 n \u2194 gcd m n = m :=\n\u27e8\u03bb h, by rw [gcd_rec, mod_eq_zero_of_dvd h, gcd_zero_left],\n \u03bb h, h \u25b8 gcd_dvd_right m n\u27e9\n\ntheorem gcd_eq_right_iff_dvd {m n : \u2115} : m \u2223 n \u2194 gcd n m = m :=\nby rw gcd_comm; apply gcd_eq_left_iff_dvd\n\ntheorem gcd_assoc (m n k : \u2115) : gcd (gcd m n) k = gcd m (gcd n k) :=\ndvd_antisymm\n  (dvd_gcd\n    ((gcd_dvd_left (gcd m n) k).trans (gcd_dvd_left m n))\n    (dvd_gcd ((gcd_dvd_left (gcd m n) k).trans (gcd_dvd_right m n))\n      (gcd_dvd_right (gcd m n) k)))\n  (dvd_gcd\n    (dvd_gcd (gcd_dvd_left m (gcd n k)) ((gcd_dvd_right m (gcd n k)).trans (gcd_dvd_left n k)))\n    ((gcd_dvd_right m (gcd n k)).trans (gcd_dvd_right n k)))\n\n@[simp] theorem gcd_one_right (n : \u2115) : gcd n 1 = 1 :=\neq.trans (gcd_comm n 1) $ gcd_one_left n\n\ntheorem gcd_mul_left (m n k : \u2115) : gcd (m * n) (m * k) = m * gcd n k :=\ngcd.induction n k\n  (\u03bbk, by repeat {rw mul_zero <|> rw gcd_zero_left})\n  (\u03bbk n H IH, by rwa [\u2190mul_mod_mul_left, \u2190gcd_rec, \u2190gcd_rec] at IH)\n\ntheorem gcd_mul_right (m n k : \u2115) : gcd (m * n) (k * n) = gcd m k * n :=\nby rw [mul_comm m n, mul_comm k n, mul_comm (gcd m k) n, gcd_mul_left]\n\ntheorem gcd_pos_of_pos_left {m : \u2115} (n : \u2115) (mpos : 0 < m) : 0 < gcd m n :=\npos_of_dvd_of_pos (gcd_dvd_left m n) mpos\n\ntheorem gcd_pos_of_pos_right (m : \u2115) {n : \u2115} (npos : 0 < n) : 0 < gcd m n :=\npos_of_dvd_of_pos (gcd_dvd_right m n) npos\n\ntheorem eq_zero_of_gcd_eq_zero_left {m n : \u2115} (H : gcd m n = 0) : m = 0 :=\nor.elim (nat.eq_zero_or_pos m) id\n  (assume H1 : 0 < m, absurd (eq.symm H) (ne_of_lt (gcd_pos_of_pos_left _ H1)))\n\ntheorem eq_zero_of_gcd_eq_zero_right {m n : \u2115} (H : gcd m n = 0) : n = 0 :=\nby rw gcd_comm at H; exact eq_zero_of_gcd_eq_zero_left H\n\n@[simp] theorem gcd_eq_zero_iff {i j : \u2115} : gcd i j = 0 \u2194 i = 0 \u2227 j = 0 :=\nbegin\n  split,\n  { intro h,\n    exact \u27e8eq_zero_of_gcd_eq_zero_left h, eq_zero_of_gcd_eq_zero_right h\u27e9, },\n  { rintro \u27e8rfl, rfl\u27e9,\n    exact nat.gcd_zero_right 0 }\nend\n\ntheorem gcd_div {m n k : \u2115} (H1 : k \u2223 m) (H2 : k \u2223 n) :\n  gcd (m / k) (n / k) = gcd m n / k :=\nor.elim (nat.eq_zero_or_pos k)\n  (\u03bbk0, by rw [k0, nat.div_zero, nat.div_zero, nat.div_zero, gcd_zero_right])\n  (\u03bbH3, nat.eq_of_mul_eq_mul_right H3 $ by rw [\n    nat.div_mul_cancel (dvd_gcd H1 H2), \u2190gcd_mul_right,\n    nat.div_mul_cancel H1, nat.div_mul_cancel H2])\n\ntheorem gcd_greatest {a b d : \u2115} (hda : d \u2223 a) (hdb : d \u2223 b)\n  (hd : \u2200 e : \u2115, e \u2223 a \u2192 e \u2223 b \u2192 e \u2223 d) : d = a.gcd b :=\n(dvd_antisymm (hd _ (gcd_dvd_left a b) (gcd_dvd_right a b)) (dvd_gcd hda hdb)).symm\n\ntheorem gcd_dvd_gcd_of_dvd_left {m k : \u2115} (n : \u2115) (H : m \u2223 k) : gcd m n \u2223 gcd k n :=\ndvd_gcd ((gcd_dvd_left m n).trans H) (gcd_dvd_right m n)\n\ntheorem gcd_dvd_gcd_of_dvd_right {m k : \u2115} (n : \u2115) (H : m \u2223 k) : gcd n m \u2223 gcd n k :=\ndvd_gcd (gcd_dvd_left n m) ((gcd_dvd_right n m).trans H)\n\ntheorem gcd_dvd_gcd_mul_left (m n k : \u2115) : gcd m n \u2223 gcd (k * m) n :=\ngcd_dvd_gcd_of_dvd_left _ (dvd_mul_left _ _)\n\ntheorem gcd_dvd_gcd_mul_right (m n k : \u2115) : gcd m n \u2223 gcd (m * k) n :=\ngcd_dvd_gcd_of_dvd_left _ (dvd_mul_right _ _)\n\ntheorem gcd_dvd_gcd_mul_left_right (m n k : \u2115) : gcd m n \u2223 gcd m (k * n) :=\ngcd_dvd_gcd_of_dvd_right _ (dvd_mul_left _ _)\n\ntheorem gcd_dvd_gcd_mul_right_right (m n k : \u2115) : gcd m n \u2223 gcd m (n * k) :=\ngcd_dvd_gcd_of_dvd_right _ (dvd_mul_right _ _)\n\ntheorem gcd_eq_left {m n : \u2115} (H : m \u2223 n) : gcd m n = m :=\ndvd_antisymm (gcd_dvd_left _ _) (dvd_gcd dvd_rfl H)\n\ntheorem gcd_eq_right {m n : \u2115} (H : n \u2223 m) : gcd m n = n :=\nby rw [gcd_comm, gcd_eq_left H]\n\n-- Lemmas where one argument is a multiple of the other\n\n@[simp] lemma gcd_mul_left_left (m n : \u2115) : gcd (m * n) n = n :=\ndvd_antisymm (gcd_dvd_right _ _) (dvd_gcd (dvd_mul_left _ _) dvd_rfl)\n\n@[simp] lemma gcd_mul_left_right (m n : \u2115) : gcd n (m * n) = n :=\nby rw [gcd_comm, gcd_mul_left_left]\n\n@[simp] lemma gcd_mul_right_left (m n : \u2115) : gcd (n * m) n = n :=\nby rw [mul_comm, gcd_mul_left_left]\n\n@[simp] lemma gcd_mul_right_right (m n : \u2115) : gcd n (n * m) = n :=\nby rw [gcd_comm, gcd_mul_right_left]\n\n-- Lemmas for repeated application of `gcd`\n\n@[simp] lemma gcd_gcd_self_right_left (m n : \u2115) : gcd m (gcd m n) = gcd m n :=\ndvd_antisymm (gcd_dvd_right _ _) (dvd_gcd (gcd_dvd_left _ _) dvd_rfl)\n\n@[simp] lemma gcd_gcd_self_right_right (m n : \u2115) : gcd m (gcd n m) = gcd n m :=\nby rw [gcd_comm n m, gcd_gcd_self_right_left]\n\n@[simp] lemma gcd_gcd_self_left_right (m n : \u2115) : gcd (gcd n m) m = gcd n m :=\nby rw [gcd_comm, gcd_gcd_self_right_right]\n\n@[simp] lemma gcd_gcd_self_left_left (m n : \u2115) : gcd (gcd m n) m = gcd m n :=\nby rw [gcd_comm m n, gcd_gcd_self_left_right]\n\n-- Lemmas where one argument consists of addition of a multiple of the other\n\n@[simp] lemma gcd_add_mul_right_right (m n k : \u2115) : gcd m (n + k * m) = gcd m n :=\nby simp [gcd_rec m (n + k * m), gcd_rec m n]\n\n@[simp] lemma gcd_add_mul_left_right (m n k : \u2115) : gcd m (n + m * k) = gcd m n :=\nby simp [gcd_rec m (n + m * k), gcd_rec m n]\n\n@[simp] lemma gcd_mul_right_add_right (m n k : \u2115) : gcd m (k * m + n) = gcd m n :=\nby simp [add_comm _ n]\n\n@[simp] lemma gcd_mul_left_add_right (m n k : \u2115) : gcd m (m * k + n) = gcd m n :=\nby simp [add_comm _ n]\n\n@[simp] lemma gcd_add_mul_right_left (m n k : \u2115) : gcd (m + k * n) n = gcd m n :=\nby rw [gcd_comm, gcd_add_mul_right_right, gcd_comm]\n\n@[simp] lemma gcd_add_mul_left_left (m n k : \u2115) : gcd (m + n * k) n = gcd m n :=\nby rw [gcd_comm, gcd_add_mul_left_right, gcd_comm]\n\n@[simp] lemma gcd_mul_right_add_left (m n k : \u2115) : gcd (k * n + m) n = gcd m n :=\nby rw [gcd_comm, gcd_mul_right_add_right, gcd_comm]\n\n@[simp] lemma gcd_mul_left_add_left (m n k : \u2115) : gcd (n * k + m) n = gcd m n :=\nby rw [gcd_comm, gcd_mul_left_add_right, gcd_comm]\n\n-- Lemmas where one argument consists of an addition of the other\n\n@[simp] lemma gcd_add_self_right (m n : \u2115) : gcd m (n + m) = gcd m n :=\neq.trans (by rw one_mul) (gcd_add_mul_right_right m n 1)\n\n@[simp] lemma gcd_add_self_left (m n : \u2115) : gcd (m + n) n = gcd m n :=\nby rw [gcd_comm, gcd_add_self_right, gcd_comm]\n\n@[simp] lemma gcd_self_add_left (m n : \u2115) : gcd (m + n) m = gcd n m :=\nby rw [add_comm, gcd_add_self_left]\n\n@[simp] lemma gcd_self_add_right (m n : \u2115) : gcd m (m + n) = gcd m n :=\nby rw [add_comm, gcd_add_self_right]\n\n/-! ### `lcm` -/\n\ntheorem lcm_comm (m n : \u2115) : lcm m n = lcm n m :=\nby delta lcm; rw [mul_comm, gcd_comm]\n\n@[simp]\ntheorem lcm_zero_left (m : \u2115) : lcm 0 m = 0 :=\nby delta lcm; rw [zero_mul, nat.zero_div]\n\n@[simp]\ntheorem lcm_zero_right (m : \u2115) : lcm m 0 = 0 := lcm_comm 0 m \u25b8 lcm_zero_left m\n\n@[simp]\ntheorem lcm_one_left (m : \u2115) : lcm 1 m = m :=\nby delta lcm; rw [one_mul, gcd_one_left, nat.div_one]\n\n@[simp]\ntheorem lcm_one_right (m : \u2115) : lcm m 1 = m := lcm_comm 1 m \u25b8 lcm_one_left m\n\n@[simp]\ntheorem lcm_self (m : \u2115) : lcm m m = m :=\nor.elim (nat.eq_zero_or_pos m)\n  (\u03bbh, by rw [h, lcm_zero_left])\n  (\u03bbh, by delta lcm; rw [gcd_self, nat.mul_div_cancel _ h])\n\ntheorem dvd_lcm_left (m n : \u2115) : m \u2223 lcm m n :=\ndvd.intro (n / gcd m n) (nat.mul_div_assoc _ $ gcd_dvd_right m n).symm\n\ntheorem dvd_lcm_right (m n : \u2115) : n \u2223 lcm m n :=\nlcm_comm n m \u25b8 dvd_lcm_left n m\n\ntheorem gcd_mul_lcm (m n : \u2115) : gcd m n * lcm m n = m * n :=\nby delta lcm; rw [nat.mul_div_cancel' ((gcd_dvd_left m n).trans (dvd_mul_right m n))]\n\ntheorem lcm_dvd {m n k : \u2115} (H1 : m \u2223 k) (H2 : n \u2223 k) : lcm m n \u2223 k :=\nor.elim (nat.eq_zero_or_pos k)\n  (\u03bbh, by rw h; exact dvd_zero _)\n  (\u03bbkpos, dvd_of_mul_dvd_mul_left (gcd_pos_of_pos_left n (pos_of_dvd_of_pos H1 kpos)) $\n    by rw [gcd_mul_lcm, \u2190gcd_mul_right, mul_comm n k];\n       exact dvd_gcd (mul_dvd_mul_left _ H2) (mul_dvd_mul_right H1 _))\n\ntheorem lcm_dvd_mul (m n : \u2115) : lcm m n \u2223 m * n :=\nlcm_dvd (dvd_mul_right _ _) (dvd_mul_left _ _)\n\nlemma lcm_dvd_iff {m n k : \u2115} : lcm m n \u2223 k \u2194 m \u2223 k \u2227 n \u2223 k :=\n\u27e8\u03bb h, \u27e8(dvd_lcm_left _ _).trans h, (dvd_lcm_right _ _).trans h\u27e9,\n  and_imp.2 lcm_dvd\u27e9\n\ntheorem lcm_assoc (m n k : \u2115) : lcm (lcm m n) k = lcm m (lcm n k) :=\ndvd_antisymm\n  (lcm_dvd\n    (lcm_dvd (dvd_lcm_left m (lcm n k)) ((dvd_lcm_left n k).trans (dvd_lcm_right m (lcm n k))))\n    ((dvd_lcm_right n k).trans (dvd_lcm_right m (lcm n k))))\n  (lcm_dvd\n    ((dvd_lcm_left m n).trans (dvd_lcm_left (lcm m n) k))\n    (lcm_dvd ((dvd_lcm_right m n).trans (dvd_lcm_left (lcm m n) k))\n      (dvd_lcm_right (lcm m n) k)))\n\ntheorem lcm_ne_zero {m n : \u2115} (hm : m \u2260 0) (hn : n \u2260 0) : lcm m n \u2260 0 :=\nby { intro h, simpa [h, hm, hn] using gcd_mul_lcm m n, }\n\n/-!\n### `coprime`\n\nSee also `nat.coprime_of_dvd` and `nat.coprime_of_dvd'` to prove `nat.coprime m n`.\n-/\n\ninstance (m n : \u2115) : decidable (coprime m n) := by unfold coprime; apply_instance\n\ntheorem coprime_iff_gcd_eq_one {m n : \u2115} : coprime m n \u2194 gcd m n = 1 := iff.rfl\n\ntheorem coprime.gcd_eq_one {m n : \u2115} (h : coprime m n) : gcd m n = 1 := h\n\ntheorem coprime.lcm_eq_mul {m n : \u2115} (h : coprime m n) : lcm m n = m * n :=\nby rw [\u2190one_mul (lcm m n), \u2190h.gcd_eq_one, gcd_mul_lcm]\n\ntheorem coprime.symm {m n : \u2115} : coprime n m \u2192 coprime m n := (gcd_comm m n).trans\n\ntheorem coprime_comm {m n : \u2115} : coprime n m \u2194 coprime m n := \u27e8coprime.symm, coprime.symm\u27e9\n\ntheorem coprime.dvd_of_dvd_mul_right {m n k : \u2115} (H1 : coprime k n) (H2 : k \u2223 m * n) : k \u2223 m :=\nlet t := dvd_gcd (dvd_mul_left k m) H2 in\nby rwa [gcd_mul_left, H1.gcd_eq_one, mul_one] at t\n\ntheorem coprime.dvd_of_dvd_mul_left {m n k : \u2115} (H1 : coprime k m) (H2 : k \u2223 m * n) : k \u2223 n :=\nby rw mul_comm at H2; exact H1.dvd_of_dvd_mul_right H2\n\ntheorem coprime.dvd_mul_right {m n k : \u2115} (H : coprime k n) : k \u2223 m * n \u2194 k \u2223 m :=\n\u27e8H.dvd_of_dvd_mul_right, \u03bb h, dvd_mul_of_dvd_left h n\u27e9\n\ntheorem coprime.dvd_mul_left {m n k : \u2115} (H : coprime k m) : k \u2223 m * n \u2194 k \u2223 n :=\n\u27e8H.dvd_of_dvd_mul_left, \u03bb h, dvd_mul_of_dvd_right h m\u27e9\n\ntheorem coprime.gcd_mul_left_cancel {k : \u2115} (m : \u2115) {n : \u2115} (H : coprime k n) :\n   gcd (k * m) n = gcd m n :=\nhave H1 : coprime (gcd (k * m) n) k,\nby rw [coprime, gcd_assoc, H.symm.gcd_eq_one, gcd_one_right],\ndvd_antisymm\n  (dvd_gcd (H1.dvd_of_dvd_mul_left (gcd_dvd_left _ _)) (gcd_dvd_right _ _))\n  (gcd_dvd_gcd_mul_left _ _ _)\n\ntheorem coprime.gcd_mul_right_cancel (m : \u2115) {k n : \u2115} (H : coprime k n) :\n   gcd (m * k) n = gcd m n :=\nby rw [mul_comm m k, H.gcd_mul_left_cancel m]\n\ntheorem coprime.gcd_mul_left_cancel_right {k m : \u2115} (n : \u2115) (H : coprime k m) :\n   gcd m (k * n) = gcd m n :=\nby rw [gcd_comm m n, gcd_comm m (k * n), H.gcd_mul_left_cancel n]\n\ntheorem coprime.gcd_mul_right_cancel_right {k m : \u2115} (n : \u2115) (H : coprime k m) :\n   gcd m (n * k) = gcd m n :=\nby rw [mul_comm n k, H.gcd_mul_left_cancel_right n]\n\ntheorem coprime_div_gcd_div_gcd {m n : \u2115} (H : 0 < gcd m n) :\n  coprime (m / gcd m n) (n / gcd m n) :=\nby rw [coprime_iff_gcd_eq_one, gcd_div (gcd_dvd_left m n) (gcd_dvd_right m n), nat.div_self H]\n\ntheorem not_coprime_of_dvd_of_dvd {m n d : \u2115} (dgt1 : 1 < d) (Hm : d \u2223 m) (Hn : d \u2223 n) :\n  \u00ac coprime m n :=\n\u03bb co, not_lt_of_ge (le_of_dvd zero_lt_one $ by rw [\u2190co.gcd_eq_one]; exact dvd_gcd Hm Hn) dgt1\n\ntheorem exists_coprime {m n : \u2115} (H : 0 < gcd m n) :\n  \u2203 m' n', coprime m' n' \u2227 m = m' * gcd m n \u2227 n = n' * gcd m n :=\n\u27e8_, _, coprime_div_gcd_div_gcd H,\n  (nat.div_mul_cancel (gcd_dvd_left m n)).symm,\n  (nat.div_mul_cancel (gcd_dvd_right m n)).symm\u27e9\n\ntheorem exists_coprime' {m n : \u2115} (H : 0 < gcd m n) :\n  \u2203 g m' n', 0 < g \u2227 coprime m' n' \u2227 m = m' * g \u2227 n = n' * g :=\nlet \u27e8m', n', h\u27e9 := exists_coprime H in \u27e8_, m', n', H, h\u27e9\n\n@[simp] theorem coprime_add_self_right {m n : \u2115} : coprime m (n + m) \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_add_self_right]\n\n@[simp] theorem coprime_self_add_right {m n : \u2115} : coprime m (m + n) \u2194 coprime m n :=\nby rw [add_comm, coprime_add_self_right]\n\n@[simp] theorem coprime_add_self_left {m n : \u2115} : coprime (m + n) n \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_add_self_left]\n\n@[simp] theorem coprime_self_add_left {m n : \u2115} : coprime (m + n) m \u2194 coprime n m :=\nby rw [coprime, coprime, gcd_self_add_left]\n\n@[simp] lemma coprime_add_mul_right_right (m n k : \u2115) : coprime m (n + k * m) \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_add_mul_right_right]\n\n@[simp] lemma coprime_add_mul_left_right (m n k : \u2115) : coprime m (n + m * k) \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_add_mul_left_right]\n\n@[simp] lemma coprime_mul_right_add_right (m n k : \u2115) : coprime m (k * m + n) \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_mul_right_add_right]\n\n@[simp] lemma coprime_mul_left_add_right (m n k : \u2115) : coprime m (m * k + n) \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_mul_left_add_right]\n\n@[simp] lemma coprime_add_mul_right_left (m n k : \u2115) : coprime (m + k * n) n \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_add_mul_right_left]\n\n@[simp] lemma coprime_add_mul_left_left (m n k : \u2115) : coprime (m + n * k) n \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_add_mul_left_left]\n\n@[simp] lemma coprime_mul_right_add_left (m n k : \u2115) : coprime (k * n + m) n \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_mul_right_add_left]\n\n@[simp] lemma coprime_mul_left_add_left (m n k : \u2115) : coprime (n * k + m) n \u2194 coprime m n :=\nby rw [coprime, coprime, gcd_mul_left_add_left]\n\ntheorem coprime.mul {m n k : \u2115} (H1 : coprime m k) (H2 : coprime n k) : coprime (m * n) k :=\n(H1.gcd_mul_left_cancel n).trans H2\n\ntheorem coprime.mul_right {k m n : \u2115} (H1 : coprime k m) (H2 : coprime k n) : coprime k (m * n) :=\n(H1.symm.mul H2.symm).symm\n\ntheorem coprime.coprime_dvd_left {m k n : \u2115} (H1 : m \u2223 k) (H2 : coprime k n) : coprime m n :=\neq_one_of_dvd_one (by delta coprime at H2; rw \u2190 H2; exact gcd_dvd_gcd_of_dvd_left _ H1)\n\ntheorem coprime.coprime_dvd_right {m k n : \u2115} (H1 : n \u2223 m) (H2 : coprime k m) : coprime k n :=\n(H2.symm.coprime_dvd_left H1).symm\n\ntheorem coprime.coprime_mul_left {k m n : \u2115} (H : coprime (k * m) n) : coprime m n :=\nH.coprime_dvd_left (dvd_mul_left _ _)\n\ntheorem coprime.coprime_mul_right {k m n : \u2115} (H : coprime (m * k) n) : coprime m n :=\nH.coprime_dvd_left (dvd_mul_right _ _)\n\ntheorem coprime.coprime_mul_left_right {k m n : \u2115} (H : coprime m (k * n)) : coprime m n :=\nH.coprime_dvd_right (dvd_mul_left _ _)\n\ntheorem coprime.coprime_mul_right_right {k m n : \u2115} (H : coprime m (n * k)) : coprime m n :=\nH.coprime_dvd_right (dvd_mul_right _ _)\n\ntheorem coprime.coprime_div_left {m n a : \u2115} (cmn : coprime m n) (dvd : a \u2223 m) :\n  coprime (m / a) n :=\nbegin\n  by_cases a_split : (a = 0),\n  { subst a_split,\n    rw zero_dvd_iff at dvd,\n    simpa [dvd] using cmn, },\n  { rcases dvd with \u27e8k, rfl\u27e9,\n    rw nat.mul_div_cancel_left _ (nat.pos_of_ne_zero a_split),\n    exact coprime.coprime_mul_left cmn, },\nend\n\ntheorem coprime.coprime_div_right {m n a : \u2115} (cmn : coprime m n) (dvd : a \u2223 n) :\n  coprime m (n / a) :=\n(coprime.coprime_div_left cmn.symm dvd).symm\n\nlemma coprime_mul_iff_left {k m n : \u2115} : coprime (m * n) k \u2194 coprime m k \u2227 coprime n k :=\n\u27e8\u03bb h, \u27e8coprime.coprime_mul_right h, coprime.coprime_mul_left h\u27e9,\n  \u03bb \u27e8h, _\u27e9, by rwa [coprime_iff_gcd_eq_one, coprime.gcd_mul_left_cancel n h]\u27e9\n\nlemma coprime_mul_iff_right {k m n : \u2115} : coprime k (m * n) \u2194 coprime k m \u2227 coprime k n :=\nby simpa only [coprime_comm] using coprime_mul_iff_left\n\nlemma coprime.gcd_left (k : \u2115) {m n : \u2115} (hmn : coprime m n) : coprime (gcd k m) n :=\nhmn.coprime_dvd_left $ gcd_dvd_right k m\n\nlemma coprime.gcd_right (k : \u2115) {m n : \u2115} (hmn : coprime m n) : coprime m (gcd k n) :=\nhmn.coprime_dvd_right $ gcd_dvd_right k n\n\nlemma coprime.gcd_both (k l : \u2115) {m n : \u2115} (hmn : coprime m n) : coprime (gcd k m) (gcd l n) :=\n(hmn.gcd_left k).gcd_right l\n\nlemma coprime.mul_dvd_of_dvd_of_dvd {a n m : \u2115} (hmn : coprime m n)\n  (hm : m \u2223 a) (hn : n \u2223 a) : m * n \u2223 a :=\nlet \u27e8k, hk\u27e9 := hm in hk.symm \u25b8 mul_dvd_mul_left _ (hmn.symm.dvd_of_dvd_mul_left (hk \u25b8 hn))\n\ntheorem coprime_one_left : \u2200 n, coprime 1 n := gcd_one_left\n\ntheorem coprime_one_right : \u2200 n, coprime n 1 := gcd_one_right\n\ntheorem coprime.pow_left {m k : \u2115} (n : \u2115) (H1 : coprime m k) : coprime (m ^ n) k :=\nnat.rec_on n (coprime_one_left _) (\u03bbn IH, H1.mul IH)\n\ntheorem coprime.pow_right {m k : \u2115} (n : \u2115) (H1 : coprime k m) : coprime k (m ^ n) :=\n(H1.symm.pow_left n).symm\n\ntheorem coprime.pow {k l : \u2115} (m n : \u2115) (H1 : coprime k l) : coprime (k ^ m) (l ^ n) :=\n(H1.pow_left _).pow_right _\n\n@[simp] lemma coprime_pow_left_iff {n : \u2115} (hn : 0 < n) (a b : \u2115)  :\n  nat.coprime (a ^ n) b \u2194 nat.coprime a b :=\nbegin\n  obtain \u27e8n, rfl\u27e9 := exists_eq_succ_of_ne_zero hn.ne',\n  rw [pow_succ, nat.coprime_mul_iff_left],\n  exact \u27e8and.left, \u03bb hab, \u27e8hab, hab.pow_left _\u27e9\u27e9\nend\n\n@[simp] lemma coprime_pow_right_iff {n : \u2115} (hn : 0 < n) (a b : \u2115)  :\n  nat.coprime a (b ^ n) \u2194 nat.coprime a b :=\nby rw [nat.coprime_comm, coprime_pow_left_iff hn, nat.coprime_comm]\n\ntheorem coprime.eq_one_of_dvd {k m : \u2115} (H : coprime k m) (d : k \u2223 m) : k = 1 :=\nby rw [\u2190 H.gcd_eq_one, gcd_eq_left d]\n\n@[simp] theorem coprime_zero_left (n : \u2115) : coprime 0 n \u2194 n = 1 :=\nby simp [coprime]\n\n@[simp] theorem coprime_zero_right (n : \u2115) : coprime n 0 \u2194 n = 1 :=\nby simp [coprime]\n\ntheorem not_coprime_zero_zero : \u00ac coprime 0 0 := by simp\n\n@[simp] theorem coprime_one_left_iff (n : \u2115) : coprime 1 n \u2194 true :=\nby simp [coprime]\n\n@[simp] theorem coprime_one_right_iff (n : \u2115) : coprime n 1 \u2194 true :=\nby simp [coprime]\n\n@[simp] theorem coprime_self (n : \u2115) : coprime n n \u2194 n = 1 :=\nby simp [coprime]\n\nlemma gcd_mul_of_coprime_of_dvd {a b c : \u2115} (hac : coprime a c) (b_dvd_c : b \u2223 c) :\n  gcd (a * b) c = b :=\nbegin\n  rcases exists_eq_mul_left_of_dvd b_dvd_c with \u27e8d, rfl\u27e9,\n  rw [gcd_mul_right],\n  convert one_mul b,\n  exact coprime.coprime_mul_right_right hac,\nend\n\nsection big_operators\n\nopen_locale big_operators\n\n/-- See `is_coprime.prod_left` for the corresponding lemma about `is_coprime` -/\nlemma coprime_prod_left\n  {\u03b9 : Type*} {x : \u2115} {s : \u03b9 \u2192 \u2115} {t : finset \u03b9} :\n  (\u2200 (i : \u03b9), i \u2208 t \u2192 coprime (s i) x) \u2192 coprime (\u220f (i : \u03b9) in t, s i) x :=\nfinset.prod_induction s (\u03bb y, y.coprime x) (\u03bb a b, coprime.mul) (by simp)\n\n/-- See `is_coprime.prod_right` for the corresponding lemma about `is_coprime` -/\nlemma coprime_prod_right\n  {\u03b9 : Type*} {x : \u2115} {s : \u03b9 \u2192 \u2115} {t : finset \u03b9} :\n  (\u2200 (i : \u03b9), i \u2208 t \u2192 coprime x (s i)) \u2192 coprime x (\u220f (i : \u03b9) in t, s i) :=\nfinset.prod_induction s (\u03bb y, x.coprime y) (\u03bb a b, coprime.mul_right) (by simp)\n\nend big_operators\n\nlemma coprime.eq_of_mul_eq_zero {m n : \u2115} (h : m.coprime n) (hmn : m * n = 0) :\n  m = 0 \u2227 n = 1 \u2228 m = 1 \u2227 n = 0 :=\n(nat.eq_zero_of_mul_eq_zero hmn).imp\n  (\u03bb hm, \u27e8hm, n.coprime_zero_left.mp $ hm \u25b8 h\u27e9)\n  (\u03bb hn, \u27e8m.coprime_zero_left.mp $ hn \u25b8 h.symm, hn\u27e9)\n\n/-- Represent a divisor of `m * n` as a product of a divisor of `m` and a divisor of `n`. -/\ndef prod_dvd_and_dvd_of_dvd_prod {m n k : \u2115} (H : k \u2223 m * n) :\n  { d : {m' // m' \u2223 m} \u00d7 {n' // n' \u2223 n} // k = d.1 * d.2 } :=\nbegin\ncases h0 : (gcd k m),\ncase nat.zero\n{ have : k = 0 := eq_zero_of_gcd_eq_zero_left h0, subst this,\n  have : m = 0 := eq_zero_of_gcd_eq_zero_right h0, subst this,\n  exact \u27e8\u27e8\u27e80, dvd_refl 0\u27e9, \u27e8n, dvd_refl n\u27e9\u27e9, (zero_mul n).symm\u27e9 },\ncase nat.succ : tmp\n{ have hpos : 0 < gcd k m := h0.symm \u25b8 nat.zero_lt_succ _; clear h0 tmp,\n  have hd : gcd k m * (k / gcd k m) = k := (nat.mul_div_cancel' (gcd_dvd_left k m)),\n  refine \u27e8\u27e8\u27e8gcd k m,  gcd_dvd_right k m\u27e9, \u27e8k / gcd k m, _\u27e9\u27e9, hd.symm\u27e9,\n  apply dvd_of_mul_dvd_mul_left hpos,\n  rw [hd, \u2190 gcd_mul_right],\n  exact dvd_gcd (dvd_mul_right _ _) H }\nend\n\ntheorem gcd_mul_dvd_mul_gcd (k m n : \u2115) : gcd k (m * n) \u2223 gcd k m * gcd k n :=\nbegin\nrcases (prod_dvd_and_dvd_of_dvd_prod $ gcd_dvd_right k (m * n)) with \u27e8\u27e8\u27e8m', hm'\u27e9, \u27e8n', hn'\u27e9\u27e9, h\u27e9,\nreplace h : gcd k (m * n) = m' * n' := h,\nrw h,\nhave hm'n' : m' * n' \u2223 k := h \u25b8 gcd_dvd_left _ _,\napply mul_dvd_mul,\n  { have hm'k : m' \u2223 k := (dvd_mul_right m' n').trans hm'n',\n    exact dvd_gcd hm'k hm' },\n  { have hn'k : n' \u2223 k := (dvd_mul_left n' m').trans hm'n',\n    exact dvd_gcd hn'k hn' }\nend\n\ntheorem coprime.gcd_mul (k : \u2115) {m n : \u2115} (h : coprime m n) : gcd k (m * n) = gcd k m * gcd k n :=\ndvd_antisymm\n  (gcd_mul_dvd_mul_gcd k m n)\n  ((h.gcd_both k k).mul_dvd_of_dvd_of_dvd\n    (gcd_dvd_gcd_mul_right_right _ _ _)\n    (gcd_dvd_gcd_mul_left_right _ _ _))\n\ntheorem pow_dvd_pow_iff {a b n : \u2115} (n0 : 0 < n) : a ^ n \u2223 b ^ n \u2194 a \u2223 b :=\nbegin\n  refine \u27e8\u03bb h, _, \u03bb h, pow_dvd_pow_of_dvd h _\u27e9,\n  cases nat.eq_zero_or_pos (gcd a b) with g0 g0,\n  { simp [eq_zero_of_gcd_eq_zero_right g0] },\n  rcases exists_coprime' g0 with \u27e8g, a', b', g0', co, rfl, rfl\u27e9,\n  rw [mul_pow, mul_pow] at h,\n  replace h := dvd_of_mul_dvd_mul_right (pow_pos g0' _) h,\n  have := pow_dvd_pow a' n0,\n  rw [pow_one, (co.pow n n).eq_one_of_dvd h] at this,\n  simp [eq_one_of_dvd_one this]\nend\n\nlemma gcd_mul_gcd_of_coprime_of_mul_eq_mul {a b c d : \u2115} (cop : c.coprime d) (h : a * b = c * d) :\n  a.gcd c * b.gcd c = c :=\nbegin\n  apply dvd_antisymm,\n  { apply nat.coprime.dvd_of_dvd_mul_right (nat.coprime.mul (cop.gcd_left _) (cop.gcd_left _)),\n    rw \u2190 h,\n    apply mul_dvd_mul (gcd_dvd _ _).1 (gcd_dvd _ _).1 },\n  { rw [gcd_comm a _, gcd_comm b _],\n    transitivity c.gcd (a * b),\n    rw [h, gcd_mul_right_right d c],\n    apply gcd_mul_dvd_mul_gcd }\nend\n\n/-- If `k:\u2115` divides coprime `a` and `b` then `k = 1` -/\nlemma eq_one_of_dvd_coprimes {a b k : \u2115} (h_ab_coprime : coprime a b)\n  (hka : k \u2223 a) (hkb : k \u2223 b) : k = 1  :=\nbegin\n  rw coprime_iff_gcd_eq_one at h_ab_coprime,\n  have h1 := dvd_gcd hka hkb,\n  rw h_ab_coprime at h1,\n  exact nat.dvd_one.mp h1,\nend\n\nlemma coprime.mul_add_mul_ne_mul {m n a b : \u2115} (cop : coprime m n) (ha : a \u2260 0) (hb : b \u2260 0) :\n  a * m + b * n \u2260 m * n :=\nbegin\n  intro h,\n  obtain \u27e8x, rfl\u27e9 : n \u2223 a := cop.symm.dvd_of_dvd_mul_right\n    ((nat.dvd_add_iff_left (dvd_mul_left n b)).mpr ((congr_arg _ h).mpr (dvd_mul_left n m))),\n  obtain \u27e8y, rfl\u27e9 : m \u2223 b := cop.dvd_of_dvd_mul_right\n    ((nat.dvd_add_iff_right (dvd_mul_left m (n*x))).mpr ((congr_arg _ h).mpr (dvd_mul_right m n))),\n  rw [mul_comm, mul_ne_zero_iff, \u2190one_le_iff_ne_zero] at ha hb,\n  refine mul_ne_zero hb.2 ha.2 (eq_zero_of_mul_eq_self_left (ne_of_gt (add_le_add ha.1 hb.1)) _),\n  rw [\u2190 mul_assoc, \u2190 h, add_mul, add_mul, mul_comm _ n, \u2190mul_assoc, mul_comm y]\nend\n\nend nat\n"}
{"text": "Formal statement is: lemma coeffs_map_poly [code abstract]: \"coeffs (map_poly f p) = strip_while ((=) 0) (map f (coeffs p))\" Informal statement is: The coefficients of the polynomial obtained by applying a function to the coefficients of a polynomial are the coefficients of the original polynomial with zeros stripped off and the function applied to each coefficient."}
{"text": "open import Relation.Binary.Core\n\nmodule TreeSort.Impl2.Correctness.Permutation  {A : Set}\n                  (_\u2264_ : A \u2192 A \u2192 Set)\n                  (tot\u2264 : Total _\u2264_)  where\n\nopen import BBSTree _\u2264_ \nopen import Bound.Total A\nopen import Bound.Total.Order _\u2264_\nopen import Data.List\nopen import Data.Sum\nopen import List.Permutation.Base A\nopen import List.Permutation.Base.Concatenation A\nopen import TreeSort.Impl2 _\u2264_ tot\u2264\n\nlemma-insert-/ : {a b : Bound}{x : A}(a\u2264x : LeB a (val x))(x\u2264b : LeB (val x) b)(t : BBSTree a b) \u2192 (flatten (insert a\u2264x x\u2264b t)) / x \u27f6 (flatten t) \nlemma-insert-/ a\u2264x x\u2264b (bslf _) = /head\nlemma-insert-/ {x = x} b\u2264x x\u2264t (bsnd {x = y} b\u2264y y\u2264t l r) \n    with tot\u2264 x y\n... | inj\u2081 x\u2264y = lemma++/r (lemma-insert-/ b\u2264x (lexy x\u2264y) l)\n... | inj\u2082 y\u2264x = lemma++/l {xs = flatten l} (/tail (lemma-insert-/ (lexy y\u2264x) x\u2264t r))\n\ntheorem-treeSort\u223c : (xs : List A) \u2192 xs \u223c (flatten (treeSort xs))\ntheorem-treeSort\u223c [] = \u223c[]\ntheorem-treeSort\u223c (x \u2237 xs) = \u223cx /head (lemma-insert-/ lebx lext (treeSort xs)) (theorem-treeSort\u223c xs)\n\n\n\n\n"}
{"text": "/-\nCopyright (c) 2023 Eric Wieser. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Eric Wieser\n\n! This file was ported from Lean 3 source module ring_theory.complex\n! leanprover-community/mathlib commit 9015c511549dc77a0f8d6eba021d8ac4bba20c82\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Data.Complex.Module\nimport Mathbin.RingTheory.Norm\nimport Mathbin.RingTheory.Trace\n\n/-! # Lemmas about `algebra.trace` and `algebra.norm` on `\u2102` -/\n\n\nopen Complex\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:207:4: warning: unsupported notation `\u00abexpr!![ \u00bb -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:387:14: unsupported user notation matrix.notation -/\ntheorem Algebra.leftMulMatrix_complex (z : \u2102) :\n    Algebra.leftMulMatrix Complex.basisOneI z =\n      \u00abexpr!![ \u00bb\n        \"./././Mathport/Syntax/Translate/Expr.lean:387:14: unsupported user notation matrix.notation\" :=\n  by\n  ext (i j)\n  rw [Algebra.leftMulMatrix_eq_repr_mul, Complex.coe_basisOneI_repr, Complex.coe_basisOneI, mul_re,\n    mul_im, Matrix.of_apply]\n  fin_cases j\n  \u00b7 simp_rw [Matrix.cons_val_zero, one_re, one_im, MulZeroClass.mul_zero, mul_one, sub_zero,\n      zero_add]\n    fin_cases i <;> rfl\n  \u00b7 simp_rw [Matrix.cons_val_one, Matrix.head_cons, I_re, I_im, MulZeroClass.mul_zero, mul_one,\n      zero_sub, add_zero]\n    fin_cases i <;> rfl\n#align algebra.left_mul_matrix_complex Algebra.leftMulMatrix_complex\n\ntheorem Algebra.trace_complex_apply (z : \u2102) : Algebra.trace \u211d \u2102 z = 2 * z.re :=\n  by\n  rw [Algebra.trace_eq_matrix_trace Complex.basisOneI, Algebra.leftMulMatrix_complex,\n    Matrix.trace_fin_two]\n  exact (two_mul _).symm\n#align algebra.trace_complex_apply Algebra.trace_complex_apply\n\ntheorem Algebra.norm_complex_apply (z : \u2102) : Algebra.norm \u211d z = z.normSq :=\n  by\n  rw [Algebra.norm_eq_matrix_det Complex.basisOneI, Algebra.leftMulMatrix_complex,\n    Matrix.det_fin_two, norm_sq_apply]\n  simp\n#align algebra.norm_complex_apply Algebra.norm_complex_apply\n\ntheorem Algebra.norm_complex_eq : Algebra.norm \u211d = normSq.toMonoidHom :=\n  MonoidHom.ext Algebra.norm_complex_apply\n#align algebra.norm_complex_eq Algebra.norm_complex_eq\n\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem amc12b_2002_p6\n  (a b : \u211d)\n  (h\u2080 : a \u2260 0 \u2227 b \u2260 0)\n  (h\u2081 : \u2200 x, x^2 + a * x + b = (x - a) * (x - b)) :\n  a = 1 \u2227 b = -2 :=\nbegin\n  have h\u2082 := h\u2081 a,\n  have h\u2083 := h\u2081 b,\n  have h\u2084 := h\u2081 0,\n  simp at *,\n  have h\u2085 : b * (1 - a) = 0, linarith,\n  simp at h\u2085,\n  cases h\u2085 with h\u2085 h\u2086,\n  exfalso,\n  exact absurd h\u2085 h\u2080.2,\n  have h\u2086 : a = 1, linarith,\n  split,\n  exact h\u2086,\n  rw h\u2086 at h\u2082,\n  linarith,\nend"}
{"text": "(* This file is generated by Why3's Coq driver *)\n(* Beware! Only edit allowed sections below    *)\nRequire Import ZArith.\nRequire Import Rbase.\nAxiom Max_is_ge : forall (x:Z) (y:Z), (x <= (Zmax x y))%Z /\\\n  (y <= (Zmax x y))%Z.\n\nAxiom Max_is_some : forall (x:Z) (y:Z), ((Zmax x y) = x) \\/ ((Zmax x y) = y).\n\nAxiom Min_is_le : forall (x:Z) (y:Z), ((Zmin x y) <= x)%Z /\\\n  ((Zmin x y) <= y)%Z.\n\nAxiom Min_is_some : forall (x:Z) (y:Z), ((Zmin x y) = x) \\/ ((Zmin x y) = y).\n\nAxiom Max_x : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmax x y) = x).\n\nAxiom Max_y : forall (x:Z) (y:Z), (x <= y)%Z -> ((Zmax x y) = y).\n\nAxiom Min_x : forall (x:Z) (y:Z), (x <= y)%Z -> ((Zmin x y) = x).\n\nAxiom Min_y : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmin x y) = y).\n\nAxiom Max_sym : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmax x y) = (Zmax y x)).\n\nAxiom Min_sym : forall (x:Z) (y:Z), (y <= x)%Z -> ((Zmin x y) = (Zmin y x)).\n\nInductive list (a:Type) :=\n  | Nil : list a\n  | Cons : a -> (list a) -> list a.\nSet Contextual Implicit.\nImplicit Arguments Nil.\nUnset Contextual Implicit.\nImplicit Arguments Cons.\n\nSet Implicit Arguments.\nFixpoint length (a:Type)(l:(list a)) {struct l}: Z :=\n  match l with\n  | Nil  => 0%Z\n  | Cons _ r => (1%Z + (length r))%Z\n  end.\nUnset Implicit Arguments.\n\nAxiom Length_nonnegative : forall (a:Type), forall (l:(list a)),\n  (0%Z <= (length l))%Z.\n\nAxiom Length_nil : forall (a:Type), forall (l:(list a)),\n  ((length l) = 0%Z) <-> (l = (Nil:(list a))).\n\nParameter char : Type.\n\nDefinition word  := (list char).\n\nInductive dist : (list char) -> (list char) -> Z -> Prop :=\n  | dist_eps : (dist (Nil:(list char)) (Nil:(list char)) 0%Z)\n  | dist_add_left : forall (w1:(list char)) (w2:(list char)) (n:Z), (dist w1\n      w2 n) -> forall (a:char), (dist (Cons a w1) w2 (n + 1%Z)%Z)\n  | dist_add_right : forall (w1:(list char)) (w2:(list char)) (n:Z), (dist w1\n      w2 n) -> forall (a:char), (dist w1 (Cons a w2) (n + 1%Z)%Z)\n  | dist_context : forall (w1:(list char)) (w2:(list char)) (n:Z), (dist w1\n      w2 n) -> forall (a:char), (dist (Cons a w1) (Cons a w2) n).\n\nDefinition min_dist(w1:(list char)) (w2:(list char)) (n:Z): Prop := (dist w1\n  w2 n) /\\ forall (m:Z), (dist w1 w2 m) -> (n <= m)%Z.\n\nSet Implicit Arguments.\nFixpoint infix_plpl (a:Type)(l1:(list a)) (l2:(list a)) {struct l1}: (list\n  a) :=\n  match l1 with\n  | Nil  => l2\n  | Cons x1 r1 => (Cons x1 (infix_plpl r1 l2))\n  end.\nUnset Implicit Arguments.\n\nAxiom Append_assoc : forall (a:Type), forall (l1:(list a)) (l2:(list a))\n  (l3:(list a)), ((infix_plpl l1 (infix_plpl l2\n  l3)) = (infix_plpl (infix_plpl l1 l2) l3)).\n\nAxiom Append_l_nil : forall (a:Type), forall (l:(list a)), ((infix_plpl l\n  (Nil:(list a))) = l).\n\nAxiom Append_length : forall (a:Type), forall (l1:(list a)) (l2:(list a)),\n  ((length (infix_plpl l1 l2)) = ((length l1) + (length l2))%Z).\n\nSet Implicit Arguments.\nFixpoint mem (a:Type)(x:a) (l:(list a)) {struct l}: Prop :=\n  match l with\n  | Nil  => False\n  | Cons y r => (x = y) \\/ (mem x r)\n  end.\nUnset Implicit Arguments.\n\nAxiom mem_append : forall (a:Type), forall (x:a) (l1:(list a)) (l2:(list a)),\n  (mem x (infix_plpl l1 l2)) <-> ((mem x l1) \\/ (mem x l2)).\n\nAxiom mem_decomp : forall (a:Type), forall (x:a) (l:(list a)), (mem x l) ->\n  exists l1:(list a), exists l2:(list a), (l = (infix_plpl l1 (Cons x l2))).\n\nSet Implicit Arguments.\nFixpoint last_char(a:char) (u:(list char)) {struct u}: char :=\n  match u with\n  | Nil  => a\n  | Cons c uqt => (last_char c uqt)\n  end.\nUnset Implicit Arguments.\n\nSet Implicit Arguments.\nFixpoint but_last(a:char) (u:(list char)) {struct u}: (list char) :=\n  match u with\n  | Nil  => (Nil:(list char))\n  | Cons c uqt => (Cons a (but_last c uqt))\n  end.\nUnset Implicit Arguments.\n\n(* YOU MAY EDIT THE CONTEXT BELOW *)\n\n(* DO NOT EDIT BELOW *)\n\nTheorem first_last_explicit : forall (u:(list char)) (a:char),\n  ((infix_plpl (but_last a u) (Cons (last_char a u) (Nil:(list\n  char)))) = (Cons a u)).\n(* YOU MAY EDIT THE PROOF BELOW *)\nsimple induction u; simpl.\nreflexivity.\nintros.\nrewrite (H a).\nreflexivity.\nQed.\n(* DO NOT EDIT BELOW *)\n\n\n"}
{"text": "A set is locally $P$ if and only if it is $P$."}
{"text": "theorem ex1 (x : Nat) : 0 + x = x := by\n  cases x with\n  | zero   => skip -- Error: unsolved goals\n  | succ y => skip -- Error: unsolved goals\n\ntheorem ex2 (x : Nat) : 0 + x = x := by\n  induction x with\n  | zero      => skip -- Error: unsolved goals\n  | succ y ih => skip -- Error: unsolved goals\n\ntheorem ex3 (x : Nat) : 0 + x = x := by\n  cases x with\n  | zero   => rfl\n  | succ y => skip -- Error: unsolved goals\n\ntheorem ex4 (x : Nat) {y : Nat} (h : y > 0) : x % y < y := by\n  induction x, y using Nat.mod.inductionOn with\n  | ind x y h\u2081 ih => skip -- Error: unsolved goals\n  | base x y h\u2081   => skip -- Error: unsolved goals\n\ntheorem ex5 (x : Nat) {y : Nat} (h : y > 0) : x % y < y := by\n  cases x, y using Nat.mod.inductionOn with\n  | ind x y h\u2081 ih => skip -- Error: unsolved goals\n  | base x y h\u2081   => skip -- Error: unsolved goals\n"}
{"text": "import data.complex.basic\nvariable z : \u2102 \ntheorem Q7 (H : z^2=-1) : z=complex.I \u2228 z = -complex.I := sorry\n"}
{"text": "[STATEMENT]\nlemma fromEnumTrue [simp]: \"fromEnum True = 1\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. fromEnum True = 1\n[PROOF STEP]\nby (simp add: fromEnum_def enum_bool)"}
{"text": "informal statement Prove that for all $n>1$ that $\\mathbb{Z}/n\\mathbb{Z}$ is not a group under multiplication of residue classes.formal statement theorem exercise_1_1_16 {G : Type*} [group G] \n  (x : G) (hx : x ^ 2 = 1) :\n  order_of x = 1 \u2228 order_of x = 2 :="}
{"text": "prelude\nset_option linter.all false -- prevent error messages from runFrontend\n\ninductive Nat where\n  | zero : Nat\n  | succ (n : Nat) : Nat\n\ninductive Eq : \u03b1 \u2192 \u03b1 \u2192 Prop where\n  | refl (a : \u03b1) : Eq a a\n\ntheorem key : \u2200 (n m : Nat), (\u2200 (n m : Nat), Eq n m) \u2192 Eq n m :=\n  fun n m ih => (fun n m => ih n m) n m\n\n--theorem key (p : Nat \u2192 Nat \u2192 Prop) : \u2200 (n : Nat), (\u2200 (n m : Nat), p n m) \u2192 (m : Nat) \u2192 p n m :=\n--  fun n ih m => (fun n m => ih n m) n m\n"}
{"text": "inductive Expr where\n  | nat  : Nat \u2192 Expr\n  | plus : Expr \u2192 Expr \u2192 Expr\n  | bool : Bool \u2192 Expr\n  | and  : Expr \u2192 Expr \u2192 Expr\n  deriving DecidableEq\n\ninductive Ty where\n  | nat\n  | bool\n  deriving DecidableEq\n\ninductive HasType : Expr \u2192 Ty \u2192 Prop\n  | nat  : HasType (.nat v) .nat\n  | plus : HasType a .nat \u2192 HasType b .nat \u2192 HasType (.plus a b) .nat\n  | bool : HasType (.bool v) .bool\n  | and  : HasType a .bool \u2192 HasType b .bool \u2192 HasType (.and a b) .bool\n\ndef Expr.typeCheck (e : Expr) : Option {t : Ty // HasType e t} :=\n  match e with\n  | nat ..   => some \u27e8.nat, .nat\u27e9\n  | bool ..  => some \u27e8.bool, .bool\u27e9\n  | plus a b =>\n    match a.typeCheck, b.typeCheck with\n    | some \u27e8.nat, h\u2081\u27e9, some \u27e8.nat, h\u2082\u27e9 => some \u27e8.nat, .plus h\u2081 h\u2082\u27e9\n    | _, _ => none\n  | and a b =>\n    match a.typeCheck, b.typeCheck with\n    | some \u27e8.bool, h\u2081\u27e9, some \u27e8.bool, h\u2082\u27e9 => some \u27e8.bool, .and h\u2081 h\u2082\u27e9\n    | _, _ => none\n\ntheorem HasType.det (h\u2081 : HasType e t\u2081) (h\u2082 : HasType e t\u2082) : t\u2081 = t\u2082 := by\n  cases h\u2081 <;> cases h\u2082 <;> rfl\n\n-- TODO: for simplifying the following proof we need: ematching for forward reasoning, and `match` blast for case analysis\n\ntheorem Expr.typeCheck_complete {e : Expr} : e.typeCheck = none \u2192 \u00ac HasType e t := by\n  induction e with simp [typeCheck]\n  | plus a b iha ihb =>\n    revert iha ihb\n    cases typeCheck a <;> cases typeCheck b <;> simp <;> intros <;> intro h <;> cases h <;> try contradiction\n    rename_i r\u2081 r\u2082 h _ _\n    cases r\u2081; rename_i t\u2081 _; cases r\u2082; rename_i t\u2082 _; cases t\u2081 <;> cases t\u2082 <;> simp at h\n    . have := HasType.det \u2039HasType b Ty.bool\u203a \u2039HasType b Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType a Ty.bool\u203a \u2039HasType a Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType a Ty.bool\u203a \u2039HasType a Ty.nat\u203a; contradiction\n  | and a b iha ihb =>\n    revert iha ihb\n    cases typeCheck a <;> cases typeCheck b <;> simp <;> intros <;> intro h <;> cases h <;> try contradiction\n    rename_i r\u2081 r\u2082 h _ _\n    cases r\u2081; rename_i t\u2081 _; cases r\u2082; rename_i t\u2082 _; cases t\u2081 <;> cases t\u2082 <;> simp at h\n    . have := HasType.det \u2039HasType b Ty.bool\u203a \u2039HasType b Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType a Ty.bool\u203a \u2039HasType a Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType b Ty.bool\u203a \u2039HasType b Ty.nat\u203a; contradiction\n\ninstance (e : Expr) (t : Ty) : Decidable (HasType e t) :=\n  match h' : e.typeCheck with\n  | some \u27e8t', ht'\u27e9 =>\n    if heq : t = t' then\n      isTrue (heq \u25b8 ht')\n    else\n      isFalse fun ht => heq (HasType.det ht ht')\n  | none => isFalse (Expr.typeCheck_complete h')\n"}
{"text": "(** * Testcases for [test_auxiliary.v]\nAuthors: \n    - Lulof Pir\u00e9e (1363638)\nCreation date: 20 May 2021\n\nTestcases for the functions used to build testcases.\nIt is assumes that [assert_raises_error] is correct,\nand using this assumption it is tested that the other\nfunctions in [test_auxiliary.v] are correct.\n\n--------------------------------------------------------------------------------\n\nThis file is part of Waterproof-lib.\n\nWaterproof-lib is free software: you can redistribute it and/or modify\nit under the terms of the GNU General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nWaterproof-lib is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU General Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with Waterproof-lib.  If not, see <https://www.gnu.org/licenses/>.\n*)\nFrom Ltac2 Require Import Ltac2.\nFrom Ltac2 Require Option.\n\n\nRequire Import Waterproof.message.\n\nLoad test_auxiliary.\n\nGoal True.\n(*\n--------------------------------------------------------------------------------\n*) (** *    Testcases for [assert_list_equal]\n*)\nassert_list_equal (constr:(1)::constr:(2)::constr:(3)::[])\n                             (constr:(1)::constr:(2)::constr:(3)::[]).\n\nassert_list_equal [] [].                             \n\nassert_raises_error (fun () =>\nassert_list_equal (constr:(1)::constr:(3)::[]) (constr:(2)::constr:(3)::[]) ).\nAbort.\n(*\n--------------------------------------------------------------------------------\n*)(** * Testcase for [assert_hyp_exists]\n*)\nGoal forall n, n = 1.\n    intros n.\n    assert_hyp_exists @n.\n    assert_raises_error (fun () => assert_hyp_exists @x).\nAbort.\n\n(*\n--------------------------------------------------------------------------------\n*)(** * Testcase for [assert_hyp_has_type]\n*)\nGoal forall n: nat, n = 1 -> n = 1.\n    intros n h.\n    assert_hyp_has_type @n constr:(nat).\n    assert_hyp_has_type @h constr:(n = 1).\n\n    (* Wrong ident *)\n    assert_raises_error (fun () => assert_hyp_has_type @m constr:(nat)).\n    (* Wrong type *)\n    assert_raises_error (fun () => assert_hyp_has_type @n constr:(bool)).\nAbort.\n\nGoal True.\n(*\n--------------------------------------------------------------------------------\n*) (** *    Testcases for [assert_constr_is_true]\n*)\nassert_constr_is_true constr:(true).\nassert_raises_error \n    (fun () => assert_constr_is_true constr:(false)).\nassert_raises_error \n    (fun () => assert_constr_is_true constr:(1)).\n\n(*\n--------------------------------------------------------------------------------\n*) (** *    Testcases for [assert_is_true] and [assert_is_false].\n*)\nassert_is_true (true).\nassert_raises_error \n    (fun () => assert_is_true false).\n\nassert_is_false (false).\nassert_raises_error \n    (fun () => assert_is_false true).\nAbort.\n(*\n--------------------------------------------------------------------------------\n*) (** * Testcases for [assert_goal_is]\n*)\n\n(** * Test 1\n    Target does equal goal, no error should be raised.\n*)\nLemma test_assert_goal_1: forall x:nat, x >= 0.\nProof.\n    let t := constr:(forall x:nat, x >= 0) in\n    assert_goal_is t.\nAbort.\n\n(** * Test 2\n    Target does not equal goal, an error should be raised.\n*)\nLemma test_assert_goal_2: forall x:nat, x >= 0.\nProof.\n    let t := constr:(forall x:nat, x < 0) in\n    let result () := assert_goal_is t in\n    assert_raises_error result.\nAbort.\n\n(** * Testcases for [assert_type_equal]\n*)\n\nGoal True.\nassert_type_equal constr:(5) constr:(nat).\nAbort.\n\n(*\n--------------------------------------------------------------------------------\n*) (** * Testcases for [assert_constr_equal]\n*)\nGoal True.\nassert_constr_equal constr:(1 < 2) constr:(1 < 2).\nlet result () := assert_constr_equal constr:(1 < 2) \n                                                constr:(1 > 2) in\n    assert_raises_error result.\nAbort."}
{"text": "theory Unified_PW_Hashing\n  imports\n    Unified_PW\n    Refine_Imperative_HOL.IICF_List_Mset\n    Worklist_Algorithms_Misc\n    TA_Library.Tracing\nbegin\n\nsubsection \\<open>Towards an Implementation of the Unified Passed-Wait List\\<close>\n\ncontext Worklist1_Defs\nbegin\n\ndefinition \"add_pw_unified_spec passed wait a \\<equiv> SPEC (\\<lambda>(passed',wait',brk).\n  if \\<exists> x \\<in> set (succs a). F x then brk\n  else passed' \\<subseteq> passed \\<union> {x \\<in> set (succs a). \\<not> (\\<exists> y \\<in> passed. x \\<preceq> y)}\n      \\<and> passed \\<subseteq> passed'\n      \\<and> wait \\<subseteq># wait'\n      \\<and> wait' \\<subseteq># wait + mset ([x \\<leftarrow> succs a. \\<not> (\\<exists> y \\<in> passed. x \\<preceq> y)])\n      \\<and> (\\<forall> x \\<in> set (succs a). \\<exists> y \\<in> passed'. x \\<preceq> y)\n      \\<and> (\\<forall> x \\<in> set (succs a). \\<not> (\\<exists> y \\<in> passed. x \\<preceq> y) \\<longrightarrow> (\\<exists> y \\<in># wait'. x \\<preceq> y))\n      \\<and> \\<not> brk)\n\"\n\ndefinition \"add_pw passed wait a \\<equiv>\n    nfoldli (succs a) (\\<lambda>(_, _, brk). \\<not>brk)\n      (\\<lambda>a (passed, wait, brk). RETURN (\n        if F a then\n          (passed, wait, True)\n        else if \\<exists> x \\<in> passed. a \\<preceq> x then\n          (passed, wait, False)\n        else (insert a passed, add_mset a wait, False)\n      ))\n      (passed, wait, False)\n\"\n\nend \\<comment> \\<open>Worklist1 Defs\\<close>\n\ncontext Worklist1\nbegin\n\nlemma add_pw_unified_spec_ref:\n  \"add_pw_unified_spec passed wait a \\<le> add_pw_spec passed wait a\"\n  if \"reachable a\" \"a \\<in> passed\"\n  using succs_correct[OF that(1)] that(2)\n  unfolding add_pw_unified_spec_def add_pw_spec_def\n  apply simp\n  apply safe\n                      apply (all \\<open>auto simp: empty_subsumes; fail | succeed\\<close>)\n  using mset_subset_eqD apply force\n    using mset_subset_eqD apply force\n  subgoal premises prems\n    using prems\n    by (auto 4 5 simp: filter_mset_eq_empty_iff intro: trans elim!: subset_mset.ord_le_eq_trans)\n      (* s/h *)\n  by (clarsimp, smt UnE mem_Collect_eq subsetCE)\n\nlemma add_pw_ref:\n  \"add_pw passed wait a \\<le> \\<Down> Id (add_pw_unified_spec passed wait a)\"\n  unfolding add_pw_def add_pw_unified_spec_def\n  apply (refine_vcg\n      nfoldli_rule[where I =\n        \"\\<lambda> l1 l2 (passed', wait', brk).\n        if brk then \\<exists> a' \\<in> set (succs a). F a'\n        else passed' \\<subseteq> passed \\<union> {x \\<in> set l1. \\<not> (\\<exists> y \\<in> passed. x \\<preceq> y)}\n           \\<and> passed  \\<subseteq> passed'\n           \\<and> wait \\<subseteq># wait'\n           \\<and> wait' \\<subseteq># wait + mset [x \\<leftarrow> l1. \\<not> (\\<exists> y \\<in> passed. x \\<preceq> y)]\n           \\<and> (\\<forall> x \\<in> set l1. \\<exists> y \\<in> passed'. x \\<preceq> y)\n           \\<and> (\\<forall> x \\<in> set l1. \\<not> (\\<exists> y \\<in> passed. x \\<preceq> y) \\<longrightarrow> (\\<exists> y \\<in># wait'. x \\<preceq> y))\n           \\<and> set l1 \\<inter> Collect F = {}\n      \"\n        ])\n     apply (auto; fail)\n    apply (clarsimp split: if_split_asm)\n     apply safe[]\n           apply (auto simp add: subset_mset.le_iff_add; fail)+\n  subgoal premises prems\n    using prems(4,9,11,12,14) by (blast intro: trans)\n  by (auto simp: subset_mset.le_iff_add)\n\nend \\<comment> \\<open>Worklist 1\\<close>\n\ncontext Worklist2_Defs\nbegin\n\ndefinition \"add_pw' passed wait a \\<equiv>\n    nfoldli (succs a) (\\<lambda>(_, _, brk). \\<not>brk)\n      (\\<lambda>a (passed, wait, brk). RETURN (\n        if F a then\n          (passed, wait, True)\n        else if empty a then\n          (passed, wait, False)\n        else if \\<exists> x \\<in> passed. a \\<unlhd> x then\n          (passed, wait, False)\n        else (insert a passed, add_mset a wait, False)\n      ))\n      (passed, wait, False)\n\"\n\ndefinition pw_algo_unified where\n    \"pw_algo_unified = do\n      {\n        if F a\\<^sub>0 then RETURN (True, {})\n        else if empty a\\<^sub>0 then RETURN (False, {})\n        else do {\n          (passed, wait) \\<leftarrow> RETURN ({a\\<^sub>0}, {#a\\<^sub>0#});\n          (passed, wait, brk) \\<leftarrow> WHILEIT pw_inv (\\<lambda> (passed, wait, brk). \\<not> brk \\<and> wait \\<noteq> {#})\n            (\\<lambda> (passed, wait, brk). do\n              {\n                (a, wait) \\<leftarrow> take_from_mset wait;\n                ASSERT (reachable a);\n                if empty a then RETURN (passed, wait, brk) else add_pw' passed wait a\n              }\n            )\n            (passed, wait, False);\n            RETURN (brk, passed)\n        }\n      }\n    \"\n\nend \\<comment> \\<open>Worklist 2 Defs\\<close>\n\ncontext Worklist2\nbegin\n\nlemma empty_subsumes'2:\n  \"empty x \\<or> x \\<unlhd> y \\<longleftrightarrow> x \\<preceq> y\"\n  using empty_subsumes' empty_subsumes by auto\n\nlemma bex_or:\n  \"P \\<or> (\\<exists> x \\<in> S. Q x) \\<longleftrightarrow> (\\<exists> x \\<in> S. P \\<or> Q x)\" if \"S \\<noteq> {}\"\n  using that by auto\n\nlemma add_pw'_ref':\n  \"add_pw' passed wait a \\<le> \\<Down> (Id \\<inter> {((p, w, _), _). p \\<noteq> {} \\<and> set_mset w \\<subseteq> p}) (add_pw passed wait a)\"\n  if \"passed \\<noteq> {}\" \"set_mset wait \\<subseteq> passed\"\n  unfolding add_pw'_def add_pw_def\n  apply (rule nfoldli_refine)\n     apply refine_dref_type\n  using that apply (auto; fail)+\n  apply refine_rcg\n  apply rule\n  unfolding z3_rule(44)\n   apply (subst bex_or)\n  by (auto simp add: empty_subsumes'2)\n\n(* XXX Why is transitivity reasoning broken here? *)\nlemma add_pw'_ref1[refine]:\n  \"add_pw' passed wait a \\<le> \\<Down> (Id \\<inter> {((p, w, _), _). p \\<noteq> {} \\<and> set_mset w \\<subseteq> p}) (add_pw_spec passed' wait' a')\"\n  if \"passed \\<noteq> {}\" \"set_mset wait \\<subseteq> passed\" \"reachable a\" \"a \\<in> passed\"\n     and [simp]: \"passed = passed'\" \"wait = wait'\" \"a = a'\"\nproof -\n  from add_pw_unified_spec_ref[OF that(3-4), of wait] add_pw_ref[of passed wait a] have\n    \"add_pw passed wait a \\<le> \\<Down> Id (add_pw_spec passed wait a)\"\n    by simp\n  moreover note add_pw'_ref'[OF that(1,2), of a]\n  ultimately show ?thesis\n    by (auto simp add: pw_le_iff refine_pw_simps)\nqed\n\nlemma refine_weaken:\n  \"p \\<le> \\<Down> R p'\" if \"p \\<le> \\<Down> S p'\" \"S \\<subseteq> R\"\n  using that\n  by (auto simp: pw_le_iff refine_pw_simps; blast)\n\nlemma add_pw'_ref:\n  \"add_pw' passed wait a \\<le>\n    \\<Down> ({((p, w, b), (p', w', b')). p \\<noteq> {} \\<and> p = p' \\<union> set_mset w \\<and> w = w' \\<and> b = b'})\n      (add_pw_spec passed' wait' a')\"\n  if \"passed \\<noteq> {}\" \"set_mset wait \\<subseteq> passed\" \"reachable a\" \"a \\<in> passed\"\n     and [simp]: \"passed = passed'\" \"wait = wait'\" \"a = a'\"\n  by (rule add_pw'_ref1[OF that, THEN refine_weaken]; auto)\n\nlemma\n  \"(({a\\<^sub>0}, {#a\\<^sub>0#}, False), {}, {#a\\<^sub>0#}, False)\n  \\<in> {((p, w, b), (p', w', b')). p = p' \\<union> set_mset w' \\<and> w = w' \\<and> b = b'}\"\n  by auto\n\nlemma [refine]:\n  \"RETURN ({a\\<^sub>0}, {#a\\<^sub>0#}) \\<le> \\<Down> (Id \\<inter> {((p, w), (p', w')). p \\<noteq> {} \\<and> set_mset w \\<subseteq> p}) init_pw_spec\"\n  if \"\\<not> empty a\\<^sub>0\"\n  using that unfolding init_pw_spec_def by (auto simp: pw_le_iff refine_pw_simps)\n\nlemma [refine]:\n  \"take_from_mset wait \\<le>\n    \\<Down> {((x, wait), (y, wait')). x = y \\<and> wait = wait' \\<and> set_mset wait \\<subseteq> passed \\<and> x \\<in> passed}\n      (take_from_mset wait')\"\n  if \"wait = wait'\" \"set_mset wait \\<subseteq> passed\" \"wait \\<noteq> {#}\"\n  using that\n  by (auto 4 5 simp: pw_le_iff refine_pw_simps dest: in_diffD dest!: take_from_mset_correct)\n\nlemma pw_algo_unified_ref:\n  \"pw_algo_unified \\<le> \\<Down> Id pw_algo\"\n  unfolding pw_algo_unified_def pw_algo_def\n  by refine_rcg (auto simp: init_pw_spec_def)\n\nend \\<comment> \\<open>Worklist 2\\<close>\n\nsubsubsection \\<open>Utilities\\<close>\n\ndefinition take_from_list where\n  \"take_from_list s = ASSERT (s \\<noteq> []) \\<then> SPEC (\\<lambda> (x, s'). s = x # s')\"\n\nlemma take_from_list_correct:\n  assumes \"s \\<noteq> []\"\n  shows \"take_from_list s \\<le> SPEC (\\<lambda> (x, s'). s = x # s')\"\nusing assms unfolding take_from_list_def by simp\n\nlemmas [refine_vcg] = take_from_list_correct[THEN order.trans]\n\ncontext Worklist_Map_Defs\nbegin\n\ndefinition\n  \"map_set_rel =\n    {(m, s).\n      \\<Union>(ran m) = s \\<and> (\\<forall> k. \\<forall> x. m k = Some x \\<longrightarrow> (\\<forall> v \\<in> x. key v = k)) \\<and>\n      finite (dom m) \\<and> (\\<forall> k S. m k = Some S \\<longrightarrow> finite S)\n    }\"\n\ndefinition\n  \"add_pw'_map passed wait a \\<equiv>\n   nfoldli (succs a) (\\<lambda>(_, _, brk). \\<not>brk)\n    (\\<lambda>a (passed, wait, _).\n      do {\n      RETURN (\n        if F a then (passed, wait, True) else\n        let k = key a; passed' = (case passed k of Some passed' \\<Rightarrow> passed' | None \\<Rightarrow> {})\n        in\n          if empty a then\n            (passed, wait, False)\n          else if \\<exists> x \\<in> passed'. a \\<unlhd> x then\n            (passed, wait, False)\n          else\n            (passed(k \\<mapsto> (insert a passed')), a # wait, False)\n        )\n      }\n    )\n    (passed,wait,False)\"\n\ndefinition\n  \"pw_map_inv \\<equiv> \\<lambda> (passed, wait, brk).\n    \\<exists> passed' wait'.\n      (passed, passed') \\<in> map_set_rel \\<and> (wait, wait') \\<in> list_mset_rel \\<and>\n      pw_inv (passed', wait', brk)\n  \"\n\ndefinition pw_algo_map where\n  \"pw_algo_map = do\n    {\n      if F a\\<^sub>0 then RETURN (True, Map.empty)\n      else if empty a\\<^sub>0 then RETURN (False, Map.empty)\n      else do {\n        (passed, wait) \\<leftarrow> RETURN ([key a\\<^sub>0 \\<mapsto> {a\\<^sub>0}], [a\\<^sub>0]);\n        (passed, wait, brk) \\<leftarrow> WHILEIT pw_map_inv (\\<lambda> (passed, wait, brk). \\<not> brk \\<and> wait \\<noteq> [])\n          (\\<lambda> (passed, wait, brk). do\n            {\n              (a, wait) \\<leftarrow> take_from_list wait;\n              ASSERT (reachable a);\n              if empty a then RETURN (passed, wait, brk) else add_pw'_map passed wait a\n            }\n          )\n          (passed, wait, False);\n          RETURN (brk, passed)\n      }\n    }\n  \"\n\nend \\<comment> \\<open>Worklist Map Defs\\<close>\n\nlemma ran_upd_cases:\n  \"(x \\<in> ran m) \\<or> (x = y)\" if \"x \\<in> ran (m(a \\<mapsto> y))\"\n  using that unfolding ran_def by (auto split: if_split_asm)\n\nlemma ran_upd_cases2:\n  \"(\\<exists> k. m k = Some x \\<and> k \\<noteq> a) \\<or> (x = y)\" if \"x \\<in> ran (m(a \\<mapsto> y))\"\n  using that unfolding ran_def by (auto split: if_split_asm)\n\ncontext Worklist_Map\nbegin\n\nlemma add_pw'_map_ref[refine]:\n  \"add_pw'_map passed wait a \\<le> \\<Down> (map_set_rel \\<times>\\<^sub>r list_mset_rel \\<times>\\<^sub>r bool_rel) (add_pw' passed' wait' a')\"\n  if \"(passed, passed') \\<in> map_set_rel\" \"(wait, wait') \\<in> list_mset_rel\" \"(a, a') \\<in> Id\"\n  using that\n  unfolding add_pw'_map_def add_pw'_def\n  apply refine_rcg\n     apply refine_dref_type\n     apply (auto; fail)\n    apply (auto; fail)\n   apply (auto; fail)\n  subgoal premises assms for a a' _ _ passed' _ wait' f' passed _ wait f\n  proof -\n    from assms have [simp]: \"a' = a\" \"f = f'\" by simp+\n    from assms have rel_passed: \"(passed, passed') \\<in> map_set_rel\" by simp\n    then have union: \"passed' = \\<Union>(ran passed)\"\n      unfolding map_set_rel_def by auto\n    from assms have rel_wait: \"(wait, wait') \\<in> list_mset_rel\" by simp\n    from rel_passed have keys[simp]: \"key v = k\" if \"passed k = Some xs\" \"v \\<in> xs\" for k xs v\n      using that unfolding map_set_rel_def by auto\n    define k where \"k \\<equiv> key a\"\n    define xs where \"xs \\<equiv> case passed k of None \\<Rightarrow> {} | Some p \\<Rightarrow> p\"\n    have xs_ran: \"x \\<in> \\<Union>(ran passed)\" if \"x \\<in> xs\" for x\n      using that unfolding xs_def ran_def by (auto split: option.split_asm)\n    have *:\n      \"(\\<exists>x \\<in> xs. a \\<unlhd> x) \\<longleftrightarrow> (\\<exists>x\\<in>passed'. a' \\<unlhd> x)\"\n    proof (simp, safe, goal_cases)\n      case (1 x)\n      with rel_passed show ?case\n        unfolding xs_def union by (auto intro: ranI split: option.split_asm)\n    next\n      case (2 x)\n      with rel_passed show ?case unfolding xs_def union ran_def k_def map_set_rel_def\n        using empty_subsumes'2 by force\n    qed\n    have \"(passed(k \\<mapsto> insert a xs), insert a' passed') \\<in> map_set_rel\"\n      using \\<open>(passed, passed') \\<in> map_set_rel\\<close>\n      unfolding map_set_rel_def\n      apply safe\n      subgoal\n        unfolding union by (auto dest!: ran_upd_cases xs_ran)\n      subgoal\n        unfolding ran_def by auto\n      subgoal for a''\n        unfolding union ran_def\n        apply clarsimp\n        subgoal for k'\n          unfolding xs_def by (cases \"k' = k\") auto\n        done\n      by (clarsimp split: if_split_asm, safe,\n          auto intro!: keys simp: xs_def k_def split: option.split_asm if_split_asm)\n    with rel_wait rel_passed show ?thesis\n      unfolding *[symmetric]\n      unfolding xs_def k_def Let_def\n      unfolding list_mset_rel_def br_def\n      by auto\n  qed\ndone\n\nlemma init_map_ref[refine]:\n  \"(([key a\\<^sub>0 \\<mapsto> {a\\<^sub>0}], [a\\<^sub>0]), {a\\<^sub>0}, {#a\\<^sub>0#}) \\<in> map_set_rel \\<times>\\<^sub>r list_mset_rel\"\n  unfolding map_set_rel_def list_mset_rel_def br_def by auto\n\nlemma take_from_list_ref[refine]:\n  \"take_from_list xs \\<le> \\<Down> (Id \\<times>\\<^sub>r list_mset_rel) (take_from_mset ms)\" if \"(xs, ms) \\<in> list_mset_rel\"\n  using that unfolding take_from_list_def take_from_mset_def list_mset_rel_def br_def\n  by (clarsimp simp: pw_le_iff refine_pw_simps)\n\nlemma pw_algo_map_ref:\n  \"pw_algo_map \\<le> \\<Down> (Id \\<times>\\<^sub>r map_set_rel) pw_algo_unified\"\n  unfolding pw_algo_map_def pw_algo_unified_def\n  apply refine_rcg\n  unfolding pw_map_inv_def list_mset_rel_def br_def map_set_rel_def by auto\n\n\nend \\<comment> \\<open>Worklist Map\\<close>\n\ncontext Worklist_Map2_Defs\nbegin\n\ndefinition\n  \"add_pw'_map2 passed wait a \\<equiv>\n   nfoldli (succs a) (\\<lambda>(_, _, brk). \\<not>brk)\n    (\\<lambda>a (passed, wait, _).\n      do {\n      RETURN (\n        if empty a then\n            (passed, wait, False)\n        else if F' a then (passed, wait, True)\n        else\n          let k = key a; passed' = (case passed k of Some passed' \\<Rightarrow> passed' | None \\<Rightarrow> {})\n          in\n            if \\<exists> x \\<in> passed'. a \\<unlhd> x then\n              (passed, wait, False)\n            else\n              (passed(k \\<mapsto> (insert a passed')), a # wait, False)\n        )\n      }\n    )\n    (passed,wait,False)\"\n\ndefinition pw_algo_map2 where\n  \"pw_algo_map2 = do\n    {\n      if F a\\<^sub>0 then RETURN (True, Map.empty)\n      else if empty a\\<^sub>0 then RETURN (False, Map.empty)\n      else do {\n        (passed, wait) \\<leftarrow> RETURN ([key a\\<^sub>0 \\<mapsto> {a\\<^sub>0}], [a\\<^sub>0]);\n        (passed, wait, brk) \\<leftarrow> WHILEIT pw_map_inv (\\<lambda> (passed, wait, brk). \\<not> brk \\<and> wait \\<noteq> [])\n          (\\<lambda> (passed, wait, brk). do\n            {\n              (a, wait) \\<leftarrow> take_from_list wait;\n              ASSERT (reachable a);\n              if empty a\n              then RETURN (passed, wait, brk)\n              else do {\n                TRACE (ExploredState); add_pw'_map2 passed wait a\n              }\n            }\n          )\n          (passed, wait, False);\n          RETURN (brk, passed)\n      }\n    }\n  \"\n\nend \\<comment> \\<open>Worklist Map 2 Defs\\<close>\n\ncontext Worklist_Map2\nbegin\n\nlemma add_pw'_map2_ref[refine]:\n  \"add_pw'_map2 passed wait a \\<le> \\<Down> Id (add_pw'_map passed' wait' a')\"\n  if \"(passed, passed') \\<in> Id\" \"(wait, wait') \\<in> Id\" \"(a, a') \\<in> Id\"\n  using that\n  unfolding add_pw'_map2_def add_pw'_map_def\n  apply refine_rcg\n     apply refine_dref_type\n  by (auto simp: F_split)\n\nlemma pw_algo_map2_ref[refine]:\n  \"pw_algo_map2 \\<le> \\<Down> Id pw_algo_map\"\n  unfolding pw_algo_map2_def pw_algo_map_def TRACE_bind\n  apply refine_rcg\n           apply refine_dref_type\n  by auto\n\nend \\<comment> \\<open>Worklist Map 2\\<close>\n\nlemma (in Worklist_Map2_finite) pw_algo_map2_correct:\n  \"pw_algo_map2 \\<le> SPEC (\\<lambda> (brk, passed).\n    (brk \\<longleftrightarrow> F_reachable) \\<and>\n    (\\<not> brk \\<longrightarrow>\n      (\\<exists> p.\n        (passed, p) \\<in> map_set_rel \\<and> (\\<forall>a. reachable a \\<and> \\<not> empty a \\<longrightarrow> (\\<exists>b\\<in>p. a \\<preceq> b))\n        \\<and> p \\<subseteq> {a. reachable a \\<and> \\<not> empty a})\n    )\n   )\"\nproof -\n  note pw_algo_map2_ref\n  also note pw_algo_map_ref\n  also note pw_algo_unified_ref\n  also note pw_algo_correct\n  finally show ?thesis\n    unfolding conc_fun_def Image_def by (fastforce intro: order.trans) (* Slow *)\nqed\n\nend \\<comment> \\<open>End of Theory\\<close>\n"}
{"text": "lemma closure_UNIV [simp]: \"closure UNIV = UNIV\""}
{"text": "module myenv\n  integer,parameter :: max_name_length=15\n  contains\n  subroutine myhostname(nname)\n  USE IFPORT\n  character(len=MAX_HOSTNAM_LENGTH + 1) :: hostname\n  character(len=max_name_length) :: nname\n  ISTAT = HOSTNAM (hostname)\n  if(len_trim(hostname) .ge. max_name_length)then\n      write(*,*)\"hostname too long\"\n      nname=\"hostname2long\"\n  else\n      nname=trim(hostname)\n  endif\n  end subroutine\nend module\n\n  \n"}
{"text": "import algebra.group\n\nvariable {G: Type*}\n\n-- mathlib's constructor for `group` asks only for a (two-sided) identity\n-- alongside a left inverse. This exercise shows it is possible to produce\n-- both of those things if given a right identity and a right inverse.\ntheorem Q_12 (G: Type*) (mul: G \u2192 G \u2192 G) (e: G) (y: G \u2192 G):\n  (\u2200 a b c: G, (mul (mul a b) c) = (mul a (mul b c))) \u2227\n  (\u2200 a: G, mul a e = a) \u2227\n  (\u2200 a: G, mul a (y a) = e)\n  \u2192 group G :=\n\u03bb \u27e8h1, \u27e8h2, h3\u27e9\u27e9, begin\n\n  -- the right inverse is also a left inverse\n  have h4: \u2200 a: G, mul (y a) a = e, from \u03bb a, calc\n  mul (y a) a\n    = mul (mul (y a) a) e                              : (h2 _).symm\n... = mul (mul (y a) a) (mul (y a) (y (y a))) : by rw \u2190h3\n... = mul (y a) (mul a (mul (y a) (y (y a)))) : h1 _ _ _\n... = mul (y a) (mul (mul a (y a)) (y (y a))) : by rw h1\n... = mul (y a) (mul e (y (y a)))                : by rw h3\n... = mul (mul (y a) e) (y (y a))                : by rw \u2190h1\n... = mul (y a) (y (y a))                        : by rw h2\n... = e                                                   : h3 _,\n\n  -- the right identity is also the left identity\n  have h5: \u2200 a: G, mul e a = a, from \u03bb a, calc\n  mul e a\n    = mul (mul a (y a)) a : by rw h3\n... = mul a (mul (y a) a) : h1 _ _ _\n... = mul a e                : by rw h4\n... = a                      : h2 _,\n\n  -- we have now shown everything we need to\n  -- synthesise an instance of group G:\n  exact {\n    mul := mul,\n    mul_assoc := h1,\n    one := e,\n    one_mul := h5,\n    mul_one := h2,\n    inv := y,\n    mul_left_inv := h4\n  },\nend\n\n\n"}
{"text": " Sargassum muticum ( <unk> ) <unk> , now well established in a number of localities on the south , west , and north @-@ east coasts \n"}
{"text": "-- Welcome to Lean! As you can tell I'm working with Lean through VS Code. Unfortunately there aren't a ton of options available for Lean-compatible editors (the other option is emacs)\n\n\n\n\n\n-- I'll be using ``tactics'' to prove the results below, so I need to import the tactics module just as I would import a module in any other language. \nimport tactic\nimport data.nat.basic\n\n\n\n\n\n-- A little trick so Lean doesn't get confused between my definition of even and odd and the one already implemented in Lean.\nnamespace hidden\n\n\n\n\n\n\n-- The syntax of Lean is very human readable. It features UTF-8 encoding, and has all of our favorite characters like \u2190, \u2192, \u2194, \u27e8\u27e9, \u2115, \u2124, \u211d, \u2102   \n\ndef even (n : \u2115) := \u2203(k : \u2115), 2*k = n\ndef odd  (n : \u2115) := \u2203(k : \u2115), 2*k + 1 = n\n\n\n\n\n\ntheorem even_plus_even {n m : \u2115} (h\u2081 : even n) (h\u2082 : even m) : even (n + m) :=\n-- Begin and end are used to denote the beginning and end of a proof given in tactic mode. Sorry is a tactic that automatically proves any theorem! (unfortunately, it's cheating so Lean scolds us for using it)\nbegin\n  sorry\nend\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n-- Lets prove an even harder theorem. This time we should think a little bit about how we would go about showing this result on pen and paper before we jump into its formalization. \ntheorem even_or_odd {n : \u2115} : even n \u2228 odd n :=\nbegin\n  sorry\nend\n\nend hidden\n"}
{"text": "--\nset_option autoBoundImplicitLocal false\nuniverse u\nvariable {\u03b1 : Type u}\nvariable {\u03b2 : \u03b1 \u2192 Type v}\ninfix:50 \" \u2245 \" => HEq\ntheorem ex {p\u2081 p\u2082 : Sigma (fun a => \u03b2 a)} (h\u2081 : p\u2081.1 = p\u2082.1) (h : p\u2081.2 \u2245 p\u2082.2) : p\u2081 = p\u2082 :=\nmatch p\u2081, p\u2082, h\u2081, h with\n| \u27e8_, _\u27e9, \u27e8_, _\u27e9, rfl, HEq.refl _ => rfl\n"}
{"text": "lemma strip_while_coeffs [simp]: \"strip_while (HOL.eq 0) (coeffs p) = coeffs p\""}
{"text": "using Distributions, StatsBase, HypothesisTests, Plots, Random; pyplot()\nRandom.seed!(0)\n\nn = 25\nN = 10^4\nxGrid = -10:0.001:10\nkGrid = 0:0.01:5\ndist1, dist2 = Exponential(1), Normal()\n\nfunction ksStat(dist)\n    data = rand(dist,n)\n    Fhat = ecdf(data)\n    sqrt(n)*maximum(abs.(Fhat.(xGrid) - cdf.(dist,xGrid)))\nend\n\nkStats1 = [ksStat(dist1) for _ in 1:N]\nkStats2 = [ksStat(dist2) for _ in 1:N]\n\np1 = stephist(kStats1, bins=50, \n\tc=:blue, label=\"KS stat (Exponential)\", normed=true)\np1 = plot!(kGrid, pdf.(Kolmogorov(),kGrid), \n\tc=:red, label=\"Kolmogorov PDF\", xlabel=\"K\", ylabel=\"Density\")\n\np2 = stephist(kStats2, bins=50, \n\tc=:blue, label=\"KS stat (Normal)\", normed=true)\np2 = plot!(kGrid, pdf.(Kolmogorov(),kGrid), \n\tc=:red, label=\"Kolmogorov PDF\", xlabel=\"K\", ylabel=\"Density\")\n\nplot(p1, p2, xlims=(0,2.5), ylims=(0,1.8), size=(800, 400))"}
{"text": "lemma iff_trans (P Q R : Prop) : (P \u2194 Q) \u2192 (Q \u2194 R) \u2192 (P \u2194 R) :=\nbegin\nintros hpq hqr,\nsplit,\nintro p,\napply hqr.1,\napply hpq.1,\nexact p,\nintro r,\napply hpq.2,\napply hqr.2,\nexact r,\nend\n"}
{"text": "module Numeral.Natural.Oper.DivMod.Proofs where\n\nimport Lvl\nopen import Data\nopen import Data.Boolean.Stmt\nopen import Logic.Predicate\nopen import Numeral.Finite\nopen import Numeral.Natural\nopen import Numeral.Natural.Oper\nopen import Numeral.Natural.Oper.Comparisons\nopen import Numeral.Natural.Oper.FlooredDivision\nopen import Numeral.Natural.Oper.FlooredDivision.Proofs.DivisibilityWithRemainder\nopen import Numeral.Natural.Oper.Modulo\nopen import Numeral.Natural.Oper.Modulo.Proofs.DivisibilityWithRemainder\nopen import Numeral.Natural.Oper.Proofs\nopen import Numeral.Natural.Relation.DivisibilityWithRemainder\nopen import Numeral.Natural.Relation.DivisibilityWithRemainder.Proofs\nopen import Relator.Equals\nopen import Relator.Equals.Proofs\nopen import Structure.Operator\nopen import Structure.Operator.Proofs.Util\nopen import Structure.Operator.Properties\nopen import Syntax.Transitivity\n\n-- The division theorem.\n[\u230a/\u230b][mod]-is-division-with-remainder : \u2200{x y} \u2192 (((x \u230a/\u230b \ud835\udc12(y)) \u22c5 \ud835\udc12(y)) + (x mod \ud835\udc12(y)) \u2261 x)\n[\u230a/\u230b][mod]-is-division-with-remainder {x}{y} with [\u2203]-intro r \u2983 p \u2984 \u2190 [\u2223\u1d63\u2091\u2098]-existence-alt {x}{y} =\n  ((x \u230a/\u230b \ud835\udc12(y)) \u22c5 \ud835\udc12(y)) + (x mod \ud835\udc12(y))                         \ud83d\udf56[ _\u2261_ ]-[ congruence\u2082(_+_) (congruence\u2082\u2097(_\u22c5_)(\ud835\udc12(y)) ([\u230a/\u230b][\u2223\u1d63\u2091\u2098]-quotient-equality {x}{y}{r}{p})) ([mod][\u2223\u1d63\u2091\u2098]-remainder-equality {x}{y}{r}{p}) ]\n  (([\u2223\u1d63\u2091\u2098]-quotient p) \u22c5 \ud835\udc12(y)) + (\ud835\udd5f-to-\u2115 ([\u2223\u1d63\u2091\u2098]-remainder p)) \ud83d\udf56[ _\u2261_ ]-[ [\u2223\u1d63\u2091\u2098]-is-division-with-remainder {x}{\ud835\udc12(y)}{r} p ]\n  x                                                            \ud83d\udf56-end\n\n[\u230a/\u230b][mod]-is-division-with-remainder-pred-commuted : \u2200{x y} \u2983 _ : IsTrue(positive?(y)) \u2984 \u2192 ((y \u22c5 (x \u230a/\u230b y)) + (x mod y) \u2261 x)\n[\u230a/\u230b][mod]-is-division-with-remainder-pred-commuted {x} {\ud835\udc12 y} = [\u2261]-with(_+ (x mod \ud835\udc12(y))) (commutativity(_\u22c5_) {\ud835\udc12(y)}{x \u230a/\u230b \ud835\udc12(y)}) \ud83d\udf56 [\u230a/\u230b][mod]-is-division-with-remainder {x}{y}\n\n-- Floored division and multiplication is not inverse operators for all numbers.\n-- This shows why it is not exactly.\n[\u230a/\u230b][\u22c5]-semiInverseOperator\u1d63 : \u2200{a b} \u2192 ((a \u230a/\u230b \ud835\udc12(b)) \u22c5 \ud835\udc12(b) \u2261 a \u2212\u2080 (a mod \ud835\udc12(b)))\n[\u230a/\u230b][\u22c5]-semiInverseOperator\u1d63 {a}{b} =\n  (a \u230a/\u230b \ud835\udc12(b)) \u22c5 \ud835\udc12(b) \ud83d\udf56[ _\u2261_ ]-[ OneTypeTwoOp.move\u1d63-to-invOp {b = a mod \ud835\udc12(b)}{c = a} (([\u230a/\u230b][mod]-is-division-with-remainder {y = b})) ]\n  a \u2212\u2080 (a mod \ud835\udc12(b))   \ud83d\udf56-end\n\n-- Floored division and multiplication is not inverse operators for all numbers.\n-- This theorem shows that modulo is the error term (difference between the actual value for it to be inverse and value of the operation).\n[\u230a/\u230b][\u22c5]-inverseOperator\u1d63-error : \u2200{a b} \u2192 (a mod \ud835\udc12(b) \u2261 a \u2212\u2080 (a \u230a/\u230b \ud835\udc12(b) \u22c5 \ud835\udc12(b)))\n[\u230a/\u230b][\u22c5]-inverseOperator\u1d63-error {a}{b} =\n  (a mod \ud835\udc12(b))             \ud83d\udf56[ _\u2261_ ]-[ OneTypeTwoOp.move\u1d63-to-invOp {a = a mod \ud835\udc12(b)}{b = (a \u230a/\u230b \ud835\udc12(b)) \u22c5 \ud835\udc12(b)}{c = a} (commutativity(_+_) {a mod \ud835\udc12(b)}{(a \u230a/\u230b \ud835\udc12(b)) \u22c5 \ud835\udc12(b)} \ud83d\udf56 [\u230a/\u230b][mod]-is-division-with-remainder {y = b}) ]\n  a \u2212\u2080 (a \u230a/\u230b \ud835\udc12(b) \u22c5 \ud835\udc12(b)) \ud83d\udf56-end\n"}
{"text": "/-\nCopyright (c) 2022 Damiano Testa. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Damiano Testa\n-/\nimport algebra.geom_sum\nimport algebra.group.unique_prods\nimport algebra.monoid_algebra.basic\nimport data.finsupp.lex\nimport data.zmod.basic\n\n/-!\n# Examples of zero-divisors in `add_monoid_algebra`s\n\nThis file contains an easy source of zero-divisors in an `add_monoid_algebra`.\nIf `k` is a field and `G` is an additive group containing a non-zero torsion element, then\n`add_monoid_algebra k G` contains non-zero zero-divisors: this is lemma `zero_divisors_of_torsion`.\n\nThere is also a version for periodic elements of an additive monoid: `zero_divisors_of_periodic`.\n\nThe converse of this statement is\n[Kaplansky's zero divisor conjecture](https://en.wikipedia.org/wiki/Kaplansky%27s_conjectures).\n\nThe formalized example generalizes in trivial ways the assumptions: the field `k` can be any\nnontrivial ring `R` and the additive group `G` with a torsion element can be any additive monoid\n`A` with a non-zero periodic element.\n\nBesides this example, we also address a comment in `data.finsupp.lex` to the effect that the proof\nthat addition is monotone on `\u03b1 \u2192\u2080 N` uses that it is *strictly* monotone on `N`.\n\nThe specific statement is about `finsupp.lex.covariant_class_le_left` and its analogue\n`finsupp.lex.covariant_class_le_right`.  We do not need two separate counterexamples, since the\noperation is commutative.\n\nThe example is very simple.  Let `F = {0, 1}` with order determined by `0 < 1` and absorbing\naddition (which is the same as `max` in this case).  We denote a function `f : F \u2192 F` (which is\nautomatically finitely supported!) by `[f 0, f 1]`, listing its values.  Recall that the order on\nfinitely supported function is lexicographic, matching the list notation.  The inequality\n`[0, 1] \u2264 [1, 0]` holds.  However, adding `[1, 0]` to both sides yields the *reversed* inequality\n`[1, 1] > [1, 0]`.\n-/\nopen finsupp add_monoid_algebra\n\n/--  This is a simple example showing that if `R` is a non-trivial ring and `A` is an additive\nmonoid with an element `a` satisfying `n \u2022 a = a` and `(n - 1) \u2022 a \u2260 a`, for some `2 \u2264 n`,\nthen `add_monoid_algebra R A` contains non-zero zero-divisors.  The elements are easy to write down:\n`[a]` and `[a] ^ (n - 1) - 1` are non-zero elements of `add_monoid_algebra R A` whose product\nis zero.\n\nObserve that such an element `a` *cannot* be invertible.  In particular, this lemma never applies\nif `A` is a group. -/\nlemma zero_divisors_of_periodic {R A} [nontrivial R] [ring R] [add_monoid A] {n : \u2115} (a : A)\n  (n2 : 2 \u2264 n) (na : n \u2022 a = a) (na1 : (n - 1) \u2022 a \u2260 0) :\n  \u2203 f g : add_monoid_algebra R A, f \u2260 0 \u2227 g \u2260 0 \u2227 f * g = 0 :=\nbegin\n  refine \u27e8single a 1, single ((n - 1) \u2022 a) 1 - single 0 1, by simp, _, _\u27e9,\n  { exact sub_ne_zero.mpr (by simpa [single_eq_single_iff]) },\n  { rw [mul_sub, add_monoid_algebra.single_mul_single, add_monoid_algebra.single_mul_single,\n      sub_eq_zero, add_zero, \u2190 succ_nsmul, nat.sub_add_cancel (one_le_two.trans n2), na] },\nend\n\nlemma single_zero_one {R A} [semiring R] [has_zero A] :\n  single (0 : A) (1 : R) = (1 : add_monoid_algebra R A) := rfl\n\n/--  This is a simple example showing that if `R` is a non-trivial ring and `A` is an additive\nmonoid with a non-zero element `a` of finite order `oa`, then `add_monoid_algebra R A` contains\nnon-zero zero-divisors.  The elements are easy to write down:\n`\u2211 i in finset.range oa, [a] ^ i` and `[a] - 1` are non-zero elements of `add_monoid_algebra R A`\nwhose product is zero.\n\nIn particular, this applies whenever the additive monoid `A` is an additive group with a non-zero\ntorsion element. -/\nlemma zero_divisors_of_torsion {R A} [nontrivial R] [ring R] [add_monoid A] (a : A)\n  (o2 : 2 \u2264 add_order_of a) :\n  \u2203 f g : add_monoid_algebra R A, f \u2260 0 \u2227 g \u2260 0 \u2227 f * g = 0 :=\nbegin\n  refine \u27e8(finset.range (add_order_of a)).sum (\u03bb (i : \u2115), (single a 1) ^ i),\n    single a 1 - single 0 1, _, _, _\u27e9,\n  { apply_fun (\u03bb x : add_monoid_algebra R A, x 0),\n    refine ne_of_eq_of_ne (_ : (_ : R) = 1) one_ne_zero,\n    simp_rw finset.sum_apply',\n    refine (finset.sum_eq_single 0 _ _).trans _,\n    { intros b hb b0,\n      rw [single_pow, one_pow, single_eq_of_ne],\n      exact nsmul_ne_zero_of_lt_add_order_of' b0 (finset.mem_range.mp hb) },\n    { simp only [(zero_lt_two.trans_le o2).ne', finset.mem_range, not_lt, le_zero_iff,\n        false_implies_iff] },\n    { rw [single_pow, one_pow, zero_smul, single_eq_same] } },\n  { apply_fun (\u03bb x : add_monoid_algebra R A, x 0),\n    refine sub_ne_zero.mpr (ne_of_eq_of_ne (_ : (_ : R) = 0) _),\n    { have a0 : a \u2260 0 := ne_of_eq_of_ne (one_nsmul a).symm\n        (nsmul_ne_zero_of_lt_add_order_of' one_ne_zero (nat.succ_le_iff.mp o2)),\n      simp only [a0, single_eq_of_ne, ne.def, not_false_iff] },\n    { simpa only [single_eq_same] using zero_ne_one, } },\n  { convert commute.geom_sum\u2082_mul _ (add_order_of a),\n    { ext, rw [single_zero_one, one_pow, mul_one] },\n    { rw [single_pow, one_pow, add_order_of_nsmul_eq_zero, single_zero_one, one_pow, sub_self] },\n    { simp only [single_zero_one, commute.one_right] } },\nend\n\nexample {R} [ring R] [nontrivial R] (n : \u2115) (n0 : 2 \u2264 n) :\n  \u2203 f g : add_monoid_algebra R (zmod n), f \u2260 0 \u2227 g \u2260 0 \u2227 f * g = 0 :=\nzero_divisors_of_torsion (1 : zmod n) (n0.trans_eq (zmod.add_order_of_one _).symm)\n\n/--  `F` is the type with two elements `zero` and `one`.  We define the \"obvious\" linear order and\nabsorbing addition on it to generate our counterexample. -/\n@[derive [decidable_eq, inhabited]] inductive F | zero | one\n\n/--  The same as `list.get_rest`, except that we take the \"rest\" from the first match, rather than\nfrom the beginning, returning `[]` if there is no match.  For instance,\n```lean\n#eval [1,2].drop_until [3,1,2,4,1,2]  -- [4, 1, 2]\n```\n-/\ndef list.drop_until {\u03b1} [decidable_eq \u03b1] : list \u03b1 \u2192 list \u03b1 \u2192 list \u03b1\n| l [] := []\n| l (a::as) := ((a::as).get_rest l).get_or_else (l.drop_until as)\n\n/-- `guard_decl_in_file na loc` makes sure that the declaration with name `na` is in the file with\nrelative path `\"src/\" ++ \"/\".intercalate loc ++ \".lean\"`.\n```lean\n#eval guard_decl_in_file `nat.nontrivial [\"data\", \"nat\", \"basic\"]  -- does nothing\n\n#eval guard_decl_in_file `nat.nontrivial [\"not\", \"in\", \"here\"]\n-- fails giving the location 'data/nat/basic.lean'\n```\n\nThis test makes sure that the comment referring to this example is in the file claimed in the\ndoc-module to this counterexample. -/\nmeta def guard_decl_in_file (na : name) (loc : list string) : tactic unit :=\ndo env \u2190 tactic.get_env,\n  some fil \u2190 pure $ env.decl_olean na | fail!\"the instance `{na}` is not imported!\",\n  let path : string := \u27e8list.drop_until \"/src/\".to_list fil.to_list\u27e9,\n  let locdot : string := \".\".intercalate loc,\n  guard (fil.ends_with (\"src/\" ++ \"/\".intercalate loc ++ \".lean\")) <|>\n    fail!(\"instance `{na}` is no longer in `{locdot}`.\\n\\n\" ++\n      \"Please, update the doc-module and this check with the correct location:\\n\\n'{path}'\\n\")\n\n#eval guard_decl_in_file `finsupp.lex.covariant_class_le_left [\"data\", \"finsupp\", \"lex\"]\n#eval guard_decl_in_file `finsupp.lex.covariant_class_le_right [\"data\", \"finsupp\", \"lex\"]\n\nnamespace F\n\ninstance : has_zero F := \u27e8F.zero\u27e9\n\n/--  `1` is not really needed, but it is nice to use the notation. -/\ninstance : has_one F := \u27e8F.one\u27e9\n\n/--  A tactic to prove trivial goals by enumeration. -/\nmeta def boom : tactic unit :=\n`[ repeat { rintro \u27e8\u27e9 }; dec_trivial ]\n\n/--  `val` maps `0 1 : F` to their counterparts in `\u2115`.\nWe use it to lift the linear order on `\u2115`. -/\ndef val : F \u2192 \u2115\n| 0 := 0\n| 1 := 1\n\ninstance : linear_order F := linear_order.lift' val (by boom)\n\n@[simp] lemma z01  : (0 : F) < 1 := by boom\n\n/--  `F` would be a `comm_semiring`, using `min` as multiplication.  Again, we do not need this. -/\ninstance : add_comm_monoid F :=\n{ add       := max,\n  add_assoc := by boom,\n  zero      := 0,\n  zero_add  := by boom,\n  add_zero  := by boom,\n  add_comm  := by boom }\n\n/--  The `covariant_class`es asserting monotonicity of addition hold for `F`. -/\ninstance covariant_class_add_le : covariant_class F F (+) (\u2264) := \u27e8by boom\u27e9\nexample : covariant_class F F (function.swap (+)) (\u2264) := by apply_instance\n\n/--  The following examples show that `F` has all the typeclasses used by\n`finsupp.lex.covariant_class_le_left`... -/\nexample : linear_order F := by apply_instance\nexample : add_monoid F   := by apply_instance\n\n/-- ... except for the strict monotonicity of addition, the crux of the matter. -/\nexample : \u00ac covariant_class F F (+) (<) := \u03bb h, lt_irrefl 1 $ (h.elim : covariant F F (+) (<)) 1 z01\n\n/--  A few `simp`-lemmas to take care of trivialities in the proof of the example below. -/\n@[simp] lemma f1   : \u2200 (a : F), 1 + a = 1 := by boom\n@[simp] lemma f011 : of_lex (single (0 : F) (1 : F)) 1 = 0 := single_apply_eq_zero.mpr (\u03bb h, h)\n@[simp] lemma f010 : of_lex (single (0 : F) (1 : F)) 0 = 1 := single_eq_same\n@[simp] lemma f111 : of_lex (single (1 : F) (1 : F)) 1 = 1 := single_eq_same\n@[simp] lemma f110 : of_lex (single (1 : F) (1 : F)) 0 = 0 := single_apply_eq_zero.mpr (\u03bb h, h.symm)\n\n/--  Here we see that (not-necessarily strict) monotonicity of addition on `lex (F \u2192\u2080 F)` is not\na consequence of monotonicity of addition on `F`.  Strict monotonicity of addition on `F` is\nenough and is the content of `finsupp.lex.covariant_class_le_left`. -/\nexample : \u00ac covariant_class (lex (F \u2192\u2080 F)) (lex (F \u2192\u2080 F)) (+) (\u2264) :=\nbegin\n  rintro \u27e8h\u27e9,\n  refine not_lt.mpr (h (single (0 : F) (1 : F)) (_ : single 1 1 \u2264 single 0 1)) \u27e81, _\u27e9,\n  { exact or.inr \u27e80, by simp [(by boom : \u2200 j : F, j < 0 \u2194 false)]\u27e9 },\n  { simp only [(by boom : \u2200 j : F, j < 1 \u2194 j = 0), of_lex_add, coe_add, pi.to_lex_apply,\n      pi.add_apply, forall_eq, f010, f1, eq_self_iff_true, f011, f111, zero_add, and_self] },\nend\n\nexample {\u03b1} [ring \u03b1] [nontrivial \u03b1] :\n  \u2203 f g : add_monoid_algebra \u03b1 F, f \u2260 0 \u2227 g \u2260 0 \u2227 f * g = 0 :=\nzero_divisors_of_periodic (1 : F) le_rfl (by simp [two_smul]) (z01.ne')\n\nexample {\u03b1} [has_zero \u03b1] : 2 \u2022 (single 0 1 : \u03b1 \u2192\u2080 F) = single 0 1 \u2227 (single 0 1 : \u03b1 \u2192\u2080 F) \u2260 0 :=\n\u27e8smul_single _ _ _, by simpa only [ne.def, single_eq_zero] using z01.ne\u27e9\n\nend F\n\n/-- A Type that does not have `unique_prods`. -/\nexample : \u00ac unique_prods \u2115 :=\nbegin\n  rintros \u27e8h\u27e9,\n  refine not_not.mpr (h (finset.singleton_nonempty 0) (finset.insert_nonempty 0 {1})) _,\n  suffices : (\u2203 (x : \u2115), (x = 0 \u2228 x = 1) \u2227 \u00acx = 0) \u2227 \u2203 (x : \u2115), (x = 0 \u2228 x = 1) \u2227 \u00acx = 1,\n  { simpa [unique_mul] },\n  exact \u27e8\u27e81, by simp\u27e9, \u27e80, by simp\u27e9\u27e9,\nend\n\n/-- Some Types that do not have `unique_sums`. -/\nexample (n : \u2115) (n2 : 2 \u2264 n): \u00ac unique_sums (zmod n) :=\nbegin\n  haveI : fintype (zmod n) := @zmod.fintype n \u27e8(zero_lt_two.trans_le n2).ne'\u27e9,\n  haveI : nontrivial (zmod n) := char_p.nontrivial_of_char_ne_one (one_lt_two.trans_le n2).ne',\n  rintros \u27e8h\u27e9,\n  refine not_not.mpr (h finset.univ_nonempty finset.univ_nonempty) _,\n  suffices : \u2200 (x y : zmod n), \u2203 (x' y' : zmod n), x' + y' = x + y \u2227 (x' = x \u2192 \u00acy' = y),\n  { simpa [unique_add] },\n  exact \u03bb x y, \u27e8x - 1, y + 1, sub_add_add_cancel _ _ _, by simp\u27e9,\nend\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_numbertheory_412\n  (x y : \u2115)\n  (h\u2080 : x % 19 = 4)\n  (h\u2081 : y % 19 = 7) :\n  ((x + 1)^2 * (y + 5)^3) % 19 = 13 :=\nbegin\n  norm_num [h\u2080, h\u2081, nat.mul_mod, nat.add_mod, pow_succ],\nend"}
{"text": "{-# OPTIONS --without-K --safe --no-sized-types --no-guardedness\n            --no-subtyping #-}\n\nmodule Agda.Builtin.Word.Properties where\n\nopen import Agda.Builtin.Word\nopen import Agda.Builtin.Equality\n\nprimitive\n\n  primWord64ToNatInjective : \u2200 a b \u2192 primWord64ToNat a \u2261 primWord64ToNat b \u2192 a \u2261 b\n"}
{"text": "theory Tut09\n  imports \"HOL-IMP.Hoare_Sound_Complete\"\nbegin\n\nparagraph \"Step 1\"\n\ndefinition Max :: \"com\"  where\n  \"Max = IF Less (V ''a'') (V ''b'') THEN ''c'' ::= V ''b'' ELSE ''c'' ::= V ''a''\"\n\nparagraph \"Step 2\"\n\nlemma max_right[simp]: \"(a::int)<b \\<Longrightarrow> max a b = b\"\n  by simp\n\nlemma max_left[simp]: \"\\<not>(a::int)<b \\<Longrightarrow> max a b = a\"\n  by simp\n\nlemma \"\\<turnstile> {\\<lambda>s. True} Max {\\<lambda>s. s ''c'' = max (s ''a'') (s ''b'')}\"\n  unfolding Max_def by(rule If Assign' | simp)+\n\nparagraph \"Step 3\"\n\ndefinition MUL :: \"com\"  where\n  \"MUL =\n    ''z'' ::= N 0;;\n  ''i'' ::= N 0;;\n  WHILE Less (V ''i'') (V ''y'') DO\n  (\n    ''z'' ::= Plus (V ''z'') (V ''x'');;\n    ''i'' ::= Plus (V ''i'') (N 1)\n  )\"\n\nparagraph \"Step 4\"\n\nlemmas Seq_bwd = Seq[rotated]\n\nlemma \"\\<turnstile> {\\<lambda>s. 0 \\<le> s ''y''} MUL {\\<lambda>s. s ''z'' = s ''x'' * s ''y''}\"\n  unfolding MUL_def\n  by(rule Seq_bwd Assign Assign'\n      While'[where P=\"\\<lambda>s. s ''z'' = s ''i'' * s ''x'' \\<and> s ''i'' \\<le> s ''y''\"]\n      | auto simp: algebra_simps)+\n\nlemmas hoare_rule[intro?] = Seq_bwd Assign Assign' If\n\nparagraph \"Step 5\"\n\ndefinition \"MAX_wrong = (''a''::=N 0;;''b''::=N 0;;''c''::= N 0)\"\n\nlemma \"\\<turnstile> {\\<lambda>s. True} MAX_wrong {\\<lambda>s. s ''c'' = max (s ''a'') (s ''b'')}\"\n  unfolding MAX_wrong_def by(rule Seq_bwd Assign Assign' | simp)+\n\nlemma \"\\<turnstile> {\\<lambda>s. a=s ''a'' \\<and> b=s ''b''} \n  Max {\\<lambda>s. s ''c'' = max a b \\<and> a = s ''a'' \\<and> b = s ''b''}\"\n  unfolding Max_def by(rule If Assign' | simp)+\n\nlemma \"\\<turnstile> {\\<lambda>s. 0 \\<le> s ''y'' \\<and> x = s ''x'' \\<and> y = s ''y''} MUL {\\<lambda>s. s ''z'' = x * y \\<and> s ''x'' = x \\<and> s ''y'' = y}\"\n  unfolding MUL_def by(rule Seq_bwd Assign Assign'\n      While'[where P=\"\\<lambda>s. s ''z'' = s ''i'' * s ''x'' \\<and> s ''i'' \\<le> s ''y'' \\<and> x = s ''x'' \\<and> y = s ''y''\"]\n      | auto simp: algebra_simps)+\n\nlemma fwd_Assign: \"\\<turnstile> {P} x::=a {\\<lambda>s. \\<exists>s'. P s' \\<and> s'[a/x] = s}\"\n  apply(rule hoare_complete)\n  unfolding hoare_valid_def by auto\n\nlemmas fwd_Assign' = weaken_post[OF fwd_Assign]\n\nlemma \"\\<turnstile> {\\<lambda>s. True} Max {\\<lambda>s. s ''c'' = max (s ''a'') (s ''b'')}\"\n  sorry\n\nlemma \"\\<turnstile> {\\<lambda>s. 0 \\<le> s ''y''} MUL {\\<lambda>s. s ''z'' = s ''x'' * s ''y''}\"\n  sorry\n\nend"}
{"text": "\nnamespace nat\n\nvariables {x y z : \u2115}\n\nlemma le_add_of_le_right (h : x \u2264 y) :\n  x \u2264 y + z :=\nby transitivity;\n   [apply nat.le_add_right, apply nat.add_le_add_right h]\n\nlemma le_add_of_le_left (h : x \u2264 z) :\n  x \u2264 y + z :=\nby transitivity;\n   [apply nat.le_add_left, apply nat.add_le_add_left h]\n\nend nat\n"}
{"text": "import data.nat.prime\nimport data.nat.parity\nimport tactic\nopen nat\n\nlemma eq_two_of_prime_and_even\n  {n : \u2115}\n  (hn : even n)\n  (hn' : nat.prime n)\n  : n = 2 :=\nbegin\n  symmetry,\n  rw \u2190 prime_dvd_prime_iff_eq prime_two hn',\n  exact even_iff_two_dvd.mp hn\nend\n\n-- 2\u00aa demostraci\u00f3n\n-- ===============\n\nlemma eq_two_of_prime_and_even2\n  (n : \u2115)\n  (hn : even n)\n  (hn' : nat.prime n)\n  : n = 2 :=\nbegin\n  contrapose! hn,\n  rw [\u2190 odd_iff_not_even, odd_iff],\n  exact or.resolve_left (prime.eq_two_or_odd hn') hn,\nend\n"}
{"text": "TYPE point\n  INTEGER :: i, j\nEND TYPE\nTYPE(POINT) :: PV = POINT(1.0,2.0)\nEND PROGRAM\n"}
{"text": "lemma to_fract_0 [simp]: \"to_fract 0 = 0\""}
{"text": "inductive Expr where\n  | nat  : Nat \u2192 Expr\n  | plus : Expr \u2192 Expr \u2192 Expr\n  | bool : Bool \u2192 Expr\n  | and  : Expr \u2192 Expr \u2192 Expr\n\ninductive Ty where\n  | nat\n  | bool\n  deriving DecidableEq\n\ninductive HasType : Expr \u2192 Ty \u2192 Prop\n  | nat  : HasType (.nat v) .nat\n  | plus : HasType a .nat \u2192 HasType b .nat \u2192 HasType (.plus a b) .nat\n  | bool : HasType (.bool v) .bool\n  | and  : HasType a .bool \u2192 HasType b .bool \u2192 HasType (.and a b) .bool\n\ninductive Maybe (p : \u03b1 \u2192 Prop) where\n  | unknown\n  | found : (a : \u03b1) \u2192 p a \u2192 Maybe p\n\nnotation \"{{ \" x \" | \" p \" }}\" => Maybe (fun x => p)\n\ndef Expr.typeCheck (e : Expr) : {{ ty | HasType e ty }} :=\n  match e with\n  | nat ..   => .found .nat .nat\n  | bool ..  => .found .bool .bool\n  | plus a b =>\n    match a.typeCheck, b.typeCheck with\n    | .found .nat h\u2081, .found .nat h\u2082 => .found .nat (.plus h\u2081 h\u2082)\n    | _, _ => .unknown\n  | and a b =>\n    match a.typeCheck, b.typeCheck with\n    | .found .bool h\u2081, .found .bool h\u2082 => .found .bool (.and h\u2081 h\u2082)\n    | _, _ => .unknown\n\ntheorem HasType.det (h\u2081 : HasType e t\u2081) (h\u2082 : HasType e t\u2082) : t\u2081 = t\u2082 := by\n  cases h\u2081 <;> cases h\u2082 <;> rfl\n\n-- TODO: for simplifying the following proof we need: ematching for forward reasoning, and `match` blast for case analysis\n\ntheorem Expr.typeCheck_complete {e : Expr} : e.typeCheck = .unknown \u2192 \u00ac HasType e t := by\n  induction e with simp [typeCheck]\n  | plus a b iha ihb =>\n    revert iha ihb\n    cases typeCheck a <;> cases typeCheck b <;> simp <;> intros <;> intro h <;> cases h <;> try contradiction\n    rename_i ty\u2081 _ ty\u2082 _ h _ _\n    cases ty\u2081 <;> cases ty\u2082 <;> simp at h\n    . have := HasType.det \u2039HasType b Ty.bool\u203a \u2039HasType b Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType a Ty.bool\u203a \u2039HasType a Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType a Ty.bool\u203a \u2039HasType a Ty.nat\u203a; contradiction\n  | and a b iha ihb =>\n    revert iha ihb\n    cases typeCheck a <;> cases typeCheck b <;> simp <;> intros <;> intro h <;> cases h <;> try contradiction\n    rename_i ty\u2081 _ ty\u2082 _ h _ _\n    cases ty\u2081 <;> cases ty\u2082 <;> simp at h\n    . have := HasType.det \u2039HasType b Ty.bool\u203a \u2039HasType b Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType a Ty.bool\u203a \u2039HasType a Ty.nat\u203a; contradiction\n    . have := HasType.det \u2039HasType b Ty.bool\u203a \u2039HasType b Ty.nat\u203a; contradiction\n\ninstance (e : Expr) (t : Ty) : Decidable (HasType e t) :=\n  match h' : e.typeCheck with\n  | .found t' ht' =>\n    if heq : t = t' then\n      isTrue (heq \u25b8 ht')\n    else\n      isFalse fun ht => heq (HasType.det ht ht')\n  | .unknown => isFalse (Expr.typeCheck_complete h')\n"}
{"text": "-- import all\n-- import utils.util\n-- import data_util.basic\n-- import data_util.lean_step\n-- import lean_step\n\n-- -- #check times_cont_diff_at_of_subsingleto\n\n-- #check continuous_linear_map.complete_space\n\n-- #check abs_max_sub_max_le_abs\n\n\n-- theorem triangle_inequality {\u03b1} [_inst_1 : normed_group \u03b1]\n--   (g h : \u03b1) : \u2225g + h\u2225 \u2264 \u2225g\u2225 + \u2225h\u2225 :=\n-- begin\n--   convert dist_triangle g 0 (-h); rw [dist_eq_norm],\n--     { rw [sub_neg_eq_add] },\n--     { rw [sub_zero] },\n--     { rw [sub_neg_eq_add, zero_add] }\n-- end\n\n\n-- run_cmd do {\n--   pf \u2190 tactic.get_proof_from_env `norm_add_le >>= expr.unfold_macros,\n--   tactic.pp pf >>= tactic.trace\n-- }\n\n-- run_cmd do {\n--   pf \u2190 tactic.get_proof_from_env `triangle_inequality >>= expr.unfold_macros,\n--   tactic.pp pf >>= tactic.trace\n-- }\n-- -- #check lean_step_main\n-- -- run_cmd lean_step_main dummy_dp_handler {rec_limit := 1000} `triangle_inequality 0 0\n-- theorem iff_of_true' {P} : (P \u2194 true) \u2192 P :=\n-- begin\n--   intro H, cases H with H\u2081 H\u2082, apply H\u2082, trivial\n-- end\n-- #check iff_of_true'\n"}
{"text": "import linear_algebra.vandermonde\nimport linear_algebra.matrix.nondegenerate\nimport to_mathlib.polynomial.degree_lt_le\n\nnamespace matrix\nopen_locale big_operators matrix\nopen finset\nlemma det_vandermonde_ne_zero_of_injective {R : Type*} [comm_ring R] \n[is_domain R] {n : \u2115} (\u03b1 : fin n \u21aa R) : (vandermonde \u03b1).det \u2260 0 :=\nbegin\n  simp_rw [det_vandermonde, prod_ne_zero_iff, mem_filter, \n  mem_univ, forall_true_left, true_and, sub_ne_zero, ne.def, \n  embedding_like.apply_eq_iff_eq],\n  rintro _ _ _ rfl, apply lt_irrefl _ (by assumption)\nend\n\ntheorem vandermonde_invertibility' {R : Type*} [comm_ring R]\n[is_domain R] {n : \u2115} (\u03b1 : fin n \u21aa R) {f : fin n \u2192 R}\n(h\u2082 : \u2200 j, \u2211 i : fin n, (\u03b1 j ^ (i : \u2115)) * f i = 0) : f = 0\n:= by {apply eq_zero_of_mul_vec_eq_zero (det_vandermonde_ne_zero_of_injective \u03b1), ext, apply h\u2082}\n\ntheorem vandermonde_invertibility {R : Type*} [comm_ring R]\n[is_domain R] {n : \u2115}\n{\u03b1 : fin n \u21aa R} {f : fin n \u2192 R}\n(h\u2082 : \u2200 j, \u2211 i, f i * (\u03b1 j ^ (i : \u2115))  = 0) : f = 0\n:= by {apply vandermonde_invertibility' \u03b1, simp_rw mul_comm, exact h\u2082}\n\ntheorem vandermonde_invertibility_transposed {R : Type*} [comm_ring R] \n[is_domain R] {n : \u2115}\n{\u03b1 : fin n \u21aa R} {f : fin n \u2192 R}\n(h\u2082 : \u2200 i : fin n, \u2211 j : fin n, f j * (\u03b1 j ^ (i : \u2115)) = 0) : f = 0\n:= by {apply eq_zero_of_vec_mul_eq_zero \n(det_vandermonde_ne_zero_of_injective \u03b1), ext, apply h\u2082}\n\nend matrix\n\nnamespace polynomial\nopen_locale polynomial big_operators\n\nopen linear_equiv matrix polynomial\n\ntheorem vandermonde_invertibility {R : Type*} [comm_ring R] [is_domain R] {n : \u2115}\n(\u03b1 : fin n \u21aa R) (p : degree_lt R n) (h\u2081 : \u2200 j, (p : R[X]).is_root (\u03b1 j)) : p = 0 :=\nbegin\n  simp_rw degree_lt.to_tuple_root at h\u2081,\n  exact (degree_lt.to_tuple_eq_zero_iff p).mp (vandermonde_invertibility h\u2081)\nend\n\ntheorem vandermonde_invertibility_tranposed {R : Type*} [comm_ring R] [is_domain R]\n{n : \u2115} (\u03b1 : fin n \u21aa R) (p : degree_lt R n)\n(h\u2081 : \u2200 i : fin n, \u2211 j : fin n, (p : R[X]).coeff j * (\u03b1 j ^ (i : \u2115)) = 0) : p = 0 :=\n(degree_lt.to_tuple_eq_zero_iff p).mp (vandermonde_invertibility_transposed h\u2081)\n\ntheorem vandermonde_agreement {R : Type*} [comm_ring R] [is_domain R] {n : \u2115}\n(\u03b1 : fin n \u21aa R) {p q : R[X]} (h\u2080 : (p - q) \u2208 degree_lt R n)\n(h\u2082 : \u2200 j, p.eval (\u03b1 j) = q.eval (\u03b1 j)) : p = q :=\nbegin\n  rw \u2190 sub_eq_zero, have vi := vandermonde_invertibility \u03b1 \u27e8p - q, h\u2080\u27e9,\n  simp only [submodule.coe_mk, is_root.def, eval_sub, submodule.mk_eq_zero] at vi,\n  exact vi (\u03bb _, sub_eq_zero.mpr (h\u2082 _)),\nend\n\nend polynomial"}
{"text": "lemma complex_cnj_inverse [simp]: \"cnj (inverse x) = inverse (cnj x)\""}
{"text": "lemma emeasure_lfp'[consumes 1, case_names cont measurable]: assumes \"P M\" assumes cont: \"sup_continuous F\" assumes *: \"\\<And>M A. P M \\<Longrightarrow> (\\<And>N. P N \\<Longrightarrow> Measurable.pred N A) \\<Longrightarrow> Measurable.pred M (F A)\" shows \"emeasure M {x\\<in>space M. lfp F x} = (SUP i. emeasure M {x\\<in>space M. (F ^^ i) (\\<lambda>x. False) x})\""}
{"text": "[STATEMENT]\nlemma lazy_sequence_of_list_of_lazy_sequence [simp]:\n  \"lazy_sequence_of_list (list_of_lazy_sequence xq) = xq\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. lazy_sequence_of_list (list_of_lazy_sequence xq) = xq\n[PROOF STEP]\nby (cases xq) simp_all"}
{"text": "abstract type Storage <: StaticInjection end\n"}
{"text": "import Aesop\nimport Mathlib.Combinatorics.Pigeonhole\nimport Mathlib.Tactic.Linarith\nimport Mathlib.Tactic.LibrarySearch\n\n/-!\n# International Mathematical Olympiad 1964, Problem 4\n\nSeventeen people correspond by mail with one another -- each one with\nall the rest. In their letters only three different topics are\ndiscussed. Each pair of correspondents deals with only one of the topics.\nProve that there are at least three people who write to each other\nabout the same topic.\n\n-/\n\n/--\n Smaller version of the problem, with 6 (or more) people and 2 topics.\n-/\ntheorem lemma1\n    (Person Topic : Type)\n    [Fintype Person]\n    [Fintype Topic]\n    (card_person : 5 < Fintype.card Person)\n    (card_topic : Fintype.card Topic = 2)\n    (discusses : Person \u2192 Person \u2192 Topic)\n    (discussion_sym : \u2200 p1 p2 : Person, discusses p1 p2 = discusses p2 p1) :\n    \u2203 t : Topic, \u2203 s : Finset Person,\n      2 < s.card \u2227\n        \u2200 p1 \u2208 s, \u2200 p2 \u2208 s, p1 \u2260 p2 \u2192 discusses p1 p2 = t := by\n  -- Choose a person p2.\n  have p2 : Person := (truncOfCardPos (by linarith)).out\n  let Person' := {p3 // p3 \u2260 p2}\n  have hf\u03b1 : Fintype Person' := Fintype.ofFinite Person'\n  have hfc\u03b1 : 4 < Fintype.card Person' := by\n    rw[Fintype.card_subtype_compl, Fintype.card_ofSubsingleton]\n    exact lt_tsub_of_add_lt_left card_person\n  have h1 : Fintype.card Topic * 2 < Fintype.card Person' := by linarith\n\n  have := Classical.decEq Topic\n\n  -- By the pigeonhole principle, there must be some topic t2 such that the\n  -- size of the set {p3 // p3 \u2260 p2 \u2227 discusses p2 p3 = t2} is at least 3.\n  have h2 := Fintype.exists_lt_card_fiber_of_mul_lt_card\n              (fun (p3: Person') \u21a6 discusses p2 p3.val) h1\n  obtain \u27e8t2, ht2\u27e9 := h2\n  -- Call that set \u03b1.\n  let \u03b1 := (Finset.filter (fun (x : Person') \u21a6 discusses p2 \u2191x = t2) Finset.univ)\n\n  -- If any pair of people p4 p5 in \u03b1 discusses topic t2, then we are done.\n  -- So the people in \u03b1 must all discuss only the remaining one topic t3.\n  let Topic' := {t3 // t3 \u2260 t2}\n  have h3 : Fintype Topic' := Fintype.ofFinite Topic'\n  have h4 : Fintype.card Topic' = 1 := by\n    simp[Fintype.card_subtype_compl, card_topic]\n\n  -- let t3 be the other element of Topic\n  obtain \u27e8t3, ht3\u27e9 := Fintype.card_eq_one_iff.mp h4\n\n  obtain h6 | h7 := Classical.em (\u2203 p3 p4 : \u03b1, p3 \u2260 p4 \u2227\n                                    discusses p3.val p4.val = t2)\n  \u00b7 obtain \u27e8p3, p4, hp1, hp2\u27e9 := h6\n    use t2\n    -- the set we want is {p2,p3,p4}\n    let s1 : Finset Person := {p3.val.val}\n    let s2 : Finset Person := Finset.cons p4.val s1\n                               (by rw[Finset.mem_singleton]; intro hp\n                                   exact (hp1 (Subtype.val_injective\n                                          (Subtype.val_injective hp)).symm).elim)\n    let s3 : Finset Person := Finset.cons p2 s2\n                               (by rw[Finset.mem_cons, Finset.mem_singleton]\n                                   intro hp\n                                   cases hp with\n                                   | inl hp =>\n                                     exact (p4.val.property.symm hp).elim\n                                   | inr hp =>\n                                     exact (p3.val.property.symm hp).elim)\n    use s3\n    constructor\n    \u00b7 simp only[Finset.card_cons, Finset.card_singleton]\n    \u00b7 intros p1' hp1' p2' hp2' hp1p2\n      rw[Finset.mem_cons, Finset.mem_cons, Finset.mem_singleton] at hp1' hp2'\n      have hp4d : discusses p2 \u2191\u2191p4 = t2 := by\n         have := p4.property; simp at this; exact this\n      have hp3d : discusses p2 \u2191\u2191p3 = t2 := by\n         have := p3.property; simp at this; exact this\n      aesop\n\n  \u00b7 push_neg at h7\n    use t3\n    let \u03b1' := Finset.map \u27e8\u03bb (x :Person') => x.val, Subtype.coe_injective\u27e9 \u03b1\n    use \u03b1'\n    constructor\n    \u00b7 rw[Finset.card_map]; exact ht2\n    \u00b7 intros p3' hp3' p4' hp4' hp3p4'\n      rw[Finset.mem_map] at hp3' hp4'\n      obtain \u27e8\u27e8p3, p3_ne\u27e9, p3_mem_\u03b1, p3_eq\u27e9 := hp3'\n      obtain \u27e8\u27e8p4, p4_ne\u27e9, p4_mem_\u03b1, p4_eq\u27e9 := hp4'\n      dsimp at p3_eq p4_eq\n      rw [\u2190p3_eq, \u2190p4_eq]\n      have hne : p3 \u2260 p4 := by rwa[p3_eq, p4_eq]\n      have h8 := h7 \u27e8\u27e8p3, p3_ne\u27e9, p3_mem_\u03b1\u27e9 \u27e8\u27e8p4, p4_ne\u27e9, p4_mem_\u03b1\u27e9 (by simp[hne])\n      let t3': Topic' := \u27e8discusses p3 p4, h8\u27e9\n      have h9 := ht3 t3'\n      rw[\u2190h9]\n\ntheorem imo1964_q4\n    (Person Topic : Type)\n    [Fintype Person]\n    [Fintype Topic]\n    (card_person : Fintype.card Person = 17)\n    (card_topic : Fintype.card Topic = 3)\n    (discusses : Person \u2192 Person \u2192 Topic)\n    (discussion_sym : \u2200 p1 p2 : Person, discusses p1 p2 = discusses p2 p1) :\n    \u2203 t : Topic, \u2203 s : Finset Person,\n      2 < s.card \u2227\n        \u2200 p1 \u2208 s, \u2200 p2 \u2208 s, p1 \u2260 p2 \u2192 discusses p1 p2 = t := by\n  -- Choose a person p1.\n  have p1 : Person := (truncOfCardPos (by linarith)).out\n  let Person' := {p2 // p2 \u2260 p1}\n\n  -- By the pigeonhole principle, there must be some topic t1 such\n  -- that the size of the set {p2 // p2 \u2260 p1 \u2227 discusses p1 p2 = t1}\n  -- is at least 6.\n\n  have hf\u03b1 : Fintype Person' := Fintype.ofFinite Person'\n  have hfc\u03b1 : Fintype.card Person' = 16 := by\n      simp[Fintype.card_subtype_compl, card_person]\n  have h1 : Fintype.card Topic * 5 < Fintype.card Person' := by\n      rw[hfc\u03b1, card_topic]; norm_num\n\n  have := Classical.decEq Topic; have := Classical.decEq Person\n\n  have h2 := Fintype.exists_lt_card_fiber_of_mul_lt_card\n              (fun (p2: Person') \u21a6 discusses p1 p2.val) h1\n  clear h1\n  obtain \u27e8t1, ht1\u27e9 := h2\n  -- Call that set \u03b1.\n  let \u03b1 := (Finset.filter (fun (x : Person') \u21a6 discusses p1 \u2191x = t1) Finset.univ)\n  have card\u03b1 : 5 < Fintype.card \u03b1 := by rw[Fintype.card_coe]; exact ht1;\n\n  -- If any pair of people p2 p3 in \u03b1 discusses topic t1, then we are done.\n  obtain h6 | h7 := Classical.em (\u2203 p2 p3 : \u03b1, p2 \u2260 p3 \u2227\n                                    discusses p2.val p3.val = t1)\n  \u00b7 obtain \u27e8p3, p4, hp1, hp2\u27e9 := h6\n    use t1\n    -- the set we want is {p1,p3,p4}\n    let s1 : Finset Person := {p3.val.val}\n\n    have hs1 : \u00ac p4.val.val \u2208 s1 := by\n      rw[Finset.mem_singleton]; intro hp\n      exact (hp1 (Subtype.val_injective (Subtype.val_injective hp)).symm).elim\n\n    let s2 : Finset Person := Finset.cons p4.val s1 hs1\n\n    have hs2 : \u00ac p1 \u2208 s2 := by\n      rw[Finset.mem_cons, Finset.mem_singleton]; intro hp\n      cases hp with\n      | inl hp => exact (p4.val.property.symm hp).elim\n      | inr hp => exact (p3.val.property.symm hp).elim\n\n    let s3 : Finset Person := Finset.cons p1 s2 hs2\n    use s3\n    constructor\n    \u00b7 simp only[Finset.card_cons, Finset.card_singleton]\n    \u00b7 intros p1' hp1' p2' hp2' hp1p2\n      rw[Finset.mem_cons, Finset.mem_cons, Finset.mem_singleton] at hp1' hp2'\n      have hp4d : discusses p1 \u2191\u2191p4 = t1 := by\n         have := p4.property; simp at this; exact this\n      have hp3d : discusses p1 \u2191\u2191p3 = t1 := by\n         have := p3.property; simp at this; exact this\n      aesop\n\n  \u00b7 -- So the people in \u03b1 must all discuss only the remaining two topics.\n    push_neg at h7\n    let Topic' := {t2 // t2 \u2260 t1}\n    have h3 : Fintype Topic' := Fintype.ofFinite Topic'\n    have h4 : Fintype.card Topic' = 2 := by\n      simp[Fintype.card_subtype_compl, card_topic]\n    have t0 : Topic' := (truncOfCardPos (by linarith)).out\n\n    let discusses' : \u03b1 \u2192 \u03b1 \u2192 Topic' :=\n      fun (p2 p3 : \u03b1) \u21a6\n        if heq : p2 = p3 then t0\n        else\n        \u27e8discusses p2.val p3.val, h7 \u27e8p2, p2.property\u27e9 \u27e8p3, p3.property\u27e9 heq\u27e9\n    have discusses_sym' :\n        \u2200 (p1 p2 : { x // x \u2208 \u03b1 }), discusses' p1 p2 = discusses' p2 p1 := by\n      intros p3 p4\n      simp\n      split_ifs with hf1 hf2 hf3\n      \u00b7 rfl\n      \u00b7 exact (hf2 hf1.symm).elim\n      \u00b7 exact (hf1 hf3.symm).elim\n      \u00b7 simp[discussion_sym]\n    have h5 := lemma1 \u03b1 Topic' card\u03b1 h4 discusses' discusses_sym'\n    obtain \u27e8t2, s, hs1, hs2\u27e9 := h5\n    use t2\n    let s' := Finset.map \u27e8\u03bb (x : \u03b1) => x.val.val,\n                          fun x y hxy \u21a6 Subtype.coe_injective (Subtype.coe_injective hxy)\u27e9 s\n    use s'\n    constructor\n    \u00b7 rwa[Finset.card_map]\n    \u00b7 intros p3 hp3 p4 hp4 hp34\n      rw[Finset.mem_map] at hp3 hp4\n      obtain \u27e8\u27e8\u27e8p3', p3_mem_person'\u27e9, p3_mem_\u03b1\u27e9, p3_mem_s, hp3eq\u27e9 := hp3\n      obtain \u27e8\u27e8\u27e8p4', p4_mem_person'\u27e9, p4_mem_\u03b1\u27e9, p4_mem_s, hp4eq\u27e9 := hp4\n      dsimp at hp3eq hp4eq\n      rw [\u2190hp3eq, \u2190hp4eq]\n      have hne : p3' \u2260 p4' := by rwa[hp3eq, hp4eq]\n      have h6 := hs2 \u27e8\u27e8p3', p3_mem_person'\u27e9, p3_mem_\u03b1\u27e9 p3_mem_s\n                     \u27e8\u27e8p4', p4_mem_person'\u27e9, p4_mem_\u03b1\u27e9 p4_mem_s (by simp[hne])\n      simp[hne] at h6\n      exact (congrArg Subtype.val h6)\n"}
{"text": "[STATEMENT]\ntheorem auth_shakey_anonymous:\n  assumes\n    A: \"s\\<^sub>0 \\<Turnstile> s\" and\n    B: \"n \\<notin> bad_id_shakey\" and\n    C: \"n \\<notin> bad_shakey \\<inter> (bad_id_password \\<union> bad_id_pubkey)\"\n  shows \"\\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<notin> spied s\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<notin> spied s\n[PROOF STEP]\nproof\n[PROOF STATE]\nproof (state)\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow> False\n[PROOF STEP]\nassume D: \"\\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s\"\n[PROOF STATE]\nproof (state)\nthis:\n\\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow> False\n[PROOF STEP]\nhence \"n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\"\n[PROOF STATE]\nproof (prove)\nusing this:\n\\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n[PROOF STEP]\nby (rule contrapos_pp, rule_tac idinfo_init [OF A])\n[PROOF STATE]\nproof (state)\nthis:\nn \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow> False\n[PROOF STEP]\nmoreover\n[PROOF STATE]\nproof (state)\nthis:\nn \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow> False\n[PROOF STEP]\nhave \"Key (Auth_ShaKey n) \\<in> spied s\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. Key (Auth_ShaKey n) \\<in> spied s\n[PROOF STEP]\nby (rule idinfo_msg [OF A D])\n[PROOF STATE]\nproof (state)\nthis:\nKey (Auth_ShaKey n) \\<in> spied s\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow> False\n[PROOF STEP]\nhence \"n \\<in> bad_shakey\"\n[PROOF STATE]\nproof (prove)\nusing this:\nKey (Auth_ShaKey n) \\<in> spied s\n\ngoal (1 subgoal):\n 1. n \\<in> bad_shakey\n[PROOF STEP]\nby (rule contrapos_pp, rule_tac auth_shakey_secret [OF A])\n[PROOF STATE]\nproof (state)\nthis:\nn \\<in> bad_shakey\n\ngoal (1 subgoal):\n 1. \\<langle>n, Key (Auth_ShaKey n)\\<rangle> \\<in> spied s \\<Longrightarrow> False\n[PROOF STEP]\nultimately\n[PROOF STATE]\nproof (chain)\npicking this:\nn \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\nn \\<in> bad_shakey\n[PROOF STEP]\nshow False\n[PROOF STATE]\nproof (prove)\nusing this:\nn \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\nn \\<in> bad_shakey\n\ngoal (1 subgoal):\n 1. False\n[PROOF STEP]\nusing B and C\n[PROOF STATE]\nproof (prove)\nusing this:\nn \\<in> bad_id_password \\<union> bad_id_pubkey \\<union> bad_id_shakey\nn \\<in> bad_shakey\nn \\<notin> bad_id_shakey\nn \\<notin> bad_shakey \\<inter> (bad_id_password \\<union> bad_id_pubkey)\n\ngoal (1 subgoal):\n 1. False\n[PROOF STEP]\nby blast\n[PROOF STATE]\nproof (state)\nthis:\nFalse\n\ngoal:\nNo subgoals!\n[PROOF STEP]\nqed"}
{"text": "Require Coq.Logic.Classical_Prop.\nRequire Import ProofCheckingEuclid.euclidean_axioms.\nRequire Import ProofCheckingEuclid.euclidean_defs.\nRequire Import ProofCheckingEuclid.lemma_collinear_ABC_ABD_BCD.\n\nSection Euclid.\n\nContext `{Ax:euclidean_neutral_ruler_compass}.\n\nLemma lemma_collinear_ABC_ABD_ABE_CDE :\n\tforall A B C D E,\n\tneq A B ->\n\tCol A B C ->\n\tCol A B D ->\n\tCol A B E ->\n\tCol C D E.\nProof.\n\tintros A B C D E.\n\tintros neq_A_B.\n\tintros Col_A_B_C.\n\tintros Col_A_B_D.\n\tintros Col_A_B_E.\n\n\tpose proof (lemma_collinear_ABC_ABD_BCD _ _ _ _ Col_A_B_C Col_A_B_D neq_A_B) as Col_B_C_D.\n\tpose proof (lemma_collinear_ABC_ABD_BCD _ _ _ _ Col_A_B_C Col_A_B_E neq_A_B) as Col_B_C_E.\n\tassert (eq B C \\/ neq B C) as [eq_B_C|neq_B_C] by (apply Classical_Prop.classic).\n\t{\n\t\tpose proof (lemma_collinear_ABC_ABD_BCD _ _ _ _ Col_A_B_D Col_A_B_E neq_A_B) as Col_B_D_E.\n\t\tassert (Col C D E) as Col_C_D_E by (rewrite <- eq_B_C; exact Col_B_D_E).\n\t\texact Col_C_D_E.\n\t}\n\t{\n\t\tpose proof (lemma_collinear_ABC_ABD_BCD _ _ _ _ Col_B_C_D Col_B_C_E neq_B_C) as Col_C_D_E.\n\t\texact Col_C_D_E.\n\t}\nQed.\n\nEnd Euclid.\n"}
{"text": "Require Import Coq.Classes.RelationClasses Coq.Classes.Morphisms Coq.Relations.Relation_Definitions.\n\nLemma PER_valid_l {A} {R : relation A} {HS : Symmetric R} {HT : Transitive R} x y (H : R x y) : Proper R x.\nProof. hnf; etransitivity; eassumption || symmetry; eassumption. Qed.\nLemma PER_valid_r {A} {R : relation A} {HS : Symmetric R} {HT : Transitive R} x y (H : R x y) : Proper R y.\nProof. hnf; etransitivity; eassumption || symmetry; eassumption. Qed.\nGlobal Hint Extern 10 (Proper ?R ?x) => simple eapply (@PER_valid_l _ R); [ | | solve [ auto with nocore ] ] : typeclass_instances.\nGlobal Hint Extern 10 (Proper ?R ?x) => simple eapply (@PER_valid_r _ R); [ | | solve [ auto with nocore ] ] : typeclass_instances.\n"}
{"text": "import data.rat.defs\nimport data.fintype.card\nimport data.polynomial.eval\nimport algebra.group.basic\nimport algebra.algebra.basic\nimport algebra.big_operators.intervals\nimport ring_theory.algebraic\nimport ring_theory.int.basic\n\n-- This code is a perfect example of how *NOT* to use Lean\n-- There are some `sorry`s because I attempted to refactor my old code\n-- to make it more idiomatic, but I just gave up halfway...\n\nnamespace rat\ntheorem pow_num_denom (q : \u211a) (n : \u2115) : q ^ n = rat.mk (q.num ^ n) (\u2191q.denom ^ n) :=\nsorry\n\ntheorem div_mk_div_cancel_right {a b c : \u2124} (c0 : c \u2260 0) :\n  rat.mk (c * a) (c * b) = rat.mk a b :=\nby rw [mul_comm c a, mul_comm c b, rat.div_mk_div_cancel_left c0]\n\ntheorem sum_same_denom {n : \u2115} {num : fin (n + 1) \u2192 \u2124} {denom : \u2124} :\n  finset.univ.sum (\u03bb x : fin (n + 1), rat.mk (num x) denom) =\n  rat.mk (finset.univ.sum (\u03bb x : fin (n + 1), num x)) denom := by {\n  induction n with i hi,\n    repeat {rw fin.sum_univ_one},\n  repeat {rw @fin.sum_univ_succ _ _ i.succ _},\n  repeat {rw rat.add_mk},\n  congr,\n  apply hi, \n}\nend rat\n\n-- The ring of integers of \u211a is \u2124\ntheorem int_of_algebraic_rat (r : \u211a) (hr : is_integral \u2124 r) : r.denom = 1 :=\nbegin\n  obtain \u27e8p, hp1, hp2\u27e9 := hr,\n  set n := p.nat_degree with hn,\n  set P := r.num with hP,\n  set Q : \u2124 := \u2191r.denom with hQ,\n\n  by_cases p.nat_degree = 0,\n  { rw [polynomial.eq_C_of_nat_degree_eq_zero h,\n      polynomial.eval\u2082_C,\n      algebra_map_int_eq,\n      ring_hom.eq_int_cast,\n      rat.coe_int_eq_mk,\n      rat.mk_eq_zero one_ne_zero,\n      \u2190h,\n      polynomial.monic.coeff_nat_degree hp1]\n      at hp2,\n    exact false.elim (one_ne_zero hp2) },\n\n  have Qpow : \u2200 n : \u2115, Q ^ n \u2260 0 := sorry,\n  rw [polynomial.eval\u2082_eq_sum,\n    polynomial.sum_over_range, -- generates an intermediate goal...\n    \u2190fin.sum_univ_eq_sum_range]\n    at hp2,\n  simp_rw [algebra_map_int_eq,\n    ring_hom.eq_int_cast,\n    rat.coe_int_eq_mk,\n    rat.pow_num_denom,\n    rat.mul_def one_ne_zero $ Qpow _,\n    one_mul,\n    rat.mk_eq_div] at hp2,\n\n  swap, -- ...which we immediately handle\n  { intro n, simp },\n  \n  have : (\u03bb x : fin (n + 1), ((p.coeff (x : \u2115) * P ^ \u2191x) / Q ^ (x : \u2115))) =\n    (\u03bb x : fin (n + 1), ((p.coeff (x : \u2115) * P ^ (x : \u2115) * Q ^ (n -(x : \u2115))) / Q ^ n : \u211a)) := by {\n    funext,\n    calc ((p.coeff \u2191x * P ^ \u2191x) / Q ^ \u2191x : \u211a)\n      = ((p.coeff \u2191x * P ^ \u2191x * Q ^ (n-\u2191x)) / (Q ^ \u2191x * Q ^ (n-\u2191x)) : \u211a) : sorry\n    ... = ((p.coeff \u2191x * P ^ \u2191x * Q ^ (n-\u2191x)) / Q ^ n : \u211a) : sorry,\n  },\n\n  -- Tedious rewriting lemmas\n  have h1 : \u2200 x : \u2115, x \u2264 n \u2192 rat.mk (P ^ x) (Q ^ x) =\n    rat.mk (Q ^ (n - x) * P ^ x) (Q ^ n) := by {\n    intros x hx,\n    calc rat.mk (P ^ x) (Q ^ x)\n      = rat.mk (Q ^ (n - x) * P ^ x) (Q ^ (n - x) * Q ^ x) :\n        rat.mk_mul_num_and_denom (Qpow x) (Qpow (n - x))\n    ... = rat.mk (Q ^ (n - x) * P ^ x) (Q ^ n) : by rw [\u2190pow_add, nat.sub_add_cancel hx]\n  },\n  \n  have h2 : (\u03bb x : fin (n + 1), rat.mk (p.coeff \u2191x) 1 * rat.mk (P ^ \u2191x) (Q ^ \u2191x)) =\n    (\u03bb x : fin (n + 1), rat.mk (p.coeff \u2191x * Q ^ (n - \u2191x) * P ^ \u2191x) (Q ^ n)) := by {\n    funext,\n    rw [h1 x $ nat.le_of_lt_succ x.is_lt,\n      rat.mul_def one_ne_zero (Qpow n),\n      \u2190mul_assoc, one_mul]\n  },\n\n  rw [h2,\n    rat.sum_same_denom,\n    rat.mk_eq_zero $ Qpow n,\n  -- Just to extract one term out...\n    fin.sum_univ_eq_sum_range (\u03bb x : \u2115, p.coeff x * Q ^ (n - x) * P ^ x) (n + 1),\n    eq_add_of_sub_eq $ finset.sum_range_succ_sub_top _,\n    \u2190fin.sum_univ_eq_sum_range (\u03bb x : \u2115, p.coeff x * Q ^ (n - x) * P ^ x) n]\n    at hp2,\n  dsimp at hp2,\n  clear h1 h2,\n  \n  have h3 : (\u03bb x : fin n, (p.coeff (\u2191x : \u2115)) * Q ^ (n - (\u2191x : \u2115)) * P ^ (\u2191x : \u2115)) =\n    (\u03bb x : fin n, Q * ((p.coeff (\u2191x : \u2115)) * Q ^ (n - (\u2191x : \u2115) - 1) * P ^ (\u2191x : \u2115))) := by {\n    funext,\n    have : Q ^ (n - \u2191x) = Q * Q ^ (n - \u2191x - 1) :=\n      calc Q ^ (n - \u2191x) = Q ^ (n - \u2191x).pred.succ : by rw nat.succ_pred_eq_of_pos (nat.sub_pos_of_lt x.is_lt)\n      ... = Q * Q ^ (n - \u2191x - 1) : by rw [pow_succ, nat.pred_eq_sub_one],\n    -- idk why `ring` tactic hangs\n    rw [this, \u2190mul_assoc (p.coeff \u2191x) _ _, mul_comm (p.coeff \u2191x) Q,\n      mul_assoc Q _ _, mul_assoc Q _ _]\n  },\n\n  rw [h3, \u2190finset.mul_sum, polynomial.monic.leading_coeff hp1,\n    one_mul, nat.sub_self, pow_zero, one_mul] at hp2,\n  clear h3,\n\n  obtain \u27e8a, b, hab\u27e9 := (is_coprime.pow_left_iff $ nat.pos_of_ne_zero h).mpr\n    ((@int.coprime_iff_nat_coprime P Q).mpr r.cop),\n  replace hp2 := congr_arg (\u03bb x : \u2124, a * x) hp2,\n  dsimp at hp2,\n  rw [mul_add, mul_zero] at hp2,\n\n  rw \u2190eq_sub_iff_add_eq at hab,\n  rw [hab, int.sub_eq_add_neg, add_comm, add_assoc, add_eq_zero_iff_eq_neg,\n    \u2190mul_assoc, mul_comm b Q, mul_comm a Q, mul_assoc Q a _,\n    neg_mul_eq_mul_neg, \u2190mul_add, neg_mul_eq_mul_neg]\n    at hp2,\n  clear hab,\n\n  rw [\u2190int.nat_abs_of_nat r.denom,\n    int.eq_one_of_dvd_one (le_of_lt $ int.pos_of_pos_nat r.pos) \u27e8_, hp2\u27e9,\n    int.nat_abs_one],\nend"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_44\n  (s t : \u211d)\n  (h\u2080 : s = 9 - 2 * t)\n  (h\u2081 : t = 3 * s + 1) :\n  s = 1 \u2227 t = 4 :=\nbegin\n  split; linarith,\nend"}
{"text": "Inductive bit : Type :=\n  | B0\n  | B1.\n\nInductive nybble : Type :=\n  | bits (b0 b1 b2 b3 : bit).\n\nCheck (bits B1 B0 B0 B0).\n\nDefinition all_zero (nb : nybble) : bool :=\n  match nb with\n    | (bits B0 B0 B0 B0) => true\n    | (bits _ _ _ _) => false\n  end.\n\nCompute (all_zero (bits B1 B0 B1 B0)).\n\nCompute (all_zero (bits B0 B0 B0 B0)).\n\n"}
{"text": "theory TA_More2\n  imports TA.TA_More\nbegin\n\nlemma collect_clock_pairs_concat:\n  \"collect_clock_pairs (concat xxs) = (\\<Union> x \\<in> set xxs. collect_clock_pairs x)\"\n  unfolding collect_clock_pairs_def by auto\n\nend"}
{"text": "lemmas bounded_linear_mult_const = bounded_linear_mult_left [THEN bounded_linear_compose]"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_37\n  (x y : \u211d)\n  (h\u2080 : x + y = 7)\n  (h\u2081 : 3 * x + y = 45) :\n  x^2 - y^2 = 217 :=\nbegin\n  nlinarith,\nend"}
{"text": "[GOAL]\nm : \u211d\nhm : 1 < m\nk : \u2115\n\u22a2 Summable fun i => 1 / m ^ (i + (k + 1))!\n[PROOFSTEP]\nconvert (summable_nat_add_iff (k + 1)).2 (LiouvilleNumber.summable hm)\n[GOAL]\nm : \u211d\nhm : 1 < m\nk x\u271d : \u2115\n\u22a2 0 \u2264 1 / m ^ (x\u271d + (k + 1))!\n[PROOFSTEP]\npositivity\n[GOAL]\nm : \u211d\nhm : 1 < m\nk : \u2115\n\u22a2 0 < 1 / m ^ (0 + (k + 1))!\n[PROOFSTEP]\npositivity\n[GOAL]\nn : \u2115\nm : \u211d\nm1 : 1 < m\nm0 : 0 < m\nmi : 1 / m < 1\n\u22a2 \u2211' (i : \u2115), 1 / m ^ (i + (n + 1)!) = \u2211' (i : \u2115), (1 / m) ^ i * (1 / m ^ (n + 1)!)\n[PROOFSTEP]\nsimp only [pow_add, one_div, mul_inv, inv_pow]\n  -- factor the constant `(1 / m ^ (n + 1)!)` out of the series\n[GOAL]\nn : \u2115\nm : \u211d\nm1 : 1 < m\nm0 : 0 < m\nmi : 1 / m < 1\n\u22a2 (\u2211' (i : \u2115), (1 / m) ^ i) * (1 / m ^ (n + 1)!) = (1 - 1 / m)\u207b\u00b9 * (1 / m ^ (n + 1)!)\n[PROOFSTEP]\nrw [tsum_geometric_of_lt_1 (by positivity) mi]\n[GOAL]\nn : \u2115\nm : \u211d\nm1 : 1 < m\nm0 : 0 < m\nmi : 1 / m < 1\n\u22a2 0 \u2264 1 / m\n[PROOFSTEP]\npositivity\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 \u2264 1 / m ^ (n + 1)!\n[PROOFSTEP]\npositivity\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 2 / m ^ (n ! * (n + 1)) \u2264 1 / m ^ (n ! * n)\n[PROOFSTEP]\napply (div_le_div_iff _ _).mpr\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 2 * m ^ (n ! * n) \u2264 1 * m ^ (n ! * (n + 1))\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 < m ^ (n ! * (n + 1))\nn : \u2115 m : \u211d hm : 2 \u2264 m \u22a2 0 < m ^ (n ! * n)\n[PROOFSTEP]\nconv_rhs =>\n  rw [one_mul, mul_add, pow_add, mul_one, pow_mul, mul_comm, \u2190 pow_mul]\n    -- the second factors coincide, so we prove the inequality of the first factors*\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n| 1 * m ^ (n ! * (n + 1))\n[PROOFSTEP]\nrw [one_mul, mul_add, pow_add, mul_one, pow_mul, mul_comm, \u2190 pow_mul]\n    -- the second factors coincide, so we prove the inequality of the first factors*\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n| 1 * m ^ (n ! * (n + 1))\n[PROOFSTEP]\nrw [one_mul, mul_add, pow_add, mul_one, pow_mul, mul_comm, \u2190 pow_mul]\n    -- the second factors coincide, so we prove the inequality of the first factors*\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n| 1 * m ^ (n ! * (n + 1))\n[PROOFSTEP]\nrw [one_mul, mul_add, pow_add, mul_one, pow_mul, mul_comm, \u2190 pow_mul]\n  -- the second factors coincide, so we prove the inequality of the first factors*\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 2 * m ^ (n ! * n) \u2264 m ^ n ! * m ^ (n ! * n)\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 < m ^ (n ! * (n + 1))\nn : \u2115 m : \u211d hm : 2 \u2264 m \u22a2 0 < m ^ (n ! * n)\n[PROOFSTEP]\nrefine'\n  (mul_le_mul_right _).mpr\n    _\n      -- solve all the inequalities `0 < m ^ ??`\n[GOAL]\ncase refine'_1\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 < m ^ (n ! * n)\ncase refine'_2\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 2 \u2264 m ^ n !\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 < m ^ (n ! * (n + 1))\nn : \u2115 m : \u211d hm : 2 \u2264 m \u22a2 0 < m ^ (n ! * n)\n[PROOFSTEP]\nany_goals\n  exact\n    pow_pos (zero_lt_two.trans_le hm)\n      _\n        -- `2 \u2264 m ^ n!` is a consequence of monotonicity of exponentiation at `2 \u2264 m`.\n[GOAL]\ncase refine'_1\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 < m ^ (n ! * n)\n[PROOFSTEP]\nexact\n  pow_pos (zero_lt_two.trans_le hm)\n    _\n      -- `2 \u2264 m ^ n!` is a consequence of monotonicity of exponentiation at `2 \u2264 m`.\n[GOAL]\ncase refine'_2\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 2 \u2264 m ^ n !\n[PROOFSTEP]\nexact\n  pow_pos (zero_lt_two.trans_le hm)\n    _\n      -- `2 \u2264 m ^ n!` is a consequence of monotonicity of exponentiation at `2 \u2264 m`.\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 < m ^ (n ! * (n + 1))\n[PROOFSTEP]\nexact\n  pow_pos (zero_lt_two.trans_le hm)\n    _\n      -- `2 \u2264 m ^ n!` is a consequence of monotonicity of exponentiation at `2 \u2264 m`.\n[GOAL]\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 0 < m ^ (n ! * n)\n[PROOFSTEP]\nexact\n  pow_pos (zero_lt_two.trans_le hm)\n    _\n      -- `2 \u2264 m ^ n!` is a consequence of monotonicity of exponentiation at `2 \u2264 m`.\n[GOAL]\ncase refine'_2\nn : \u2115\nm : \u211d\nhm : 2 \u2264 m\n\u22a2 2 \u2264 m ^ n !\n[PROOFSTEP]\nexact _root_.trans (_root_.trans hm (pow_one _).symm.le) (pow_mono (one_le_two.trans hm) n.factorial_pos)\n[GOAL]\nm : \u2115\nhm : 0 < m\nk : \u2115\n\u22a2 \u2203 p, partialSum (\u2191m) k = \u2191p / \u2191(m ^ k !)\n[PROOFSTEP]\ninduction' k with k h\n[GOAL]\ncase zero\nm : \u2115\nhm : 0 < m\n\u22a2 \u2203 p, partialSum (\u2191m) Nat.zero = \u2191p / \u2191(m ^ Nat.zero !)\n[PROOFSTEP]\nexact \u27e81, by rw [partialSum, range_one, sum_singleton, Nat.cast_one, Nat.factorial, pow_one, pow_one]\u27e9\n[GOAL]\nm : \u2115\nhm : 0 < m\n\u22a2 partialSum (\u2191m) Nat.zero = \u21911 / \u2191(m ^ Nat.zero !)\n[PROOFSTEP]\nrw [partialSum, range_one, sum_singleton, Nat.cast_one, Nat.factorial, pow_one, pow_one]\n[GOAL]\ncase succ\nm : \u2115\nhm : 0 < m\nk : \u2115\nh : \u2203 p, partialSum (\u2191m) k = \u2191p / \u2191(m ^ k !)\n\u22a2 \u2203 p, partialSum (\u2191m) (Nat.succ k) = \u2191p / \u2191(m ^ (Nat.succ k)!)\n[PROOFSTEP]\nrcases h with \u27e8p_k, h_k\u27e9\n[GOAL]\ncase succ.intro\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2203 p, partialSum (\u2191m) (Nat.succ k) = \u2191p / \u2191(m ^ (Nat.succ k)!)\n[PROOFSTEP]\nuse p_k * m ^ ((k + 1)! - k !) + 1\n[GOAL]\ncase h\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 partialSum (\u2191m) (Nat.succ k) = \u2191(p_k * m ^ ((k + 1)! - k !) + 1) / \u2191(m ^ (Nat.succ k)!)\n[PROOFSTEP]\nrw [partialSum_succ, h_k, div_add_div, div_eq_div_iff, add_mul]\n[GOAL]\ncase h\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191p_k * \u2191m ^ (k + 1)! * \u2191(m ^ (Nat.succ k)!) + \u2191(m ^ k !) * 1 * \u2191(m ^ (Nat.succ k)!) =\n    \u2191(p_k * m ^ ((k + 1)! - k !) + 1) * (\u2191(m ^ k !) * \u2191m ^ (k + 1)!)\n[PROOFSTEP]\nnorm_cast\n[GOAL]\ncase h\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 p_k * m ^ (k + 1)! * m ^ (Nat.succ k)! + m ^ k ! * 1 * m ^ (Nat.succ k)! =\n    (p_k * m ^ ((k + 1)! - k !) + 1) * (m ^ k ! * m ^ (k + 1)!)\n[PROOFSTEP]\nrw [add_mul, one_mul, Nat.factorial_succ, add_mul, one_mul, add_tsub_cancel_right, pow_add]\n[GOAL]\ncase h\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 p_k * (m ^ (k * k !) * m ^ k !) * (m ^ (k * k !) * m ^ k !) + m ^ k ! * 1 * (m ^ (k * k !) * m ^ k !) =\n    p_k * m ^ (k * k !) * (m ^ k ! * (m ^ (k * k !) * m ^ k !)) + m ^ k ! * (m ^ (k * k !) * m ^ k !)\n[PROOFSTEP]\nsimp [mul_assoc]\n[GOAL]\ncase h.hb\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191(m ^ k !) * \u2191m ^ (k + 1)! \u2260 0\ncase h.hd\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191(m ^ (Nat.succ k)!) \u2260 0\ncase h.hb\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191(m ^ k !) \u2260 0\ncase h.hd m : \u2115 hm : 0 < m k p_k : \u2115 h_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !) \u22a2 \u2191m ^ (k + 1)! \u2260 0\n[PROOFSTEP]\nall_goals positivity\n[GOAL]\ncase h.hb\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191(m ^ k !) * \u2191m ^ (k + 1)! \u2260 0\n[PROOFSTEP]\npositivity\n[GOAL]\ncase h.hd\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191(m ^ (Nat.succ k)!) \u2260 0\n[PROOFSTEP]\npositivity\n[GOAL]\ncase h.hb\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191(m ^ k !) \u2260 0\n[PROOFSTEP]\npositivity\n[GOAL]\ncase h.hd\nm : \u2115\nhm : 0 < m\nk p_k : \u2115\nh_k : partialSum (\u2191m) k = \u2191p_k / \u2191(m ^ k !)\n\u22a2 \u2191m ^ (k + 1)! \u2260 0\n[PROOFSTEP]\npositivity\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\n\u22a2 Liouville (liouvilleNumber \u2191m)\n[PROOFSTEP]\nhave mZ1 : 1 < (m : \u2124) := by norm_cast\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\n\u22a2 1 < \u2191m\n[PROOFSTEP]\nnorm_cast\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\n\u22a2 Liouville (liouvilleNumber \u2191m)\n[PROOFSTEP]\nhave m1 : 1 < (m : \u211d) := by norm_cast\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\n\u22a2 1 < \u2191m\n[PROOFSTEP]\nnorm_cast\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\n\u22a2 Liouville (liouvilleNumber \u2191m)\n[PROOFSTEP]\nintro n\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn : \u2115\n\u22a2 \u2203 a b, 1 < b \u2227 liouvilleNumber \u2191m \u2260 \u2191a / \u2191b \u2227 |liouvilleNumber \u2191m - \u2191a / \u2191b| < 1 / \u2191b ^ n\n[PROOFSTEP]\nrcases partialSum_eq_rat (zero_lt_two.trans_le hm) n with \u27e8p, hp\u27e9\n[GOAL]\ncase intro\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191(m ^ n !)\n\u22a2 \u2203 a b, 1 < b \u2227 liouvilleNumber \u2191m \u2260 \u2191a / \u2191b \u2227 |liouvilleNumber \u2191m - \u2191a / \u2191b| < 1 / \u2191b ^ n\n[PROOFSTEP]\nrefine' \u27e8p, m ^ n !, by rw [Nat.cast_pow]; exact one_lt_pow mZ1 n.factorial_ne_zero, _\u27e9\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191(m ^ n !)\n\u22a2 1 < \u2191(m ^ n !)\n[PROOFSTEP]\nrw [Nat.cast_pow]\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191(m ^ n !)\n\u22a2 1 < \u2191m ^ n !\n[PROOFSTEP]\nexact one_lt_pow mZ1 n.factorial_ne_zero\n[GOAL]\ncase intro\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191(m ^ n !)\n\u22a2 liouvilleNumber \u2191m \u2260 \u2191\u2191p / \u2191\u2191(m ^ n !) \u2227 |liouvilleNumber \u2191m - \u2191\u2191p / \u2191\u2191(m ^ n !)| < 1 / \u2191\u2191(m ^ n !) ^ n\n[PROOFSTEP]\npush_cast\n[GOAL]\ncase intro\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191(m ^ n !)\n\u22a2 liouvilleNumber \u2191m \u2260 \u2191p / \u2191m ^ n ! \u2227 |liouvilleNumber \u2191m - \u2191p / \u2191m ^ n !| < 1 / (\u2191m ^ n !) ^ n\n[PROOFSTEP]\nrw [Nat.cast_pow] at hp \n[GOAL]\ncase intro\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191m ^ n !\n\u22a2 liouvilleNumber \u2191m \u2260 \u2191p / \u2191m ^ n ! \u2227 |liouvilleNumber \u2191m - \u2191p / \u2191m ^ n !| < 1 / (\u2191m ^ n !) ^ n\n[PROOFSTEP]\nrw [\u2190 partialSum_add_remainder m1 n, \u2190 hp]\n[GOAL]\ncase intro\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191m ^ n !\n\u22a2 partialSum (\u2191m) n + remainder (\u2191m) n \u2260 partialSum (\u2191m) n \u2227\n    |partialSum (\u2191m) n + remainder (\u2191m) n - partialSum (\u2191m) n| < 1 / (\u2191m ^ n !) ^ n\n[PROOFSTEP]\nhave hpos := remainder_pos m1 n\n[GOAL]\ncase intro\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191m ^ n !\nhpos : 0 < remainder (\u2191m) n\n\u22a2 partialSum (\u2191m) n + remainder (\u2191m) n \u2260 partialSum (\u2191m) n \u2227\n    |partialSum (\u2191m) n + remainder (\u2191m) n - partialSum (\u2191m) n| < 1 / (\u2191m ^ n !) ^ n\n[PROOFSTEP]\nsimpa [abs_of_pos hpos, hpos.ne'] using @remainder_lt n m (by assumption_mod_cast)\n[GOAL]\nm : \u2115\nhm : 2 \u2264 m\nmZ1 : 1 < \u2191m\nm1 : 1 < \u2191m\nn p : \u2115\nhp : partialSum (\u2191m) n = \u2191p / \u2191m ^ n !\nhpos : 0 < remainder (\u2191m) n\n\u22a2 2 \u2264 \u2191m\n[PROOFSTEP]\nassumption_mod_cast\n"}
{"text": "\nimport pq_induction_principles\nimport minimal_sub_pq_gen_group\n\n\nuniverse u\n\nsection pq_like_eq_equalizer\n\nvariables {G : Type u} [group G] --[inhabited Q]\n\nlemma prod_in_free_gen_list (gen : set G) (x : list (free_gen_group_sub_pq gen)) (hx : of ((x.map of).prod) = (x.map (of \u2218 of)).prod) : (x.map coe).prod \u2208 (free_gen_group_sub_pq gen : set G) :=\nbegin\n  induction x with g x hx,\n  {\n    simp only [list.prod_nil, list.map],\n    sorry,\n  },\n  {\n    simp only [list.prod_cons, list.map],\n    simp only [function.comp_app, list.prod_cons, list.map] at hx,\n    have hx1 := congr_arg (L_of_morph (gen_set_counit gen) (functoriality_group_to_pq (gen_set_counit gen))) hx,\n    simp only [monoid_hom.map_mul, L_of_morph_of, gen_set_counit_of] at hx1,\n    sorry,\n  },\nend\n\ntheorem eta_eq_L_eta (gen : set G) (x : pq_group (free_gen_group_sub_pq gen)) : (of x = L_of_morph of of_is_pq_morphism x) \u2194 (\u2203 y, x = of y) :=\nbegin\n  split,\n  swap,\n  {\n    intro hx,\n    cases hx with y hy,\n    rw hy,\n    simp only [L_of_morph_of],\n  },\n  {\n    revert x,\n    refine pq_group_list _,\n    intros x hx,\n    fconstructor,\n    fconstructor,\n    use (x.map (\u03bb x, \u2191x)).prod,\n    {\n      simp only,\n      induction x,\n      {\n        simp only [list.prod_nil, list.map],\n        sorry,\n      },\n      have hx1 := congr_arg (L_of_morph (gen_set_counit gen) (functoriality_group_to_pq (gen_set_counit gen))) hx,\n      simp only [monoid_hom.map_mul, list.prod_cons, list.map, L_of_morph_of, gen_set_counit_of] at hx1,\n      simp only [list.prod_cons, list.map],\n      sorry,\n    },\n    {\n      sorry,\n    },\n    /-\n    refine pq_group_word_induction _ _,\n    {\n      intro h1,\n      clear h1,\n      use (arbitrary Q)^(0 : \u2124),\n      simp only [of_pow_eq_pow_of, gpow_zero],\n    },\n    {\n      intros x z hx hxz,\n      sorry,\n    },\n    -/\n  },\nend\n\nend pq_like_eq_equalizer\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_513\n  (a b : \u211d)\n  (h\u2080 : 3 * a + 2 * b = 5)\n  (h\u2081 : a + b = 2) :\n  a = 1 \u2227 b = 1 :=\nbegin\n  split; linarith,\nend"}
{"text": "informal statement Let $A$ be a nonempty set of real numbers which is bounded below. Let $-A$ be the set of all numbers $-x$, where $x \\in A$. Prove that $\\inf A=-\\sup (-A)$.formal statement theorem exercise_1_5 (A minus_A : set \u211d) (hA : A.nonempty) \n  (hA_bdd_below : bdd_below A) (hminus_A : minus_A = {x | -x \u2208 A}) :\n  Inf A = Sup minus_A :="}
{"text": "record category { \u2113\u2080 \u2113\u2081 } { k : Set \u2113\u2080 } (_\u21d2_ : k \u2192 k \u2192 Set \u2113\u2081) : Set (lsuc lzero \u2294 \u2113\u2080 \u2294 \u2113\u2081)\nrecord groupoid { \u2113\u2080 \u2113\u2081 } { k : Set \u2113\u2080 } (_\u2248_ : k \u2192 k \u2192 Set \u2113\u2081) : Set (lsuc lzero \u2294 \u2113\u2080 \u2294 \u2113\u2081)\nrecord groupoid { \u2113\u2080 \u2113\u2081 } { k } _\u2248_\n  where\n  coinductive\n  field\n    \u2983 cat \u2984 : category _\u2248_\n  field\n    symmetry : \u2200 { x y } \u2192 x \u2248 y \u2192 y \u2248 x\nrecord category { \u2113\u2080 \u2113\u2081 } { k } _\u21d2_\n  where\n  coinductive\n  field\n    id  : \u2200 { a } \u2192 a \u21d2 a\n    _\u2218_ : \u2200 { a b c } \u2192 b \u21d2 c \u2192 a \u21d2 b \u2192 a \u21d2 c\n  field\n    _\u2248_ : { a b : k } \u2192 (f g : a \u21d2 b) \u2192 Set\n    \u2983 hom \u2984 : { a b : k } \u2192 groupoid { k = a \u21d2 b } _\u2248_\n  field\n    lunit : \u2200 { a b }     { x : a \u21d2 b }                             \u2192 (id \u2218 x) \u2248 x\n    runit : \u2200 { a b }     { x : a \u21d2 b }                             \u2192 (x \u2218 id) \u2248 x\n    assoc : \u2200 { a b c d } { x : c \u21d2 d } { y : b \u21d2 c } { z : a \u21d2 b } \u2192 (x \u2218 (y \u2218 z)) \u2248 ((x \u2218 y) \u2218 z)\nopen category \u2983 ... \u2984\nopen groupoid \u2983 ... \u2984\n"}
{"text": "{-# OPTIONS --rewriting --confluence-check -v rewriting:80 #-}\n\nopen import Agda.Builtin.Equality\n\npostulate\n  decorate      : \u2200{a} (A : Set a) \u2192 Set a\n  rewriteMe     : \u2200{a b} {A : Set a} {B : A \u2192 Set b}\n                \u2192 decorate ((x : A) \u2192 B x) \u2261 (decorate A \u2192 \u2200 x \u2192 decorate (B x))\n\n{-# BUILTIN REWRITE _\u2261_ #-}\n{-# REWRITE rewriteMe #-}\n\npostulate A : Set\n\ntest : decorate (A \u2192 A) \u2261 (decorate A \u2192 \u2200 (x : A) \u2192 decorate A)\ntest = refl\n"}
{"text": "module Categories.Functor.Discrete where\n\nopen import Categories.Category\nopen import Categories.Functor\nopen import Categories.Agda\nopen import Categories.Categories\nopen import Categories.Support.PropositionalEquality\nimport Categories.Discrete as D\n\nDiscrete : \u2200 {o} -> Functor (Sets o) (Categories o o _)\nDiscrete {o} = record {\n             F\u2080 = D.Discrete;\n             F\u2081 = F\u2081;\n             identity = \u03bb f \u2192 Heterogeneous.\u2261\u21d2\u223c _;\n             homomorphism = \u03bb f \u2192 Heterogeneous.\u2261\u21d2\u223c _;\n             F-resp-\u2261 = F-resp-\u2261}\n  where\n    F\u2081 : {A B : Category.Obj (Sets o)} \u2192 Sets o [ A , B ] \u2192\n                        Categories o o _ [ D.Discrete A , D.Discrete B ]\n    F\u2081 f = record {\n             F\u2080 = f;\n             F\u2081 = \u2263-cong f;\n             identity = _;\n             homomorphism = _;\n             F-resp-\u2261 = _ }\n  \n    F-resp-\u2261 : {A B : Set o} {F G : Sets o [ A , B ]} \u2192\n                  Sets o [ F \u2261 G ] \u2192 Categories o o _ [ F\u2081 F \u2261 F\u2081 G ]\n    F-resp-\u2261 F\u2261G {a} \u2263-refl rewrite F\u2261G {a} = Heterogeneous.\u2261\u21d2\u223c _\n"}
{"text": "------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Lists defined in terms of Data.Star\n------------------------------------------------------------------------\n\nmodule Data.Star.List where\n\nopen import Data.Star\nopen import Data.Unit\nopen import Relation.Binary.Simple\nopen import Data.Star.Nat\n\n-- Lists.\n\nList : Set \u2192 Set\nList a = Star (Const a) tt tt\n\n-- Nil and cons.\n\n[] : \u2200 {a} \u2192 List a\n[] = \u03b5\n\ninfixr 5 _\u2237_\n\n_\u2237_ : \u2200 {a} \u2192 a \u2192 List a \u2192 List a\n_\u2237_ = _\u25c5_\n\n-- The sum of the elements in a list containing natural numbers.\n\nsum : List \u2115 \u2192 \u2115\nsum = fold (Star Always) _+_ zero\n"}
{"text": "State Before: q : \u211a\n\u22a2 q * \u2191q.den = \u2191q.num State After: q : \u211a\n\u22a2 q.num /. \u2191q.den * (\u2191q.den /. 1) = q.num /. 1 Tactic: suffices (q.num /. \u2191q.den) * (\u2191q.den /. 1) = q.num /. 1 by\n  conv => pattern (occs := 1)q ; (rw [\u2190 @num_den q])\n  simp only [coe_int_eq_divInt, coe_nat_eq_divInt, num_den] at this \u22a2; assumption State Before: q : \u211a\n\u22a2 q.num /. \u2191q.den * (\u2191q.den /. 1) = q.num /. 1 State After: q : \u211a\nthis : \u2191q.den \u2260 0\n\u22a2 q.num /. \u2191q.den * (\u2191q.den /. 1) = q.num /. 1 Tactic: have : (q.den : \u2124) \u2260 0 := ne_of_gt (by exact_mod_cast q.pos) State Before: q : \u211a\nthis : \u2191q.den \u2260 0\n\u22a2 q.num /. \u2191q.den * (\u2191q.den /. 1) = q.num /. 1 State After: no goals Tactic: rw [Rat.mul_def' this one_ne_zero, mul_comm (q.den : \u2124) 1, divInt_mul_right this] State Before: q : \u211a\nthis : q.num /. \u2191q.den * (\u2191q.den /. 1) = q.num /. 1\n\u22a2 q * \u2191q.den = \u2191q.num State After: q : \u211a\nthis : q.num /. \u2191q.den * (\u2191q.den /. 1) = q.num /. 1\n\u22a2 q.num /. \u2191q.den * \u2191q.den = \u2191q.num Tactic: conv => pattern (occs := 1)q ; (rw [\u2190 @num_den q]) State Before: q : \u211a\nthis : q.num /. \u2191q.den * (\u2191q.den /. 1) = q.num /. 1\n\u22a2 q.num /. \u2191q.den * \u2191q.den = \u2191q.num State After: q : \u211a\nthis : q * (\u2191q.den /. 1) = q.num /. 1\n\u22a2 q * (\u2191q.den /. 1) = q.num /. 1 Tactic: simp only [coe_int_eq_divInt, coe_nat_eq_divInt, num_den] at this \u22a2 State Before: q : \u211a\nthis : q * (\u2191q.den /. 1) = q.num /. 1\n\u22a2 q * (\u2191q.den /. 1) = q.num /. 1 State After: no goals Tactic: assumption State Before: q : \u211a\n\u22a2 0 < \u2191q.den State After: no goals Tactic: exact_mod_cast q.pos"}
{"text": "import tactic.show_term\nimport tactic.tauto\n\nopen tactic\n\nlemma ex1 {P Q R : Prop} (h\u2081 : Q \u2192 P) (h\u2082 : R) (h\u2083 : R \u2192 Q) : P \u2227 R :=\nby show_term { tauto }\n\n#print ex1\n\nexample (x y : \u2115) (hx : x = 0) (hy : y = 1) : x + y = 1 :=\nbegin\n  show_term { rw hx, }, -- (id ((eq.refl (x + y = 1)).rec hx)).mpr ?m_1\n  show_term { rw hy, },\nend\n\nexample (x y z : \u2115) : x + y + z = x + z + y :=\nbegin\n  show_term { simp [add_comm], },\n  sorry,\nend"}
{"text": "import natural.definition\n\n@[derive decidable_eq]\ninductive Z\n| pos (n : N) : Z\n| neg_succ (n : N) : Z\n\nnamespace Z\n\ninstance : has_zero Z := \u27e8 pos N.zero \u27e9 \ntheorem zero_eq_zero : pos N.zero = 0 := rfl\n\ndef one : Z := pos (N.succ 0)\n\ninstance : has_one Z := \u27e8 Z.one \u27e9 \ntheorem one_eq_one : one = 1 := rfl\n\nlemma reduce_one : 1 = pos (N.succ 0) := rfl\n\ntheorem eq_comm (a b : Z) : (a = b) -> (b = a) :=\nbegin\n  intro h,\n  rw h,\nend\n\nlemma eq_pos_eq (a b : N) : (a = b) -> (pos a = pos b) := \nbegin\n  intro h,\n  rw h,\nend\n\nlemma eq_neg_eq (a b : N) : (a = b) -> (neg_succ a = neg_succ b) :=\nbegin\n  intro h,\n  rw h,\nend\n\nlemma pos_neq_neg (a b : N) : pos a \u2260 neg_succ b :=\nbegin\n  intro h,\n  cases h,\nend\n\nlemma neg_neq_pos (a b : N) : neg_succ a \u2260 pos b :=\nbegin\n  intro h,\n  cases h,\nend\n\ntheorem int1_to_nat (q : Prop) : (\u2200 (a: Z), q) -> (\u2200 (b: N), q) :=\nbegin\n  intro h,\n  intro a,\n  have b := pos a,\n  exact h b,\nend\n\ntheorem int2_to_nat (q : Prop) : (\u2200 (a b: Z), q) -> (\u2200 (c d: N), q) :=\nbegin\n  intro h,\n  intros a b,\n  have c := pos a,\n  have d := pos b,\n  exact h c d,\nend\n\nend Z"}
{"text": "[GOAL]\n\u22a2 size \u2260 0\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 size \u2260 0\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 size \u2260 0\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 size \u2260 0\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2115\nh : n < size\n\u22a2 Nat.isValidChar \u2191(UInt32.ofNat n).val\n[PROOFSTEP]\nrw [UInt32.val_eq_of_lt]\n[GOAL]\nn : \u2115\nh : n < size\n\u22a2 Nat.isValidChar n\nn : \u2115 h : n < size \u22a2 n < UInt32.size\n[PROOFSTEP]\nexact Or.inl $ Nat.lt_trans h $ by decide\n[GOAL]\nn : \u2115\nh : n < size\n\u22a2 size < 55296\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2115\nh : n < size\n\u22a2 n < UInt32.size\n[PROOFSTEP]\nexact Nat.lt_trans h $ by decide\n[GOAL]\nn : \u2115\nh : n < size\n\u22a2 size < UInt32.size\n[PROOFSTEP]\ndecide\n"}
{"text": "import data.real.irrational\nimport topology.basic\nimport algebra.order.floor\n\n\n--OUTPUT 1\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h\u03b1 : \u00ac is_rat \u03b1) : \u2200 y \u2208 Icc 0 1, \u2203 x \u2208 Icc 0 1, x \u2260 y \u2227 |x - y| < 1 :=\nbegin\n  assume (y : \u211d) (h1 : y \u2208 Icc 0 1),\n  have h2 : \u2200 (i j : \u2124), i \u2260 j \u2192 \u00ac (i * \u03b1 - \u230ai * \u03b1\u230b = j * \u03b1 - \u230aj * \u03b1\u230b), from by auto [is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def_iff, is_rat.def_iff, is_rat.def, is_rat.def\nend --Needs more than 2000 tokens!\n\n--OUTPUT 2\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h : \u00ac is_rat \u03b1) : \u2200 y \u2208 Icc 0 1, \u2203 x \u2208 Icc 0 1, x \u2260 y \u2227 dist x y < 1 :=\nbegin\n  assume (y : \u211d) (h1 : y \u2208 Icc 0 1),\n  have h2 : \u2200 (i : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 0, from by auto [int.cast_ne_zero],\n  have h3 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h4 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h5 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h6 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h7 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h8 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h9 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h10 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h11 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h12 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h13 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h14 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h15 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h16 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h17 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h18 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h19 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h20 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h21 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h22 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h23 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h24 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h25 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h26 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h27 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h28 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h29 : \u2200 (i j : \u2124), (i : \u211d) * \u03b1 - (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1 - (j : \u211d) * \u03b1, from by auto [int.cast_ne_zero],\n  have h30\nend --Needs more than 2000 tokens!\n\n--OUTPUT 3\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h : \u00ac is_rat \u03b1) : \u2200 y \u2208 Icc 0 1, \u2203 x \u2208 Icc 0 1, x \u2260 y \u2227 abs (x - y) < 1 :=\nbegin\n  assume y h1,\n  have h2 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h3 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h4 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h5 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h6 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h7 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h8 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h9 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h10 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h11 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h12 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h13 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h14 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h15 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h16 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h17 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h18 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h19 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h20 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h21 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h22 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h23 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h24 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h25 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h26 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 - (i : \u211d) \u2260 (j : \u211d) * \u03b1 - (j : \u211d), from by auto [sub_eq_zero_iff_eq, mul_eq_zero_iff_eq, h],\n  have h27 : \u2200 i j : \u2124, i \u2260 j \u2192 (i : \u211d) * \u03b1 \u2260 (j : \u211d) * \u03b1, from by auto [sub_eq_zero_iff_eq, mul_eq_zero\nend --Needs more than 2000 tokens!\n\n/- FEW SHOT PROMPTS TO CODEX(START)\n/--`theorem`\nPower Set is Closed under Intersection\nLet $S$ be a set.\n\nLet $\\powerset S$ be the power set of $S$.\n\n\nThen:\n:$\\forall A, B \\in \\powerset S: A \\cap B \\in \\powerset S$\n`proof`\nLet $A, B \\in \\powerset S$.\n\nThen by the definition of power set, $A \\subseteq S$ and $B \\subseteq S$.\n\nFrom Intersection is Subset we have that $A \\cap B \\subseteq A$.\n\nIt follows from Subset Relation is Transitive that $A \\cap B \\subseteq S$.\n\nThus $A \\cap B \\in \\powerset S$ and closure is proved.\n{{qed}}\n-/\ntheorem power_set_intersection_closed {\u03b1 : Type*} (S : set \u03b1) : \u2200 A B \u2208 \ud835\udcab S, (A \u2229 B) \u2208 \ud835\udcab S :=\nbegin\n  assume (A : set \u03b1) (hA : A \u2208 \ud835\udcab S) (B : set \u03b1) (hB : B \u2208 \ud835\udcab S),\n  have h1 : (A \u2286 S) \u2227 (B \u2286 S), from by auto [set.subset_of_mem_powerset, set.subset_of_mem_powerset],\n  have h2 : (A \u2229 B) \u2286 A, from by auto [set.inter_subset_left],\n  have h3 : (A \u2229 B) \u2286 S, from by auto [set.subset.trans],\n  show (A \u2229 B) \u2208  \ud835\udcab S, from by auto [set.mem_powerset],\nend\n\n/--`theorem`\nSquare of Sum\n :$\\forall x, y \\in \\R: \\paren {x + y}^2 = x^2 + 2 x y + y^2$\n`proof`\nFollows from the distribution of multiplication over addition:\n\n{{begin-eqn}}\n{{eqn | l = \\left({x + y}\\right)^2\n      | r = \\left({x + y}\\right) \\cdot \\left({x + y}\\right)\n}}\n{{eqn | r = x \\cdot \\left({x + y}\\right) + y \\cdot \\left({x + y}\\right)\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x \\cdot x + x \\cdot y + y \\cdot x + y \\cdot y\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x^2 + 2xy + y^2\n      | c = \n}}\n{{end-eqn}}\n{{qed}}\n-/\ntheorem square_of_sum (x y : \u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \nbegin\n  calc (x + y)^2 = (x+y)*(x+y) : by auto [sq]\n  ... = x*(x+y) + y*(x+y) : by auto [add_mul]\n  ... = x*x + x*y + y*x + y*y : by auto [mul_comm, add_mul] using [ring]\n  ... = x^2 + 2*x*y + y^2 : by auto [sq, mul_comm] using [ring]\nend\n\n/--`theorem`\nIdentity of Group is Unique\nLet $\\struct {G, \\circ}$ be a group. Then there is a unique identity element $e \\in G$.\n`proof`\nFrom Group has Latin Square Property, there exists a unique $x \\in G$ such that:\n:$a x = b$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = b$\n\nSetting $b = a$, this becomes:\n\nThere exists a unique $x \\in G$ such that:\n:$a x = a$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = a$\n\nThese $x$ and $y$ are both $e$, by definition of identity element.\n{{qed}}\n-/\ntheorem group_identity_unique {G : Type*} [group G] : \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a :=\nbegin\n  have h1 : \u2200 a b : G, \u2203! x : G, a * x = b, from by auto using [use (a\u207b\u00b9 * b)],\n  have h2 : \u2200 a b : G, \u2203! y : G, y * a = b, from by auto using [use b * a\u207b\u00b9], \n\n  have h3 : \u2200 a : G, \u2203! x : G, a * x = a, from by auto [h1],\n  have h4 : \u2200 a : G, \u2203! y : G, y * a = a, from by auto [h2],\n\n  have h5 : \u2200 a : G, classical.some (h3 a).exists = (1 : G), from by auto [exists_unique.unique, h3, classical.some_spec, exists_unique.exists, mul_one],\n  have h6 : \u2200 a : G, classical.some (h4 a).exists = (1 : G), from by auto [exists_unique.unique, h4, classical.some_spec, exists_unique.exists, one_mul],\n\n  show \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a, from by auto [h3, h4, exists_unique.unique, classical.some_spec, exists_unique.exists] using [use (1 : G)],\nend\n\n/--`theorem`\nSqueeze Theorem for Real Numbers\nLet $\\sequence {x_n}$, $\\sequence {y_n}$ and $\\sequence {z_n}$ be sequences in $\\R$.\n\nLet $\\sequence {y_n}$ and $\\sequence {z_n}$ both be convergent to the following limit:\n:$\\ds \\lim_{n \\mathop \\to \\infty} y_n = l, \\lim_{n \\mathop \\to \\infty} z_n = l$\n\nSuppose that:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\n\nThen:\n:$x_n \\to l$ as $n \\to \\infty$\nthat is:\n:$\\ds \\lim_{n \\mathop \\to \\infty} x_n = l$\n\n`proof`\nFrom Negative of Absolute Value:\n:$\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n\nLet $\\epsilon > 0$.\n\nWe need to prove that:\n:$\\exists N: \\forall n > N: \\size {x_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that:\n:$\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that:\n:$\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n\n\nLet $N = \\max \\set {N_1, N_2}$.\n\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n:$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n\nBut:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n\nand so:\n:$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n\nSo:\n:$\\forall n > N: \\size {x_n - l} < \\epsilon$\n\nHence the result.\n{{qed}}\n\n-/\ntheorem squeeze_theorem_real_numbers (x y z : \u2115 \u2192 \u211d) (l : \u211d) : \nlet seq_limit : (\u2115 \u2192 \u211d) \u2192 \u211d \u2192 Prop :=  \u03bb (u : \u2115 \u2192 \u211d) (l : \u211d), \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, |u n - l| < \u03b5 in\n seq_limit y l \u2192 seq_limit z l \u2192  (\u2200 n : \u2115, (y n) \u2264 (x n) \u2227 (x n) \u2264 (z n)) \u2192 seq_limit x l :=\nbegin\n  assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \u2200 (n : \u2115), y n \u2264 x n \u2227 x n \u2264 z n) (\u03b5), \n\n  have h5 : \u2200 x, |x - l| < \u03b5 \u2194 (((l - \u03b5) < x) \u2227 (x < (l + \u03b5))), \n  from by auto [abs_sub_lt_iff] using [linarith],\n  \n  assume (h7 : \u03b5 > 0),\n\n  cases h2 \u03b5 h7 with N1 h8,\n  cases h3 \u03b5 h7 with N2 h9,\n  let N := max N1 N2,\n  use N,\n\n  have h10 : \u2200 n > N, n > N1 \u2227 n > N2 := by auto [lt_of_le_of_lt, le_max_left, le_max_right],\n  \n  have h11 : \u2200 n > N, (((l - \u03b5) < (y n)) \u2227 ((y n) \u2264 (x n))) \u2227 (((x n) \u2264 (z n)) \u2227 ((z n) < l+\u03b5)), \n  from by auto [h8, h10, h5, h9],\n\n  have h15 : \u2200 n > N, ((l - \u03b5) < (x n)) \u2227 ((x n) < (l+\u03b5)), \n  from by auto [h11] using [linarith],\n\n  show  \u2200 (n : \u2115), n > N \u2192 |x n - l| < \u03b5, \n  from by auto [h5, h15], \n\nend\n\n/--`theorem`\nDensity of irrational orbit\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\n`proof`\nLet $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n$$\ni \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n$$\nwhich yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$. Hence,\n$$\nS:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n$$\nis an infinite subset of $\\left[0,1\\right]$.\n\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\n\nTo show that $S$ is dense in $[0, 1]$, consider $y \\in[0,1]$, and $\\epsilon>0$. Then by selecting $x \\in S$ such that $\\{x\\}<\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\cdot\\{x\\} \\leq y<(N+1) \\cdot\\{x\\}$, we get: $|y-\\{N x\\}|<\\epsilon$.\n\nQED\n-/\ntheorem \nFEW SHOT PROMPTS TO CODEX(END)-/\n"}
{"text": "import data.complex.basic\nimport algebra.field\n\ntheorem cpge_group_3_a {G1 : Type*} [group G1] {G2 : Type*} [group G2] \n                      (H : (subgroup G1)) (f : (G1 \u2192* G2) ) : is_subgroup (f '' H) := sorry\n"}
{"text": "From Coq Require Import\n     ssreflect\n.\n\nFrom ExtensibleCompiler.Theory Require Import\n     IndexedAlgebra\n     IndexedFunctor\n     IndexedSubFunctor\n     IndexedSum1\n     UniversalProperty\n.\n\nLocal Open Scope SubFunctor.\nLocal Open Scope Sum1.\n\nClass IndexedProofAlgebra (* cf. [iPAlgebra] *)\n      (Tag : Set) {I} F `{IndexedFunctor I F} A :=\n  {\n    indexedProofAlgebra (* cf. [ip_algebra] *)\n    : IndexedAlgebra F A;\n  }.\n\nDefinition indexedProofAlgebra'\n           {Tag I F A}\n           `{IndexedFunctor I F}\n           (PA : IndexedProofAlgebra Tag F A)\n  : IndexedAlgebra F A\n  := indexedProofAlgebra (IndexedProofAlgebra := PA).\n\nGlobal Instance\n       IndexedProofAlgebra__Sum1\n       {Tag I} F G {A}\n       `{IndexedFunctor I F} `{IndexedFunctor I G}\n       {FAlg : IndexedProofAlgebra Tag F A}\n       {GAlg : IndexedProofAlgebra Tag G A}\n  : IndexedProofAlgebra Tag (F + G) A\n  :=\n    {|\n      indexedProofAlgebra :=\n        fun i fg =>\n          match fg with\n          | iinl1 f => indexedProofAlgebra i f\n          | iinr1 g => indexedProofAlgebra i g\n          end\n      ;\n    |}.\n\nClass WellFormedIndexedProofAlgebra (* cf. [iWF_Ind] *)\n      {Tag I F G}\n      `{IndexedFunctor I F} `{IndexedFunctor I G}\n      `{S : ! IndexedSubFunctor F G}\n      {P : forall i, IndexedFix G i -> Prop}\n      `(PA : ! IndexedProofAlgebra Tag F (fun i => sig (P i)))\n  :=\n    {\n      indexedProjEq\n      : forall i e,\n        proj1_sig (indexedProofAlgebra (IndexedProofAlgebra := PA) i e)\n        =\n        iWrapF i (iInj (IndexedSubFunctor := S) (indexedFmap i (fun i => proj1_sig (P := P i)) e));\n    }.\n\n(** TODO: document why we need this *)\nClass WellFormedIndexedProofAlgebra2 (* cf. [WF_Ind2] *)\n      {Tag I F G H}\n      `{IndexedFunctor I F} `{IndexedFunctor I G} `{IndexedFunctor I H}\n      `{SG : ! IndexedSubFunctor F G} `{SH : ! IndexedSubFunctor F H}\n      {P : forall i, (IndexedFix G i * IndexedFix H i) -> Prop}\n      `(PA : ! IndexedProofAlgebra Tag F (fun i => sig (P i)))\n  :=\n    {\n      proj1Eq\n      : forall i e,\n        fst (proj1_sig (indexedProofAlgebra (IndexedProofAlgebra := PA) i e))\n        =\n        iWrapF i (iInj (IndexedSubFunctor := SG)\n                       (indexedFmap i (fun i e => fst (proj1_sig (P := P i) e)) e));\n      proj2Eq\n      : forall i e,\n        snd (proj1_sig (indexedProofAlgebra (IndexedProofAlgebra := PA) i e))\n        =\n        iWrapF i (iInj (IndexedSubFunctor := SH)\n                       (indexedFmap i (fun i e => snd (proj1_sig (P := P i) e)) e));\n    }.\n"}
{"text": "--=============================--\n------ L\u00d3GICA PROPOSICIONAL------\n--=============================--\n\n-- En l\u00f3gica cl\u00e1sica, la doble negaci\u00f3n de p y p son equivalentes\ntheorem iff_not_not {p : Prop} : \u00ac\u00acp \u2194 p := \n  Iff.intro\n  Classical.byContradiction\n  (fun hp : p => fun hnp : \u00acp => (hnp hp))\n\n\ntheorem notfalse_iff_true : \u00acFalse \u2194 True :=\n  \u27e8fun _ => True.intro, fun _ hfalse => hfalse\u27e9\n\ntheorem nottrue_iff_false : \u00acTrue \u2194 False :=\n  \u27e8fun hnottrue => hnottrue True.intro, fun hfalse => hfalse.elim\u27e9  \n\ntheorem forall_of_not_exists {p : \u03b1 \u2192 Prop} : \u00ac (\u2203 a, p a) \u2192 \u2200 a, \u00ac p a :=\n  fun h a hpa => h \u27e8a,hpa\u27e9\n\n-- El contrarrec\u00edproco de una implicaci\u00f3n\ntheorem contrapositive {p q : Prop} : (p \u2192 q) \u2192 \u00acq \u2192 \u00acp :=\n  fun hpq hnq hp => hnq (hpq hp)\n\ntheorem implies_of_not_and {p q : Prop} : \u00ac (p \u2227 q) \u2192 (p \u2192 \u00ac q) :=\n  fun hnpq hp hq => hnpq \u27e8hp,hq\u27e9\n\ntheorem or_not_iff_not_and {p q : Prop} : \u00ac (p \u2227 q) \u2194 \u00acp \u2228 \u00acq := \n  \u27e8fun hnpq : \u00ac(p \u2227 q) =>\n    Or.elim (Classical.em p)\n    (fun hp => Or.inr (fun hq => hnpq \u27e8hp,hq\u27e9))\n    (fun hnp => Or.inl hnp),\n  fun hnpnq : \u00acp \u2228 \u00acq =>\n    fun \u27e8hp,hq\u27e9 => hnpnq.elim (fun hnp => hnp hp) (fun hnq => hnq hq)\u27e9\n\n-- Una de las leyes de De Morgan\ntheorem and_or_iff {p q1 q2: Prop} : p \u2227 (q1 \u2228 q2) \u2194 (p \u2227 q1) \u2228 (p \u2227 q2) :=\n  \u27e8fun h => h.right.elim (fun hq1 => Or.inl \u27e8h.left,hq1\u27e9) (fun hq2 => Or.inr \u27e8h.left,hq2\u27e9),\n  fun h => h.elim (fun hpq1 => \u27e8hpq1.left, Or.inl hpq1.right\u27e9) (fun hpq2 => \u27e8hpq2.left, Or.inr hpq2.right\u27e9)\u27e9\n\n-- El rec\u00edproco del principio de extensionalidad funcional\ntheorem funext_converse {f g : \u03b1 \u2192 \u03b2} : f \u2260 g \u2192 \u2203 x : \u03b1, f x \u2260 g x :=\n  fun hneq =>\n    Classical.byContradiction (fun hnotex => \n      have hforall1 : \u2200 x, \u00ac f x \u2260 g x := forall_of_not_exists hnotex\n      have hforall : \u2200 x, f x = g x := fun x => propext (@iff_not_not (f x = g x)) \u25b8 (hforall1 x)\n      hneq (funext hforall))"}
{"text": "### A Pluto.jl notebook ###\n# v0.18.4\n\nusing Markdown\nusing InteractiveUtils\n\n# \u2554\u2550\u2561 89efa14e-b00c-11ec-09fe-15316ef94166\n1+1\n\n# \u2554\u2550\u2561 00000000-0000-0000-0000-000000000001\nPLUTO_PROJECT_TOML_CONTENTS = \"\"\"\n[deps]\n\"\"\"\n\n# \u2554\u2550\u2561 00000000-0000-0000-0000-000000000002\nPLUTO_MANIFEST_TOML_CONTENTS = \"\"\"\n# This file is machine-generated - editing it directly is not advised\n\njulia_version = \"1.7.2\"\nmanifest_format = \"2.0\"\n\n[deps]\n\"\"\"\n\n# \u2554\u2550\u2561 Cell order:\n# \u2560\u255089efa14e-b00c-11ec-09fe-15316ef94166\n# \u255f\u250000000000-0000-0000-0000-000000000001\n# \u255f\u250000000000-0000-0000-0000-000000000002\n"}
{"text": "module Main where\n\nimport Control.DeepSeq (NFData)\nimport Data.Complex (Complex((:+)))\nimport Data.Function (on)\n\ntest1 :: Int\ntest1 = undefined\n\ntest2 :: a -> a -> Complex a\ntest2 = (:+)\n\ntest25 :: NFData a => a\ntest25 = undefined\n\ntest3 :: (b -> b -> c) -> (a -> b) -> a -> a -> c\ntest3 = on\n\ntest4 :: IO ()\ntest4 = putStrLn \"Bar\"\n\ntest5 :: [t] -> ()\ntest5 (_:_) = ()\ntest5 _ = error \"test5\"\n\n-- hlint\ntest6 :: [Integer] -> [Integer]\ntest6 = map ((+ 1) . (* 2))\n"}
{"text": "lemma dist_add_cancel2 [simp]: \"dist (b + a) (c + a) = dist b c\""}
{"text": "# Here . and , print and read an integer, not a character\nBrainfuck := function(prog)\n  local pointer, stack, leftcells, rightcells, instr, stackptr, len,\n    output, input, jump, i, j, set, get;\n  input := InputTextUser();\n  output := OutputTextUser();\n  instr := 1;\n  pointer := 0;\n  leftcells := [ ];\n  rightcells := [ ];\n  stack := [ ];\n  stackptr := 0;\n  len := Length(prog);\n  jump := [ ];\n\n  get := function()\n    local p;\n    if pointer >= 0 then\n      p := pointer + 1;\n      if IsBound(rightcells[p]) then\n        return rightcells[p];\n      else\n        return 0;\n      fi;\n    else\n      p := -pointer;\n      if IsBound(leftcells[p]) then\n        return leftcells[p];\n      else\n        return 0;\n      fi;\n    fi;\n  end;\n\n  set := function(value)\n    local p;\n    if pointer >= 0 then\n      p := pointer + 1;\n      if value = 0 then\n        Unbind(rightcells[p]);\n      else\n        rightcells[p] := value;\n      fi;\n    else\n      p := -pointer;\n      if value = 0 then\n        Unbind(leftcells[p]);\n      else\n        leftcells[p] := value;\n      fi;\n    fi;\n  end;\n\n  # find jumps for faster execution\n  for i in [1 .. len] do\n    if prog[i] = '[' then\n      stackptr := stackptr + 1;\n      stack[stackptr] := i;\n    elif prog[i] = ']' then\n      j := stack[stackptr];\n      stackptr := stackptr - 1;\n      jump[i] := j;\n      jump[j] := i;\n    fi;\n  od;\n\n  while instr <= len do\n    c := prog[instr];\n    if c = '<' then\n      pointer := pointer - 1;\n    elif c = '>' then\n      pointer := pointer + 1;\n    elif c = '+' then\n      set(get() + 1);\n    elif c = '-' then\n      set(get() - 1);\n    elif c = '.' then\n      WriteLine(output, String(get()));\n    elif c = ',' then\n      set(Int(Chomp(ReadLine(input))));\n    elif c = '[' then\n      if get() = 0 then\n        instr := jump[instr];\n      fi;\n    elif c = ']' then\n      if get() <> 0 then\n        instr := jump[instr];\n      fi;\n    fi;\n    instr := instr + 1;\n  od;\n  CloseStream(input);\n  CloseStream(output);\n  # for debugging purposes, return last state\n  return [leftcells, rightcells, pointer];\nend;\n\n# An addition\nBrainfuck(\"+++.<+++++.[->+<]>.\");\n# 3\n# 5\n# 8\n"}
{"text": "[GOAL]\n\u22a2 \u03c6 1 = 1\n[PROOFSTEP]\nsimp [totient]\n[GOAL]\nn : \u2115\n\u22a2 \u03c6 n = Nat.card \u2191{m | m < n \u2227 coprime n m}\n[PROOFSTEP]\nlet e : {m | m < n \u2227 n.coprime m} \u2243 Finset.filter n.coprime (Finset.range n) :=\n  { toFun := fun m => \u27e8m, by simpa only [Finset.mem_filter, Finset.mem_range] using m.property\u27e9\n    invFun := fun m => \u27e8m, by simpa only [Finset.mem_filter, Finset.mem_range] using m.property\u27e9\n    left_inv := fun m => by simp only [Subtype.coe_mk, Subtype.coe_eta]\n    right_inv := fun m => by simp only [Subtype.coe_mk, Subtype.coe_eta] }\n[GOAL]\nn : \u2115\nm : \u2191{m | m < n \u2227 coprime n m}\n\u22a2 \u2191m \u2208 filter (coprime n) (range n)\n[PROOFSTEP]\nsimpa only [Finset.mem_filter, Finset.mem_range] using m.property\n[GOAL]\nn : \u2115\nm : { x // x \u2208 filter (coprime n) (range n) }\n\u22a2 \u2191m \u2208 {m | m < n \u2227 coprime n m}\n[PROOFSTEP]\nsimpa only [Finset.mem_filter, Finset.mem_range] using m.property\n[GOAL]\nn : \u2115\nm : \u2191{m | m < n \u2227 coprime n m}\n\u22a2 (fun m => { val := \u2191m, property := (_ : \u2191m < n \u2227 coprime n \u2191m) })\n      ((fun m => { val := \u2191m, property := (_ : \u2191m \u2208 filter (coprime n) (range n)) }) m) =\n    m\n[PROOFSTEP]\nsimp only [Subtype.coe_mk, Subtype.coe_eta]\n[GOAL]\nn : \u2115\nm : { x // x \u2208 filter (coprime n) (range n) }\n\u22a2 (fun m => { val := \u2191m, property := (_ : \u2191m \u2208 filter (coprime n) (range n)) })\n      ((fun m => { val := \u2191m, property := (_ : \u2191m < n \u2227 coprime n \u2191m) }) m) =\n    m\n[PROOFSTEP]\nsimp only [Subtype.coe_mk, Subtype.coe_eta]\n[GOAL]\nn : \u2115\ne : \u2191{m | m < n \u2227 coprime n m} \u2243 { x // x \u2208 filter (coprime n) (range n) } :=\n  { toFun := fun m => { val := \u2191m, property := (_ : \u2191m \u2208 filter (coprime n) (range n)) },\n    invFun := fun m => { val := \u2191m, property := (_ : \u2191m < n \u2227 coprime n \u2191m) },\n    left_inv :=\n      (_ :\n        \u2200 (m : \u2191{m | m < n \u2227 coprime n m}),\n          { val := \u2191m,\n              property :=\n                (_ :\n                  \u2191((fun m => { val := \u2191m, property := (_ : \u2191m \u2208 filter (coprime n) (range n)) }) m) < n \u2227\n                    coprime n \u2191((fun m => { val := \u2191m, property := (_ : \u2191m \u2208 filter (coprime n) (range n)) }) m)) } =\n            m),\n    right_inv :=\n      (_ :\n        \u2200 (m : { x // x \u2208 filter (coprime n) (range n) }),\n          { val := \u2191m,\n              property :=\n                (_ :\n                  \u2191((fun m => { val := \u2191m, property := (_ : \u2191m < n \u2227 coprime n \u2191m) }) m) \u2208\n                    filter (coprime n) (range n)) } =\n            m) }\n\u22a2 \u03c6 n = Nat.card \u2191{m | m < n \u2227 coprime n m}\n[PROOFSTEP]\nrw [totient_eq_card_coprime, card_congr e, card_eq_fintype_card, Fintype.card_coe]\n[GOAL]\nn : \u2115\nhn : 1 < n\n\u22a2 0 \u2208 range n \u2227 \u00accoprime n 0\n[PROOFSTEP]\nsimp [hn.ne', pos_of_gt hn]\n[GOAL]\n\u22a2 0 < 0 \u2192 0 < \u03c6 0\n[PROOFSTEP]\ndecide\n[GOAL]\n\u22a2 0 < 1 \u2192 0 < \u03c6 1\n[PROOFSTEP]\nsimp [totient]\n[GOAL]\nn : \u2115\nx\u271d : 0 < n + 2\n\u22a2 1 < n + 2\n[PROOFSTEP]\nsimp\n[GOAL]\na n : \u2115\n\u22a2 card (filter (coprime a) (Ico n (n + a))) = \u03c6 a\n[PROOFSTEP]\nrw [totient, filter_Ico_card_eq_of_periodic, count_eq_card_filter_range]\n[GOAL]\ncase pp\na n : \u2115\n\u22a2 Function.Periodic (coprime a) a\n[PROOFSTEP]\nexact periodic_coprime a\n[GOAL]\na k n : \u2115\na_pos : 0 < a\n\u22a2 card (filter (coprime a) (Ico k (k + n))) \u2264 \u03c6 a * (n / a + 1)\n[PROOFSTEP]\nconv_lhs => rw [\u2190 Nat.mod_add_div n a]\n[GOAL]\na k n : \u2115\na_pos : 0 < a\n| card (filter (coprime a) (Ico k (k + n)))\n[PROOFSTEP]\nrw [\u2190 Nat.mod_add_div n a]\n[GOAL]\na k n : \u2115\na_pos : 0 < a\n| card (filter (coprime a) (Ico k (k + n)))\n[PROOFSTEP]\nrw [\u2190 Nat.mod_add_div n a]\n[GOAL]\na k n : \u2115\na_pos : 0 < a\n| card (filter (coprime a) (Ico k (k + n)))\n[PROOFSTEP]\nrw [\u2190 Nat.mod_add_div n a]\n[GOAL]\na k n : \u2115\na_pos : 0 < a\n\u22a2 card (filter (coprime a) (Ico k (k + (n % a + a * (n / a))))) \u2264 \u03c6 a * (n / a + 1)\n[PROOFSTEP]\ninduction' n / a with i ih\n[GOAL]\ncase zero\na k n : \u2115\na_pos : 0 < a\n\u22a2 card (filter (coprime a) (Ico k (k + (n % a + a * zero)))) \u2264 \u03c6 a * (zero + 1)\n[PROOFSTEP]\nrw [\u2190 filter_coprime_Ico_eq_totient a k]\n[GOAL]\ncase zero\na k n : \u2115\na_pos : 0 < a\n\u22a2 card (filter (coprime a) (Ico k (k + (n % a + a * zero)))) \u2264 card (filter (coprime a) (Ico k (k + a))) * (zero + 1)\n[PROOFSTEP]\nsimp only [add_zero, mul_one, mul_zero, le_of_lt (mod_lt n a_pos), Nat.zero_eq, zero_add]\n  --Porting note: below line was `mono`\n[GOAL]\ncase zero\na k n : \u2115\na_pos : 0 < a\n\u22a2 card (filter (coprime a) (Ico k (k + n % a))) \u2264 card (filter (coprime a) (Ico k (k + a)))\n[PROOFSTEP]\nrefine Finset.card_mono ?_\n[GOAL]\ncase zero\na k n : \u2115\na_pos : 0 < a\n\u22a2 filter (coprime a) (Ico k (k + n % a)) \u2264 filter (coprime a) (Ico k (k + a))\n[PROOFSTEP]\nrefine' monotone_filter_left a.coprime _\n[GOAL]\ncase zero\na k n : \u2115\na_pos : 0 < a\n\u22a2 Ico k (k + n % a) \u2264 Ico k (k + a)\n[PROOFSTEP]\nsimp only [Finset.le_eq_subset]\n[GOAL]\ncase zero\na k n : \u2115\na_pos : 0 < a\n\u22a2 Ico k (k + n % a) \u2286 Ico k (k + a)\n[PROOFSTEP]\nexact Ico_subset_Ico rfl.le (add_le_add_left (le_of_lt (mod_lt n a_pos)) k)\n[GOAL]\ncase succ\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + (n % a + a * i)))) \u2264 \u03c6 a * (i + 1)\n\u22a2 card (filter (coprime a) (Ico k (k + (n % a + a * succ i)))) \u2264 \u03c6 a * (succ i + 1)\n[PROOFSTEP]\nsimp only [mul_succ]\n[GOAL]\ncase succ\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + (n % a + a * i)))) \u2264 \u03c6 a * (i + 1)\n\u22a2 card (filter (coprime a) (Ico k (k + (n % a + (a * i + a))))) \u2264 \u03c6 a * i + \u03c6 a + \u03c6 a\n[PROOFSTEP]\nsimp_rw [\u2190 add_assoc] at ih \u22a2\n[GOAL]\ncase succ\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 card (filter (coprime a) (Ico k (k + n % a + a * i + a))) \u2264 \u03c6 a * i + \u03c6 a + \u03c6 a\n[PROOFSTEP]\ncalc\n  (filter a.coprime (Ico k (k + n % a + a * i + a))).card =\n      (filter a.coprime (Ico k (k + n % a + a * i) \u222a Ico (k + n % a + a * i) (k + n % a + a * i + a))).card :=\n    by\n    congr\n    rw [Ico_union_Ico_eq_Ico]\n    rw [add_assoc]\n    exact le_self_add\n    exact le_self_add\n  _ \u2264 (filter a.coprime (Ico k (k + n % a + a * i))).card + a.totient :=\n    by\n    rw [filter_union, \u2190 filter_coprime_Ico_eq_totient a (k + n % a + a * i)]\n    apply card_union_le\n  _ \u2264 a.totient * i + a.totient + a.totient := add_le_add_right ih (totient a)\n[GOAL]\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 card (filter (coprime a) (Ico k (k + n % a + a * i + a))) =\n    card (filter (coprime a) (Ico k (k + n % a + a * i) \u222a Ico (k + n % a + a * i) (k + n % a + a * i + a)))\n[PROOFSTEP]\ncongr\n[GOAL]\ncase e_s.e_s\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 Ico k (k + n % a + a * i + a) = Ico k (k + n % a + a * i) \u222a Ico (k + n % a + a * i) (k + n % a + a * i + a)\n[PROOFSTEP]\nrw [Ico_union_Ico_eq_Ico]\n[GOAL]\ncase e_s.e_s.hab\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 k \u2264 k + n % a + a * i\ncase e_s.e_s.hbc\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 k + n % a + a * i \u2264 k + n % a + a * i + a\n[PROOFSTEP]\nrw [add_assoc]\n[GOAL]\ncase e_s.e_s.hab\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 k \u2264 k + (n % a + a * i)\ncase e_s.e_s.hbc\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 k + n % a + a * i \u2264 k + n % a + a * i + a\n[PROOFSTEP]\nexact le_self_add\n[GOAL]\ncase e_s.e_s.hbc\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 k + n % a + a * i \u2264 k + n % a + a * i + a\n[PROOFSTEP]\nexact le_self_add\n[GOAL]\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 card (filter (coprime a) (Ico k (k + n % a + a * i) \u222a Ico (k + n % a + a * i) (k + n % a + a * i + a))) \u2264\n    card (filter (coprime a) (Ico k (k + n % a + a * i))) + \u03c6 a\n[PROOFSTEP]\nrw [filter_union, \u2190 filter_coprime_Ico_eq_totient a (k + n % a + a * i)]\n[GOAL]\na k n : \u2115\na_pos : 0 < a\ni : \u2115\nih : card (filter (coprime a) (Ico k (k + n % a + a * i))) \u2264 \u03c6 a * (i + 1)\n\u22a2 card\n      (filter (coprime a) (Ico k (k + n % a + a * i)) \u222a\n        filter (coprime a) (Ico (k + n % a + a * i) (k + n % a + a * i + a))) \u2264\n    card (filter (coprime a) (Ico k (k + n % a + a * i))) +\n      card (filter (coprime a) (Ico (k + n % a + a * i) (k + n % a + a * i + a)))\n[PROOFSTEP]\napply card_union_le\n[GOAL]\nn : \u2115\ninst\u271d\u00b9 : NeZero n\ninst\u271d : Fintype (ZMod n)\u02e3\n\u22a2 Fintype.card { x // coprime (ZMod.val x) n } = \u03c6 n\n[PROOFSTEP]\nobtain \u27e8m, rfl\u27e9 : \u2203 m, n = m + 1 := exists_eq_succ_of_ne_zero NeZero.out\n[GOAL]\ncase intro\nm : \u2115\ninst\u271d\u00b9 : NeZero (m + 1)\ninst\u271d : Fintype (ZMod (m + 1))\u02e3\n\u22a2 Fintype.card { x // coprime (ZMod.val x) (m + 1) } = \u03c6 (m + 1)\n[PROOFSTEP]\nsimp only [totient, Finset.card_eq_sum_ones, Fintype.card_subtype, Finset.sum_filter, \u2190 Fin.sum_univ_eq_sum_range,\n  @Nat.coprime_comm (m + 1)]\n[GOAL]\ncase intro\nm : \u2115\ninst\u271d\u00b9 : NeZero (m + 1)\ninst\u271d : Fintype (ZMod (m + 1))\u02e3\n\u22a2 (\u2211 a : ZMod (m + 1), if coprime (ZMod.val a) (m + 1) then 1 else 0) =\n    \u2211 i : Fin (m + 1), if coprime (\u2191i) (m + 1) then 1 else 0\n[PROOFSTEP]\nrfl\n[GOAL]\nn : \u2115\nhn : 2 < n\n\u22a2 Even (\u03c6 n)\n[PROOFSTEP]\nhaveI : Fact (1 < n) := \u27e8one_lt_two.trans hn\u27e9\n[GOAL]\nn : \u2115\nhn : 2 < n\nthis : Fact (1 < n)\n\u22a2 Even (\u03c6 n)\n[PROOFSTEP]\nhaveI : NeZero n := NeZero.of_gt hn\n[GOAL]\nn : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 Even (\u03c6 n)\n[PROOFSTEP]\nsuffices 2 = orderOf (-1 : (ZMod n)\u02e3)\n  by\n  rw [\u2190 ZMod.card_units_eq_totient, even_iff_two_dvd, this]\n  exact orderOf_dvd_card_univ\n[GOAL]\nn : \u2115\nhn : 2 < n\nthis\u271d\u00b9 : Fact (1 < n)\nthis\u271d : NeZero n\nthis : 2 = orderOf (-1)\n\u22a2 Even (\u03c6 n)\n[PROOFSTEP]\nrw [\u2190 ZMod.card_units_eq_totient, even_iff_two_dvd, this]\n[GOAL]\nn : \u2115\nhn : 2 < n\nthis\u271d\u00b9 : Fact (1 < n)\nthis\u271d : NeZero n\nthis : 2 = orderOf (-1)\n\u22a2 orderOf (-1) \u2223 Fintype.card (ZMod n)\u02e3\n[PROOFSTEP]\nexact orderOf_dvd_card_univ\n[GOAL]\nn : \u2115\nhn : 2 < n\nthis\u271d : Fact (1 < n)\nthis : NeZero n\n\u22a2 2 = orderOf (-1)\n[PROOFSTEP]\nrw [\u2190 orderOf_units, Units.coe_neg_one, orderOf_neg_one, ringChar.eq (ZMod n) n, if_neg hn.ne']\n[GOAL]\nm n : \u2115\nh : coprime m n\nhmn0 : m * n = 0\n\u22a2 \u03c6 (m * n) = \u03c6 m * \u03c6 n\n[PROOFSTEP]\ncases' Nat.mul_eq_zero.1 hmn0 with h h\n[GOAL]\ncase inl\nm n : \u2115\nh\u271d : coprime m n\nhmn0 : m * n = 0\nh : m = 0\n\u22a2 \u03c6 (m * n) = \u03c6 m * \u03c6 n\n[PROOFSTEP]\nsimp only [totient_zero, mul_zero, zero_mul, h]\n[GOAL]\ncase inr\nm n : \u2115\nh\u271d : coprime m n\nhmn0 : m * n = 0\nh : n = 0\n\u22a2 \u03c6 (m * n) = \u03c6 m * \u03c6 n\n[PROOFSTEP]\nsimp only [totient_zero, mul_zero, zero_mul, h]\n[GOAL]\nm n : \u2115\nh : coprime m n\nhmn0 : \u00acm * n = 0\n\u22a2 \u03c6 (m * n) = \u03c6 m * \u03c6 n\n[PROOFSTEP]\nhaveI : NeZero (m * n) := \u27e8hmn0\u27e9\n[GOAL]\nm n : \u2115\nh : coprime m n\nhmn0 : \u00acm * n = 0\nthis : NeZero (m * n)\n\u22a2 \u03c6 (m * n) = \u03c6 m * \u03c6 n\n[PROOFSTEP]\nhaveI : NeZero m := \u27e8left_ne_zero_of_mul hmn0\u27e9\n[GOAL]\nm n : \u2115\nh : coprime m n\nhmn0 : \u00acm * n = 0\nthis\u271d : NeZero (m * n)\nthis : NeZero m\n\u22a2 \u03c6 (m * n) = \u03c6 m * \u03c6 n\n[PROOFSTEP]\nhaveI : NeZero n := \u27e8right_ne_zero_of_mul hmn0\u27e9\n[GOAL]\nm n : \u2115\nh : coprime m n\nhmn0 : \u00acm * n = 0\nthis\u271d\u00b9 : NeZero (m * n)\nthis\u271d : NeZero m\nthis : NeZero n\n\u22a2 \u03c6 (m * n) = \u03c6 m * \u03c6 n\n[PROOFSTEP]\nsimp only [\u2190 ZMod.card_units_eq_totient]\n[GOAL]\nm n : \u2115\nh : coprime m n\nhmn0 : \u00acm * n = 0\nthis\u271d\u00b9 : NeZero (m * n)\nthis\u271d : NeZero m\nthis : NeZero n\n\u22a2 Fintype.card (ZMod (m * n))\u02e3 = Fintype.card (ZMod m)\u02e3 * Fintype.card (ZMod n)\u02e3\n[PROOFSTEP]\nrw [Fintype.card_congr (Units.mapEquiv (ZMod.chineseRemainder h).toMulEquiv).toEquiv,\n  Fintype.card_congr (@MulEquiv.prodUnits (ZMod m) (ZMod n) _ _).toEquiv, Fintype.card_prod]\n[GOAL]\nn d : \u2115\nhnd : d \u2223 n\n\u22a2 \u03c6 (n / d) = Finset.card (filter (fun k => gcd n k = d) (range n))\n[PROOFSTEP]\nrcases d.eq_zero_or_pos with (rfl | hd0)\n[GOAL]\ncase inl\nn : \u2115\nhnd : 0 \u2223 n\n\u22a2 \u03c6 (n / 0) = Finset.card (filter (fun k => gcd n k = 0) (range n))\n[PROOFSTEP]\nsimp [eq_zero_of_zero_dvd hnd]\n[GOAL]\ncase inr\nn d : \u2115\nhnd : d \u2223 n\nhd0 : d > 0\n\u22a2 \u03c6 (n / d) = Finset.card (filter (fun k => gcd n k = d) (range n))\n[PROOFSTEP]\nrcases hnd with \u27e8x, rfl\u27e9\n[GOAL]\ncase inr.intro\nd : \u2115\nhd0 : d > 0\nx : \u2115\n\u22a2 \u03c6 (d * x / d) = Finset.card (filter (fun k => gcd (d * x) k = d) (range (d * x)))\n[PROOFSTEP]\nrw [Nat.mul_div_cancel_left x hd0]\n[GOAL]\ncase inr.intro\nd : \u2115\nhd0 : d > 0\nx : \u2115\n\u22a2 \u03c6 x = Finset.card (filter (fun k => gcd (d * x) k = d) (range (d * x)))\n[PROOFSTEP]\napply Finset.card_congr fun k _ => d * k\n[GOAL]\ncase inr.intro.h\u2081\nd : \u2115\nhd0 : d > 0\nx : \u2115\n\u22a2 \u2200 (a : \u2115), a \u2208 filter (coprime x) (range x) \u2192 d * a \u2208 filter (fun k => gcd (d * x) k = d) (range (d * x))\n[PROOFSTEP]\nsimp only [mem_filter, mem_range, and_imp, coprime]\n[GOAL]\ncase inr.intro.h\u2081\nd : \u2115\nhd0 : d > 0\nx : \u2115\n\u22a2 \u2200 (a : \u2115), a < x \u2192 gcd x a = 1 \u2192 d * a < d * x \u2227 gcd (d * x) (d * a) = d\n[PROOFSTEP]\nrefine' fun a ha1 ha2 => \u27e8(mul_lt_mul_left hd0).2 ha1, _\u27e9\n[GOAL]\ncase inr.intro.h\u2081\nd : \u2115\nhd0 : d > 0\nx a : \u2115\nha1 : a < x\nha2 : gcd x a = 1\n\u22a2 gcd (d * x) (d * a) = d\n[PROOFSTEP]\nrw [gcd_mul_left, ha2, mul_one]\n[GOAL]\ncase inr.intro.h\u2082\nd : \u2115\nhd0 : d > 0\nx : \u2115\n\u22a2 \u2200 (a b : \u2115), a \u2208 filter (coprime x) (range x) \u2192 b \u2208 filter (coprime x) (range x) \u2192 d * a = d * b \u2192 a = b\n[PROOFSTEP]\nsimp [hd0.ne']\n[GOAL]\ncase inr.intro.h\u2083\nd : \u2115\nhd0 : d > 0\nx : \u2115\n\u22a2 \u2200 (b : \u2115), b \u2208 filter (fun k => gcd (d * x) k = d) (range (d * x)) \u2192 \u2203 a ha, d * a = b\n[PROOFSTEP]\nsimp only [mem_filter, mem_range, exists_prop, and_imp]\n[GOAL]\ncase inr.intro.h\u2083\nd : \u2115\nhd0 : d > 0\nx : \u2115\n\u22a2 \u2200 (b : \u2115), b < d * x \u2192 gcd (d * x) b = d \u2192 \u2203 a, (a < x \u2227 coprime x a) \u2227 d * a = b\n[PROOFSTEP]\nrefine' fun b hb1 hb2 => _\n[GOAL]\ncase inr.intro.h\u2083\nd : \u2115\nhd0 : d > 0\nx b : \u2115\nhb1 : b < d * x\nhb2 : gcd (d * x) b = d\n\u22a2 \u2203 a, (a < x \u2227 coprime x a) \u2227 d * a = b\n[PROOFSTEP]\nhave : d \u2223 b := by\n  rw [\u2190 hb2]\n  apply gcd_dvd_right\n[GOAL]\nd : \u2115\nhd0 : d > 0\nx b : \u2115\nhb1 : b < d * x\nhb2 : gcd (d * x) b = d\n\u22a2 d \u2223 b\n[PROOFSTEP]\nrw [\u2190 hb2]\n[GOAL]\nd : \u2115\nhd0 : d > 0\nx b : \u2115\nhb1 : b < d * x\nhb2 : gcd (d * x) b = d\n\u22a2 gcd (d * x) b \u2223 b\n[PROOFSTEP]\napply gcd_dvd_right\n[GOAL]\ncase inr.intro.h\u2083\nd : \u2115\nhd0 : d > 0\nx b : \u2115\nhb1 : b < d * x\nhb2 : gcd (d * x) b = d\nthis : d \u2223 b\n\u22a2 \u2203 a, (a < x \u2227 coprime x a) \u2227 d * a = b\n[PROOFSTEP]\nrcases this with \u27e8q, rfl\u27e9\n[GOAL]\ncase inr.intro.h\u2083.intro\nd : \u2115\nhd0 : d > 0\nx q : \u2115\nhb1 : d * q < d * x\nhb2 : gcd (d * x) (d * q) = d\n\u22a2 \u2203 a, (a < x \u2227 coprime x a) \u2227 d * a = d * q\n[PROOFSTEP]\nrefine' \u27e8q, \u27e8\u27e8(mul_lt_mul_left hd0).1 hb1, _\u27e9, rfl\u27e9\u27e9\n[GOAL]\ncase inr.intro.h\u2083.intro\nd : \u2115\nhd0 : d > 0\nx q : \u2115\nhb1 : d * q < d * x\nhb2 : gcd (d * x) (d * q) = d\n\u22a2 coprime x q\n[PROOFSTEP]\nrwa [gcd_mul_left, mul_right_eq_self_iff hd0] at hb2 \n[GOAL]\nn : \u2115\n\u22a2 Finset.sum (divisors n) \u03c6 = n\n[PROOFSTEP]\nrcases n.eq_zero_or_pos with (rfl | hn)\n[GOAL]\ncase inl\n\u22a2 Finset.sum (divisors 0) \u03c6 = 0\n[PROOFSTEP]\nsimp\n[GOAL]\ncase inr\nn : \u2115\nhn : n > 0\n\u22a2 Finset.sum (divisors n) \u03c6 = n\n[PROOFSTEP]\nrw [\u2190 sum_div_divisors n \u03c6]\n[GOAL]\ncase inr\nn : \u2115\nhn : n > 0\n\u22a2 \u2211 d in divisors n, \u03c6 (n / d) = n\n[PROOFSTEP]\nhave : n = \u2211 d : \u2115 in n.divisors, (filter (fun k : \u2115 => n.gcd k = d) (range n)).card :=\n  by\n  nth_rw 1 [\u2190 card_range n]\n  refine' card_eq_sum_card_fiberwise fun x _ => mem_divisors.2 \u27e8_, hn.ne'\u27e9\n  apply gcd_dvd_left\n[GOAL]\nn : \u2115\nhn : n > 0\n\u22a2 n = \u2211 d in divisors n, Finset.card (filter (fun k => gcd n k = d) (range n))\n[PROOFSTEP]\nnth_rw 1 [\u2190 card_range n]\n[GOAL]\nn : \u2115\nhn : n > 0\n\u22a2 Finset.card (range n) = \u2211 d in divisors n, Finset.card (filter (fun k => gcd n k = d) (range n))\n[PROOFSTEP]\nrefine' card_eq_sum_card_fiberwise fun x _ => mem_divisors.2 \u27e8_, hn.ne'\u27e9\n[GOAL]\nn : \u2115\nhn : n > 0\nx : \u2115\nx\u271d : x \u2208 range n\n\u22a2 gcd n x \u2223 n\n[PROOFSTEP]\napply gcd_dvd_left\n[GOAL]\ncase inr\nn : \u2115\nhn : n > 0\nthis : n = \u2211 d in divisors n, Finset.card (filter (fun k => gcd n k = d) (range n))\n\u22a2 \u2211 d in divisors n, \u03c6 (n / d) = n\n[PROOFSTEP]\nnth_rw 3 [this]\n[GOAL]\ncase inr\nn : \u2115\nhn : n > 0\nthis : n = \u2211 d in divisors n, Finset.card (filter (fun k => gcd n k = d) (range n))\n\u22a2 \u2211 d in divisors n, \u03c6 (n / d) = \u2211 d in divisors n, Finset.card (filter (fun k => gcd n k = d) (range n))\n[PROOFSTEP]\nexact sum_congr rfl fun x hx => totient_div_of_dvd (dvd_of_mem_divisors hx)\n[GOAL]\nn : \u2115\n\u22a2 \u2211 m in filter (fun x => x \u2223 n) (range (succ n)), \u03c6 m = n\n[PROOFSTEP]\nconvert sum_totient _ using 1\n[GOAL]\ncase h.e'_2\nn : \u2115\n\u22a2 \u2211 m in filter (fun x => x \u2223 n) (range (succ n)), \u03c6 m = Finset.sum (divisors n) \u03c6\n[PROOFSTEP]\nsimp only [Nat.divisors, sum_filter, range_eq_Ico]\n[GOAL]\ncase h.e'_2\nn : \u2115\n\u22a2 (\u2211 a in Ico 0 (succ n), if a \u2223 n then \u03c6 a else 0) = \u2211 a in Ico 1 (n + 1), if a \u2223 n then \u03c6 a else 0\n[PROOFSTEP]\nrw [sum_eq_sum_Ico_succ_bot]\n[GOAL]\ncase h.e'_2\nn : \u2115\n\u22a2 ((if 0 \u2223 n then \u03c6 0 else 0) + \u2211 k in Ico (0 + 1) (succ n), if k \u2223 n then \u03c6 k else 0) =\n    \u2211 a in Ico 1 (n + 1), if a \u2223 n then \u03c6 a else 0\n[PROOFSTEP]\nsimp\n[GOAL]\ncase h.e'_2.hab\nn : \u2115\n\u22a2 0 < succ n\n[PROOFSTEP]\nsimp\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\n\u22a2 filter (coprime (p ^ (n + 1))) (range (p ^ (n + 1))) = range (p ^ (n + 1)) \\ image (fun x => x * p) (range (p ^ n))\n[PROOFSTEP]\nrw [sdiff_eq_filter]\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\n\u22a2 filter (coprime (p ^ (n + 1))) (range (p ^ (n + 1))) =\n    filter (fun x => \u00acx \u2208 image (fun x => x * p) (range (p ^ n))) (range (p ^ (n + 1)))\n[PROOFSTEP]\napply filter_congr\n[GOAL]\ncase H\np : \u2115\nhp : Prime p\nn : \u2115\n\u22a2 \u2200 (x : \u2115), x \u2208 range (p ^ (n + 1)) \u2192 (coprime (p ^ (n + 1)) x \u2194 \u00acx \u2208 image (fun x => x * p) (range (p ^ n)))\n[PROOFSTEP]\nsimp only [mem_range, mem_filter, coprime_pow_left_iff n.succ_pos, mem_image, not_exists, hp.coprime_iff_not_dvd]\n[GOAL]\ncase H\np : \u2115\nhp : Prime p\nn : \u2115\n\u22a2 \u2200 (x : \u2115), x < p ^ (n + 1) \u2192 (\u00acp \u2223 x \u2194 \u2200 (x_1 : \u2115), \u00ac(x_1 < p ^ n \u2227 x_1 * p = x))\n[PROOFSTEP]\nintro a ha\n[GOAL]\ncase H\np : \u2115\nhp : Prime p\nn a : \u2115\nha : a < p ^ (n + 1)\n\u22a2 \u00acp \u2223 a \u2194 \u2200 (x : \u2115), \u00ac(x < p ^ n \u2227 x * p = a)\n[PROOFSTEP]\nconstructor\n[GOAL]\ncase H.mp\np : \u2115\nhp : Prime p\nn a : \u2115\nha : a < p ^ (n + 1)\n\u22a2 \u00acp \u2223 a \u2192 \u2200 (x : \u2115), \u00ac(x < p ^ n \u2227 x * p = a)\n[PROOFSTEP]\nintro hap b h\n[GOAL]\ncase H.mp\np : \u2115\nhp : Prime p\nn a : \u2115\nha : a < p ^ (n + 1)\nhap : \u00acp \u2223 a\nb : \u2115\nh : b < p ^ n \u2227 b * p = a\n\u22a2 False\n[PROOFSTEP]\nrcases h with \u27e8_, rfl\u27e9\n[GOAL]\ncase H.mp.intro\np : \u2115\nhp : Prime p\nn b : \u2115\nleft\u271d : b < p ^ n\nha : b * p < p ^ (n + 1)\nhap : \u00acp \u2223 b * p\n\u22a2 False\n[PROOFSTEP]\nexact hap (dvd_mul_left _ _)\n[GOAL]\ncase H.mpr\np : \u2115\nhp : Prime p\nn a : \u2115\nha : a < p ^ (n + 1)\n\u22a2 (\u2200 (x : \u2115), \u00ac(x < p ^ n \u2227 x * p = a)) \u2192 \u00acp \u2223 a\n[PROOFSTEP]\nrintro h \u27e8b, rfl\u27e9\n[GOAL]\ncase H.mpr.intro\np : \u2115\nhp : Prime p\nn b : \u2115\nha : p * b < p ^ (n + 1)\nh : \u2200 (x : \u2115), \u00ac(x < p ^ n \u2227 x * p = p * b)\n\u22a2 False\n[PROOFSTEP]\nrw [pow_succ'] at ha \n[GOAL]\ncase H.mpr.intro\np : \u2115\nhp : Prime p\nn b : \u2115\nha : p * b < p * p ^ n\nh : \u2200 (x : \u2115), \u00ac(x < p ^ n \u2227 x * p = p * b)\n\u22a2 False\n[PROOFSTEP]\nexact h b \u27e8lt_of_mul_lt_mul_left ha (zero_le _), mul_comm _ _\u27e9\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\n\u22a2 Finset.card (range (p ^ (n + 1)) \\ image (fun x => x * p) (range (p ^ n))) = p ^ n * (p - 1)\n[PROOFSTEP]\nhave h1 : Function.Injective (\u00b7 * p) := mul_left_injective\u2080 hp.ne_zero\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\n\u22a2 Finset.card (range (p ^ (n + 1)) \\ image (fun x => x * p) (range (p ^ n))) = p ^ n * (p - 1)\n[PROOFSTEP]\nhave h2 : (range (p ^ n)).image (\u00b7 * p) \u2286 range (p ^ (n + 1)) := fun a =>\n  by\n  simp only [mem_image, mem_range, exists_imp]\n  rintro b \u27e8h, rfl\u27e9\n  rw [pow_succ]\n  exact (mul_lt_mul_right hp.pos).2 h\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\na : \u2115\n\u22a2 a \u2208 image (fun x => x * p) (range (p ^ n)) \u2192 a \u2208 range (p ^ (n + 1))\n[PROOFSTEP]\nsimp only [mem_image, mem_range, exists_imp]\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\na : \u2115\n\u22a2 \u2200 (x : \u2115), x < p ^ n \u2227 x * p = a \u2192 a < p ^ (n + 1)\n[PROOFSTEP]\nrintro b \u27e8h, rfl\u27e9\n[GOAL]\ncase intro\np : \u2115\nhp : Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nb : \u2115\nh : b < p ^ n\n\u22a2 b * p < p ^ (n + 1)\n[PROOFSTEP]\nrw [pow_succ]\n[GOAL]\ncase intro\np : \u2115\nhp : Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nb : \u2115\nh : b < p ^ n\n\u22a2 b * p < p ^ n * p\n[PROOFSTEP]\nexact (mul_lt_mul_right hp.pos).2 h\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\nh1 : Function.Injective fun x => x * p\nh2 : image (fun x => x * p) (range (p ^ n)) \u2286 range (p ^ (n + 1))\n\u22a2 Finset.card (range (p ^ (n + 1)) \\ image (fun x => x * p) (range (p ^ n))) = p ^ n * (p - 1)\n[PROOFSTEP]\nrw [card_sdiff h2, card_image_of_injOn (h1.injOn _), card_range, card_range, \u2190 one_mul (p ^ n), pow_succ', \u2190 tsub_mul,\n  one_mul, mul_comm]\n[GOAL]\np : \u2115\nhp : Prime p\nn : \u2115\nhn : 0 < n\n\u22a2 \u03c6 (p ^ n) = p ^ (n - 1) * (p - 1)\n[PROOFSTEP]\nrcases exists_eq_succ_of_ne_zero (pos_iff_ne_zero.1 hn) with \u27e8m, rfl\u27e9\n[GOAL]\ncase intro\np : \u2115\nhp : Prime p\nm : \u2115\nhn : 0 < succ m\n\u22a2 \u03c6 (p ^ succ m) = p ^ (succ m - 1) * (p - 1)\n[PROOFSTEP]\nexact totient_prime_pow_succ hp _\n[GOAL]\np : \u2115\nhp : Prime p\n\u22a2 \u03c6 p = p - 1\n[PROOFSTEP]\nrw [\u2190 pow_one p, totient_prime_pow hp]\n[GOAL]\np : \u2115\nhp : Prime p\n\u22a2 p ^ (1 - 1) * (p - 1) = p ^ 1 - 1\n[PROOFSTEP]\nsimp\n[GOAL]\np : \u2115\nhp : Prime p\n\u22a2 0 < 1\n[PROOFSTEP]\nsimp\n[GOAL]\np : \u2115\nhp : 0 < p\n\u22a2 \u03c6 p = p - 1 \u2194 Prime p\n[PROOFSTEP]\nrefine' \u27e8fun h => _, totient_prime\u27e9\n[GOAL]\np : \u2115\nhp : 0 < p\nh : \u03c6 p = p - 1\n\u22a2 Prime p\n[PROOFSTEP]\nreplace hp : 1 < p\n[GOAL]\ncase hp\np : \u2115\nhp : 0 < p\nh : \u03c6 p = p - 1\n\u22a2 1 < p\n[PROOFSTEP]\napply lt_of_le_of_ne\n[GOAL]\ncase hp.a\np : \u2115\nhp : 0 < p\nh : \u03c6 p = p - 1\n\u22a2 1 \u2264 p\n[PROOFSTEP]\nrwa [succ_le_iff]\n[GOAL]\ncase hp.a\np : \u2115\nhp : 0 < p\nh : \u03c6 p = p - 1\n\u22a2 1 \u2260 p\n[PROOFSTEP]\nrintro rfl\n[GOAL]\ncase hp.a\nhp : 0 < 1\nh : \u03c6 1 = 1 - 1\n\u22a2 False\n[PROOFSTEP]\nrw [totient_one, tsub_self] at h \n[GOAL]\ncase hp.a\nhp : 0 < 1\nh\u271d : 1 = 1 - 1\nh : 1 = 0\n\u22a2 False\n[PROOFSTEP]\nexact one_ne_zero h\n[GOAL]\np : \u2115\nh : \u03c6 p = p - 1\nhp : 1 < p\n\u22a2 Prime p\n[PROOFSTEP]\nrw [totient_eq_card_coprime, range_eq_Ico, \u2190 Ico_insert_succ_left hp.le, Finset.filter_insert,\n  if_neg (not_coprime_of_dvd_of_dvd hp (dvd_refl p) (dvd_zero p)), \u2190 Nat.card_Ico 1 p] at h \n[GOAL]\np : \u2115\nh : Finset.card (filter (coprime p) (Ico (succ 0) p)) = Finset.card (Ico 1 p)\nhp : 1 < p\n\u22a2 Prime p\n[PROOFSTEP]\nrefine' p.prime_of_coprime hp fun n hn hnz => Finset.filter_card_eq h n <| Finset.mem_Ico.mpr \u27e8_, hn\u27e9\n[GOAL]\np : \u2115\nh : Finset.card (filter (coprime p) (Ico (succ 0) p)) = Finset.card (Ico 1 p)\nhp : 1 < p\nn : \u2115\nhn : n < p\nhnz : n \u2260 0\n\u22a2 succ 0 \u2264 n\n[PROOFSTEP]\nrwa [succ_le_iff, pos_iff_ne_zero]\n[GOAL]\np : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\n\u22a2 Fintype.card (ZMod p)\u02e3 \u2264 p - 1\n[PROOFSTEP]\nhaveI : NeZero p := \u27e8(pos_of_gt hp).ne'\u27e9\n[GOAL]\np : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\nthis : NeZero p\n\u22a2 Fintype.card (ZMod p)\u02e3 \u2264 p - 1\n[PROOFSTEP]\nrw [ZMod.card_units_eq_totient p]\n[GOAL]\np : \u2115\nhp : 1 < p\ninst\u271d : Fintype (ZMod p)\u02e3\nthis : NeZero p\n\u22a2 \u03c6 p \u2264 p - 1\n[PROOFSTEP]\nexact Nat.le_pred_of_lt (Nat.totient_lt p hp)\n[GOAL]\np : \u2115\ninst\u271d : Fintype (ZMod p)\u02e3\n\u22a2 Prime p \u2194 Fintype.card (ZMod p)\u02e3 = p - 1\n[PROOFSTEP]\ncases' eq_zero_or_neZero p with hp hp\n[GOAL]\ncase inl\np : \u2115\ninst\u271d : Fintype (ZMod p)\u02e3\nhp : p = 0\n\u22a2 Prime p \u2194 Fintype.card (ZMod p)\u02e3 = p - 1\n[PROOFSTEP]\nsubst hp\n[GOAL]\ncase inl\ninst\u271d : Fintype (ZMod 0)\u02e3\n\u22a2 Prime 0 \u2194 Fintype.card (ZMod 0)\u02e3 = 0 - 1\n[PROOFSTEP]\nsimp only [ZMod, not_prime_zero, false_iff_iff, zero_tsub]\n  -- the subst created a non-defeq but subsingleton instance diamond; resolve it\n[GOAL]\ncase inl\ninst\u271d : Fintype (ZMod 0)\u02e3\n\u22a2 \u00acFintype.card \u2124\u02e3 = 0\n[PROOFSTEP]\nsuffices Fintype.card \u2124\u02e3 \u2260 0 by convert this\n[GOAL]\ninst\u271d : Fintype (ZMod 0)\u02e3\nthis : Fintype.card \u2124\u02e3 \u2260 0\n\u22a2 \u00acFintype.card \u2124\u02e3 = 0\n[PROOFSTEP]\nconvert this\n[GOAL]\ncase inl\ninst\u271d : Fintype (ZMod 0)\u02e3\n\u22a2 Fintype.card \u2124\u02e3 \u2260 0\n[PROOFSTEP]\nsimp\n[GOAL]\ncase inr\np : \u2115\ninst\u271d : Fintype (ZMod p)\u02e3\nhp : NeZero p\n\u22a2 Prime p \u2194 Fintype.card (ZMod p)\u02e3 = p - 1\n[PROOFSTEP]\nrw [ZMod.card_units_eq_totient, Nat.totient_eq_iff_prime <| NeZero.pos p]\n[GOAL]\n\u22a2 \u03c6 0 = 1 \u2194 0 = 1 \u2228 0 = 2\n[PROOFSTEP]\nsimp\n[GOAL]\n\u22a2 \u03c6 1 = 1 \u2194 1 = 1 \u2228 1 = 2\n[PROOFSTEP]\nsimp\n[GOAL]\n\u22a2 \u03c6 2 = 1 \u2194 2 = 1 \u2228 2 = 2\n[PROOFSTEP]\nsimp\n[GOAL]\nn : \u2115\n\u22a2 \u03c6 (n + 3) = 1 \u2194 n + 3 = 1 \u2228 n + 3 = 2\n[PROOFSTEP]\nhave : 3 \u2264 n + 3 := le_add_self\n[GOAL]\nn : \u2115\nthis : 3 \u2264 n + 3\n\u22a2 \u03c6 (n + 3) = 1 \u2194 n + 3 = 1 \u2228 n + 3 = 2\n[PROOFSTEP]\nsimp only [succ_succ_ne_one, false_or_iff]\n[GOAL]\nn : \u2115\nthis : 3 \u2264 n + 3\n\u22a2 \u03c6 (n + 3) = 1 \u2194 n + 3 = 2\n[PROOFSTEP]\nexact \u27e8fun h => not_even_one.elim <| h \u25b8 totient_even this, by rintro \u27e8\u27e9\u27e9\n[GOAL]\nn : \u2115\nthis : 3 \u2264 n + 3\n\u22a2 n + 3 = 2 \u2192 \u03c6 (n + 3) = 1\n[PROOFSTEP]\nrintro \u27e8\u27e9\n[GOAL]\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u03c6 n = Finsupp.prod (factorization n) fun p k => p ^ (k - 1) * (p - 1)\n[PROOFSTEP]\nrw [multiplicative_factorization \u03c6 (@totient_mul) totient_one hn]\n[GOAL]\nn : \u2115\nhn : n \u2260 0\n\u22a2 (Finsupp.prod (factorization n) fun p k => \u03c6 (p ^ k)) =\n    Finsupp.prod (factorization n) fun p k => p ^ (k - 1) * (p - 1)\n[PROOFSTEP]\napply Finsupp.prod_congr _\n[GOAL]\nn : \u2115\nhn : n \u2260 0\n\u22a2 \u2200 (x : \u2115), x \u2208 (factorization n).support \u2192 \u03c6 (x ^ \u2191(factorization n) x) = x ^ (\u2191(factorization n) x - 1) * (x - 1)\n[PROOFSTEP]\nintro p hp\n[GOAL]\nn : \u2115\nhn : n \u2260 0\np : \u2115\nhp : p \u2208 (factorization n).support\n\u22a2 \u03c6 (p ^ \u2191(factorization n) p) = p ^ (\u2191(factorization n) p - 1) * (p - 1)\n[PROOFSTEP]\nhave h := zero_lt_iff.mpr (Finsupp.mem_support_iff.mp hp)\n[GOAL]\nn : \u2115\nhn : n \u2260 0\np : \u2115\nhp : p \u2208 (factorization n).support\nh : 0 < \u2191(factorization n) p\n\u22a2 \u03c6 (p ^ \u2191(factorization n) p) = p ^ (\u2191(factorization n) p - 1) * (p - 1)\n[PROOFSTEP]\nrw [totient_prime_pow (prime_of_mem_factorization hp) h]\n[GOAL]\nn : \u2115\n\u22a2 \u03c6 n * \u220f p in List.toFinset (factors n), p = n * \u220f p in List.toFinset (factors n), (p - 1)\n[PROOFSTEP]\nby_cases hn : n = 0\n[GOAL]\ncase pos\nn : \u2115\nhn : n = 0\n\u22a2 \u03c6 n * \u220f p in List.toFinset (factors n), p = n * \u220f p in List.toFinset (factors n), (p - 1)\n[PROOFSTEP]\nsimp [hn]\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\n\u22a2 \u03c6 n * \u220f p in List.toFinset (factors n), p = n * \u220f p in List.toFinset (factors n), (p - 1)\n[PROOFSTEP]\nrw [totient_eq_prod_factorization hn]\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\n\u22a2 (Finsupp.prod (factorization n) fun p k => p ^ (k - 1) * (p - 1)) * \u220f p in List.toFinset (factors n), p =\n    n * \u220f p in List.toFinset (factors n), (p - 1)\n[PROOFSTEP]\nnth_rw 3 [\u2190 factorization_prod_pow_eq_self hn]\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\n\u22a2 (Finsupp.prod (factorization n) fun p k => p ^ (k - 1) * (p - 1)) * \u220f p in List.toFinset (factors n), p =\n    (Finsupp.prod (factorization n) fun x x_1 => x ^ x_1) * \u220f p in List.toFinset (factors n), (p - 1)\n[PROOFSTEP]\nsimp only [\u2190 prod_factorization_eq_prod_factors, \u2190 Finsupp.prod_mul]\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\n\u22a2 (Finsupp.prod (factorization n) fun a b => a ^ (b - 1) * (a - 1) * a) =\n    Finsupp.prod (factorization n) fun a b => a ^ b * (a - 1)\n[PROOFSTEP]\nrefine' Finsupp.prod_congr (M := \u2115) (N := \u2115) fun p hp => _\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\np : \u2115\nhp : p \u2208 (factorization n).support\n\u22a2 p ^ (\u2191(factorization n) p - 1) * (p - 1) * p = p ^ \u2191(factorization n) p * (p - 1)\n[PROOFSTEP]\nrw [Finsupp.mem_support_iff, \u2190 zero_lt_iff] at hp \n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\np : \u2115\nhp : 0 < \u2191(factorization n) p\n\u22a2 p ^ (\u2191(factorization n) p - 1) * (p - 1) * p = p ^ \u2191(factorization n) p * (p - 1)\n[PROOFSTEP]\nrw [mul_comm, \u2190 mul_assoc, \u2190 pow_succ', Nat.sub_one, Nat.succ_pred_eq_of_pos hp]\n[GOAL]\nn : \u2115\n\u22a2 \u03c6 n = (n / \u220f p in List.toFinset (factors n), p) * \u220f p in List.toFinset (factors n), (p - 1)\n[PROOFSTEP]\nrw [\u2190 mul_div_left n.totient, totient_mul_prod_factors, mul_comm, Nat.mul_div_assoc _ (prod_prime_factors_dvd n),\n  mul_comm]\n[GOAL]\nn : \u2115\n\u22a2 0 < \u220f p in List.toFinset (factors n), p\n[PROOFSTEP]\nhave := prod_pos (fun p => pos_of_mem_factorization (n := n))\n[GOAL]\nn : \u2115\nthis : 0 < \u220f i in (factorization n).support, i\n\u22a2 0 < \u220f p in List.toFinset (factors n), p\n[PROOFSTEP]\nsimpa [prod_factorization_eq_prod_factors] using this\n[GOAL]\nn : \u2115\n\u22a2 \u2191(\u03c6 n) = \u2191n * \u220f p in List.toFinset (factors n), (1 - (\u2191p)\u207b\u00b9)\n[PROOFSTEP]\nby_cases hn : n = 0\n[GOAL]\ncase pos\nn : \u2115\nhn : n = 0\n\u22a2 \u2191(\u03c6 n) = \u2191n * \u220f p in List.toFinset (factors n), (1 - (\u2191p)\u207b\u00b9)\n[PROOFSTEP]\nsimp [hn]\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\n\u22a2 \u2191(\u03c6 n) = \u2191n * \u220f p in List.toFinset (factors n), (1 - (\u2191p)\u207b\u00b9)\n[PROOFSTEP]\nhave hn' : (n : \u211a) \u2260 0 := by simp [hn]\n[GOAL]\nn : \u2115\nhn : \u00acn = 0\n\u22a2 \u2191n \u2260 0\n[PROOFSTEP]\nsimp [hn]\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\n\u22a2 \u2191(\u03c6 n) = \u2191n * \u220f p in List.toFinset (factors n), (1 - (\u2191p)\u207b\u00b9)\n[PROOFSTEP]\nhave hpQ : (\u220f p in n.factors.toFinset, (p : \u211a)) \u2260 0 :=\n  by\n  rw [\u2190 cast_prod, cast_ne_zero, \u2190 zero_lt_iff, \u2190 prod_factorization_eq_prod_factors]\n  exact prod_pos fun p hp => pos_of_mem_factorization hp\n[GOAL]\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\n\u22a2 \u220f p in List.toFinset (factors n), \u2191p \u2260 0\n[PROOFSTEP]\nrw [\u2190 cast_prod, cast_ne_zero, \u2190 zero_lt_iff, \u2190 prod_factorization_eq_prod_factors]\n[GOAL]\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\n\u22a2 0 < Finsupp.prod (factorization n) fun p x => p\n[PROOFSTEP]\nexact prod_pos fun p hp => pos_of_mem_factorization hp\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\nhpQ : \u220f p in List.toFinset (factors n), \u2191p \u2260 0\n\u22a2 \u2191(\u03c6 n) = \u2191n * \u220f p in List.toFinset (factors n), (1 - (\u2191p)\u207b\u00b9)\n[PROOFSTEP]\nsimp only [totient_eq_div_factors_mul n, prod_prime_factors_dvd n, cast_mul, cast_prod, cast_div_charZero, mul_comm_div,\n  mul_right_inj' hn', div_eq_iff hpQ, \u2190 prod_mul_distrib]\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\nhpQ : \u220f p in List.toFinset (factors n), \u2191p \u2260 0\n\u22a2 \u220f i in List.toFinset (factors n), \u2191(i - 1) = \u220f x in List.toFinset (factors n), (1 - (\u2191x)\u207b\u00b9) * \u2191x\n[PROOFSTEP]\nrefine' prod_congr rfl fun p hp => _\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\nhpQ : \u220f p in List.toFinset (factors n), \u2191p \u2260 0\np : \u2115\nhp : p \u2208 List.toFinset (factors n)\n\u22a2 \u2191(p - 1) = (1 - (\u2191p)\u207b\u00b9) * \u2191p\n[PROOFSTEP]\nhave hp := pos_of_mem_factors (List.mem_toFinset.mp hp)\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\nhpQ : \u220f p in List.toFinset (factors n), \u2191p \u2260 0\np : \u2115\nhp\u271d : p \u2208 List.toFinset (factors n)\nhp : 0 < p\n\u22a2 \u2191(p - 1) = (1 - (\u2191p)\u207b\u00b9) * \u2191p\n[PROOFSTEP]\nhave hp' : (p : \u211a) \u2260 0 := cast_ne_zero.mpr hp.ne.symm\n[GOAL]\ncase neg\nn : \u2115\nhn : \u00acn = 0\nhn' : \u2191n \u2260 0\nhpQ : \u220f p in List.toFinset (factors n), \u2191p \u2260 0\np : \u2115\nhp\u271d : p \u2208 List.toFinset (factors n)\nhp : 0 < p\nhp' : \u2191p \u2260 0\n\u22a2 \u2191(p - 1) = (1 - (\u2191p)\u207b\u00b9) * \u2191p\n[PROOFSTEP]\nrw [sub_mul, one_mul, mul_comm, mul_inv_cancel hp', cast_pred hp]\n[GOAL]\na b : \u2115\n\u22a2 \u03c6 (gcd a b) * \u03c6 (a * b) = \u03c6 a * \u03c6 b * gcd a b\n[PROOFSTEP]\nhave shuffle :\n  \u2200 a1 a2 b1 b2 c1 c2 : \u2115, b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2) :=\n  by\n  intro a1 a2 b1 b2 c1 c2 h1 h2\n  calc\n    a1 / b1 * c1 * (a2 / b2 * c2) = a1 / b1 * (a2 / b2) * (c1 * c2) := by apply mul_mul_mul_comm\n    _ = a1 * a2 / (b1 * b2) * (c1 * c2) := by\n      congr 1\n      exact div_mul_div_comm h1 h2\n[GOAL]\na b : \u2115\n\u22a2 \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n[PROOFSTEP]\nintro a1 a2 b1 b2 c1 c2 h1 h2\n[GOAL]\na b a1 a2 b1 b2 c1 c2 : \u2115\nh1 : b1 \u2223 a1\nh2 : b2 \u2223 a2\n\u22a2 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n[PROOFSTEP]\ncalc\n  a1 / b1 * c1 * (a2 / b2 * c2) = a1 / b1 * (a2 / b2) * (c1 * c2) := by apply mul_mul_mul_comm\n  _ = a1 * a2 / (b1 * b2) * (c1 * c2) := by\n    congr 1\n    exact div_mul_div_comm h1 h2\n[GOAL]\na b a1 a2 b1 b2 c1 c2 : \u2115\nh1 : b1 \u2223 a1\nh2 : b2 \u2223 a2\n\u22a2 a1 / b1 * c1 * (a2 / b2 * c2) = a1 / b1 * (a2 / b2) * (c1 * c2)\n[PROOFSTEP]\napply mul_mul_mul_comm\n[GOAL]\na b a1 a2 b1 b2 c1 c2 : \u2115\nh1 : b1 \u2223 a1\nh2 : b2 \u2223 a2\n\u22a2 a1 / b1 * (a2 / b2) * (c1 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n[PROOFSTEP]\ncongr 1\n[GOAL]\ncase e_a\na b a1 a2 b1 b2 c1 c2 : \u2115\nh1 : b1 \u2223 a1\nh2 : b2 \u2223 a2\n\u22a2 a1 / b1 * (a2 / b2) = a1 * a2 / (b1 * b2)\n[PROOFSTEP]\nexact div_mul_div_comm h1 h2\n[GOAL]\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u03c6 (gcd a b) * \u03c6 (a * b) = \u03c6 a * \u03c6 b * gcd a b\n[PROOFSTEP]\nsimp only [totient_eq_div_factors_mul]\n[GOAL]\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 ((gcd a b / \u220f p in List.toFinset (factors (gcd a b)), p) * \u220f p in List.toFinset (factors (gcd a b)), (p - 1)) *\n      ((a * b / \u220f p in List.toFinset (factors (a * b)), p) * \u220f p in List.toFinset (factors (a * b)), (p - 1)) =\n    ((a / \u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors a), (p - 1)) *\n        ((b / \u220f p in List.toFinset (factors b), p) * \u220f p in List.toFinset (factors b), (p - 1)) *\n      gcd a b\n[PROOFSTEP]\nrw [shuffle, shuffle]\n[GOAL]\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 gcd a b * (a * b) / ((\u220f p in List.toFinset (factors (gcd a b)), p) * \u220f p in List.toFinset (factors (a * b)), p) *\n      ((\u220f p in List.toFinset (factors (gcd a b)), (p - 1)) * \u220f p in List.toFinset (factors (a * b)), (p - 1)) =\n    a * b / ((\u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors b), p) *\n        ((\u220f p in List.toFinset (factors a), (p - 1)) * \u220f p in List.toFinset (factors b), (p - 1)) *\n      gcd a b\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors a), p \u2223 a\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors b), p \u2223 b\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors (gcd a b)), p \u2223 gcd a b\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors (a * b)), p \u2223 a * b\n[PROOFSTEP]\nrotate_left\n[GOAL]\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors a), p \u2223 a\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors b), p \u2223 b\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors (gcd a b)), p \u2223 gcd a b\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors (a * b)), p \u2223 a * b\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 gcd a b * (a * b) / ((\u220f p in List.toFinset (factors (gcd a b)), p) * \u220f p in List.toFinset (factors (a * b)), p) *\n      ((\u220f p in List.toFinset (factors (gcd a b)), (p - 1)) * \u220f p in List.toFinset (factors (a * b)), (p - 1)) =\n    a * b / ((\u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors b), p) *\n        ((\u220f p in List.toFinset (factors a), (p - 1)) * \u220f p in List.toFinset (factors b), (p - 1)) *\n      gcd a b\n[PROOFSTEP]\nrepeat' apply prod_prime_factors_dvd\n[GOAL]\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors a), p \u2223 a\n[PROOFSTEP]\napply prod_prime_factors_dvd\n[GOAL]\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors b), p \u2223 b\n[PROOFSTEP]\napply prod_prime_factors_dvd\n[GOAL]\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors (gcd a b)), p \u2223 gcd a b\n[PROOFSTEP]\napply prod_prime_factors_dvd\n[GOAL]\ncase a\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 \u220f p in List.toFinset (factors (a * b)), p \u2223 a * b\n[PROOFSTEP]\napply prod_prime_factors_dvd\n[GOAL]\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 gcd a b * (a * b) / ((\u220f p in List.toFinset (factors (gcd a b)), p) * \u220f p in List.toFinset (factors (a * b)), p) *\n      ((\u220f p in List.toFinset (factors (gcd a b)), (p - 1)) * \u220f p in List.toFinset (factors (a * b)), (p - 1)) =\n    a * b / ((\u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors b), p) *\n        ((\u220f p in List.toFinset (factors a), (p - 1)) * \u220f p in List.toFinset (factors b), (p - 1)) *\n      gcd a b\n[PROOFSTEP]\napply prod_prime_factors_dvd\n[GOAL]\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 gcd a b * (a * b) / ((\u220f p in List.toFinset (factors (gcd a b)), p) * \u220f p in List.toFinset (factors (a * b)), p) *\n      ((\u220f p in List.toFinset (factors (gcd a b)), (p - 1)) * \u220f p in List.toFinset (factors (a * b)), (p - 1)) =\n    a * b / ((\u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors b), p) *\n        ((\u220f p in List.toFinset (factors a), (p - 1)) * \u220f p in List.toFinset (factors b), (p - 1)) *\n      gcd a b\n[PROOFSTEP]\nsimp only [prod_factors_gcd_mul_prod_factors_mul]\n[GOAL]\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 gcd a b * (a * b) / ((\u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors b), p) *\n      ((\u220f p in List.toFinset (factors a), (p - 1)) * \u220f p in List.toFinset (factors b), (p - 1)) =\n    a * b / ((\u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors b), p) *\n        ((\u220f p in List.toFinset (factors a), (p - 1)) * \u220f p in List.toFinset (factors b), (p - 1)) *\n      gcd a b\n[PROOFSTEP]\nrw [eq_comm, mul_comm, \u2190 mul_assoc, \u2190 Nat.mul_div_assoc]\n[GOAL]\ncase H\na b : \u2115\nshuffle : \u2200 (a1 a2 b1 b2 c1 c2 : \u2115), b1 \u2223 a1 \u2192 b2 \u2223 a2 \u2192 a1 / b1 * c1 * (a2 / b2 * c2) = a1 * a2 / (b1 * b2) * (c1 * c2)\n\u22a2 (\u220f p in List.toFinset (factors a), p) * \u220f p in List.toFinset (factors b), p \u2223 a * b\n[PROOFSTEP]\nexact mul_dvd_mul (prod_prime_factors_dvd a) (prod_prime_factors_dvd b)\n[GOAL]\na b : \u2115\n\u22a2 \u03c6 a * \u03c6 b \u2264 \u03c6 (a * b)\n[PROOFSTEP]\nlet d := a.gcd b\n[GOAL]\na b : \u2115\nd : \u2115 := gcd a b\n\u22a2 \u03c6 a * \u03c6 b \u2264 \u03c6 (a * b)\n[PROOFSTEP]\nrcases(zero_le a).eq_or_lt with (rfl | ha0)\n[GOAL]\ncase inl\nb : \u2115\nd : \u2115 := gcd 0 b\n\u22a2 \u03c6 0 * \u03c6 b \u2264 \u03c6 (0 * b)\n[PROOFSTEP]\nsimp\n[GOAL]\ncase inr\na b : \u2115\nd : \u2115 := gcd a b\nha0 : 0 < a\n\u22a2 \u03c6 a * \u03c6 b \u2264 \u03c6 (a * b)\n[PROOFSTEP]\nhave hd0 : 0 < d := Nat.gcd_pos_of_pos_left _ ha0\n[GOAL]\ncase inr\na b : \u2115\nd : \u2115 := gcd a b\nha0 : 0 < a\nhd0 : 0 < d\n\u22a2 \u03c6 a * \u03c6 b \u2264 \u03c6 (a * b)\n[PROOFSTEP]\napply le_of_mul_le_mul_right _ hd0\n[GOAL]\na b : \u2115\nd : \u2115 := gcd a b\nha0 : 0 < a\nhd0 : 0 < d\n\u22a2 \u03c6 a * \u03c6 b * d \u2264 \u03c6 (a * b) * d\n[PROOFSTEP]\nrw [\u2190 totient_gcd_mul_totient_mul a b, mul_comm]\n[GOAL]\na b : \u2115\nd : \u2115 := gcd a b\nha0 : 0 < a\nhd0 : 0 < d\n\u22a2 \u03c6 (a * b) * \u03c6 (gcd a b) \u2264 \u03c6 (a * b) * d\n[PROOFSTEP]\napply mul_le_mul_left' (Nat.totient_le d)\n[GOAL]\na b : \u2115\nh : a \u2223 b\n\u22a2 \u03c6 a \u2223 \u03c6 b\n[PROOFSTEP]\nrcases eq_or_ne a 0 with (rfl | ha0)\n[GOAL]\ncase inl\nb : \u2115\nh : 0 \u2223 b\n\u22a2 \u03c6 0 \u2223 \u03c6 b\n[PROOFSTEP]\nsimp [zero_dvd_iff.1 h]\n[GOAL]\ncase inr\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\n\u22a2 \u03c6 a \u2223 \u03c6 b\n[PROOFSTEP]\nrcases eq_or_ne b 0 with (rfl | hb0)\n[GOAL]\ncase inr.inl\na : \u2115\nha0 : a \u2260 0\nh : a \u2223 0\n\u22a2 \u03c6 a \u2223 \u03c6 0\n[PROOFSTEP]\nsimp\n[GOAL]\ncase inr.inr\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 \u03c6 a \u2223 \u03c6 b\n[PROOFSTEP]\nhave hab' : a.factorization.support \u2286 b.factorization.support :=\n  by\n  intro p\n  simp only [support_factorization, List.mem_toFinset]\n  apply factors_subset_of_dvd h hb0\n[GOAL]\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\nhb0 : b \u2260 0\n\u22a2 (factorization a).support \u2286 (factorization b).support\n[PROOFSTEP]\nintro p\n[GOAL]\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\nhb0 : b \u2260 0\np : \u2115\n\u22a2 p \u2208 (factorization a).support \u2192 p \u2208 (factorization b).support\n[PROOFSTEP]\nsimp only [support_factorization, List.mem_toFinset]\n[GOAL]\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\nhb0 : b \u2260 0\np : \u2115\n\u22a2 p \u2208 factors a \u2192 p \u2208 factors b\n[PROOFSTEP]\napply factors_subset_of_dvd h hb0\n[GOAL]\ncase inr.inr\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhab' : (factorization a).support \u2286 (factorization b).support\n\u22a2 \u03c6 a \u2223 \u03c6 b\n[PROOFSTEP]\nrw [totient_eq_prod_factorization ha0, totient_eq_prod_factorization hb0]\n[GOAL]\ncase inr.inr\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhab' : (factorization a).support \u2286 (factorization b).support\n\u22a2 (Finsupp.prod (factorization a) fun p k => p ^ (k - 1) * (p - 1)) \u2223\n    Finsupp.prod (factorization b) fun p k => p ^ (k - 1) * (p - 1)\n[PROOFSTEP]\nrefine' Finsupp.prod_dvd_prod_of_subset_of_dvd hab' fun p _ => mul_dvd_mul _ dvd_rfl\n[GOAL]\ncase inr.inr\na b : \u2115\nh : a \u2223 b\nha0 : a \u2260 0\nhb0 : b \u2260 0\nhab' : (factorization a).support \u2286 (factorization b).support\np : \u2115\nx\u271d : p \u2208 (factorization a).support\n\u22a2 p ^ (\u2191(factorization a) p - 1) \u2223 p ^ (\u2191(factorization b) p - 1)\n[PROOFSTEP]\nexact pow_dvd_pow p (tsub_le_tsub_right ((factorization_le_iff_dvd ha0 hb0).2 h p) 1)\n[GOAL]\np n : \u2115\nhp : Prime p\nh : p \u2223 n\n\u22a2 \u03c6 (p * n) = p * \u03c6 n\n[PROOFSTEP]\nhave h1 := totient_gcd_mul_totient_mul p n\n[GOAL]\np n : \u2115\nhp : Prime p\nh : p \u2223 n\nh1 : \u03c6 (gcd p n) * \u03c6 (p * n) = \u03c6 p * \u03c6 n * gcd p n\n\u22a2 \u03c6 (p * n) = p * \u03c6 n\n[PROOFSTEP]\nrw [gcd_eq_left h, mul_assoc] at h1 \n[GOAL]\np n : \u2115\nhp : Prime p\nh : p \u2223 n\nh1 : \u03c6 p * \u03c6 (p * n) = \u03c6 p * (\u03c6 n * p)\n\u22a2 \u03c6 (p * n) = p * \u03c6 n\n[PROOFSTEP]\nsimpa [(totient_pos hp.pos).ne', mul_comm] using h1\n[GOAL]\np n : \u2115\nhp : Prime p\nh : \u00acp \u2223 n\n\u22a2 \u03c6 (p * n) = (p - 1) * \u03c6 n\n[PROOFSTEP]\nrw [totient_mul _, totient_prime hp]\n[GOAL]\np n : \u2115\nhp : Prime p\nh : \u00acp \u2223 n\n\u22a2 coprime p n\n[PROOFSTEP]\nsimpa [h] using coprime_or_dvd_of_prime hp n\n"}
{"text": "@[default_instance high] instance : HPow R Nat R where hPow a _ := a\nexample (x y : Nat) : (x + y) ^ 3 = x ^ 3 + y ^ 3 + 3 * (x * y ^ 2 + x ^ 2 * y) := sorry\n"}
{"text": "#\n# This file is part of the Actors.jl Julia package, \n# MIT license, part of https://github.com/JuliaActors\n#\n\nusing Actors, Test\n\n@msg Msg A B C\n@test supertype(A) == Msg\n@test supertype(B) == Msg\n@test supertype(C) == Msg\n\n@msg D E F\n@test supertype(D) == Any\n@test supertype(E) == Any\n@test supertype(F) == Any\n"}
{"text": "import data.rat.basic tactic\n\n-- prove one and delete the other\n\ntheorem some_reciprocal_is_zero : \u2203 x : \u211a, 1 / x = 0 :=\nbegin\n  use 0,\n  norm_num -- exact dec_trivial would also work\nend\n\n--theorem no_reciprocal_is_zero : \u00ac (\u2203 x : \u211a, 1 / x = 0) :=\n--begin\n--  sorry\n--end"}
{"text": "class HasMulComm (\u03b1 : Type u) [Mul \u03b1] : Prop where\n    mulComm : {a b : \u03b1} \u2192 a * b = b * a\n\nclass A (\u03b1 : Type u) extends Mul \u03b1\nattribute [instance] A.mk\n\nclass B (\u03b1 : Type u) extends A \u03b1, HasMulComm \u03b1\nattribute [instance] B.mk\n\nexample [Mul \u03b1] : A \u03b1 := inferInstance\nexample [Mul \u03b1] [HasMulComm \u03b1] : A \u03b1 := inferInstance\nexample [B \u03b1] : A \u03b1 := inferInstance\n\nexample [A \u03b1] [HasMulComm \u03b1] : B \u03b1 := inferInstance\nexample [Mul \u03b1] [HasMulComm \u03b1] : B \u03b1 := inferInstance\nexample [Mul \u03b1] [HasMulComm \u03b1] : B \u03b1 := B.mk\n"}
{"text": "import data.real.basic\nimport .uwyo_sqrt2\nimport analysis.specific_limits\n\nopen_locale topological_space\nopen filter\n\nlemma aux_0 (X : \u211a) (hX: 0 < X): ( X * X + 2) / (2 * X) - X = (2 - X * X) / (2 * X) :=\nbegin\n  set Y := X * X with hY,\n  have h1 : 2 - Y = 2 + Y - 2 * Y, linarith,\n  rw add_comm 2 Y at h1,\n  rw h1,\n  set V := 2 * X with hV,\n  have h31 : V \u2260 0, linarith,\n  have h2 := sub_div (Y+2) (2*Y) V,\n  rw h2,\n  have h32 : (2 * Y) / V = X, \n    apply (div_eq_iff h31).mpr,\n    rw [hY, hV], ring,\n  rw h32,\n  done\nend\n\nlemma aux_1 (X Y V : \u211a) (G : X \u2260 0) (hY : Y = X * X) (hV : V = 2 * X) (G1 : Y \u2260 0) : \n  4 * (Y + 2) / V * ((Y + 2) / (V)) = Y + 2 * 2 + (2*2/(X * X)) :=\nbegin\n  -- this is a struggle\n      rw hV, rw hY,\n      norm_num, field_simp,\n      have h211 : 2 * X * ( 2 * X ) = 4 * X * X,\n        ring,\n      rw h211, rw mul_assoc 4 X X,\n      rw \u2190 hY, field_simp,\n      rw mul_assoc,\n      have h212 : (Y+2) * (Y + 2) = Y * Y + 4 * Y +4, ring,\n      rw h212, \n      set T := 4 * (Y * Y + 4 * Y + 4) with hT,\n      rw \u2190 hT,\n      have h214 : (4: \u211a) \u2260 0, linarith,\n      have h213 : 4 * Y \u2260 0, exact mul_ne_zero h214 G1,\n      apply (div_eq_iff h213).mpr,\n      have h214 : (Y + 4 + (4/Y)) * (4 * Y) = (Y+4) * (4*Y) + (4/Y) * (4 * Y), \n        ring,\n      rw h214,\n      have h215 : (4/Y) * (4 * Y) = 16, ring, \n        rw mul_assoc,\n        have h216 : Y * Y\u207b\u00b9 = 1, exact mul_inv_cancel G1,\n        rw h216, linarith,\n      rw h215,\n      rw hT, ring, done\nend\n\nlemma aux_2 (X : \u211a) (G : X \u2260 0) : ( 2 / X - X ) * ( 2 / X - X ) = 4 / (X*X) - 4 + X * X :=\nbegin\n  set V := (2/X) with hV,\n  have h1 : V * V = 4 / (X * X), \n    rw hV, ring, field_simp,\n    have h11 : X ^ 2 = X * X, ring,\n    rw h11,\n  rw \u2190 h1,\n  have h2 : (V - X) * (V - X) = V * V - 2 * V * X + X * X, ring,\n  rw h2,\n  have h3 : V * X = 2, field_simp, ring, rw mul_assoc, rw mul_comm X\u207b\u00b9 _,\n    rw mul_inv_cancel G, linarith,\n  rw mul_assoc 2 V X, rw h3,\n  linarith, done\nend \n\n-- This proof (considerably shorter than mine) is due to Reid Barton\nlemma aux_3 (s : \u2115 \u2192 \u211d) (hs : \u2200 n : \u2115, real.sqrt 2 < s n) : \u00ac (tendsto s at_top (\ud835\udcdd 0)) :=\nbegin\n  rw metric.tendsto_at_top,\n  push_neg,\n  refine \u27e8real.sqrt 2, by norm_num, \u03bb N, \u27e8N, le_refl _, _\u27e9\u27e9,\n  change real.sqrt 2 \u2264 abs (s N - 0),\n  refine le_trans _ (le_abs_self _),\n  specialize hs N,\n  linarith, done\nend\n\n\nlemma no_rat_sq_eq_two (X : \u211a) (hX1 : X \u2260 0) :  0 \u2260 ( 2 / X - X ) :=\nbegin\n  by_contradiction H,\n  push_neg at H,\n  have h1 := congr_arg (\u03bb (b : \u211a), X * b) H,\n  simp only [] at h1,\n  rw mul_zero at h1,\n  have h2 : X * (2 / X - X) = 2 - X ^ 2, \n    ring, \n    have h21 : ( - X + 2 * X\u207b\u00b9) * X = - X * X + 2 * X\u207b\u00b9 * X, ring,\n    rw h21, rw mul_assoc 2 (X\u207b\u00b9) X, rw mul_comm (X\u207b\u00b9) _, rw mul_inv_cancel hX1,\n    ring,\n  rw \u2190 h1 at h2,\n  have h2 : X ^ 2 = 2, linarith,\n  have h3 : \u2203 r : \u211a, r ^ 2 = 2,\n    use X, exact h2,\n  exact rational_not_sqrt_two h3, -- from uwyo_sqrt2\n  done\nend\n"}
{"text": "/-\nCopyright (c) 2022 Jun Yoshida. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\n-/\n\nimport Std.Classes.LawfulMonad\n\nimport Algdata.Data.Array.Lemmas\n\nnamespace Array\n\nuniverse u v\n\nvariable {m : Type u \u2192 Type v} [Monad m] {\u03b1 : Type u}\n\n@[simp]\ntheorem modifyM_nil (n : Nat) (f : \u03b1 \u2192 m \u03b1) : #[].modifyM n f = pure #[] := by\n  rfl\n\n@[simp]\ntheorem modifyM_head (a : \u03b1) (as : List \u03b1) (f : \u03b1 \u2192 m \u03b1) : modifyM {data := a::as} 0 f = (f a >>= fun a' => pure {data := a' :: as }) := by\n  dsimp [modifyM]\n  rw [dif_pos (Nat.zero_lt_succ _)]\n  conv =>\n    lhs; lhs; change f a\n\n-- modifyM with an out-of-range index\ntheorem modifyM_oor (x : Array \u03b1) (n : Nat) (f : \u03b1 \u2192 m \u03b1) : \u00ac(n < x.size) \u2192 x.modifyM n f = pure x := by\n  intro h\n  rw [modifyM, dif_neg h]\n\ntheorem modifyM_tail [LawfulMonad m] {\u03b1 : Type _} (a : \u03b1) (as : List \u03b1) (n : Nat) (f : \u03b1 \u2192 m \u03b1) : Array.modifyM {data := a::as} n.succ f = #[a].append <$> (Array.modifyM {data := as} n f) := by\n  by_cases n < as.length\n  case pos hpos =>\n    dsimp [modifyM, modifyM]\n    have : n.succ < size {data := as} + 1 :=\n      Nat.succ_lt_succ hpos\n    rw [dif_pos this, dif_pos hpos]\n    rw [bind_pure_comp, bind_pure_comp, \u2190comp_map]\n    apply map_congr\n    intro a\n    rw [set_cons_succ']\n    rfl\n  case neg hneg =>\n    rw [modifyM_oor {data := as} n f hneg]\n    have : \u00ac(n.succ < size {data := a::as}) := hneg \u2218 Nat.lt_of_succ_lt_succ\n    rw [modifyM_oor {data := a::as} n.succ f this]\n    simp\n    apply congrArg\n    apply Array.eq\n    conv =>\n      rhs; rw [append_data]; change [a] ++ as; change a::as\n\n@[simp]\ntheorem modify_nil (n : Nat) (f : \u03b1 \u2192 \u03b1) : Array.modify #[] n f = #[] := by\n  rw [modify, Id.run, modifyM_nil]\n  rfl\n\n@[simp]\ntheorem modify_head (a : \u03b1) (as : List \u03b1) (f : \u03b1 \u2192 \u03b1) : Array.modify {data := a::as} 0 f = {data := f a :: as} := by\n  rw [modify, Id.run, modifyM_head]\n  rfl\n\ntheorem modify_oor (x : Array \u03b1) (n : Nat) (f : \u03b1 \u2192 \u03b1) (h : \u00ac(n < x.size)) : x.modify n f = x := by\n  rw [modify, Id.run, modifyM_oor (m:=Id) x n f h]\n  rfl\n\n@[simp]\ntheorem modify_tail (a : \u03b1) (as : List \u03b1) {k : Nat} {f : \u03b1 \u2192 \u03b1} : Array.modify {data := a::as} k.succ f = #[a].append (modify {data := as} k f) := by\n  rw [modify, Id.run, modify, Id.run]\n  exact modifyM_tail (m:=Id) a as k f\n\ntheorem size_modifyM [LawfulMonad m] {\u03b1 : Type _} : \u2200 (x : Array \u03b1) (n : Nat) (f : \u03b1 \u2192 m \u03b1), SatisfiesM (fun y => y.size = x.size) (x.modifyM n f)\n| mk as => by\n  induction as with\n  | nil =>\n    intros n f\n    exists pure (f:=m) (Subtype.mk (p:=fun y => y.size = (mk (\u03b1:=\u03b1) []).size) (mk (\u03b1:=\u03b1) []) rfl)\n    have : mk (\u03b1:=\u03b1) [] = #[] := rfl\n    rw [this, modifyM_nil]; clear this\n    rw [map_pure]\n  | cons a as hi =>\n    intros n f\n    cases n with\n    | zero =>\n      simp\n      exists f a >>= fun a' => pure (Subtype.mk (p:=fun y => y.size = as.length.succ) (mk (a'::as)) rfl)\n      rw [bind_pure_comp, bind_pure_comp]\n      rw [\u2190comp_map]\n      rfl\n    | succ n =>\n      rw [modifyM_tail]\n      apply SatisfiesM.map (p:=\u03bb y => y.size = as.length)\n      . cases hi n f with | intro w hw =>\n        exact Exists.intro w hw\n      . intros y hy;\n        conv =>\n          lhs; change size (#[a] ++ y);\n          rw [size_eq_length_of_data, append_data, List.length_append]\n          change 1 + y.size; rw [hy]\n        exact Nat.add_comm 1 _\n\n@[simp]\ntheorem size_modify : \u2200 (x : Array \u03b1) (n : Nat) (f : \u03b1 \u2192 \u03b1), (x.modify n f).size = x.size := by\n  intro x n f\n  cases size_modifyM (m:=Id) x n f with | intro w hw =>\n  dsimp at hw\n  conv at hw => rhs; change modify x n f\n  rw [\u2190hw]\n  exact w.property\n\nend Array\n"}
{"text": " Prior to the 1913 \u2013 14 NHA season , Ross refused to sign a contract for the Wanderers , requesting a salary increase . As one of the top players on the team , the Wanderers agreed to his demands of $ 1 @,@ 500 for the forthcoming season , in which he finished with four goals and nine points in eighteen games . The next season Ross , again concerned with his salary , began negotiating with other players in the NHA to leave their teams and form a new league that would offer higher wages . These actions resulted in his suspension in November 1914 by Emmett Quinn , president of the NHA . Ross responded by declaring himself a free agent and claiming his contract with the Wanderers was no longer valid . Consequently , although having no technical power to do so , Quinn suspended Ross from all organized hockey . The proposed new league failed to materialize and Ross applied for reinstatement to the NHA , which was granted at a meeting of the team owners on December 18 , 1914 . The owners realized if they suspended Ross , they would also have to suspend all those he signed , hurting the league . However , Ross 's actions led to his release by the Wanderers . At first he trained with the Montreal Canadiens , then joined the Ottawa Senators . \n"}
{"text": "[STATEMENT]\ntheorem FNTT_inv_IFNTT:  \n  assumes \"length numbers = n\"\n  shows \"FNTT (IFNTT numbers) = map ((*) (of_int_mod_ring (int n))) numbers\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. FNTT (IFNTT numbers) = map ((*) (of_int_mod_ring (int n))) numbers\n[PROOF STEP]\nby (simp add: FNTT_correct IFNTT_correct assms inv_ntt_correct length_INTT)"}
{"text": "(*begin hide*)\nRequire Import String. Open Scope string_scope.\nRequire Import Program.\n\nFrom mathcomp Require Import ssreflect ssrnat ssrbool eqtype fintype.\nImport ssreflect ssrnat ssrbool ssrfun eqtype fintype.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nImport Prenex Implicits.\n\nAdd LoadPath \"./\" as Top.\nRequire Import Top.CaseTactic.\nRequire Import Top.Syntax.\nRequire Import Top.Semantics.\nRequire Import Top.Coincidence.\n\nRequire Import Vector.\nRequire Import VectorEq.\nRequire Import ZArith.\n(*end hide*)\n\nTheorem Substitution_IntExp :\n  forall (E E' : Env) (ie : IntExp E) (\u03c3 : \u03a3(E')) (\u03c3' : \u03a3(E)) (\u03b4 : \u0394 E E'),\n    (forall (w : Var E), \u27e6 \u03b4 w \u27e7\u1d62 \u03c3  = \u03c3' ! w) -> \u27e6 ie \u2afd\u1d62 \u03b4 \u27e7\u1d62 \u03c3 = \u27e6 ie \u27e7\u1d62 \u03c3'.\nProof.\n  \u00bf?. (* Hueco a completar *)\nQed.\n\nTheorem Substitution_BoolExp :\n  forall (E : Env) (ae : Assert E) (E' : Env) (\u03c3 : \u03a3(E')) (\u03c3' : \u03a3(E)) (\u03b4 : \u0394 E E') ,\n    (forall (w : Var E), \u27e6 \u03b4 w \u27e7\u1d62 \u03c3  = \u03c3' ! w) -> \u27e6 ae \u2afd\u2090 \u03b4 \u27e7\u2090 \u03c3 = \u27e6 ae \u27e7\u2090 \u03c3'.\nProof.\n  \u00bf?. (* Hueco a completar *)\nQed.\n"}
{"text": "\n\ndata Foo : Type where\n Fee : Main.foo\n \n"}
{"text": "State Before: z : \u2102\nh : z \u2260 0\n\u22a2 z * z\u207b\u00b9 = 1 State After: no goals Tactic: rw [inv_def, \u2190 mul_assoc, mul_conj, \u2190 ofReal_mul, mul_inv_cancel (mt normSq_eq_zero.1 h),\n  ofReal_one]"}
{"text": "\ndata A : Set where\n  consA : A \u2192 A\n\nA-false : {Y : Set} \u2192 A \u2192 Y\nA-false (consA b) = A-false b\n\ndata Nat : Set where\n  zero : Nat\n  suc : Nat \u2192 Nat\n\nA-on-Nat : A \u2192 Nat \u2192 Nat\nA-on-Nat \u03c3 zero = A-false \u03c3\nA-on-Nat \u03c3 (suc t) = suc (A-on-Nat \u03c3 t)\n\nmodule _\n  (any : {X : Set} \u2192 X)\n  (P : Nat \u2192 Set)\n  (p : (n : Nat) \u2192 P n \u2192 P (suc n))\n  (eternity : (a : A) (n : Nat) \u2192 P (A-on-Nat (A-false a) n))\n  where\n\n  A-loop-term : (a : A) (n : Nat) \u2192 P (A-on-Nat a n)\n  A-loop-term a zero = any\n  A-loop-term a (suc n) = p _ (eternity _ n)\n"}
{"text": "import Mathlib\nimport Mathlib.Tactic.Basic\nimport LeanCodePrompts.CheckParse\nimport LeanCodePrompts.ThmInfo\nuniverse u v u_1 u_2\n\n/-- Every Nat.Prime that is `1` greater than a multiple of `4` can be expressed as the sum of two squares. -/\ntheorem fermat_two_square0 : (\u2200 {p : \u2115}, p % 4 = 1 \u2192 Nat.Prime p \u2192 \u2203 a b, a ^ 2 + b ^ 2 = p) \u2192 (\u2200 p : \u2115, Nat.Prime p \u2192 (p % 4 = 1) \u2192 \u2203 a b : \u2115, a ^ 2 + b ^ 2 = p) := by\n  intros h\n  intros\n  apply h <;> assumption\n\ntheorem fermat_two_square1 : (\u2200 p : \u2115, Nat.Prime p \u2192 (p % 4 = 1) \u2192 \u2203 a b : \u2115, a ^ 2 + b ^ 2 = p) \u2192 (\u2200 {p : \u2115}, p % 4 = 1 \u2192 Nat.Prime p \u2192 \u2203 a b, a ^ 2 + b ^ 2 = p) := by\n  intro h\n  intros\n  apply h <;> assumption\n\n/-- The product of two numbers, each of which is the sum of four squares, is itself a sum of four squares. -/\ntheorem euler_four_square_identity0 : (\u2200 {a b : \u2124},   \u2203 x y z w,     a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 \u2227 \u2203 x y z w, b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 \u2192       \u2203 x y z w, (a * b) = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) \u2192 (let is_sum_of_four_squares : \u2115 \u2192 Prop := \u03bb n : \u2115 => \u2203 (a b c d : \u2115), n = a^2 + b^2 + c^2 + d^2;\n  \u2200 (x y : \u2115), is_sum_of_four_squares x \u2192 is_sum_of_four_squares y \u2192 is_sum_of_four_squares (x * y)) := sorry\ntheorem euler_four_square_identity1 : (let is_sum_of_four_squares : \u2115 \u2192 Prop := \u03bb n : \u2115 => \u2203 (a b c d : \u2115), n = a^2 + b^2 + c^2 + d^2;\n  \u2200 (x y : \u2115), is_sum_of_four_squares x \u2192 is_sum_of_four_squares y \u2192 is_sum_of_four_squares (x * y)) \u2192 (\u2200 {a b : \u2124},   \u2203 x y z w,     a = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 \u2227 b = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2 \u2192       \u2203 x y z w, (a * b) = x ^ 2 + y ^ 2 + z ^ 2 + w ^ 2) := sorry\n\n/-- A ring with all elements idempotent is commutative. -/\nexample : ({R : Type u} \u2192 [inst : CommRing R] \u2192 (\u2200 (x : R), (x * x) = x) \u2192 CommRing R) \u2192 ({R : Type u} \u2192  [Ring R] \u2192  (\u2200 x : R, (x * x) = x) \u2192 CommRing R) := by\n  intro h R RRing hyp\n  -- the typeclasses seem to be causing issues\n  haveI : CommRing R := sorry\n  apply h\n  intro x\n  sorry -- apply hyp\n\nexample : ({R : Type u} \u2192  [Ring R] \u2192  (\u2200 x : R, (x * x) = 1)) \u2192 ({R : Type u} \u2192 [inst : CommRing R] \u2192 (\u2200 (x : R), (x * x) = x) \u2192 CommRing R) := sorry\n\n/-- There are infinitely many pairs of Nat.Primes that differ exactly by `2`. -/\nexample : (\u2200 (n : \u2115), \u2203 p\u2081 p\u2082, Nat.Prime p\u2081 \u2227 Nat.Prime p\u2082 \u2227 p\u2081 + 2 = p\u2082 \u2227 (2 + n) < p\u2082) \u2192 (\u2200 n : \u2115, \u2203 p : \u2115, p > n \u2227 Nat.Prime p \u2227 Nat.Prime (p + 2)) := by\n  intro h n\n  let \u27e8p\u2081, p\u2082, Prime_p\u2081, Prime_p\u2082, hyp\u2081, hyp\u2082\u27e9 := h n\n  use p\u2081\n  apply And.intro -- `split` does not appear to exist yet\n  sorry -- needs `linarith` or `norm_num`\n  apply And.intro\n  exact Prime_p\u2081\n  rw [hyp\u2081]\n  exact Prime_p\u2082\n\nexample : (\u2200 n : \u2115, \u2203 p : \u2115, p > n \u2227 Nat.Prime p \u2227 Nat.Prime (p + 2)) \u2192 (\u2200 (n : \u2115), \u2203 p\u2081 p\u2082, Nat.Prime p\u2081 \u2227 Nat.Prime p\u2082 \u2227 p\u2081 + 2 = p\u2082 \u2227 2 + n < p\u2082) := by\n  intro h n\n  let \u27e8p, hpn, Prime_p, Prime_pp2\u27e9 := h n\n  use p\n  use p + 2\n  have : (2 + n) < p + 2 := sorry -- linarith\n  exact \u27e8Prime_p, Prime_pp2, rfl, this\u27e9\n\n\n\n\n/-- Every non-empty poset in which every chain has an upper bound contains a maximal element. -/\nexample : (\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [inst : Preorder \u03b1],   (\u2200 (c : Set \u03b1) (a : IsChain r c), \u2203 ub, \u2200 (a : \u03b1), a \u2208 c \u2192 r a ub) \u2192     \u2200 [inst : Nonempty \u03b1], \u2203 m, \u2200 (a : \u03b1), r m a \u2192 r a m) \u2192 ({\u03b1 : Type u} \u2192 [PartialOrder \u03b1] \u2192  [Nonempty \u03b1] \u2192  (\u2200 c : Set \u03b1, IsChain LE.le c \u2192 (\u2203 b : \u03b1, \u2200 a \u2208 c, a \u2264 b)) \u2192 (\u2203 m : \u03b1, \u2200 a : \u03b1, m \u2264 a \u2192 a = m)) := sorry\nexample : ({\u03b1 : Type u} \u2192 [PartialOrder \u03b1] \u2192  [Nonempty \u03b1] \u2192  (\u2200 c : Set \u03b1, IsChain LE.le c \u2192 (\u2203 b : \u03b1, \u2200 a \u2208 c, a \u2264 b)) \u2192 (\u2203 m : \u03b1, \u2200 a : \u03b1, m \u2264 a \u2192 a = m)) \u2192 (\u2200 {\u03b1 : Type u_1} {r : \u03b1 \u2192 \u03b1 \u2192 Prop} [inst : Preorder \u03b1],   (\u2200 (c : Set \u03b1) (a : IsChain r c), \u2203 ub, \u2200 (a : \u03b1), a \u2208 c \u2192 r a ub) \u2192     \u2200 [inst : Nonempty \u03b1], \u2203 m, \u2200 (a : \u03b1), r m a \u2192 r a m) := sorry\n\n/-- A uniformly continuous function of a uniformly continuous function is uniformly continuous. -/\nexample : (\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2]   [inst_2 : UniformSpace \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3},   UniformContinuous f \u2192 UniformContinuous g \u2192 UniformContinuous (g \u2218 f)) \u2192 ({\u03b1 \u03b2 \u03b3 : Type u} \u2192  [UniformSpace \u03b1] \u2192  [UniformSpace \u03b2] \u2192 [UniformSpace \u03b3] \u2192  (f : \u03b1 \u2192 \u03b2) \u2192  (g : \u03b2 \u2192 \u03b3) \u2192  UniformContinuous f \u2192 UniformContinuous g \u2192 UniformContinuous (g \u2218 f)) := sorry\nexample : ({\u03b1 \u03b2 \u03b3 : Type u} \u2192  [UniformSpace \u03b1] \u2192  [UniformSpace \u03b2] \u2192 [UniformSpace \u03b3] \u2192  (f : \u03b1 \u2192 \u03b2) \u2192  (g : \u03b2 \u2192 \u03b3) \u2192  UniformContinuous f \u2192 UniformContinuous g \u2192 UniformContinuous (g \u2218 f)) \u2192 (\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} {\u03b3 : Type u_3} [inst : UniformSpace \u03b1] [inst_1 : UniformSpace \u03b2]   [inst_2 : UniformSpace \u03b3] {f : \u03b1 \u2192 \u03b2} {g : \u03b2 \u2192 \u03b3},   UniformContinuous f \u2192 UniformContinuous g \u2192 UniformContinuous (g \u2218 f)) := sorry\n\n\n/-- A terminal object in a category is unique up to unique isomorphism. -/\nexample : (\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {T T' : C}   (t : CategoryTheory.Limits.IsTerminal T),   CategoryTheory.Limits.IsTerminal T' \u2192 CategoryTheory.IsIso (CategoryTheory.Limits.IsTerminal.from t T')) \u2192 ({C : Type _} \u2192  [CategoryTheory.Category C] \u2192  \u2200 T\u2081 T\u2082 : C, CategoryTheory.Limits.IsTerminal T\u2081 \u2192 CategoryTheory.Limits.IsTerminal T\u2082 \u2192 (\u2203 \u03b9 : CategoryTheory.Iso T\u2081 T\u2082, \u2200 \u03b9' : CategoryTheory.Iso T\u2081 T\u2082, \u03b9 = \u03b9')) := sorry\nexample : ({C : Type _} \u2192  [CategoryTheory.Category C] \u2192  \u2200 T\u2081 T\u2082 : C, CategoryTheory.Limits.IsTerminal T\u2081 \u2192 CategoryTheory.Limits.IsTerminal T\u2082 \u2192 (\u2203 \u03b9 : CategoryTheory.Iso T\u2081 T\u2082, \u2200 \u03b9' : CategoryTheory.Iso T\u2081 T\u2082, \u03b9 = \u03b9')) \u2192 (\u2200 {C : Type u\u2081} [inst : CategoryTheory.Category C] [inst_1 : CategoryTheory.Limits.HasTerminal C] {T T' : C}   (t : CategoryTheory.Limits.IsTerminal T),   CategoryTheory.Limits.IsTerminal T' \u2192 CategoryTheory.IsIso (CategoryTheory.Limits.IsTerminal.from t T')) := sorry\n\n/-- The sum of the cubes of two positive integers is never equal to the cube of a third integer. -/\nexample : (\u2200 (a b c : \u2124), a ^ 3 + b ^ 3 \u2260 c ^ 3) \u2192 (\u2200 a b c : \u2115, a > 0 \u2192 b > 0 \u2192 \u00ac(a^3 + b^3 = c^3)) := sorry\nexample : (\u2200 a b c : \u2115, a > 0 \u2192 b > 0 \u2192 \u00ac(a^3 + b^3 = c^3)) \u2192 (\u2200 (a b c : \u2124), a ^ 3 + b ^ 3 \u2260 c ^ 3) := sorry\n\n/-- If every element of a group `G` has order `2`, then every pair of elements of `G` commutes. -/\nexample : (\u2200 {G : Type u_1} [inst : Group G], (\u2200 (x : G), x ^ 2 = 1) \u2192 \u2200 {x y : G}, Commute x y) \u2192 ({G: Type u} \u2192 [Group G] \u2192  (\u2200 x y : G, (x * x) = 1) \u2192 (\u2200 x y : G, Commute x y)) := sorry\nexample : ({G: Type u} \u2192 [Group G] \u2192  (\u2200 x y : G, (x * x) = 1) \u2192 (\u2200 x y : G, Commute x y)) \u2192 (\u2200 {G : Type u_1} [inst : Group G], (\u2200 (x : G), x ^ 2 = 1) \u2192 \u2200 {x y : G}, Commute x y) := sorry\n\n/-- The product of two consecutive natural numbers is even. -/\nexample : (\u2200 {p q : \u2115}, p = q + 1 \u2192 Even (p * q)) \u2192 ((n: Nat) \u2192  Even <| n * (n + 1)) := sorry\nexample : ((n: Nat) \u2192  Even <| n * (n + 1)) \u2192 (\u2200 {p q : \u2115}, p = q + 1 \u2192 Even (p * q)) := sorry\n\n/-- Every free group is torsion free. -/\nexample : (\u2200 (\u03b1 : Type u), Monoid.IsTorsionFree (FreeGroup \u03b1)) \u2192 ({\u03b1 : Type u} \u2192 Monoid.IsTorsionFree (FreeGroup \u03b1)) := sorry\nexample : ({\u03b1 : Type u} \u2192 Monoid.IsTorsionFree (FreeGroup \u03b1)) \u2192 (\u2200 (\u03b1 : Type u), Monoid.IsTorsionFree (FreeGroup \u03b1)) := sorry\n\n/-- Every natural number greater than `1` is divisible by a Nat.Prime number.  -/\nexample : (\u2200 {n : \u2115}, 1 < n \u2192 \u2203 p, Nat.Prime p \u2227 p \u2223 n) \u2192 ((n: \u2115) \u2192 \n  n > 1 \u2192 \u2203 p: \u2115, Nat.Prime p \u2227 (\u2203 d: \u2115, (p * d) = n)) := sorry\nexample : ((n: \u2115) \u2192 n > 1 \u2192 \u2203 p: \u2115, Nat.Prime p \u2227 (\u2203 d: \u2115, (p * d) = n)) \u2192 (\u2200 {n : \u2115}, 1 < n \u2192 \u2203 p, Nat.Prime p \u2227 p \u2223 n) := sorry\n\n/-- A finite torsion-free group is trivial -/\nexample : (\u2200 {G : Type u} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G \u2192 Fintype.card G = 1) \u2192 ({G: Type u} \u2192 [Group G] \u2192 [Finite G] \u2192 Monoid.IsTorsionFree G \u2192 IsSubgroup.Trivial G) := sorry\nexample : ({G: Type u} \u2192 [Group G] \u2192 [Finite G] \u2192 Monoid.IsTorsionFree G \u2192 IsSubgroup.Trivial G) \u2192 (\u2200 {G : Type u} [inst : Group G] [inst_1 : Fintype G], Monoid.IsTorsionFree G \u2192 Fintype.card G = 1) := sorry\n\n\n\n/-- Every surjective homomorphism from a finitely generated free group to itself is injective -/\nexample : (\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : Group \u03b1] [inst_1 : Group \u03b2] [inst_2 : Fintype \u03b1] [inst_3 : Fintype \u03b2]   {f : \u03b1 \u2192 \u03b2}, IsGroupHom f \u2192 Function.Surjective f \u2192 Function.Injective f) \u2192 ({\u03b1 : Type u} \u2192  [Finite \u03b1] \u2192 (f: FreeGroup \u03b1 \u2192 FreeGroup \u03b1) \u2192 (IsGroupHom f) \u2192 f.Surjective \u2192 f.Injective) := sorry\nexample : ({\u03b1 : Type u} \u2192  [Finite \u03b1] \u2192 (f: FreeGroup \u03b1 \u2192 FreeGroup \u03b1) \u2192 (IsGroupHom f) \u2192 f.Surjective \u2192 f.Injective) \u2192 (\u2200 {\u03b1 : Type u_1} {\u03b2 : Type u_2} [inst : Group \u03b1] [inst_1 : Group \u03b2] [inst_2 : Fintype \u03b1] [inst_3 : Fintype \u03b2]   {f : \u03b1 \u2192 \u03b2}, IsGroupHom f \u2192 Function.Surjective f \u2192 Function.Injective f) := sorry\n\n/-- Every positive even integer can be written as the sum of two Nat.Primes. -/\nexample : (\u2200 {n : \u2115}, 0 < n \u2192 Even n \u2192 \u2203 p q, Nat.Prime p \u2227 Nat.Prime q \u2227 p + q = n) \u2192 (\u2200 n : \u2115, n > 0 \u2192 Even n \u2192 \u2203 p q : \u2115, Nat.Prime p \u2192 Nat.Prime q \u2192 n = p + q) := sorry\nexample : (\u2200 n : \u2115, n > 0 \u2192 Even n \u2192 \u2203 p q : \u2115, Nat.Prime p \u2192 Nat.Prime q \u2192 n = p + q) \u2192 (\u2200 {n : \u2115}, 0 < n \u2192 Even n \u2192 \u2203 p q, Nat.Prime p \u2227 Nat.Prime q \u2227 p + q = n) := sorry\n\n\n\n/-- If the square of a number is even, the number itself is even. -/\nexample : (\u2200 {M : Type u} [inst : Semiring M] [inst_1 : DecidableEq M] (a : M), Even (a * a) \u2192 Even a) \u2192 (\u2200 n : \u2115, Even (n^2) \u2192 Even n) := sorry\nexample : (\u2200 n : \u2115, Even (n^2) \u2192 Even n) \u2192 (\u2200 {M : Type u} [inst : Semiring M] [inst_1 : DecidableEq M] (a : M), Even (a * a) \u2192 Even a) := sorry\n\n\n/-- If every point of a subset of a topological space is contained in some open set, the subset itself is open. -/\nexample : (\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s : Set \u03b1}, (\u2200 (x : \u03b1), x \u2208 s \u2192 \u2203 t, IsOpen t \u2227 x \u2208 t) \u2192 IsOpen s) \u2192 ({X : Type u} \u2192  [TopologicalSpace X] \u2192  (S : Set X) \u2192  (\u2200 x \u2208 S, \u2203 U : Set X, IsOpen U) \u2192 IsOpen S) := sorry\nexample : ({X : Type u} \u2192  [TopologicalSpace X] \u2192  (S : Set X) \u2192  (\u2200 x \u2208 S, \u2203 U : Set X, IsOpen U) \u2192 IsOpen S) \u2192 (\u2200 {\u03b1 : Type u} [inst : TopologicalSpace \u03b1] {s : Set \u03b1}, (\u2200 (x : \u03b1), x \u2208 s \u2192 \u2203 t, IsOpen t \u2227 x \u2208 t) \u2192 IsOpen s) := sorry\n\n/-- Every non-identity element of a free group is of infinite order. -/\nexample : (\u2200 {\u03b1 : Type u} [inst : DecidableEq \u03b1] {x : FreeGroup \u03b1}, x \u2260 1 \u2192 \u00acIsOfFinOrder x) \u2192 ({G : Type u} \u2192  [Group G] \u2192  FreeGroup G \u2192 (\u2200 g : G, g \u2260 1 \u2192 orderOf g = 0)) := sorry\nexample : ({G : Type u} \u2192  [Group G] \u2192  FreeGroup G \u2192 (\u2200 g : G, g \u2260 1 \u2192 orderOf g = 0)) \u2192 (\u2200 {\u03b1 : Type u} [inst : DecidableEq \u03b1] {x : FreeGroup \u03b1}, x \u2260 1 \u2192 \u00acIsOfFinOrder x) := sorry\n\n/-- For any two relatively Nat.Prime positive integers $a$ and $b$, every sufficiently large natural number $N$ can be written as a linear combination $ax + by$ of $a$ and $b$, where both $x$ and $y$ are natural numbers. -/\nexample : (\u2200 {m n : \u2115}, 0 < m \u2192 0 < n \u2192 Nat.gcd m n = 1 \u2192 \u2200 (N : \u2115), N > (m * n) \u2192 \u2203 x y, N = (m * x) + (n * y)) \u2192 (\u2200 a b : \u2115, a > 0 \u2192 b > 0 \u2192 Nat.coprime a b \u2192 \u2203 m : \u2115, \u2200 N : \u2115, N > m \u2192 \u2203 x y : \u2115, N = (a*x) + (b*y)) := sorry\nexample : (\u2200 a b : \u2115, a > 0 \u2192 b > 0 \u2192 Nat.coprime a b \u2192 \u2203 m : \u2115, \u2200 N : \u2115, N > m \u2192 \u2203 x y : \u2115, N = (a*x) + (b*y)) \u2192 (\u2200 {m n : \u2115}, 0 < m \u2192 0 < n \u2192 Nat.gcd m n = 1 \u2192 \u2200 (N : \u2115), N > (m * n) \u2192 \u2203 x y, N = (m * x) + (n * y)) := sorry\n\n-- The ones below had no model answers\n\n\n/-- The set of units in a ring forms a group. -/\nexample : ((R : Type u_1) \u2192 [inst : Ring R] \u2192 AddGroup (Units R)) \u2192 (Unit) := sorry\nexample : (Unit) \u2192 ((R : Type u_1) \u2192 [inst : Ring R] \u2192 AddGroup (Units R)) := sorry\n\n/-- If the direct product of two groups is torsion free then each of the groups is torsion free. -/\nexample : (\u2200 {\u03b7 : Type u_1} (G : Type u_2) [inst : Group G] {\u0393 : Type u_3} [inst_1 : Group \u0393],   Monoid.IsTorsionFree (G \u00d7 \u0393) \u2192 Monoid.IsTorsionFree G \u2227 Monoid.IsTorsionFree \u0393) \u2192 (Unit) := sorry\nexample : (Unit) \u2192 (\u2200 {\u03b7 : Type u_1} (G : Type u_2) [inst : Group G] {\u0393 : Type u_3} [inst_1 : Group \u0393],   Monoid.IsTorsionFree (G \u00d7 \u0393) \u2192 Monoid.IsTorsionFree G \u2227 Monoid.IsTorsionFree \u0393) := sorry\n\n\n-- #eval do\n--   let l \u2190 getFileThmInfo\n--   --let l' := l.map Prod.fst |>.map Lean.Name.toString |>.qsort\n--   -- return l'.groupBy $ \u03bb s s' => s.dropRight 1 == s'.dropRight 1\n--   return 1\n\n-- #eval [1, 1, 2, 2].groupBy (\u00b7 = \u00b7)\n\n-- #eval (Lean.Name.toString `fermat_two_square0).dropRight 1"}
{"text": "lemma components_empty [simp]: \"components {} = {}\""}
{"text": "[GOAL]\nn : \u2115\nh : 0 < n\nm : \u2115 := n / 2\n\u22a2 m < n\n[PROOFSTEP]\napply Nat.div_lt_self h\n[GOAL]\nn : \u2115\nh : 0 < n\nm : \u2115 := n / 2\n\u22a2 1 < 2\n[PROOFSTEP]\ndecide\n[GOAL]\nn : \u2115\n\u22a2 Fin.ofNat 0 \u2264 Fin.ofNat __do_lift\u271d\n[PROOFSTEP]\nsimp [Fin.ofNat, LE.le]\n[GOAL]\nn : \u2115\n\u22a2 0 \u2264 __do_lift\u271d % (n + 1)\n[PROOFSTEP]\nexact Nat.zero_le _\n[GOAL]\n\u22a2 0 < List.length (String.toList \" 0123abcABC:,;`\\\\/\")\n[PROOFSTEP]\ndecide\n"}
{"text": "[STATEMENT]\nlemma composite_simps [simp]:\n    shows \"src (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = src \\<pi>\"\n    and \"src ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = src \\<pi>\"\n    and \"trg (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = trg \\<mu>\"\n    and \"trg ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = trg \\<mu>\"\n    and \"dom (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = dom \\<mu> \\<star> dom \\<nu> \\<star> dom \\<pi>\"\n    and \"dom ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = (dom \\<mu> \\<star> dom \\<nu>) \\<star> dom \\<pi>\"\n    and \"cod (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = cod \\<mu> \\<star> cod \\<nu> \\<star> cod \\<pi>\"\n    and \"cod ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = (cod \\<mu> \\<star> cod \\<nu>) \\<star> cod \\<pi>\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. ((src (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = src \\<pi> &&& src ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = src \\<pi>) &&& trg (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = trg \\<mu> &&& trg ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = trg \\<mu>) &&& (local.dom (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = local.dom \\<mu> \\<star> local.dom \\<nu> \\<star> local.dom \\<pi> &&& local.dom ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = (local.dom \\<mu> \\<star> local.dom \\<nu>) \\<star> local.dom \\<pi>) &&& cod (\\<mu> \\<star> \\<nu> \\<star> \\<pi>) = cod \\<mu> \\<star> cod \\<nu> \\<star> cod \\<pi> &&& cod ((\\<mu> \\<star> \\<nu>) \\<star> \\<pi>) = (cod \\<mu> \\<star> cod \\<nu>) \\<star> cod \\<pi>\n[PROOF STEP]\nby (auto simp add: \\<mu>\\<nu>.composable \\<nu>\\<pi>.composable)"}
{"text": "[GOAL]\nf : \u2102[X]\nhf : 0 < degree f\n\u22a2 \u2203 z, IsRoot f z\n[PROOFSTEP]\ncontrapose! hf\n[GOAL]\nf : \u2102[X]\nhf : \u2200 (z : \u2102), \u00acIsRoot f z\n\u22a2 degree f \u2264 0\n[PROOFSTEP]\nhave : Metric.Bounded (Set.range (eval \u00b7 f)\u207b\u00b9)\n[GOAL]\ncase this\nf : \u2102[X]\nhf : \u2200 (z : \u2102), \u00acIsRoot f z\n\u22a2 Metric.Bounded (Set.range (fun x => eval x f)\u207b\u00b9)\n[PROOFSTEP]\nobtain \u27e8z\u2080, h\u2080\u27e9 := f.exists_forall_norm_le\n[GOAL]\ncase this.intro\nf : \u2102[X]\nhf : \u2200 (z : \u2102), \u00acIsRoot f z\nz\u2080 : \u2102\nh\u2080 : \u2200 (y : \u2102), \u2016eval z\u2080 f\u2016 \u2264 \u2016eval y f\u2016\n\u22a2 Metric.Bounded (Set.range (fun x => eval x f)\u207b\u00b9)\n[PROOFSTEP]\nsimp only [Pi.inv_apply, bounded_iff_forall_norm_le, Set.forall_range_iff, norm_inv]\n[GOAL]\ncase this.intro\nf : \u2102[X]\nhf : \u2200 (z : \u2102), \u00acIsRoot f z\nz\u2080 : \u2102\nh\u2080 : \u2200 (y : \u2102), \u2016eval z\u2080 f\u2016 \u2264 \u2016eval y f\u2016\n\u22a2 \u2203 C, \u2200 (i : \u2102), \u2016eval i f\u2016\u207b\u00b9 \u2264 C\n[PROOFSTEP]\nexact \u27e8\u2016eval z\u2080 f\u2016\u207b\u00b9, fun z => inv_le_inv_of_le (norm_pos_iff.2 <| hf z\u2080) (h\u2080 z)\u27e9\n[GOAL]\nf : \u2102[X]\nhf : \u2200 (z : \u2102), \u00acIsRoot f z\nthis : Metric.Bounded (Set.range (fun x => eval x f)\u207b\u00b9)\n\u22a2 degree f \u2264 0\n[PROOFSTEP]\nobtain \u27e8c, hc\u27e9 := (f.differentiable.inv hf).exists_const_forall_eq_of_bounded this\n[GOAL]\ncase intro\nf : \u2102[X]\nhf : \u2200 (z : \u2102), \u00acIsRoot f z\nthis : Metric.Bounded (Set.range (fun x => eval x f)\u207b\u00b9)\nc : \u2102\nhc : \u2200 (z : \u2102), (eval z f)\u207b\u00b9 = c\n\u22a2 degree f \u2264 0\n[PROOFSTEP]\nobtain rfl : f = C c\u207b\u00b9 := Polynomial.funext fun z => by rw [eval_C, \u2190 hc z, inv_inv]\n[GOAL]\nf : \u2102[X]\nhf : \u2200 (z : \u2102), \u00acIsRoot f z\nthis : Metric.Bounded (Set.range (fun x => eval x f)\u207b\u00b9)\nc : \u2102\nhc : \u2200 (z : \u2102), (eval z f)\u207b\u00b9 = c\nz : \u2102\n\u22a2 eval z f = eval z (\u2191C c\u207b\u00b9)\n[PROOFSTEP]\nrw [eval_C, \u2190 hc z, inv_inv]\n[GOAL]\ncase intro\nc : \u2102\nhf : \u2200 (z : \u2102), \u00acIsRoot (\u2191C c\u207b\u00b9) z\nthis : Metric.Bounded (Set.range (fun x => eval x (\u2191C c\u207b\u00b9))\u207b\u00b9)\nhc : \u2200 (z : \u2102), (eval z (\u2191C c\u207b\u00b9))\u207b\u00b9 = c\n\u22a2 degree (\u2191C c\u207b\u00b9) \u2264 0\n[PROOFSTEP]\nexact degree_C_le\n"}
{"text": "module Issue1148 where\n\nfoo : Set \u2192 Set\nfoo = {!!}\n\n\n\n"}
{"text": "theory Check\n  imports Submission\nbegin\n\ntheorem SQUARE_correct: \"\\<turnstile> {\\<lambda>s. s ''n'' \\<ge> 0 \\<and> s=s\\<^sub>0} SQUARE {\\<lambda>s. s ''a'' = s\\<^sub>0 ''n'' * s\\<^sub>0 ''n''}\"\n  by (rule Submission.SQUARE_correct)\n\nend"}
{"text": "function results = vl_test_slic(varargin)\n% VL_TEST_SLIC\nvl_test_init ;\n\nfunction s = setup()\ns.im = im2single(vl_impattern('roofs1')) ;\n\nfunction test_slic(s)\nsegmentation = vl_slic(s.im, 10, 0.1) ;\n"}
{"text": "open classical\nvariables {A B C : Prop}\n-- Prove \u00ac (A \u2227 B) \u2192 \u00ac A \u2228 \u00ac B by replacing the sorry's below\n-- by proofs.\n\nlemma step1 (h1 : \u00ac (A \u2227 B)) (h2 : A) : \u00ac A \u2228 \u00ac B :=\nhave \u00ac B, from (assume g1 : B, show false, from h1 (and.intro h2 g1)),\nshow \u00ac A \u2228 \u00ac B, from or.inr this\n\n\nlemma step2 (h1 : \u00ac (A \u2227 B)) (h2 : \u00ac (\u00ac A \u2228 \u00ac B)) : false :=\nhave \u00ac A, from\n  assume : A,\n  have \u00ac A \u2228 \u00ac B, from step1 h1 \u2039A\u203a,\n  show false, from h2 this,\nshow false, from h2 (or.inl this)\n\n\ntheorem step3 (h : \u00ac (A \u2227 B)) : \u00ac A \u2228 \u00ac B :=\nby_contradiction\n  (assume h' : \u00ac (\u00ac A \u2228 \u00ac B),\n  show false, from step2 h h')\n\n\nexample (h : \u00ac B \u2192 \u00ac A) : A \u2192 B :=\nassume ha : A,\nby_contradiction\n  (assume hnb : \u00ac B,\n    have hna : \u00ac A, from h hnb,\n    show false, from hna ha)\n\n\nexample (h : A \u2192 B) : \u00ac A \u2228 B :=\nhave t : A \u2228 \u00ac A, from em A,\nor.elim t\n  (assume ha : A,\n    have hb : B, from h ha,\n    show \u00ac A \u2228 B, from or.inr hb)\n  (assume hna : \u00ac A,  show \u00ac A \u2228 B, from or.inl hna)\n"}
{"text": "import category_theory.equivalence\n\nopen category_theory\n\nvariables {C : Type*} [category C]\nvariables {D : Type*} [category D]\n\nlemma equiv_reflects_mono {X Y : C} (f : X \u27f6 Y) (e : C \u224c D)\n  (hef : mono (e.functor.map f)) : mono f :=\nbegin\n  split,\n  intros Z g h w,\n  apply e.functor.map_injective,\n  rw \u2190 cancel_mono (e.functor.map f),\n  apply e.inverse.map_injective,\n  -- That's ugly! In fact, so ugly that surely `simp` can clean things up from here.\n  sorry\nend\n"}
{"text": "opaque f (x y : Nat) : Nat\nopaque g (x : Nat) : Nat\n\ntheorem ex1 (x : Nat) (h\u2081 : f x x = g x) (h\u2082 : g x = x) : f x (f x x) = x := by\n  simp\n  simp [*]\n\ntheorem ex2 (x : Nat) (h\u2081 : f x x = g x) (h\u2082 : g x = x) : f x (f x x) = x := by\n  simp [*]\n\naxiom g_ax (x : Nat) : g x = 0\n\ntheorem ex3 (x y : Nat) (h\u2081 : f x x = g x) (h\u2082 : f x x < 5) : f x x + f x x = 0 := by\n  simp [*] at *\n  trace_state\n  have aux\u2081 : f x x = g x := h\u2081\n  have aux\u2082 : g x < 5     := h\u2082\n  simp [g_ax]\n"}
{"text": "(* ** License\n * -----------------------------------------------------------------------\n * Copyright 2016--2017 IMDEA Software Institute\n * Copyright 2016--2017 Inria\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.\n * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n * CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,\n * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE\n * SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\n * ----------------------------------------------------------------------- *)\n\n(* ** Imports and settings *)\nRequire Import oseq.\nRequire Export ZArith Setoid Morphisms.\nFrom mathcomp Require Import all_ssreflect all_algebra.\nFrom CoqWord Require Import ssrZ.\nRequire Export strings word utils type var global sem_type x86_decl x86_instr_decl.\nRequire Import xseq.\nImport Utf8 ZArith.\n\nSet Implicit Arguments.\nUnset Strict Implicit.\nUnset Printing Implicit Defensive.\n\nLocal Unset Elimination Schemes.\n\n(* ** Operators\n * -------------------------------------------------------------------- *)\n(* *** Summary\n   Operators represent several constructs in the Ocaml compiler:\n   - const-op: compile-time expressions (constexpr in C++)\n   - list-op: argument and result lists\n   - arr-op: reading and writing arrays\n   - cpu-op: CPU instructions such as addition with carry\n*)\n\nVariant cmp_kind :=\n  | Cmp_int\n  | Cmp_w of signedness & wsize.\n\nVariant op_kind :=\n  | Op_int\n  | Op_w of wsize.\n\nVariant sop1 :=\n| Oword_of_int of wsize (* int \u2192 word *)\n| Oint_of_word of wsize (* word \u2192 unsigned int *)\n| Osignext of wsize & wsize (* Sign-extension: output-size, input-size *)\n| Ozeroext of wsize & wsize (* Zero-extension: output-size, input-size *)\n| Onot (* Boolean negation *)\n| Olnot of wsize (* Bitwize not: 1s\u2019 complement *)\n| Oneg  of op_kind (* Arithmetic negation *)\n.\n\nVariant sop2 :=\n| Oand                        (* const : sbool -> sbool -> sbool *)\n| Oor                         (* const : sbool -> sbool -> sbool *)\n\n| Oadd  of op_kind\n| Omul  of op_kind\n| Osub  of op_kind\n| Odiv  of cmp_kind\n| Omod  of cmp_kind\n\n| Oland of wsize\n| Olor  of wsize\n| Olxor of wsize\n| Olsr  of wsize\n| Olsl  of wsize\n| Oasr  of wsize\n\n| Oeq   of op_kind\n| Oneq  of op_kind\n| Olt   of cmp_kind\n| Ole   of cmp_kind\n| Ogt   of cmp_kind\n| Oge   of cmp_kind\n\n(* vector operation *)\n| Ovadd of velem & wsize (* VPADD   *)\n| Ovsub of velem & wsize (* VPSUB   *)\n| Ovmul of velem & wsize (* VPMULLW *)\n| Ovlsr of velem & wsize\n| Ovlsl of velem & wsize\n| Ovasr of velem & wsize\n.\n\n(* N-ary operators *)\nVariant opN :=\n| Opack of wsize & pelem (* Pack words of size pelem into one word of wsize *)\n.\n\nVariant sopn : Set :=\n(* Generic operation *)\n| Omulu     of wsize   (* cpu   : [sword; sword]        -> [sword;sword] *)\n| Oaddcarry of wsize   (* cpu   : [sword; sword; sbool] -> [sbool;sword] *)\n| Osubcarry of wsize   (* cpu   : [sword; sword; sbool] -> [sbool;sword] *)\n\n(* Low level x86 operations *)\n| Oset0     of wsize  (* set register + flags to 0 (implemented using XOR x x or VPXOR x x) *)\n| Ox86MOVZX32\n| Ox86      of asm_op  (* x86 instruction *)\n.\n\nScheme Equality for sop1.\n(* Definition sop1_beq : sop1 -> sop1 -> bool *)\n\nLemma sop1_eq_axiom : Equality.axiom sop1_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_sop1_dec_bl.\n  by apply: internal_sop1_dec_lb.\nQed.\n\nDefinition sop1_eqMixin     := Equality.Mixin sop1_eq_axiom.\nCanonical  sop1_eqType      := Eval hnf in EqType sop1 sop1_eqMixin.\n\nScheme Equality for sop2.\n(* Definition sop2_beq : sop2 -> sop2 -> bool *)\n\nLemma sop2_eq_axiom : Equality.axiom sop2_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_sop2_dec_bl.\n  by apply: internal_sop2_dec_lb.\nQed.\n\nDefinition sop2_eqMixin     := Equality.Mixin sop2_eq_axiom.\nCanonical  sop2_eqType      := Eval hnf in EqType sop2 sop2_eqMixin.\n\nScheme Equality for opN.\n\nLemma opN_eq_axiom : Equality.axiom opN_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_opN_dec_bl.\n  by apply: internal_opN_dec_lb.\nQed.\n\nDefinition opN_eqMixin     := Equality.Mixin opN_eq_axiom.\nCanonical  opN_eqType      := Eval hnf in EqType opN opN_eqMixin.\n\nScheme Equality for sopn.\n(* Definition sopn_beq : sopn -> sopn -> bool *)\nLemma sopn_eq_axiom : Equality.axiom sopn_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_sopn_dec_bl.\n  by apply: internal_sopn_dec_lb.\nQed.\n\nDefinition sopn_eqMixin     := Equality.Mixin sopn_eq_axiom.\nCanonical  sopn_eqType      := Eval hnf in EqType sopn sopn_eqMixin.\n\n(* ----------------------------------------------------------------------------- *)\n\nRecord instruction := mkInstruction {\n  str      : unit -> string;\n  tin      : list stype;\n  i_in     : seq arg_desc; \n  tout     : list stype;\n  i_out    : seq arg_desc;\n  semi     : sem_prod tin (exec (sem_tuple tout));\n  tin_narr : all is_not_sarr tin;\n  wsizei   : wsize;\n  i_safe   : seq safe_cond;\n}.\n\nNotation mk_instr str tin i_in tout i_out semi wsizei safe:=\n  {| str      := str;\n     tin      := tin;\n     i_in     := i_in;\n     tout     := tout;\n     i_out    := i_out;\n     semi     := semi;\n     tin_narr := refl_equal;\n     wsizei   := wsizei;\n     i_safe   := safe;\n  |}.\n\n(* ----------------------------------------------------------------------------- *)\n\nDefinition Omulu_instr sz := \n  mk_instr (pp_sz \"mulu\" sz) \n           (w2_ty sz sz) [:: R RAX; E 0]\n           (w2_ty sz sz) [:: R RDX; R RAX] (fun x y => ok (@wumul sz x y)) sz [::].\n \nDefinition Oaddcarry_instr sz := \n  mk_instr (pp_sz \"addc\" sz) \n           [::sword sz; sword sz; sbool] \n           [::E 0; E 1; F CF]\n           (sbool :: (w_ty sz))  \n           [:: F CF; E 0]\n           (fun x y c => let p := @waddcarry sz x y c in ok (Some p.1, p.2))\n           sz [::].\n\nDefinition Osubcarry_instr sz:= \n  mk_instr (pp_sz \"subc\" sz) \n           [::sword sz; sword sz; sbool] [::E 0; E 1; F CF]\n           (sbool :: (w_ty sz)) [:: F CF; E 0] \n           (fun x y c => let p := @wsubcarry sz x y c in ok (Some p.1, p.2))\n           sz [::].\n\nDefinition Oset0_instr sz  :=\n  let name := pp_sz \"set0\" sz in\n  if (sz <= U64)%CMP then \n    mk_instr name \n             [::] [::]\n             (b5w_ty sz) (implicit_flags ++ [::E 0])\n             (let vf := Some false in\n              ok (::vf, vf, vf, vf, Some true & (0%R: word sz)))\n             sz [::]\n  else \n    mk_instr name \n             [::] [::]  \n             (w_ty sz) [::E 0] \n             (ok (0%R: word sz)) sz [::].\n\nDefinition Ox86MOVZX32_instr := \n  mk_instr (pp_s \"MOVZX32\") \n           [:: sword32] [:: E 1] \n           [:: sword64] [:: E 0] \n           (\u03bb x : u32, ok (zero_extend U64 x)) \n           U32 [::].\n\nDefinition get_instr o :=\n  match o with\n  | Omulu     sz => Omulu_instr sz\n  | Oaddcarry sz => Oaddcarry_instr sz\n  | Osubcarry sz => Osubcarry_instr sz\n  | Oset0     sz => Oset0_instr sz\n  | Ox86MOVZX32  => Ox86MOVZX32_instr\n  | Ox86   instr =>\n      let id := instr_desc instr in\n      {|\n        str      := id.(id_str_jas);\n        tin      := id.(id_tin);\n        i_in     := id.(id_in);\n        i_out    := id.(id_out);\n        tout     := id.(id_tout);\n        semi     := id.(id_semi);\n        tin_narr := id.(id_tin_narr);\n        wsizei   := id.(id_wsize);\n        i_safe   := id.(id_safe)\n      |}\n  end.\n\nDefinition string_of_sopn o : string := str (get_instr o) tt.\n\nDefinition sopn_tin o : list stype := tin (get_instr o).\nDefinition sopn_tout o : list stype := tout (get_instr o).\nDefinition sopn_sem  o := semi (get_instr o).\nDefinition wsize_of_sopn o : wsize := wsizei (get_instr o).\n\n(* Type of unany operators: input, output *)\nDefinition type_of_op1 (o: sop1) : stype * stype :=\n  match o with\n  | Oword_of_int sz => (sint, sword sz)\n  | Oint_of_word sz => (sword sz, sint)\n  | Osignext szo szi\n  | Ozeroext szo szi\n    => (sword szi, sword szo)\n  | Onot => (sbool, sbool)\n  | Olnot sz\n  | Oneg (Op_w sz)\n    => let t := sword sz in (t, t)\n  | Oneg Op_int => (sint, sint)\n  end.\n\n(* Type of binany operators: inputs, output *)\nDefinition type_of_op2 (o: sop2) : stype * stype * stype :=\n  match o with\n  | Oand | Oor => (sbool, sbool, sbool)\n  | Oadd Op_int\n  | Omul Op_int\n  | Osub Op_int\n  | Odiv Cmp_int | Omod Cmp_int\n    => (sint, sint, sint)\n  | Oadd (Op_w s)\n  | Omul (Op_w s)\n  | Osub (Op_w s)\n  | Odiv (Cmp_w _ s) | Omod (Cmp_w _ s)\n  | Oland s | Olor s | Olxor s | Ovadd _ s | Ovsub _ s | Ovmul _ s\n    => let t := sword s in (t, t, t)\n  | Olsr s | Olsl s | Oasr s\n  | Ovlsr _ s | Ovlsl _ s | Ovasr _ s\n    => let t := sword s in (t, sword8, t)\n  | Oeq Op_int | Oneq Op_int\n  | Olt Cmp_int | Ole Cmp_int\n  | Ogt Cmp_int | Oge Cmp_int\n    => (sint, sint, sbool)\n  | Oeq (Op_w s) | Oneq (Op_w s)\n  | Olt (Cmp_w _ s) | Ole (Cmp_w _ s)\n  | Ogt (Cmp_w _ s) | Oge (Cmp_w _ s)\n    => let t := sword s in (t, t, sbool)\n  end.\n\n(* Type of n-ary operators: inputs, output *)\nDefinition type_of_opN (op: opN) : seq stype * stype :=\n  match op with\n  | Opack ws p =>\n    let n := nat_of_wsize ws %/ nat_of_pelem p in\n    (nseq n sint, sword ws)\n  end.\n\n(* ** Expressions\n * -------------------------------------------------------------------- *)\n(* Used only by the ocaml compiler *)\nDefinition var_info := positive.\n\nRecord var_i := VarI {\n  v_var :> var;\n  v_info : var_info\n}.\n\nRecord var_attr := VarA {\n  va_pub : bool\n}.\n\nDefinition var_info_to_attr (vi: var_info) :=\n  match vi with\n  | xI _ => VarA true\n  | _ => VarA false\n  end.\n\nInductive pexpr : Type :=\n| Pconst :> Z -> pexpr\n| Pbool  :> bool -> pexpr\n| Parr_init : positive \u2192 pexpr\n| Pvar   :> var_i -> pexpr\n| Pglobal :> global -> pexpr\n| Pget   : wsize -> var_i -> pexpr -> pexpr\n| Pload  : wsize -> var_i -> pexpr -> pexpr\n| Papp1  : sop1 -> pexpr -> pexpr\n| Papp2  : sop2 -> pexpr -> pexpr -> pexpr\n| PappN of opN & seq pexpr\n| Pif    : stype -> pexpr -> pexpr -> pexpr -> pexpr.\n\nNotation pexprs := (seq pexpr).\n\nSection ALL2.\n   Variable T:Type.\n   Variable eqb: T -> T -> bool.\n   Variable Heq : forall (x y:T), reflect (x = y) (eqb x y).\n\n   Lemma reflect_all2 l1 l2 : reflect (l1 = l2) (all2 eqb l1 l2).\n   Proof.\n     elim: l1 l2 => [|e1 l1 Hrec1] [|e2 l2] /=;try by constructor.\n     apply (@equivP (eqb e1 e2 /\\ all2 eqb l1 l2));first by apply andP.\n     split=> [ [] /Heq -> /Hrec1 ->|[] ??] //.\n     split. by apply /Heq. by apply /Hrec1.\n   Defined.\nEnd ALL2.\n\nSection ALLT.\n  Context (A: Type) (P: A \u2192 Type).\n  Fixpoint allT (m: seq A) : Type :=\n    if m is a :: m' then P a * allT m' else unit.\nEnd ALLT.\n\nLemma allT_refl A (P: A \u2192 A \u2192 Prop) m :\n  allT (\u03bb a, P a a) m \u2192 List.Forall2 P m m.\nProof. by elim: m => // a m ih [h] /ih{ih}ih; constructor. Qed.\n\nSection PEXPR_RECT.\n\n  Context\n    (P: pexpr \u2192 Type)\n    (Hconst: \u2200 z, P (Pconst z))\n    (Hbool: \u2200 b, P (Pbool b))\n    (Harr_init: \u2200 n, P (Parr_init n))\n    (Hvar: \u2200 x, P (Pvar x))\n    (Hglobal: \u2200 g, P (Pglobal g))\n    (Hget: \u2200 sz x e, P e \u2192 P (Pget sz x e))\n    (Hload: \u2200 sz x e, P e \u2192 P (Pload sz x e))\n    (Happ1: \u2200 op e, P e \u2192 P (Papp1 op e))\n    (Happ2: \u2200 op e1 e2, P e1 \u2192 P e2 \u2192 P (Papp2 op e1 e2))\n    (HappN: \u2200 op es, allT P es \u2192 P (PappN op es))\n    (Hif: \u2200 t e e1 e2, P e \u2192 P e1 \u2192 P e2 \u2192 P (Pif t e e1 e2))\n  .\n\n  Definition pexpr_rect_rec (f: \u2200 e, P e) : \u2200 es, allT P es :=\n    fix loop es :=\n      if es is e :: es\n      then (f e, loop es)\n      else tt.\n\n  Fixpoint pexpr_rect (e: pexpr) : P e :=\n    match e with\n    | Pconst z => Hconst z\n    | Pbool b => Hbool b\n    | Parr_init n => Harr_init n\n    | Pvar x => Hvar x\n    | Pglobal g => Hglobal g\n    | Pget sz x e => Hget sz x (pexpr_rect e)\n    | Pload sz x e => Hload sz x (pexpr_rect e)\n    | Papp1 op e => Happ1 op (pexpr_rect e)\n    | Papp2 op e1 e2 => Happ2 op (pexpr_rect e1) (pexpr_rect e2)\n    | PappN op es => HappN op (pexpr_rect_rec pexpr_rect es)\n    | Pif t e e1 e2 => Hif t (pexpr_rect e) (pexpr_rect e1) (pexpr_rect e2)\n    end.\n\nEnd PEXPR_RECT.\n\nArguments pexpr_rect: clear implicits.\n\nDefinition var_i_beq x1 x2 :=\n  match x1, x2 with\n  | VarI x1 i1, VarI x2 i2 => (x1 == x2) && (i1 == i2)\n  end.\n\nLemma var_i_eq_axiom : Equality.axiom var_i_beq.\nProof.\n  move=> [x xi] [y yi] /=.\n  apply (@equivP ((x == y) /\\ (xi == yi)));first by apply: andP.\n  by split => -[] => [/eqP -> /eqP| -> ] ->.\nQed.\n\nDefinition var_i_eqMixin     := Equality.Mixin var_i_eq_axiom.\nCanonical  var_i_eqType      := Eval hnf in EqType var_i var_i_eqMixin.\n\nModule Eq_pexpr.\n\nFixpoint eqb (e1 e2:pexpr) : bool :=\n  match e1, e2 with\n  | Pconst n1   , Pconst n2    => n1 == n2\n  | Pbool  b1   , Pbool  b2    => b1 == b2\n  | Parr_init n1, Parr_init n2 => n1 == n2\n  | Pvar   x1   , Pvar   x2    => (x1 == x2)\n  | Pglobal g1, Pglobal g2 => g1 == g2\n  | Pget sz1 x1 e1, Pget sz2 x2 e2 => (sz1 == sz2) && (x1 == x2) && eqb e1 e2\n  | Pload sz1 x1 e1, Pload sz2 x2 e2 => (sz1 == sz2) && (x1 == x2) && eqb e1 e2\n  | Papp1 o1 e1 , Papp1  o2 e2 => (o1 == o2) && eqb e1 e2\n  | Papp2 o1 e11 e12, Papp2 o2 e21 e22  =>\n     (o1 == o2) && eqb e11 e21 && eqb e12 e22\n  | PappN o1 es1, PappN o2 es2 =>\n    (o1 == o2) && all2 eqb es1 es2\n  | Pif t1 b1 e11 e12, Pif t2 b2 e21 e22  =>\n     (t1 == t2) && eqb b1 b2 && eqb e11 e21 && eqb e12 e22\n  | _, _ => false\n  end.\n\n  Lemma eqb_refl e : eqb e e.\n  Proof.\n    elim/pexpr_rect: e => //= *;\n    repeat match goal with\n    | H : _ |- _ => rewrite H //=\n    | |- context[ (?a == ?a) ] => rewrite eqxx //=\n    end.\n    apply/all2P; exact: allT_refl.\n  Qed.\n\n  Lemma eq_axiom : Equality.axiom eqb.\n  Proof.\n    elim => [n1|b1| n1 |x1|g1|w1 x1 e1 He1|w1 x1 e1 He1\n            |o1 e1 He1|o1 e11 e12 He11 He12 | o1 es1 Hes1 | st1 t1 e11 e12 Ht1 He11 He12]\n            [n2|b2| n2 |x2|g2|w2 x2 e2|w2 x2 e2|o2 e2|o2 e21 e22 | o2 es2 |st2 t2 e21 e22] /=;\n        try by constructor.\n    + apply (@equivP (n1 = n2));first by apply: eqP.\n      by split => [->|[]->].\n    + apply (@equivP (b1 = b2));first by apply: eqP.\n      by split => [->|[]->].\n    + apply (@equivP (n1 = n2));first by apply eqP.\n      by split => [->|[]->].\n    + apply (@equivP (x1 = x2));first by apply: eqP.\n      by split => [->|[]->].\n    + apply (@equivP (g1 = g2));first by apply: eqP.\n      by split => [->|[]->].\n    + apply (@equivP (((w1 == w2) && (x1 == x2)) /\\ eqb e1 e2));first by apply andP.\n      split => [ [] /andP [] /eqP -> /eqP -> /He1 -> | [] -> -> <-] //.\n      by rewrite ! eq_refl; split => //; apply/ He1.\n    + apply (@equivP (((w1 == w2) && (x1 == x2)) /\\ eqb e1 e2)); first by apply andP.\n      split => [ [] /andP [] /eqP -> /eqP -> /He1 -> | [] -> -> <-] //.\n      by rewrite ! eq_refl; split => //; apply/ He1.\n    + apply (@equivP ((o1 == o2) /\\ eqb e1 e2));first by apply andP.\n      by split=> [ [] /eqP -> /He1 -> | [] -> <- ] //;split => //;apply /He1.\n    + apply (@equivP (((o1 == o2) && eqb e11 e21) /\\ eqb e12 e22));first by apply andP.\n      split=> [ []/andP[]/eqP-> /He11 -> /He12->| [] <- <- <- ] //.\n      by rewrite eq_refl /=;split;[apply /He11|apply /He12].\n    + apply (@equivP ((o1 == o2) \u2227 all2 eqb es1 es2)); first by apply: andP.\n      split.\n      - case => /eqP <-{o2} h; f_equal.\n        elim: es1 es2 Hes1 h; first by case.\n        by move => e1 es1 ih [] // e2 es2 [h1] /ih{ih}ih/=/andP[]/(rwP (h1 _)) <- /ih <-.\n      move => h.\n      have : o1 = o2 \u2227 es1 = es2 by refine (let: erefl := h in conj erefl erefl).\n      move => {h} [??]; subst es2 o2; split; first exact: eqxx.\n      elim: es1 Hes1 => // e es ih [h] /ih{ih}ih /=.\n      by case: (h e).\n    apply (@equivP (((st1 == st2) && eqb t1 t2 && eqb e11 e21) /\\ eqb e12 e22));first by apply andP.\n    split => [ [] /andP[]/andP[] /eqP -> /Ht1 -> /He11 -> /He12 ->| [<- <- <- <-]] //.\n    by split;[apply /andP;split;[apply /andP;split|]|]; [apply /eqP | apply /Ht1 | apply /He11 | apply /He12].\n  Qed.\n\n  Definition pexpr_eqMixin := Equality.Mixin eq_axiom.\n  Module Exports.\n  Canonical pexpr_eqType  := Eval hnf in EqType pexpr pexpr_eqMixin.\n  End Exports.\nEnd Eq_pexpr.\nExport Eq_pexpr.Exports.\n\nSection PEXPR_IND.\n  Context\n    (P: pexpr \u2192 Prop)\n    (Hconst: \u2200 z, P (Pconst z))\n    (Hbool: \u2200 b, P (Pbool b))\n    (Harr_init: \u2200 n, P (Parr_init n))\n    (Hvar: \u2200 x, P (Pvar x))\n    (Hglobal: \u2200 g, P (Pglobal g))\n    (Hget: \u2200 sz x e, P e \u2192 P (Pget sz x e))\n    (Hload: \u2200 sz x e, P e \u2192 P (Pload sz x e))\n    (Happ1: \u2200 op e, P e \u2192 P (Papp1 op e))\n    (Happ2: \u2200 op e1, P e1 \u2192 \u2200 e2, P e2 \u2192 P (Papp2 op e1 e2))\n    (HappN: \u2200 op es, (\u2200 e, e \\in es \u2192 P e) \u2192 P (PappN op es))\n    (Hif: \u2200 t e, P e \u2192 \u2200 e1, P e1 \u2192 \u2200 e2, P e2 \u2192 P (Pif t e e1 e2))\n  .\n\n  Definition pexpr_ind_rec (f: \u2200 e, P e) : \u2200 es : pexprs, \u2200 e, e \\in es \u2192 P e.\n  refine\n    (fix loop es :=\n       if es is e :: es'\n       then \u03bb (e: pexpr), _\n       else \u03bb e (k: e \\in [::]), False_ind _ (Bool.diff_false_true k)\n    ).\n  rewrite in_cons; case/orP.\n  + move => /eqP -> ; exact: f.\n  apply: loop.\n  Defined.\n\n  Fixpoint pexpr_ind (e: pexpr) : P e :=\n    match e with\n    | Pconst z => Hconst z\n    | Pbool b => Hbool b\n    | Parr_init n => Harr_init n\n    | Pvar x => Hvar x\n    | Pglobal g => Hglobal g\n    | Pget sz x e => Hget sz x (pexpr_ind e)\n    | Pload sz x e => Hload sz x (pexpr_ind e)\n    | Papp1 op e => Happ1 op (pexpr_ind e)\n    | Papp2 op e1 e2 => Happ2 op (pexpr_ind e1) (pexpr_ind e2)\n    | PappN op es => HappN op (@pexpr_ind_rec pexpr_ind es)\n    | Pif t e e1 e2 => Hif t (pexpr_ind e) (pexpr_ind e1) (pexpr_ind e2)\n    end.\n\nEnd PEXPR_IND.\n\n(* Mutual induction scheme for pexpr and pexprs *)\nSection PEXPRS_IND.\n  Context\n    (P: pexpr \u2192 Prop)\n    (Q: pexprs \u2192 Prop)\n  .\n\n  Record pexpr_ind_hypotheses : Prop := {\n    pexprs_nil: Q [::];\n    pexprs_cons: \u2200 pe, P pe \u2192 \u2200 pes, Q pes \u2192 Q (pe :: pes);\n    pexprs_const: \u2200 z, P (Pconst z);\n    pexprs_bool: \u2200 b, P (Pbool b);\n    pexprs_arr_init: \u2200 n, P (Parr_init n);\n    pexprs_var: \u2200 x, P (Pvar x);\n    pexprs_global: \u2200 g, P (Pglobal g);\n    pexprs_get: \u2200 sz x e, P e \u2192 P (Pget sz x e);\n    pexprs_load: \u2200 sz x e, P e \u2192 P (Pload sz x e);\n    pexprs_app1: \u2200 op e, P e \u2192 P (Papp1 op e);\n    pexprs_app2: \u2200 op e1, P e1 \u2192 \u2200 e2, P e2 \u2192 P (Papp2 op e1 e2);\n    pexprs_appN: \u2200 op es, Q es \u2192 P (PappN op es);\n    pexprs_if: \u2200 t e, P e \u2192 \u2200 e1, P e1 \u2192 \u2200 e2, P e2 \u2192 P (Pif t e e1 e2);\n  }.\n\n  Context (h: pexpr_ind_hypotheses).\n\n  Definition pexprs_ind pexpr_mut_ind : \u2200 pes, Q pes :=\n    fix pexprs_ind pes :=\n      if pes is pe :: pes'\n      then pexprs_cons h (pexpr_mut_ind pe) (pexprs_ind pes')\n      else pexprs_nil h.\n\n  Fixpoint pexpr_mut_ind pe : P pe :=\n    match pe with\n    | Pconst z => pexprs_const h z\n    | Pbool b => pexprs_bool h b\n    | Parr_init n => pexprs_arr_init h n\n    | Pvar x => pexprs_var h x\n    | Pglobal g => pexprs_global h g\n    | Pget sz x e => pexprs_get h sz x (pexpr_mut_ind e)\n    | Pload sz x e => pexprs_load h sz x (pexpr_mut_ind e)\n    | Papp1 op e => pexprs_app1 h op (pexpr_mut_ind e)\n    | Papp2 op e1 e2 => pexprs_app2 h op (pexpr_mut_ind e1) (pexpr_mut_ind e2)\n    | PappN op es => pexprs_appN h op (pexprs_ind pexpr_mut_ind es)\n    | Pif t e e1 e2 => pexprs_if h t (pexpr_mut_ind e) (pexpr_mut_ind e1) (pexpr_mut_ind e2)\n    end.\n\n  Definition pexprs_ind_pair :=\n    conj pexpr_mut_ind (pexprs_ind pexpr_mut_ind).\n\nEnd PEXPRS_IND.\n\n(* ** Left values\n * -------------------------------------------------------------------- *)\n\nVariant lval : Type :=\n| Lnone `(var_info) `(stype)\n| Lvar `(var_i)\n| Lmem `(wsize) `(var_i) `(pexpr)\n| Laset `(wsize) `(var_i) `(pexpr).\n\nCoercion Lvar : var_i >-> lval.\n\nNotation lvals := (seq lval).\n\nDefinition lval_beq (x1:lval) (x2:lval) :=\n  match x1, x2 with\n  | Lnone i1 t1, Lnone i2 t2 => (i1 == i2) && (t1 == t2)\n  | Lvar  x1   , Lvar  x2    => x1 == x2\n  | Lmem w1 x1 e1, Lmem w2 x2 e2 => (w1 == w2) && (x1 == x2) && (e1 == e2)\n  | Laset w1 x1 e1, Laset w2 x2 e2 => (w1 == w2) && (x1 == x2) && (e1 == e2)\n  | _          , _           => false\n  end.\n\nLemma lval_eq_axiom : Equality.axiom lval_beq.\nProof.\n  case=> [i1 t1|x1|w1 x1 e1|w1 x1 e1] [i2 t2|x2|w2 x2 e2|w2 x2 e2] /=;try by constructor.\n  + apply (@equivP ((i1 == i2) /\\ t1 == t2));first by apply andP.\n    by split=> [ [] /eqP -> /eqP -> | [] -> <- ] //.\n  + apply (@equivP (x1 = x2));first by apply: eqP.\n    by split => [->|[]->].\n  + apply (@equivP (((w1 == w2) && (x1 == x2)) /\\ e1 == e2));first by apply andP.\n    split => [ [] /andP [] /eqP -> /eqP -> /eqP -> // | [] -> -> <- ].\n    by rewrite !eq_refl.\n  apply (@equivP (((w1 == w2) && (x1 == x2)) /\\ e1 == e2));first by apply andP.\n  split => [ [] /andP [] /eqP -> /eqP -> /eqP -> // | [] -> -> <- ].\n  by rewrite !eq_refl.\nQed.\n\nDefinition lval_eqMixin     := Equality.Mixin lval_eq_axiom.\nCanonical  lval_eqType      := Eval hnf in EqType lval lval_eqMixin.\n\n(* ** Instructions\n * -------------------------------------------------------------------- *)\n\nVariant dir := UpTo | DownTo.\n\nScheme Equality for dir.\n\nLemma dir_eq_axiom : Equality.axiom dir_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_dir_dec_bl.\n  by apply: internal_dir_dec_lb.\nQed.\n\nDefinition dir_eqMixin     := Equality.Mixin dir_eq_axiom.\nCanonical  dir_eqType      := Eval hnf in EqType dir dir_eqMixin.\n\nDefinition range := (dir * pexpr * pexpr)%type.\n\nDefinition wrange d (n1 n2 : Z) :=\n  let n := Z.to_nat (n2 - n1) in\n  match d with\n  | UpTo   => [seq (Z.add n1 (Z.of_nat i)) | i <- iota 0 n]\n  | DownTo => [seq (Z.sub n2 (Z.of_nat i)) | i <- iota 0 n]\n  end.\n\nDefinition instr_info := positive.\n\nVariant assgn_tag :=\n  | AT_none       (* assignment introduced by the develloper that can be removed *)\n  | AT_keep       (* assignment that should be keep *)\n  | AT_rename     (* equality constraint introduced by inline *)\n  | AT_inline.    (* assignment to be removed later : introduce by unrolling or inlining *)\n\nScheme Equality for assgn_tag.\n\nLemma assgn_tag_eq_axiom : Equality.axiom assgn_tag_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_assgn_tag_dec_bl.\n  by apply: internal_assgn_tag_dec_lb.\nQed.\n\nDefinition assgn_tag_eqMixin     := Equality.Mixin assgn_tag_eq_axiom.\nCanonical  assgn_tag_eqType      := Eval hnf in EqType assgn_tag assgn_tag_eqMixin.\n\n(* -------------------------------------------------------------------- *)\n\nVariant inline_info :=\n  | InlineFun\n  | DoNotInline.\n\nScheme Equality for inline_info.\n\nLemma inline_info_eq_axiom : Equality.axiom inline_info_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_inline_info_dec_bl.\n  by apply: internal_inline_info_dec_lb.\nQed.\n\nDefinition inline_info_eqMixin     := Equality.Mixin inline_info_eq_axiom.\nCanonical  inline_info_eqType      := Eval hnf in EqType inline_info inline_info_eqMixin.\n\n(* -------------------------------------------------------------------- *)\n\nVariant align := \n  | Align\n  | NoAlign.\n\nScheme Equality for align.\n\nLemma align_eq_axiom : Equality.axiom align_beq.\nProof.\n  move=> x y;apply:(iffP idP).\n  + by apply: internal_align_dec_bl.\n  by apply: internal_align_dec_lb.\nQed.\n\nDefinition align_eqMixin     := Equality.Mixin align_eq_axiom.\nCanonical  align_eqType      := Eval hnf in EqType align align_eqMixin.\n\n(* -------------------------------------------------------------------- *)\n\nInductive instr_r :=\n| Cassgn : lval -> assgn_tag -> stype -> pexpr -> instr_r\n| Copn   : lvals -> assgn_tag -> sopn -> pexprs -> instr_r\n\n| Cif    : pexpr -> seq instr -> seq instr  -> instr_r\n| Cfor   : var_i -> range -> seq instr -> instr_r\n| Cwhile : align -> seq instr -> pexpr -> seq instr -> instr_r\n| Ccall  : inline_info -> lvals -> funname -> pexprs -> instr_r\n\nwith instr := MkI : instr_info -> instr_r ->  instr.\n\nNotation cmd := (seq instr).\n\nRecord fundef := MkFun {\n  f_iinfo  : instr_info;\n  f_tyin  : seq stype;\n  f_params : seq var_i;\n  f_body   : cmd;\n  f_tyout : seq stype;\n  f_res    : seq var_i;\n}.\n\nDefinition function_signature : Type :=\n  (seq stype * seq stype).\n\nDefinition signature_of_fundef (fd: fundef) : function_signature :=\n  (f_tyin fd, f_tyout fd).\n\nDefinition fun_decl := (funname * fundef)%type.\nNotation fun_decls  := (seq fun_decl).\n\nRecord prog := {\n  p_globs : glob_decls;\n  p_funcs : fun_decls;\n}.\n\nDefinition instr_d (i:instr) :=\n  match i with\n  | MkI i _ => i\n  end.\n\nFixpoint instr_r_beq i1 i2 :=\n  match i1, i2 with\n  | Cassgn x1 tag1 ty1 e1, Cassgn x2 tag2 ty2 e2 =>\n     (tag1 == tag2) && (ty1 == ty2) && (x1 == x2) && (e1 == e2)\n  | Copn x1 tag1 o1 e1, Copn x2 tag2 o2 e2 =>\n     (x1 == x2) && (tag1 == tag2) && (o1 == o2) && (e1 == e2)\n  | Cif e1 c11 c12, Cif e2 c21 c22 =>\n    (e1 == e2) && all2 instr_beq c11 c21 && all2 instr_beq c12 c22\n  | Cfor i1 (dir1,lo1,hi1) c1, Cfor i2 (dir2,lo2,hi2) c2 =>\n    (i1 == i2) && (dir1 == dir2) && (lo1 == lo2) && (hi1 == hi2) && all2 instr_beq c1 c2\n  | Cwhile a1 c1 e1 c1' , Cwhile a2 c2 e2 c2' =>\n    (a1 == a2) && all2 instr_beq c1 c2 && (e1 == e2) && all2 instr_beq c1' c2'\n  | Ccall ii1 x1 f1 arg1, Ccall ii2 x2 f2 arg2 =>\n    (ii1 == ii2) && (x1==x2) && (f1 == f2) && (arg1 == arg2)\n  | _, _ => false\n  end\nwith instr_beq i1 i2 :=\n  match i1, i2 with\n  | MkI if1 i1, MkI if2 i2 => (if1 == if2) && (instr_r_beq i1 i2)\n  end.\n\nSection EQI.\n  Variable Heq : forall (x y:instr_r), reflect (x=y) (instr_r_beq x y).\n\n  Lemma instr_eq_axiom_ : Equality.axiom instr_beq.\n  Proof.\n    move=> [ii1 ir1] [ii2 ir2].\n    apply (@equivP (ii1 == ii2 /\\ instr_r_beq ir1 ir2));first by apply andP.\n    by split=> [[] /eqP -> /Heq -> |[]/eqP ?/Heq ]//; split.\n  Defined.\nEnd EQI.\n\nLemma instr_r_eq_axiom : Equality.axiom instr_r_beq.\nProof.\n  rewrite /Equality.axiom.\n  fix Hrec 1;case =>\n    [x1 t1 ty1 e1|x1 t1 o1 e1|e1 c11 c12|x1 [[dir1 lo1] hi1] c1|a1 c1 e1 c1'|ii1 x1 f1 arg1]\n    [x2 t2 ty2 e2|x2 t2 o2 e2|e2 c21 c22|x2 [[dir2 lo2] hi2] c2|a2 c2 e2 c2'|ii2 x2 f2 arg2] /=;\n  try by constructor.\n  + apply (@equivP ((t1 == t2) && (ty1 == ty2) && (x1 == x2) && (e1 == e2)));first by apply idP.\n    split=> [/andP [] /andP [] /andP [] /eqP -> /eqP-> /eqP-> /eqP-> | [] <- <- <- <- ] //.\n    by rewrite !eq_refl.\n  + apply (@equivP ((x1 == x2) && (t1 == t2)&& (o1 == o2) && (e1 == e2)));first by apply idP.\n    split=> [/andP [] /andP [] /andP [] /eqP-> /eqP-> /eqP-> /eqP-> | [] <- <- <- <-] //.\n    by rewrite !eq_refl.\n  + apply (@equivP ((e1 == e2) && (all2 instr_beq c11 c21) && (all2 instr_beq c12 c22)));\n      first by apply idP.\n    have H := reflect_all2 (instr_eq_axiom_ Hrec).\n    split=> [/andP[]/andP[]| []] /eqP -> /H -> /H -> //.\n  + apply (@equivP  ((x1 == x2) && (dir1 == dir2) && (lo1 == lo2) && (hi1 == hi2) &&\n      all2 instr_beq c1 c2)); first by apply idP.\n    have H := reflect_all2 (instr_eq_axiom_ Hrec).\n    split=> [/andP[]/andP[]/andP[]/andP[]| []] /eqP->/eqP->/eqP->/eqP->/H-> //.\n  + apply (@equivP  ((a1 == a2) && all2 instr_beq c1 c2 && (e1 == e2) && all2 instr_beq c1' c2')); first by apply idP.\n    have H := reflect_all2 (instr_eq_axiom_ Hrec).\n    split=> [/andP[]/andP[]/andP[]/eqP->/H->/eqP->/H-> | []/eqP->/H->/eqP->/H->] //.\n  apply (@equivP ((ii1 == ii2) && (x1 == x2) && (f1 == f2) && (arg1 == arg2)));first by apply idP.\n  by split=> [/andP[]/andP[]/andP[]| []]/eqP->/eqP->/eqP->/eqP->.\nQed.\n\nDefinition instr_r_eqMixin     := Equality.Mixin instr_r_eq_axiom.\nCanonical  instr_r_eqType      := Eval hnf in EqType instr_r instr_r_eqMixin.\n\nLemma instr_eq_axiom : Equality.axiom instr_beq.\nProof.\n  apply: instr_eq_axiom_ instr_r_eq_axiom .\nQed.\n\nDefinition instr_eqMixin     := Equality.Mixin instr_eq_axiom.\nCanonical  instr_eqType      := Eval hnf in EqType instr instr_eqMixin.\n\nDefinition fundef_beq fd1 fd2 :=\n  match fd1, fd2 with\n  | MkFun ii1 tin1 x1 c1 tout1 r1, MkFun ii2 tin2 x2 c2 tout2 r2 =>\n    (ii1 == ii2) && (tin1 == tin2) && (x1 == x2) && (c1 == c2) && (tout1 == tout2) && (r1 == r2)\n  end.\n\nLemma fundef_eq_axiom : Equality.axiom fundef_beq.\nProof.\n  move=> [i1 tin1 p1 c1 tout1 r1] [i2 tin2 p2 c2 tout2 r2] /=.\n  apply (@equivP ((i1 == i2) && (tin1 == tin2) && (p1 == p2) &&\n           (c1 == c2) && (tout1 == tout2) &&(r1 == r2)));first by apply idP.\n  by split=> [/andP[]/andP[]/andP[]/andP[]/andP[] | []] /eqP->/eqP->/eqP->/eqP->/eqP->/eqP->.\nQed.\n\nDefinition fundef_eqMixin     := Equality.Mixin fundef_eq_axiom.\nCanonical  fundef_eqType      := Eval hnf in EqType fundef fundef_eqMixin.\n\nDefinition prog_beq p1 p2 := (p_globs p1 == p_globs p2) && (p_funcs p1 == p_funcs p2).\n\nLemma prog_eq_axiom : Equality.axiom prog_beq.\nProof.\n  move=> [gd1 fs1] [gd2 fs2] /=.\n  apply (@equivP ((gd1 == gd2) && (fs1 == fs2)));first by apply idP.\n  by split => [/andP [] | []] /eqP -> /eqP ->.\nQed.\n\nDefinition prog_eqMixin     := Equality.Mixin prog_eq_axiom.\nCanonical  prog_eqType      := Eval hnf in EqType prog prog_eqMixin.\n\nDefinition map_prog (F: fundef -> fundef) (p:prog) :=\n  {| p_globs := p_globs p;\n     p_funcs := map (fun f => (f.1, F f.2)) (p_funcs p) |}.\n\nLemma map_prog_globs F p : p_globs (map_prog F p) = p_globs p.\nProof. done. Qed.\n\nLemma get_map_prog F p fn :\n  get_fundef (p_funcs (map_prog F p)) fn = omap F (get_fundef (p_funcs p) fn).\nProof. exact: assoc_map. Qed.\n\nLemma get_fundef_cons {T} (fnd: funname * T) p fn:\n  get_fundef (fnd :: p) fn = if fn == fnd.1 then Some fnd.2 else get_fundef p fn.\nProof. by case: fnd. Qed.\n\nLemma get_fundef_in {T} p f (fd: T) : get_fundef p f = Some fd -> f \\in [seq x.1 | x <- p].\nProof. by rewrite/get_fundef; apply: assoc_mem_dom'. Qed.\n\nLemma get_fundef_in' {T} p fn (fd: T):\n  get_fundef p fn = Some fd -> List.In (fn, fd) p.\nProof. exact: assoc_mem'. Qed.\n\nDefinition all_prog {aT bT cT} (s1: seq (funname * aT)) (s2: seq (funname * bT)) (ll: seq cT) f :=\n  (size s1 == size s2) && all2 (fun fs a => let '(fd1, fd2) := fs in (fd1.1 == fd2.1) && f a fd1.2 fd2.2) (zip s1 s2) ll.\n\nLemma all_progP {aT bT cT} (s1: seq (funname * aT)) (s2: seq (funname * bT)) (l: seq cT) f:\n  all_prog s1 s2 l f ->\n  forall fn fd, get_fundef s1 fn = Some fd ->\n  exists fd' l', get_fundef s2 fn = Some fd' /\\ f l' fd fd'.\nProof.\nelim: s1 s2 l=> // [[fn fd] p IH] [|[fn' fd'] p'] // [|lh la] //.\n+ by rewrite /all_prog /= andbF.\n+ move=> /andP [/= Hs /andP [/andP [/eqP Hfn Hfd] Hall]].\n  move=> fn0 fd0.\n  case: ifP=> /eqP Hfn0.\n  + move=> [] <-.\n    exists fd', lh.\n    rewrite -Hfn Hfn0 /= eq_refl; split=> //.\n  + move=> H.\n    have [|fd'' [l' [IH1 IH2]]] := (IH p' la _ _ _ H).\n    apply/andP; split.\n    by rewrite -eqSS.\n    exact: Hall.\n    exists fd'', l'; split=> //.\n    rewrite /= -Hfn.\n    by case: ifP=> // /eqP.\nQed.\n\nSection RECT.\n  Variables (Pr:instr_r -> Type) (Pi:instr -> Type) (Pc : cmd -> Type).\n  Hypothesis Hmk  : forall i ii, Pr i -> Pi (MkI ii i).\n  Hypothesis Hnil : Pc [::].\n  Hypothesis Hcons: forall i c, Pi i -> Pc c -> Pc (i::c).\n  Hypothesis Hasgn: forall x tg ty e, Pr (Cassgn x tg ty e).\n  Hypothesis Hopn : forall xs t o es, Pr (Copn xs t o es).\n  Hypothesis Hif  : forall e c1 c2, Pc c1 -> Pc c2 -> Pr (Cif e c1 c2).\n  Hypothesis Hfor : forall v dir lo hi c, Pc c -> Pr (Cfor v (dir,lo,hi) c).\n  Hypothesis Hwhile : forall a c e c', Pc c -> Pc c' -> Pr (Cwhile a c e c').\n  Hypothesis Hcall: forall i xs f es, Pr (Ccall i xs f es).\n\n  Section C.\n  Variable instr_rect : forall i, Pi i.\n\n  Fixpoint cmd_rect_aux (c:cmd) : Pc c :=\n    match c return Pc c with\n    | [::] => Hnil\n    | i::c => @Hcons i c (instr_rect i) (cmd_rect_aux c)\n    end.\n  End C.\n\n  Fixpoint instr_Rect (i:instr) : Pi i :=\n    match i return Pi i with\n    | MkI ii i => @Hmk i ii (instr_r_Rect i)\n    end\n  with instr_r_Rect (i:instr_r) : Pr i :=\n    match i return Pr i with\n    | Cassgn x tg ty e => Hasgn x tg ty e\n    | Copn xs t o es => Hopn xs t o es\n    | Cif e c1 c2  => @Hif e c1 c2 (cmd_rect_aux instr_Rect c1) (cmd_rect_aux instr_Rect c2)\n    | Cfor i (dir,lo,hi) c => @Hfor i dir lo hi c (cmd_rect_aux instr_Rect c)\n    | Cwhile a c e c'   => @Hwhile a c e c' (cmd_rect_aux instr_Rect c) (cmd_rect_aux instr_Rect c')\n    | Ccall ii xs f es => @Hcall ii xs f es\n    end.\n\n  Definition cmd_rect := cmd_rect_aux instr_Rect.\n\nEnd RECT.\n\n(* ** Compute written variables\n * -------------------------------------------------------------------- *)\n\nDefinition vrv_rec (s:Sv.t) (rv:lval) :=\n  match rv with\n  | Lnone _ _  => s\n  | Lvar  x    => Sv.add x s\n  | Lmem _ _ _  => s\n  | Laset _ x _  => Sv.add x s\n  end.\n\nDefinition vrvs_rec s (rv:lvals) := foldl vrv_rec s rv.\n\nDefinition vrv := (vrv_rec Sv.empty).\nDefinition vrvs := (vrvs_rec Sv.empty).\n\nFixpoint write_i_rec s i :=\n  match i with\n  | Cassgn x _ _ _    => vrv_rec s x\n  | Copn xs _ _ _   => vrvs_rec s xs\n  | Cif   _ c1 c2   => foldl write_I_rec (foldl write_I_rec s c2) c1\n  | Cfor  x _ c     => foldl write_I_rec (Sv.add x s) c\n  | Cwhile _ c _ c'   => foldl write_I_rec (foldl write_I_rec s c') c\n  | Ccall _ x _ _   => vrvs_rec s x\n  end\nwith write_I_rec s i :=\n  match i with\n  | MkI _ i => write_i_rec s i\n  end.\n\nDefinition write_i i := write_i_rec Sv.empty i.\n\nDefinition write_I i := write_I_rec Sv.empty i.\n\nDefinition write_c_rec s c := foldl write_I_rec s c.\n\nDefinition write_c c := write_c_rec Sv.empty c.\n\nInstance vrv_rec_m : Proper (Sv.Equal ==> eq ==> Sv.Equal) vrv_rec.\nProof.\n  move=> s1 s2 Hs x r ->;case:r => //= [v | _ v _];SvD.fsetdec.\nQed.\n\nLemma vrv_none i t: vrv (Lnone i t) = Sv.empty.\nProof. by []. Qed.\n\nLemma vrv_var x: Sv.Equal (vrv (Lvar x)) (Sv.singleton x).\nProof. rewrite /vrv /=;SvD.fsetdec. Qed.\n\nLemma vrv_mem w x e : vrv (Lmem w x e) = Sv.empty.\nProof. by []. Qed.\n\nLemma vrv_aset w x e : Sv.Equal (vrv (Laset w x e)) (Sv.singleton x).\nProof. rewrite /vrv /=;SvD.fsetdec. Qed.\n\nLemma vrv_recE s (r:lval) : Sv.Equal (vrv_rec s r) (Sv.union s (vrv r)).\nProof.\n  case: r => [i| x| x e| x e];\n    rewrite ?vrv_none ?vrv_var ?vrv_mem ?vrv_aset /=;\n    SvD.fsetdec.\nQed.\n\nLemma vrvs_recE s rs : Sv.Equal (vrvs_rec s rs) (Sv.union s (vrvs rs)).\nProof.\n  rewrite /vrvs;elim: rs s => [|r rs Hrec] s /=;first by SvD.fsetdec.\n  rewrite Hrec (Hrec (vrv_rec _ _)) (vrv_recE s);SvD.fsetdec.\nQed.\n\nLemma vrvs_cons r rs : Sv.Equal (vrvs (r::rs)) (Sv.union (vrv r) (vrvs rs)).\nProof. by rewrite /vrvs /= vrvs_recE. Qed.\n\nLemma write_c_recE s c : Sv.Equal (write_c_rec s c) (Sv.union s (write_c c)).\nProof.\n  apply (@cmd_rect\n           (fun i => forall s, Sv.Equal (write_i_rec s i) (Sv.union s (write_i i)))\n           (fun i => forall s, Sv.Equal (write_I_rec s i) (Sv.union s (write_I i)))\n           (fun c => forall s, Sv.Equal (foldl write_I_rec s c) (Sv.union s (write_c c)))) =>\n     /= {c s}\n    [ i ii Hi | | i c Hi Hc | x tg ty e | xs t o es | e c1 c2 Hc1 Hc2\n    | v dir lo hi c Hc | a c e c' Hc Hc' | ii xs f es] s;\n    rewrite /write_I /write_i /write_c /=\n    ?Hc1 ?Hc2 /write_c_rec ?Hc ?Hc' ?Hi -?vrv_recE -?vrvs_recE //;\n    by SvD.fsetdec.\nQed.\n\nLemma write_I_recE s i : Sv.Equal (write_I_rec s i) (Sv.union s (write_I i)).\nProof. by apply (write_c_recE s [:: i]). Qed.\n\nLemma write_i_recE s i : Sv.Equal (write_i_rec s i) (Sv.union s (write_i i)).\nProof. by apply (write_I_recE s (MkI 1%positive i)). Qed.\n\nLemma write_c_nil : write_c [::] = Sv.empty.\nProof. done. Qed.\n\nLemma write_c_cons i c: Sv.Equal (write_c (i::c)) (Sv.union (write_I i) (write_c c)).\nProof. rewrite {1}/write_c /= write_c_recE write_I_recE;SvD.fsetdec. Qed.\n\nLemma write_c_app c1 c2 :\n  Sv.Equal (write_c (c1 ++ c2)) (Sv.union (write_c c1) (write_c c2)).\nProof. by elim: c1 => //= i c1 Hrec;rewrite !write_c_cons;SvD.fsetdec. Qed.\n\nLemma write_i_assgn x tag ty e : write_i (Cassgn x tag ty e) = vrv x.\nProof. done. Qed.\n\nLemma write_i_opn xs t o es : write_i (Copn xs t o es) = vrvs xs.\nProof. done. Qed.\n\nLemma write_i_if e c1 c2 :\n   Sv.Equal (write_i (Cif e c1 c2)) (Sv.union (write_c c1) (write_c c2)).\nProof.\n  rewrite /write_i /= -/(write_c_rec _ c1) -/(write_c_rec _ c2) !write_c_recE;SvD.fsetdec.\nQed.\n\nLemma write_i_for x rn c :\n   Sv.Equal (write_i (Cfor x rn c)) (Sv.union (Sv.singleton x) (write_c c)).\nProof.\n  rewrite /write_i /= -/(write_c_rec _ c) write_c_recE ;SvD.fsetdec.\nQed.\n\nLemma write_i_while a c e c' :\n   Sv.Equal (write_i (Cwhile a c e c')) (Sv.union (write_c c) (write_c c')).\nProof.\n  rewrite /write_i /= -/(write_c_rec _ c) write_c_recE;SvD.fsetdec.\nQed.\n\nLemma write_i_call ii xs f es :\n  write_i (Ccall ii xs f es) = vrvs xs.\nProof. done. Qed.\n\n(* -------------------------------------------------------------------- *)\nHint Rewrite write_c_nil write_c_cons : write_c.\nHint Rewrite write_i_assgn write_i_opn write_i_if : write_i.\nHint Rewrite write_i_while write_i_for write_i_call : write_i.\nHint Rewrite vrv_none vrv_var : vrv.\n\nLtac writeN := autorewrite with write_c write_i vrv.\n\n(* ** Compute read variables\n * -------------------------------------------------------------------- *)\n\nFixpoint read_e_rec (s:Sv.t) (e:pexpr) : Sv.t :=\n  match e with\n  | Pconst _\n  | Pbool  _\n  | Parr_init _    => s\n  | Pvar   x       => Sv.add x s\n  | Pglobal _      => s\n  | Pget _ x e     => read_e_rec (Sv.add x s) e\n  | Pload _ x e    => read_e_rec (Sv.add x s) e\n  | Papp1  _ e     => read_e_rec s e\n  | Papp2  _ e1 e2 => read_e_rec (read_e_rec s e2) e1\n  | PappN _ es     => foldl read_e_rec s es\n  | Pif  _ t e1 e2 => read_e_rec (read_e_rec (read_e_rec s e2) e1) t\n  end.\n\nDefinition read_e := read_e_rec Sv.empty.\nDefinition read_es_rec := foldl read_e_rec.\nDefinition read_es := read_es_rec Sv.empty.\n\nDefinition read_rv_rec  (s:Sv.t) (r:lval) :=\n  match r with\n  | Lnone _ _   => s\n  | Lvar  _     => s\n  | Lmem _ x e  => read_e_rec (Sv.add x s) e\n  | Laset _ x e => read_e_rec (Sv.add x s) e\n  end.\n\nDefinition read_rv := read_rv_rec Sv.empty.\nDefinition read_rvs_rec := foldl read_rv_rec.\nDefinition read_rvs := read_rvs_rec Sv.empty.\n\nFixpoint read_i_rec (s:Sv.t) (i:instr_r) : Sv.t :=\n  match i with\n  | Cassgn x _ _ e => read_rv_rec (read_e_rec s e) x\n  | Copn xs _ _ es => read_es_rec (read_rvs_rec s xs) es\n  | Cif b c1 c2 =>\n    let s := foldl read_I_rec s c1 in\n    let s := foldl read_I_rec s c2 in\n    read_e_rec s b\n  | Cfor x (dir, e1, e2) c =>\n    let s := foldl read_I_rec s c in\n    read_e_rec (read_e_rec s e2) e1\n  | Cwhile a c e c' =>\n    let s := foldl read_I_rec s c in\n    let s := foldl read_I_rec s c' in\n    read_e_rec s e\n  | Ccall _ xs _ es => read_es_rec (read_rvs_rec s xs) es\n  end\nwith read_I_rec (s:Sv.t) (i:instr) : Sv.t :=\n  match i with\n  | MkI _ i => read_i_rec s i\n  end.\n\nDefinition read_c_rec := foldl read_I_rec.\n\nDefinition read_i := read_i_rec Sv.empty.\n\nDefinition read_I := read_I_rec Sv.empty.\n\nDefinition read_c := read_c_rec Sv.empty.\n\nLemma read_eE e s : Sv.Equal (read_e_rec s e) (Sv.union (read_e e) s).\nProof.\n  elim: e s => //= [v | w v e He | w v e He | o e1 He1 e2 He2 | o es Hes | t e He e1 He1 e2 He2] s;\n   rewrite /read_e /= ?He ?He1 ?He2; try SvD.fsetdec.\n  rewrite -/read_es_rec -/read_es.\n  elim: es Hes s.\n  + by move => _ /= s; SvD.fsetdec.\n  move => e es ih Hes s /=.\n  rewrite /read_es /= -/read_e ih.\n  + rewrite Hes.\n    + rewrite ih.\n      + by SvD.fsetdec.\n      move => e' he' s'; apply: Hes.\n      by rewrite in_cons he' orbT.\n    by rewrite in_cons eqxx.\n  move => e' he' s'; apply: Hes.\n  by rewrite in_cons he' orbT.\nQed.\n\nLemma read_e_var (x:var_i) : Sv.Equal (read_e (Pvar x)) (Sv.singleton x).\nProof. rewrite /read_e /=;SvD.fsetdec. Qed.\n\nLemma read_esE es s : Sv.Equal (read_es_rec s es) (Sv.union (read_es es) s).\nProof.\n  elim: es s => [ | e es Hes] s;rewrite /read_es /= ?Hes ?read_eE;SvD.fsetdec.\nQed.\n\nLemma read_es_cons e es :\n  Sv.Equal (read_es (e :: es)) (Sv.union (read_e e) (read_es es)).\nProof. by rewrite /read_es /= !read_esE read_eE;SvD.fsetdec. Qed.\n\nLemma read_rvE s x: Sv.Equal (read_rv_rec s x) (Sv.union s (read_rv x)).\nProof.\n  case: x => //= [_|_|w x e|w x e]; rewrite /read_rv /= ?read_eE; SvD.fsetdec.\nQed.\n\nLemma read_rvsE s xs:  Sv.Equal (read_rvs_rec s xs) (Sv.union s (read_rvs xs)).\nProof.\n  elim: xs s => [ |x xs Hxs] s;rewrite /read_rvs /= ?Hxs ?read_rvE;SvD.fsetdec.\nQed.\n\nLemma read_rvs_nil : read_rvs [::] = Sv.empty.\nProof. done. Qed.\n\nLemma read_rvs_cons x xs : Sv.Equal (read_rvs (x::xs)) (Sv.union (read_rv x) (read_rvs xs)).\nProof.\n  rewrite {1}/read_rvs /= read_rvsE read_rvE;SvD.fsetdec.\nQed.\n\nLemma read_cE s c : Sv.Equal (read_c_rec s c) (Sv.union s (read_c c)).\nProof.\n  apply (@cmd_rect\n           (fun i => forall s, Sv.Equal (read_i_rec s i) (Sv.union s (read_i i)))\n           (fun i => forall s, Sv.Equal (read_I_rec s i) (Sv.union s (read_I i)))\n           (fun c => forall s, Sv.Equal (foldl read_I_rec s c) (Sv.union s (read_c c))))\n           => /= {c s}\n   [ i ii Hi | | i c Hi Hc | x tg ty e | xs t o es | e c1 c2 Hc1 Hc2\n    | v dir lo hi c Hc | a c e c' Hc Hc' | ii xs f es] s;\n    rewrite /read_I /read_i /read_c /=\n     ?read_rvE ?read_eE ?read_esE ?read_rvsE ?Hc2 ?Hc1 /read_c_rec ?Hc' ?Hc ?Hi //;\n    by SvD.fsetdec.\nQed.\n\nLemma read_IE s i : Sv.Equal (read_I_rec s i) (Sv.union s (read_I i)).\nProof. by apply (read_cE s [:: i]). Qed.\n\nLemma read_iE s i : Sv.Equal (read_i_rec s i) (Sv.union s (read_i i)).\nProof. by apply (read_IE s (MkI 1%positive i)). Qed.\n\nLemma read_c_nil : read_c [::] = Sv.empty.\nProof. done. Qed.\n\nLemma read_c_cons i c: Sv.Equal (read_c (i::c)) (Sv.union (read_I i) (read_c c)).\nProof. by rewrite {1}/read_c /= read_cE //. Qed.\n\nLemma read_i_assgn x tag ty e :\n  Sv.Equal (read_i (Cassgn x tag ty e)) (Sv.union (read_rv x) (read_e e)).\nProof. rewrite /read_i /= read_rvE read_eE;SvD.fsetdec. Qed.\n\nLemma read_i_opn xs t o es:\n  Sv.Equal (read_i (Copn xs t o es)) (Sv.union (read_rvs xs) (read_es es)).\nProof. by rewrite /read_i /= read_esE read_rvsE;SvD.fsetdec. Qed.\n\nLemma read_i_if e c1 c2 :\n   Sv.Equal (read_i (Cif e c1 c2)) (Sv.union (read_e e) (Sv.union (read_c c1) (read_c c2))).\nProof.\n  rewrite /read_i /= -/read_c_rec read_eE !read_cE;SvD.fsetdec.\nQed.\n\nLemma read_i_for x dir lo hi c :\n   Sv.Equal (read_i (Cfor x (dir, lo, hi) c))\n            (Sv.union (read_e lo) (Sv.union (read_e hi) (read_c c))).\nProof.\n  rewrite /read_i /= -/read_c_rec !read_eE read_cE;SvD.fsetdec.\nQed.\n\nLemma read_i_while a c e c' :\n   Sv.Equal (read_i (Cwhile a c e c'))\n            (Sv.union (read_c c) (Sv.union (read_e e) (read_c c'))).\nProof.\n  rewrite /read_i /= -/read_c_rec !read_eE read_cE;SvD.fsetdec.\nQed.\n\nLemma read_i_call ii xs f es :\n  Sv.Equal (read_i (Ccall ii xs f es)) (Sv.union (read_rvs xs) (read_es es)).\nProof. rewrite /read_i /= read_esE read_rvsE;SvD.fsetdec. Qed.\n\nLemma read_Ii ii i: read_I (MkI ii i) = read_i i.\nProof. by done. Qed.\n\n(* ** Some smart constructors\n * -------------------------------------------------------------------------- *)\n\nFixpoint is_const (e:pexpr) :=\n  match e with\n  | Pconst n => Some n\n  | _        => None\n  end.\n\nDefinition is_bool (e:pexpr) :=\n  match e with\n  | Pbool b => Some b\n  | _ => None\n  end.\n\nDefinition wconst (sz: wsize) (n: word sz) : pexpr :=\n  Papp1 (Oword_of_int sz) (Pconst (wunsigned n)).\n\nDefinition is_wconst (sz: wsize) (e: pexpr) : option (word sz) :=\n  match e with\n  | Papp1 (Oword_of_int sz') e =>\n    if (sz <= sz')%CMP then\n      is_const e >>= \u03bb n, Some (zero_extend sz (wrepr sz' n))\n    else None\n  | _       => None\n  end%O.\n\nDefinition is_wconst_of_size sz (e: pexpr) : option Z :=\n  match e with\n  | Papp1 (Oword_of_int sz') (Pconst z) =>\n    if sz' == sz then Some z else None\n  | _ => None end.\n\nVariant is_reflect (A:Type) (P:A -> pexpr) : pexpr -> option A -> Prop :=\n | Is_reflect_some : forall a, is_reflect P (P a) (Some a)\n | Is_reflect_none : forall e, is_reflect P e None.\n\nLemma is_boolP e : is_reflect Pbool e (is_bool e).\nProof. by case e=> *;constructor. Qed.\n\nLemma is_constP e : is_reflect Pconst e (is_const e).\nProof. by case: e=>*;constructor. Qed.\n\nLemma is_reflect_some_inv {A P e a} (H: @is_reflect A P e (Some a)) : e = P a.\nProof.\n  set (d e m := match m with None => True | Some a => e = P a end).\n  change (d e (Some a)).\n  case H; simpl; auto.\nQed.\n\nLemma is_wconst_of_sizeP sz e :\n  is_reflect (fun z => Papp1 (Oword_of_int sz) (Pconst z)) e (is_wconst_of_size sz e).\nProof.\ncase: e; try constructor.\ncase; try constructor.\nmove => sz' []; try constructor.\nmove => z /=; case: eqP; try constructor.\nmove => ->; exact: Is_reflect_some.\nQed.\n\n(* --------------------------------------------------------------------- *)\n(* Test the equality of two expressions modulo variable info              *)\nFixpoint eq_expr e e' :=\n  match e, e' with\n  | Pconst z      , Pconst z'         => z == z'\n  | Pbool  b      , Pbool  b'         => b == b'\n  | Parr_init n   , Parr_init n'      => n == n'\n  | Pvar   x      , Pvar   x'         => v_var x == v_var x'\n  | Pglobal g, Pglobal g' => g == g'\n  | Pget w x e    , Pget w' x' e'      => (w == w') && (v_var x == v_var x') && eq_expr e e'\n  | Pload w x e, Pload w' x' e' => (w == w') && (v_var x == v_var x') && eq_expr e e'\n  | Papp1  o e    , Papp1  o' e'      => (o == o') && eq_expr e e'\n  | Papp2  o e1 e2, Papp2  o' e1' e2' => (o == o') && eq_expr e1 e1' && eq_expr e2 e2'\n  | PappN o es, PappN o' es' => (o == o') && (all2 eq_expr es es')\n  | Pif t e e1 e2, Pif t' e' e1' e2' =>\n    (t == t') && eq_expr e e' && eq_expr e1 e1' && eq_expr e2 e2'\n  | _             , _                 => false\n  end.\n\nLemma eq_expr_refl e : eq_expr e e.\nProof.\nelim: e => //= [ ??? -> | ??? -> | ?? -> | ?? -> ? -> | ? es ih | ??-> ? -> ? -> ] //=;\n  rewrite ?eqxx //=.\nelim: es ih => // e es ih h /=; rewrite h.\n+ by apply: ih => e' he'; apply: h; rewrite in_cons he' orbT.\nby rewrite in_cons eqxx.\nQed.\n\nDefinition eq_lval (x x': lval) : bool :=\n  match x, x' with\n  | Lnone _ ty,  Lnone _ ty' => ty == ty'\n  | Lvar v, Lvar v' => v_var v == v_var v'\n  | Lmem w v e, Lmem w' v' e' => (w == w') && (v_var v == v_var v') && (eq_expr e e')\n  | Laset w v e, Laset w' v' e'\n    => (w == w') && (v_var v == v_var v') && (eq_expr e e')\n  | _, _ => false\n  end.\n\nLemma eq_lval_refl x : eq_lval x x.\nProof.\n  by case: x => // [ i ty | x | w x e | w x e] /=; rewrite !eqxx // eq_expr_refl.\nQed.\n\nLemma eq_expr_constL z e :\n  eq_expr (Pconst z) e -> e = z :> pexpr.\nProof. by case: e => // z' /eqP ->. Qed.\n\nLemma eq_expr_const z1 z2 :\n  eq_expr (Pconst z1) (Pconst z2) -> z1 = z2.\nProof. by move/eqP. Qed.\n\nLemma eq_expr_var x1 x2 :\n  eq_expr (Pvar x1) (Pvar x2) -> x1 = x2 :> var.\nProof. by move/eqP. Qed.\n\nLemma eq_expr_global g1 g2 :\n  eq_expr (Pglobal g1) (Pglobal g2) -> g1 = g2.\nProof. by move/eqP. Qed.\n\nLemma eq_expr_load w1 w2 v1 v2 e1 e2 :\n     eq_expr (Pload w1 v1 e1) (Pload w2 v2 e2)\n  -> [/\\ w1 = w2, v1 = v2 :> var & eq_expr e1 e2].\nProof. by move=> /= /andP [/andP[]] /eqP-> /eqP-> ->. Qed.\n\nLemma eq_expr_app1 o1 o2 e1 e2 :\n     eq_expr (Papp1 o1 e1) (Papp1 o2 e2)\n  -> [/\\ o1 = o2 & eq_expr e1 e2].\nProof. by move=> /= /andP[/eqP-> ->]. Qed.\n"}
{"text": "lemma coeff_0_reflect_poly [simp]: \"coeff (reflect_poly p) 0 = lead_coeff p\""}
{"text": "lemmas bounded_linear_const_mult = bounded_linear_mult_right [THEN bounded_linear_compose]"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_numbertheory_109\n  (v : \u2115 \u2192 \u2115)\n  (h\u2080 : \u2200 n, v n = 2 * n - 1) :\n  (\u2211 k in (finset.erase (finset.range 101) 0), v k) % 7 = 4 :=\nbegin\n  norm_num,\n  simp [h\u2080],\n  rw finset.sum_erase,\n  swap,\n  { simp, },\n  norm_num [finset.sum_range_succ, h\u2080],\nend"}
{"text": "namespace Ex1\n  variable (a : Nat) (i : Fin a) (h : 1 = a)\n  example : i < a := h \u25b8 i.2 -- `\u25b8` uses `subst` here\nend Ex1\n\nnamespace Ex2\ndef heapifyDown' (a : Array \u03b1) (i : Fin a.size) : Array \u03b1 := sorry\ndef heapifyDown (a : Array \u03b1) (i : Fin a.size) : Array \u03b1 :=\n  heapifyDown' a \u27e8i.1, a.size_swap i i \u25b8 i.2\u27e9 -- Error, failed to compute motive, `subst` is not applicable here\nend Ex2\n\nnamespace Ex3\ndef heapifyDown (a : Array \u03b1) (i : Fin a.size) : Array \u03b1 :=\n  have : i < i := sorry\n  heapifyDown a \u27e8i.1, a.size_swap i i \u25b8 i.2\u27e9 -- Error, failed to compute motive, `subst` is not applicable here\ntermination_by' measure fun i => i.1\ndecreasing_by assumption\nend Ex3\n\nnamespace Ex4\ndef heapifyDown (lt : \u03b1 \u2192 \u03b1 \u2192 Bool) (a : Array \u03b1) (i : Fin a.size) : Array \u03b1 :=\n  let left := 2 * i.1 + 1\n  let right := left + 1\n  have left_le : i \u2264 left := sorry\n  have right_le : i \u2264 right := sorry\n  have i_le : i \u2264 i := Nat.le_refl _\n  have j : {j : Fin a.size // i \u2264 j} := if h : left < a.size then\n    if lt (a.get i) (a.get \u27e8left, h\u27e9) then \u27e8\u27e8left, h\u27e9, left_le\u27e9 else \u27e8i, i_le\u27e9 else \u27e8i, i_le\u27e9\n  have j := if h : right < a.size then\n    if lt (a.get j) (a.get \u27e8right, h\u27e9) then \u27e8\u27e8right, h\u27e9, right_le\u27e9 else j else j\n  if h : i \u2260 j then\n    let a' := a.swap i j\n    have : a'.size - j < a.size - i := sorry\n    heapifyDown lt a' \u27e8j.1.1, a.size_swap i j \u25b8 j.1.2\u27e9 -- Error, failed to compute motive, `subst` is not applicable here\n  else\n    a\ntermination_by' measure fun \u27e8a, i\u27e9 => a.size - i.1\ndecreasing_by assumption\nend Ex4\n"}
{"text": "/ news / Teleskin in ElectroBoutique gallery.\nTeleskin offers a televiewer taking control over TV interface in her hands. When pushing a remote control button one does not switch the content (who cares about that?) but the shape: a TV model, interior where it is placed, - another words, the context - both visual and ideological. The process of zapping is not any more a thoughtless way of spending time, but a creative activity that is forming one's living space. When altering TV skin and adjusting it to a current mood, one breaks free form pre-defined behavioral patterns of the totalitarian post-information society."}
{"text": "Buried in the news that HP is buying Palm is an updated lower guidance for the fourth quarter, otherwise known as a warning.\nThe Company expects revenues for its fourth fiscal quarter to be in the range of approximately $90 million to $100 million on a GAAP (1) and a non-GAAP basis. Revenues for the fourth fiscal quarter are being impacted by slow sales of the Company\u2019s products, which has resulted in low order volumes from carriers. Palm also expects to close its fourth fiscal quarter with a cash, cash equivalents and short-term investments balance between $350 million and $400 million.\n$90 million in revenues for an average ASP of $300 would put unit sales at 300,000 for the quarter. RIM just sold 10.4 million devices, Apple sold 8.75 million. 300k is just an astonishingly small number.\nHuawei has largely rejected Palm\u2019s request for a buyout, a tip said this morning. Palm had reportedly proposed that Huawei take over the company in mid-February but hasn\u2019t made any progress since. It\u2019s not clear what objections, if any, Huawei might have.\nvia Palm rebuffed by Huawei on takeover talks | Electronista.\nDubinsky gets it, Glaser no so much.\n[Rob Glaser] said with those \u201csuper\u201d abilities, mobile has a great potential, but if Apple gets its way, the wireless industry could end up like the MP3 industry. The other option is for things to go the way of the PC, which he considers more horizontal.\nSorry Rob, you\u2019re still missing the whole point. It\u2019s not incredible, it\u2019s the only way to go. What\u2019s incredible is that anybody tried to do it differently."}
{"text": "{-# OPTIONS --cubical #-}\nmodule _ where\n\nmodule _ where\n  import Agda.Primitive\n  open import Agda.Primitive.Cubical public\n  open import Agda.Builtin.Cubical.Path public\n\n  refl : \u2200 {a} {A : Set a} {x : A} \u2192 x \u2261 x\n  refl {x = x} = \\ _ \u2192 x\n\n\ntestPath : \u2200 {A : Set} {b a : A} (let H : b \u2261 b; H = _) \u2192 \u2200 i \u2192 H i \u2261 b\ntestPath i = refl\n"}
{"text": "lemma no_trailing_coeffs [simp]: \"no_trailing (HOL.eq 0) (coeffs p)\""}
{"text": "/-\nCopyright (c) 2022 Yury Kudryashov. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Yury Kudryashov\n-/\nimport measure_theory.integral.interval_integral\nimport measure_theory.integral.average\n\n/-!\n# Integral average over an interval\n\nIn this file we introduce notation `\u2a0d x in a..b, f x` for the average `\u2a0d x in \u0399 a b, f x` of `f`\nover the interval `\u0399 a b = set.Ioc (min a b) (max a b)` w.r.t. the Lebesgue measure, then prove\nformulas for this average:\n\n* `interval_average_eq`: `\u2a0d x in a..b, f x = (b - a)\u207b\u00b9 \u2022 \u222b x in a..b, f x`;\n* `interval_average_eq_div`: `\u2a0d x in a..b, f x = (\u222b x in a..b, f x) / (b - a)`.\n\nWe also prove that `\u2a0d x in a..b, f x = \u2a0d x in b..a, f x`, see `interval_average_symm`.\n\n## Notation\n\n`\u2a0d x in a..b, f x`: average of `f` over the interval `\u0399 a b` w.r.t. the Lebesgue measure.\n\n-/\n\nopen measure_theory set topological_space\nopen_locale interval\n\nvariables {E : Type*} [normed_add_comm_group E] [normed_space \u211d E] [complete_space E]\n\nnotation `\u2a0d` binders ` in ` a `..` b `, `\n  r:(scoped:60 f, average (measure.restrict volume (\u0399 a b)) f) := r\n\nlemma interval_average_symm (f : \u211d \u2192 E) (a b : \u211d) : \u2a0d x in a..b, f x = \u2a0d x in b..a, f x :=\nby rw [set_average_eq, set_average_eq, uIoc_swap]\n\nlemma interval_average_eq (f : \u211d \u2192 E) (a b : \u211d) : \u2a0d x in a..b, f x = (b - a)\u207b\u00b9 \u2022 \u222b x in a..b, f x :=\nbegin\n  cases le_or_lt a b with h h,\n  { rw [set_average_eq, uIoc_of_le h, real.volume_Ioc, interval_integral.integral_of_le h,\n      ennreal.to_real_of_real (sub_nonneg.2 h)] },\n  { rw [set_average_eq, uIoc_of_lt h, real.volume_Ioc, interval_integral.integral_of_ge h.le,\n     ennreal.to_real_of_real (sub_nonneg.2 h.le), smul_neg, \u2190 neg_smul, \u2190 inv_neg, neg_sub] }\nend\n\nlemma interval_average_eq_div (f : \u211d \u2192 \u211d) (a b : \u211d) :\n  \u2a0d x in a..b, f x = (\u222b x in a..b, f x) / (b - a) :=\nby rw [interval_average_eq, smul_eq_mul, div_eq_inv_mul]\n"}
{"text": "Formal statement is: lemma frontier_empty [simp]: \"frontier {} = {}\" Informal statement is: The frontier of the empty set is the empty set."}
{"text": "{-# LANGUAGE Trustworthy, CPP, MagicHash, UnboxedTuples, BangPatterns #-}\n{-# LANGUAGE FlexibleInstances, FlexibleContexts, TypeOperators #-}\n\n{- |\n    Module      :  SDP.Unboxed\n    Copyright   :  (c) Andrey Mulik 2019-2021\n    License     :  BSD-style\n    Maintainer  :  work.a.mulik@gmail.com\n    Portability :  non-portable (GHC extensions)\n    \n    \"SDP.Unboxed\" provide service class 'Unboxed', that needed for\n    \"SDP.Prim.SBytes\"-based structures.\n-}\nmodule SDP.Unboxed\n(\n  -- * Unboxed\n  Unboxed (..), cloneUnboxed#, cloneUnboxedM#, thawUnboxed#, freezeUnboxed#,\n  \n  -- ** Kind @(Type -> Type)@ proxies\n  fromProxy, psizeof#, psizeof, pnewUnboxed, pcopyUnboxed, pcopyUnboxedM,\n  pcloneUnboxed, pcloneUnboxedM, pthawUnboxed, pfreezeUnboxed,\n  \n  -- ** Kind @(Type -> Type -> Type)@ proxies\n  fromProxy1, pnewUnboxed1, pcloneUnboxed1, pcopyUnboxed1, pcopyUnboxedM1,\n  cloneUnboxed1#, pcloneUnboxedM1,\n  \n  -- Wrap helper\n  Wrap (..), lzero#, single#, fromList#, fromFoldable#, fromListN#,\n  newLinear#, newLinearN#, fromFoldableM#, concat#, pconcat\n)\nwhere\n\nimport Prelude ()\nimport SDP.SafePrelude\nimport SDP.Nullable\nimport SDP.Finite\nimport SDP.Shape\nimport SDP.Ratio\n\nimport GHC.Stable\nimport GHC.Base   hiding ( (.), foldr )\nimport GHC.Word\nimport GHC.Int\nimport GHC.Ptr\nimport GHC.ST\n\nimport Data.Complex\n\nimport Foreign.C.Types\n\n#include \"MachDeps.h\"\n\ndefault ()\n\n--------------------------------------------------------------------------------\n\n{- |\n  'Unboxed' is a layer between untyped raw data and parameterized unboxed data\n  structures. Also it prevents direct interaction with primitives.\n-}\nclass (Eq e) => Unboxed e\n  where\n    {-# MINIMAL (sizeof#|sizeof), (!#), (!>#), writeByteArray#, newUnboxed #-}\n    \n    {- |\n      @sizeof e n@ returns the length (in bytes) of primitive, where @n@ - count\n      of elements, @e@ - type parameter.\n    -}\n    {-# INLINE sizeof #-}\n    sizeof :: e -> Int -> Int\n    sizeof e (I# c#) = I# (sizeof# e c#)\n    \n    -- | 'sizeof#' is unboxed 'sizeof'.\n    {-# INLINE sizeof# #-}\n    sizeof# :: e -> Int# -> Int#\n    sizeof# e c# = case sizeof e (I# c#) of I# n# -> n#\n    \n    -- | Unsafe 'ByteArray#' reader with overloaded result type.\n    (!#) :: ByteArray# -> Int# -> e\n    \n    -- | Unsafe 'MutableByteArray#' reader with overloaded result type.\n    (!>#) :: MutableByteArray# s -> Int# -> State# s -> (# State# s, e #)\n    \n    -- | Unsafe 'MutableByteArray#' writer.\n    writeByteArray# :: MutableByteArray# s -> Int# -> e -> State# s -> State# s\n    \n    {-# INLINE fillByteArray# #-}\n    -- | Procedure for filling the array with the default value (like calloc).\n    fillByteArray# :: MutableByteArray# s -> Int# -> e -> State# s -> State# s\n    fillByteArray# mbytes# n# e = I# n# > 0 ? go (n# -# 1#) $ \\ s1# -> s1#\n      where\n        go 0# s2# = writeByteArray# mbytes# 0# e s2#\n        go c# s2# = go (c# -# 1#) (writeByteArray# mbytes# c# e s2#)\n    \n    {- |\n      'newUnboxed' creates new 'MutableByteArray#' of given count of elements.\n      First argument used as type variable.\n    -}\n    newUnboxed :: e -> Int# -> State# s -> (# State# s, MutableByteArray# s #)\n    \n    {-# INLINE newUnboxed' #-}\n    {- |\n      'newUnboxed'' is version of 'newUnboxed', that use first argument as\n      initial value. May fail when trying to write 'error' or 'undefined'.\n    -}\n    newUnboxed' :: e -> Int# -> State# s -> (# State# s, MutableByteArray# s #)\n    newUnboxed' e n# = \\ s1# -> case newByteArray# (sizeof# e n#) s1# of\n      (# s2#, mbytes# #) -> case fillByteArray# mbytes# n# e s2# of\n        s3# -> (# s3#, mbytes# #)\n    \n    {- |\n      @'copyUnboxed#' e bytes\\# o1\\# mbytes\\# o2\\# n\\#@ unsafely writes elements\n      from @bytes\\#@ to @mbytes\\#@, where o1\\# and o2\\# - offsets (element\n      count), @n\\#@ - count of elements to copy.\n    -}\n    copyUnboxed# :: e -> ByteArray# -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\n    copyUnboxed# e bytes# o1# mbytes# o2# n# = copyByteArray# bytes# (sizeof# e o1#) mbytes# (sizeof# e o2#) (sizeof# e n#)\n    \n    {- |\n      @'copyUnboxedM#' e msrc\\# o1\\# mbytes\\# o2\\# n\\#@ unsafely writes elements\n      from @msrc\\#@ to @mbytes\\#@, where o1\\# and o2\\# - offsets (element\n      count), @n\\#@ - count of elements to copy.\n    -}\n    copyUnboxedM# :: e -> MutableByteArray# s -> Int# -> MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\n    copyUnboxedM# e msrc# o1# mbytes# o2# n# = copyMutableByteArray# msrc# (sizeof# e o1#) mbytes# (sizeof# e o2#) (sizeof# e n#)\n    \n    {- |\n      @'hashUnboxedWith' e len# off# bytes# salt@ returns @bytes#@ @FNV-1@ hash,\n      where @off#@ and @len#@ is offset and length (in elements).\n      \n      Note: the standard definition of this function is written in Haskell using\n      low-level functions, but this implementation mayn't be as efficient as the\n      foreign procedure in the @hashable@ package.\n    -}\n    hashUnboxedWith :: e -> Int# -> Int# -> ByteArray# -> Int# -> Int#\n    hashUnboxedWith e len# off# bytes# = go (sizeof# e off#) (sizeof# e len#)\n      where\n        go _  0# salt# = salt#\n        go o# n# salt# = go (o# +# 1#) (n# -# 1#) (word2Int# hash#)\n          where\n            prod# = int2Word# (salt# *# 16777619#)\n            elem# = indexWord8Array# bytes# o#\n            hash# = prod# `xor#` elem#\n\n--------------------------------------------------------------------------------\n\n{- Unboxed helpers. -}\n\n{- |\n  @since 0.2\n  @cloneUnboxed# e bytes# o# c#@ creates new @c#@-element length immutable slice\n  of @bytes#@ beginning from @o#@-th element.\n-}\ncloneUnboxed# :: (Unboxed e) => e -> ByteArray# -> Int# -> Int# -> ByteArray#\ncloneUnboxed# e bytes# o# c# = unwrap $ runST $ ST $\n  \\ s1# -> case newUnboxed e c# s1# of\n    (# s2#, mbytes# #) -> case copyUnboxed# e bytes# o# mbytes# 0# c# s2# of\n      s3# -> case unsafeFreezeByteArray# mbytes# s3# of\n        (# s4#, bytes'# #) -> (# s4#, (Wrap bytes'#) #)\n\n{- |\n  @since 0.2.1\n  @cloneUnboxedM# e mbytes# o# c#@ creates new @c#@-element length mutable slice\n  of @bytes#@ beginning from @o#@-th element.\n-}\ncloneUnboxedM# :: (Unboxed e) => e -> MutableByteArray# s -> Int# -> Int# ->\n  State# s -> (# State# s, MutableByteArray# s #)\ncloneUnboxedM# e mbytes# o# n# = \\ s1# -> case newByteArray# (sizeof# e n#) s1# of\n  (# s2#, copy# #) -> case copyUnboxedM# e mbytes# o# copy# 0# n# s2# of\n    s3# -> (# s3#, copy# #)\n\n{- |\n  @since 0.2.1\n  @'thawUnboxed#' e bytes# c#@ creates new @sizeof# e c#@ bytes length\n  'MutableByteArray#' and copy @bytes#@ to it.\n-}\nthawUnboxed# :: (Unboxed e) => e -> ByteArray# -> Int# ->\n  State# s -> (# State# s, MutableByteArray# s #)\nthawUnboxed# e bytes# c# = \\ s1# -> case newByteArray# n# s1# of\n    (# s2#, mbytes# #) -> case copyByteArray# bytes# 0# mbytes# 0# n# s2# of\n      s3# -> (# s3#, mbytes# #)\n  where\n    n# = sizeof# e c#\n\n{- |\n  @since 0.2.1\n  @'freezeUnboxed#' e mbytes# c#@ creates new @sizeof# e c#@ bytes length\n  'ByteArray#' and copy @mbytes#@ to it.\n-}\nfreezeUnboxed# :: (Unboxed e) => e -> MutableByteArray# s -> Int# ->\n  State# s -> (# State# s, ByteArray# #)\nfreezeUnboxed# e mbytes# n# = \\ s1# -> case cloneUnboxedM# e mbytes# 0# n# s1# of\n  (# s2#, copy# #) -> unsafeFreezeByteArray# copy# s2#\n\n--------------------------------------------------------------------------------\n\n{- Rank 1 Unboxed proxies. -}\n\n-- | Returns 'undefined' of suitable type.\nfromProxy :: proxy e -> e\nfromProxy =  const undefined\n\n{- |\n  @since 0.2.1\n  'psizeof#' is proxy version of 'sizeof#'.\n-}\npsizeof# :: (Unboxed e) => proxy e -> Int# -> Int#\npsizeof# =  sizeof# . fromProxy\n\n{- |\n  @since 0.2\n  'psizeof' is proxy version of 'sizeof'.\n-}\npsizeof :: (Unboxed e) => proxy e -> Int -> Int\npsizeof =  sizeof . fromProxy\n\n{- |\n  @since 0.2\n  Kind @(Type -> Type)@ proxy version of 'newUnboxed'.\n-}\npnewUnboxed :: (Unboxed e) => proxy e -> Int# ->\n  State# s -> (# State# s, MutableByteArray# s #)\npnewUnboxed =  newUnboxed . fromProxy\n\n{- |\n  @since 0.2\n  Kind @(Type -> Type)@ proxy version if 'copyUnboxed#'.\n-}\npcopyUnboxed :: (Unboxed e) => proxy e -> ByteArray# -> Int# ->\n  MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\npcopyUnboxed =  copyUnboxed# . fromProxy\n\n{- |\n  @since 0.2\n  Kind @(Type -> Type)@ proxy version if 'copyUnboxedM#'.\n-}\npcopyUnboxedM :: (Unboxed e) => proxy e -> MutableByteArray# s -> Int# ->\n  MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\npcopyUnboxedM =  copyUnboxedM# . fromProxy\n\n{- |\n  @since 0.2\n  Kind @(Type -> Type)@ proxy version of 'cloneUnboxed#'.\n-}\ncloneUnboxed1# :: (Unboxed e) => proxy e -> ByteArray# -> Int# -> Int# -> ByteArray#\ncloneUnboxed1# =  cloneUnboxed# . fromProxy\n\n{- |\n  @since 0.2.1\n  Same as @sdp-0.2@ 'cloneUnboxed1#'. Use only if you don't need @sdp-0.2@\n  compatibility.\n-}\npcloneUnboxed :: (Unboxed e) => proxy e -> ByteArray# -> Int# -> Int# -> ByteArray#\npcloneUnboxed =  cloneUnboxed1#\n\n{- |\n  @since 0.2.1\n  Kind @(Type -> Type)@ proxy version of 'cloneUnboxed#'.\n-}\npcloneUnboxedM :: (Unboxed e) => proxy e -> MutableByteArray# s -> Int# -> Int# ->\n  State# s -> (# State# s, MutableByteArray# s #)\npcloneUnboxedM =  cloneUnboxedM# . fromProxy\n\n{- |\n  @since 0.2.1\n  Kind @(Type -> Type)@ proxy version of 'thawUnboxed#'.\n-}\npthawUnboxed :: (Unboxed e) => proxy e -> ByteArray# -> Int# ->\n  State# s -> (# State# s, MutableByteArray# s #)\npthawUnboxed =  thawUnboxed# . fromProxy\n\n{- |\n  @since 0.2.1\n  Kind @(Type -> Type)@ proxy version of 'pfreezeUnboxed'.\n-}\npfreezeUnboxed :: (Unboxed e) => proxy e -> MutableByteArray# s -> Int# ->\n  State# s -> (# State# s, ByteArray# #)\npfreezeUnboxed =  freezeUnboxed# . fromProxy\n\n--------------------------------------------------------------------------------\n\n{- (Type -> Type -> Type)-kind Unboxed proxies. -}\n\n-- | Returns 'undefined' of suitable type.\nfromProxy1 :: m (proxy e) -> e\nfromProxy1 =  const undefined\n\n{- |\n  @since 0.2\n  Kind @(Type -> Type -> Type)@ proxy version of 'newUnboxed'.\n-}\npnewUnboxed1 :: (Unboxed e) => p (proxy e) -> Int# ->\n  State# s -> (# State# s, MutableByteArray# s #)\npnewUnboxed1 =  newUnboxed . fromProxy1\n\n{- |\n  @since 0.2\n  Kind @(Type -> Type -> Type)@ proxy version of 'copyUnboxed#'.\n-}\npcopyUnboxed1 :: (Unboxed e) => p (proxy e) -> ByteArray# -> Int# ->\n  MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\npcopyUnboxed1 =  copyUnboxed# . fromProxy1\n\n{- |\n  @since 0.2.1\n  Kind @(Type -> Type -> Type)@ proxy version of 'copyUnboxedM#'.\n-}\npcopyUnboxedM1 :: (Unboxed e) => p (proxy e) -> MutableByteArray# s -> Int# ->\n  MutableByteArray# s -> Int# -> Int# -> State# s -> State# s\npcopyUnboxedM1 =  copyUnboxedM# . fromProxy1\n\n{- |\n  @since 0.2.1\n  Kind @(Type -> Type -> Type)@ proxy version of 'cloneUnboxed#'.\n-}\npcloneUnboxed1 :: (Unboxed e) => p (proxy e) -> ByteArray# -> Int# -> Int# -> ByteArray#\npcloneUnboxed1 =  cloneUnboxed# . fromProxy1\n\n{- |\n  @since 0.2.1\n  Kind @(Type -> Type -> Type)@ proxy version of 'cloneUnboxed#'.\n-}\npcloneUnboxedM1 :: (Unboxed e) => p (proxy e) -> MutableByteArray# s -> Int# -> Int# ->\n  State# s -> (# State# s, MutableByteArray# s #)\npcloneUnboxedM1 =  cloneUnboxedM# . fromProxy1\n\n--------------------------------------------------------------------------------\n\n{- Numeric instances. -}\n\ninstance Unboxed Int\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * SIZEOF_HSWORD\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = I# (indexIntArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readIntArray# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, I# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (I# e#) = writeIntArray# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Int)\n\ninstance Unboxed Int8\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = I8# (indexInt8Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readInt8Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, I8# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (I8# e#) = writeInt8Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Int8)\n\ninstance Unboxed Int16\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * 2\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = I16# (indexInt16Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readInt16Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, I16# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (I16# e#) = writeInt16Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Int16)\n\ninstance Unboxed Int32\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * 4\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = I32# (indexInt32Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readInt32Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, I32# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (I32# e#) = writeInt32Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Int32)\n\ninstance Unboxed Int64\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * 8\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = I64# (indexInt64Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readInt64Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, I64# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (I64# e#) = writeInt64Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Int64)\n\ninstance Unboxed Word\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * SIZEOF_HSWORD\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = W# (indexWordArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readWordArray# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, W# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (W# e#) = writeWordArray# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Word)\n\ninstance Unboxed Word8\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = W8# (indexWord8Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readWord8Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, W8# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (W8#  e#) = writeWord8Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Word8)\n\ninstance Unboxed Word16\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * 2\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = W16# (indexWord16Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readWord16Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, W16# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (W16# e#) = writeWord16Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Word16)\n\ninstance Unboxed Word32\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * 4\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = W32# (indexWord32Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readWord32Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, W32# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (W32# e#) = writeWord32Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Word32)\n\ninstance Unboxed Word64\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * 8\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = W64# (indexWord64Array# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readWord64Array# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, W64# e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (W64# e#) = writeWord64Array# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Word64)\n\ninstance Unboxed Float\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * SIZEOF_HSFLOAT\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = F# (indexFloatArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readFloatArray# mbytes# i# s1# of\n      (# s2#, f# #) -> (# s2#, F# f# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (F# e#) = writeFloatArray# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Float)\n\ninstance Unboxed Double\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * SIZEOF_HSDOUBLE\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = D# (indexDoubleArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readDoubleArray# mbytes# i# s1# of\n      (# s2#, d# #) -> (# s2#, D# d# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (D# e#) = writeDoubleArray# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' (0 :: Double)\n\ninstance (Unboxed a, Integral a) => Unboxed (Ratio a)\n  where\n    sizeof e n = 2 * psizeof e n\n    \n    bytes# !# i# = bytes# !# i2# :% (bytes# !# (i2# +# 1#)) where i2# = 2# *# i#\n    \n    mbytes# !># i# = let i2# = 2# *# i# in \\ s1# -> case (!>#) mbytes# i2# s1# of\n      (# s2#, n #) -> case (!>#) mbytes# (i2# +# 1#) s2# of\n        (# s3#, d #) -> (# s3#, n :% d #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# i# (n :% d) = let i2# = 2# *# i# in\n      \\ s1# -> case writeByteArray# mbytes# i2# n s1# of\n        s2# -> writeByteArray# mbytes# (i2# +# 1#) d s2#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed e n# = pnewUnboxed e (2# *# n#)\n\ninstance (Unboxed a, Num a) => Unboxed (Complex a)\n  where\n    sizeof e n = 2 * psizeof e n\n    \n    bytes#  !#  i# = bytes# !# i2# :+ (bytes# !# (i2# +# 1#)) where i2# = 2# *# i#\n    mbytes# !># i# = let i2# = 2# *# i# in \\ s1# -> case (!>#) mbytes# i2# s1# of\n      (# s2#, n #) -> case (!>#) mbytes# (i2# +# 1#) s2# of\n        (# s3#, d #) -> (# s3#, n :+ d #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# i# (n :+ d) = let i2# = 2# *# i# in\n      \\ s1# -> case writeByteArray# mbytes# i2# n s1# of\n        s2# -> writeByteArray# mbytes# (i2# +# 1#) d s2#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed e n# = pnewUnboxed e (2# *# n#)\n\n--------------------------------------------------------------------------------\n\n{- Pointer instances. -}\n\ninstance Unboxed (Ptr a)\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * SIZEOF_HSWORD\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = Ptr (indexAddrArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readAddrArray# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, Ptr e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (Ptr e) = writeAddrArray# mbytes# n# e\n\n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' nullPtr\n\ninstance Unboxed (FunPtr a)\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * SIZEOF_HSWORD\n    \n    {-# INLINE (!#) #-}\n    bytes#  !#  i# = FunPtr (indexAddrArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readAddrArray# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, FunPtr e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (FunPtr e) = writeAddrArray# mbytes# n# e\n\n    {-# INLINE newUnboxed #-}\n    newUnboxed e = newUnboxed' (NULL `asTypeOf` e)\n\ninstance Unboxed (StablePtr a)\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * SIZEOF_HSWORD\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = StablePtr (indexStablePtrArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readStablePtrArray# mbytes# i# s1# of\n      (# s2#, e# #) -> (# s2#, StablePtr e# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (StablePtr e) = writeStablePtrArray# mbytes# n# e\n\n    {-# INLINE newUnboxed #-}\n    newUnboxed e = newUnboxed' (NULL `asTypeOf` e)\n\n--------------------------------------------------------------------------------\n\n{- Foreign C instances. -}\n\n#define deriving_instance_Unboxed(Type)\\\ninstance Unboxed Type where\\\n{\\\n  sizeof e = sizeof (consSizeof Type e);\\\n  arr# !# i# = Type ( arr# !# i# );\\\n  marr# !># i# = \\ s1# -> case (!>#) marr# i# s1# of {(# s2#, e #) -> (# s2#, Type e #)};\\\n  writeByteArray# marr# i# (Type e) = writeByteArray# marr# i# e;\\\n  fillByteArray#  marr# i# (Type e) = fillByteArray#  marr# i# e;\\\n  newUnboxed  (Type e) = newUnboxed  e;\\\n  newUnboxed' (Type e) = newUnboxed' e;\\\n}\n\nderiving_instance_Unboxed(CChar)\nderiving_instance_Unboxed(CSChar)\nderiving_instance_Unboxed(CWchar)\nderiving_instance_Unboxed(CShort)\nderiving_instance_Unboxed(CUShort)\n\nderiving_instance_Unboxed(CInt)\nderiving_instance_Unboxed(CUInt)\nderiving_instance_Unboxed(CLong)\nderiving_instance_Unboxed(CULong)\nderiving_instance_Unboxed(CLLong)\nderiving_instance_Unboxed(CULLong)\nderiving_instance_Unboxed(CIntPtr)\nderiving_instance_Unboxed(CUIntPtr)\nderiving_instance_Unboxed(CIntMax)\nderiving_instance_Unboxed(CUIntMax)\nderiving_instance_Unboxed(CPtrdiff)\n\nderiving_instance_Unboxed(CTime)\nderiving_instance_Unboxed(CClock)\nderiving_instance_Unboxed(CUSeconds)\nderiving_instance_Unboxed(CSUSeconds)\n\nderiving_instance_Unboxed(CSize)\n\n#if MIN_VERSION_base(4,10,0)\n-- | @since base-4.10.0.0\nderiving_instance_Unboxed(CBool)\n#endif\n\nderiving_instance_Unboxed(CFloat)\nderiving_instance_Unboxed(CDouble)\nderiving_instance_Unboxed(CSigAtomic)\n\n#undef deriving_instance_Unboxed\n\n--------------------------------------------------------------------------------\n\n{- Other instances. -}\n\ninstance Unboxed Bool\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ c = d == 0 ? n $ n + 1 where (n, d) = max 0 c `divMod` 8\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = isTrue# ((indexWordArray# bytes# (bool_index i#) `and#` bool_bit i#) `neWord#` int2Word# 0#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readWordArray# mbytes# (bool_index i#) s1# of\n      (# s2#, e# #) -> (# s2#, isTrue# ((e# `and#` bool_bit i#) `neWord#` int2Word# 0#) #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# e = \\ s1# -> case readWordArray# mbytes# i# s1# of\n        (# s2#, old_byte# #) -> writeWordArray# mbytes# i# (bitWrite old_byte#) s2#\n      where\n        bitWrite old_byte# = if e then old_byte# `or#` bool_bit n# else old_byte# `and#` bool_not_bit n#\n        i# = bool_index n#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed _ = newUnboxed' False\n    \n    fillByteArray# mbytes# n# e =\n      setByteArray# mbytes# 0# (bool_scale n#) (if e then 0xff# else 0#)\n    \n    copyUnboxed# e bytes# o1# mbytes# o2# c# = isTrue# (c# <# 1#) ? (\\ s1# -> s1#) $\n      \\ s1# -> case writeByteArray# mbytes# o2# ((bytes# !# o1#) `asTypeOf` e) s1# of\n        s2# -> copyUnboxed# e bytes# (o1# +# 1#) mbytes# (o2# +# 1#) (c# -# 1#) s2#\n    \n    copyUnboxedM# e src# o1# mbytes# o2# n# = \\ s1# -> case (!>#) src# o1# s1# of\n      (# s2#, x #) -> case writeByteArray# mbytes# o2# (x `asTypeOf` e) s2# of\n        s3# -> copyUnboxedM# e src# (o1# +# 1#) mbytes# (o2# +# 1#) (n# -# 1#) s3#\n    \n    hashUnboxedWith e len# off# bytes#\n        | isTrue#   (len# <# 1#)    = \\ salt# -> salt#\n        | isTrue#   (off# <# 0#)    = hashUnboxedWith e len# 0# bytes#\n        | isTrue# (bit_off# ==# 0#) = go0 byte_cnt# byte_off#\n        |            True           = goo byte_cnt# (byte_off# +# 1#) (indexWord8Array# bytes# byte_off#)\n      where\n        go0 0# _  salt# = salt#\n        go0 1# o# salt# = hash# salt# (indexWord8Array# bytes# o# `and#` mask#)\n        go0 n# o# salt# = go0 (n# -# 1#) (o# +# 1#) (salt# `hash#` indexWord8Array# bytes# o#)\n        \n        goo 0# _    _   salt# = salt#\n        goo 1# _  temp# salt# = hash# salt# (shiftRL# temp# bit_off# `and#` mask#)\n        goo n# o# temp# salt# = goo (n# -# 1#) (o# +# 1#) byte# (hash# salt# curr#)\n          where\n            curr# = shiftRL# temp# bit_off# `or#` shiftL# byte# (8# -# bit_off#)\n            byte# = indexWord8Array# bytes# o#\n        \n        hash# = \\ s# v# -> word2Int# (int2Word# (s# *# 16777619#) `xor#` v#)\n        mask# = int2Word# 0xff# `shiftRL#` bit_rest#\n        \n        !(I# byte_off#, I# bit_off#) = I# off# `divMod` 8\n        !(I# bit_len#) = I# len# `mod` 8\n        \n        bit_rest# = if isTrue# (bit_len# ==# 0#) then 0# else 8# -# bit_len#\n        byte_cnt# = sizeof# e len#\n\ninstance Unboxed Char\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ n = max 0 n * 4\n    \n    {-# INLINE (!#) #-}\n    bytes# !# i# = C# (indexWideCharArray# bytes# i#)\n    \n    {-# INLINE (!>#) #-}\n    mbytes# !># i# = \\ s1# -> case readWideCharArray# mbytes# i# s1# of\n      (# s2#, c# #) -> (# s2#, C# c# #)\n    \n    {-# INLINE writeByteArray# #-}\n    writeByteArray# mbytes# n# (C# e#) = writeWideCharArray# mbytes# n# e#\n    \n    {-# INLINE newUnboxed #-}\n    newUnboxed e n# = \\ s1# -> case newByteArray# (sizeof# e n#) s1# of\n      (# s2#, mbytes# #) -> case fillByteArray# mbytes# n# '\\0' s2# of\n        s3# -> (# s3#, mbytes# #)\n\ninstance Unboxed E\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ _ = 0\n    \n    {-# INLINE (!#) #-}\n    (!>#) = \\ _ _ s# -> (# s#, E #)\n    (!#)  = \\ _ _ -> E\n    \n    newUnboxed  _ _ = newByteArray# 0#\n    newUnboxed' _ _ = newByteArray# 0#\n    \n    writeByteArray# _ _ = \\ _ s# -> s#\n    fillByteArray#  _ _ = \\ _ s# -> s#\n\ninstance (Unboxed e) => Unboxed (I1 e)\n  where\n    sizeof# = psizeof#\n    sizeof  = psizeof\n    \n    bytes# !#  i# = E :& (bytes# !# i#)\n    bytes# !># i# = \\ s1# -> case (!>#) bytes# i# s1# of\n      (# s2#, e #) -> (# s2#, E :& e #)\n    \n    writeByteArray# bytes# n# (E :& e) = writeByteArray# bytes# n# e\n    fillByteArray#  bytes# n# (E :& e) = fillByteArray#  bytes# n# e\n    \n    newUnboxed' = \\ (E :& i) -> newUnboxed i\n    newUnboxed  = pnewUnboxed\n\ninstance (Enum e, Shape e, Bounded e, Unboxed e, Shape (e' :& e), Unboxed (e' :& e)) => Unboxed (e' :& e :& e)\n  where\n    sizeof# e n# = psizeof# e (rank# e *# n#)\n    sizeof  e  n = psizeof  e (rank  e *   n)\n    \n    bytes# !# i# = go undefined\n      where\n        go t =\n          let r# = rank# t; o# = i#*#r# +# i#\n          in  ((bytes# !# o#) `asTypeOf` t) :& (bytes# !# (o# +# r#))\n    \n    bytes# !># i# = go undefined\n      where\n        go t = let r# = rank# t; o# = i#*#r# +# i# in\n          \\ s1# -> case (!>#) bytes# o# s1# of\n            (# s2#, es #) -> case (!>#) bytes# (o# +# r#) s2# of\n              (# s3#, e #) -> (# s3#, (es `asTypeOf` t) :& e #)\n    \n    writeByteArray# bytes# i# (es :& e) = let r# = rank# es; o# = i#*#r# +# i# in\n      \\ s1# -> case writeByteArray# bytes# o# es s1# of\n        s2# -> writeByteArray# bytes# (o# +# r#) e s2#\n    \n    newUnboxed e n# = pnewUnboxed e (rank# e *# n#)\n\n--------------------------------------------------------------------------------\n\n{- Tuple instances. -}\n\ninstance Unboxed ()\n  where\n    {-# INLINE sizeof #-}\n    sizeof _ _ = 0\n    \n    {-# INLINE (!#) #-}\n    (!>#) = \\ _ _ s# -> (# s#, () #)\n    (!#)  = \\ _ _ -> ()\n    \n    newUnboxed  _ _ = newByteArray# 0#\n    newUnboxed' _ _ = newByteArray# 0#\n    \n    writeByteArray# _ _ = \\ _ s# -> s#\n    fillByteArray#  _ _ = \\ _ s# -> s#\n\ninstance (Unboxed e) => Unboxed (T2 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (2  *   n)\n    sizeof# e2 n# = psizeof# e2 (2# *# n#)\n    \n    bytes# !#  n# = let o# = 2# *# n# in (bytes# !# o#, bytes# !# (o#+#1#))\n    bytes# !># n# = let o# = 2# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> (# s3#, (e1,e2) #)\n    \n    writeByteArray# mbytes# n# (e1,e2) = let o# = 2# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> writeByteArray# mbytes# (o# +# 1#) e2 s2#\n    \n    newUnboxed e n# = pnewUnboxed e (2# *# n#)\n\ninstance (Unboxed e) => Unboxed (T3 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (3  *   n)\n    sizeof# e2 n# = psizeof# e2 (3# *# n#)\n    \n    bytes# !# n# =\n      let o# = 3# *# n#\n      in  (bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#))\n    \n    bytes# !># n# = let o# = 3# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> (# s4#, (e1,e2,e3) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3) = let o# = 3# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> writeByteArray# mbytes# (o# +# 2#) e3 s3#\n    \n    newUnboxed e n# = pnewUnboxed e (3# *# n#)\n\ninstance (Unboxed e) => Unboxed (T4 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (4  *   n)\n    sizeof# e2 n# = psizeof# e2 (4# *# n#)\n    \n    bytes# !# n# =\n      let o# = 4# *# n#\n      in  (bytes# !# o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#), bytes# !# (o#+#3#))\n    \n    bytes# !># n# = let o# = 4# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> (# s5#, (e1,e2,e3,e4) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4) = let o# = 4# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> writeByteArray# mbytes# (o# +# 3#) e4 s4#\n    \n    newUnboxed e n# = pnewUnboxed e (4# *# n#)\n\ninstance (Unboxed e) => Unboxed (T5 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (5  *   n)\n    sizeof# e2 n# = psizeof# e2 (5# *# n#)\n    \n    bytes# !# n# =\n      let o# = 5# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !# (o#+#4#)\n        )\n    \n    bytes# !># n# = let o# = 5# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> (# s6#, (e1,e2,e3,e4,e5) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5) = let o# = 5# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> writeByteArray# mbytes# (o# +# 4#) e5 s5#\n    \n    newUnboxed e n# = pnewUnboxed e (5# *# n#)\n\ninstance (Unboxed e) => Unboxed (T6 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (6  *   n)\n    sizeof# e2 n# = psizeof# e2 (6# *# n#)\n    \n    bytes# !# n# =\n      let o# = 6# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#)\n        )\n    \n    bytes# !># n# = let o# = 6# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> (# s7#, (e1,e2,e3,e4,e5,e6) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6) = let o# = 6# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> writeByteArray# mbytes# (o# +# 5#) e6 s6#\n    \n    newUnboxed e n# = pnewUnboxed e (6# *# n#)\n\ninstance (Unboxed e) => Unboxed (T7 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (7  *   n)\n    sizeof# e2 n# = psizeof# e2 (7# *# n#)\n    \n    bytes# !# n# =\n      let o# = 7# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\n          bytes# !# (o#+#6#)\n        )\n    \n    bytes# !># n# = let o# = 7# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> (# s8#, (e1,e2,e3,e4,e5,e6,e7) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7) = let o# = 7# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> writeByteArray# mbytes# (o# +# 6#) e7 s7#\n    \n    newUnboxed e n# = pnewUnboxed e (7# *# n#)\n\ninstance (Unboxed e) => Unboxed (T8 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (8  *   n)\n    sizeof# e2 n# = psizeof# e2 (8# *# n#)\n    \n    bytes# !# n# =\n      let o# = 8# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\n          bytes# !# (o#+#6#), bytes# !# (o#+#7#)\n        )\n    \n    bytes# !># n# = let o# = 8# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> (# s9#, (e1,e2,e3,e4,e5,e6,e7,e8) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8) = let o# = 8# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> writeByteArray# mbytes# (o# +# 7#) e8 s8#\n    \n    newUnboxed e n# = pnewUnboxed e (8# *# n#)\n\ninstance (Unboxed e) => Unboxed (T9 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (9  *   n)\n    sizeof# e2 n# = psizeof# e2 (9# *# n#)\n    \n    bytes# !# n# =\n      let o# = 9# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\n          bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#)\n        )\n    \n    bytes# !># n# = let o# = 9# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\n                      (# s10#, e9 #) -> (# s10#, (e1,e2,e3,e4,e5,e6,e7,e8,e9) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9) = let o# = 9# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\n                      s9# -> writeByteArray# mbytes# (o# +# 8#) e9 s9#\n    \n    newUnboxed e n# = pnewUnboxed e (9# *# n#)\n\ninstance (Unboxed e) => Unboxed (T10 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (10  *   n)\n    sizeof# e2 n# = psizeof# e2 (10# *# n#)\n    \n    bytes# !# n# =\n      let o# = 10# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\n          bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\n          bytes# !# (o#+#9#)\n        )\n    \n    bytes# !># n# = let o# = 10# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\n                      (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\n                        (# s11#, e10 #) -> (# s11#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10) = let o# = 10# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\n                      s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\n                        s10# -> writeByteArray# mbytes# (o# +# 9#) e10 s10#\n    \n    newUnboxed e n# = pnewUnboxed e (10# *# n#)\n\ninstance (Unboxed e) => Unboxed (T11 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (11  *   n)\n    sizeof# e2 n# = psizeof# e2 (11# *# n#)\n    \n    bytes# !# n# =\n      let o# = 11# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !# (o#+#1#), bytes# !# (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !# (o#+#4#), bytes# !# (o#+#5#),\n          bytes# !# (o#+#6#), bytes# !# (o#+#7#), bytes# !# (o#+#8#),\n          bytes# !# (o#+#9#), bytes# !# (o#+#10#)\n        )\n    \n    bytes# !># n# = let o# = 11# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\n                      (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\n                        (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\n                          (# s12#, e11 #) -> (# s12#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11) = let o# = 11# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\n                      s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\n                        s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\n                          s11# -> writeByteArray# mbytes# (o# +# 10#) e11 s11#\n    \n    newUnboxed e n# = pnewUnboxed e (11# *# n#)\n\ninstance (Unboxed e) => Unboxed (T12 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (12  *   n)\n    sizeof# e2 n# = psizeof# e2 (12# *# n#)\n    \n    bytes# !# n# =\n      let o# = 12# *# n#\n      in\n        (\n          bytes# !#       o#, bytes# !#  (o#+#1#), bytes# !#  (o#+#2#),\n          bytes# !# (o#+#3#), bytes# !#  (o#+#4#), bytes# !#  (o#+#5#),\n          bytes# !# (o#+#6#), bytes# !#  (o#+#7#), bytes# !#  (o#+#8#),\n          bytes# !# (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#)\n        )\n    \n    bytes# !># n# = let o# = 12# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\n                      (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\n                        (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\n                          (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\n                            (# s13#, e12 #) -> (# s13#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12) = let o# = 12# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\n                      s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\n                        s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\n                          s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\n                            s12# -> writeByteArray# mbytes# (o# +# 11#) e12 s12#\n    \n    newUnboxed e n# = pnewUnboxed e (12# *# n#)\n\ninstance (Unboxed e) => Unboxed (T13 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (13  *   n)\n    sizeof# e2 n# = psizeof# e2 (13# *# n#)\n    \n    bytes# !# n# =\n      let o# = 13# *# n#\n      in\n        (\n          bytes# !#        o#, bytes# !#  (o#+#1#), bytes# !#  (o#+#2#),\n          bytes# !#  (o#+#3#), bytes# !#  (o#+#4#), bytes# !#  (o#+#5#),\n          bytes# !#  (o#+#6#), bytes# !#  (o#+#7#), bytes# !#  (o#+#8#),\n          bytes# !#  (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#),\n          bytes# !# (o#+#12#)\n        )\n    \n    bytes# !># n# = let o# = 13# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\n                      (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\n                        (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\n                          (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\n                            (# s13#, e12 #) -> case (!>#) bytes# (o# +# 12#) s13# of\n                              (# s14#, e13 #) -> (# s14#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13) = let o# = 13# *# n# in\n      \\ s1# -> case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\n                      s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\n                        s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\n                          s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\n                            s12# -> case writeByteArray# mbytes# (o# +# 11#) e12 s12# of\n                              s13# -> writeByteArray# mbytes# (o# +# 12#) e13 s13#\n    \n    newUnboxed e n# = pnewUnboxed e (13# *# n#)\n\ninstance (Unboxed e) => Unboxed (T14 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (14  *   n)\n    sizeof# e2 n# = psizeof# e2 (14# *# n#)\n    \n    bytes# !# n# =\n      let o# = 14# *# n#\n      in\n        (\n          bytes# !#        o#, bytes# !#  (o#+#1#), bytes# !#  (o#+#2#),\n          bytes# !#  (o#+#3#), bytes# !#  (o#+#4#), bytes# !#  (o#+#5#),\n          bytes# !#  (o#+#6#), bytes# !#  (o#+#7#), bytes# !#  (o#+#8#),\n          bytes# !#  (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#),\n          bytes# !# (o#+#12#), bytes# !# (o#+#13#)\n        )\n    \n    bytes# !># n# = let o# = 14# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\n                      (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\n                        (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\n                          (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\n                            (# s13#, e12 #) -> case (!>#) bytes# (o# +# 12#) s13# of\n                              (# s14#, e13 #) -> case (!>#) bytes# (o# +# 13#) s14# of\n                                (# s15#, e14 #) -> (# s15#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14) =\n      \\ s1# -> let o# = 14# *# n# in case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\n                      s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\n                        s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\n                          s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\n                            s12# -> case writeByteArray# mbytes# (o# +# 11#) e12 s12# of\n                              s13# -> case writeByteArray# mbytes# (o# +# 12#) e13 s13# of\n                                s14# -> writeByteArray# mbytes# (o# +# 13#) e14 s14#\n    \n    newUnboxed e n# = pnewUnboxed e (14# *# n#)\n\ninstance (Unboxed e) => Unboxed (T15 e)\n  where\n    sizeof  e2 n  = psizeof  e2 (15  *   n)\n    sizeof# e2 n# = psizeof# e2 (15# *# n#)\n    \n    bytes# !# n# =\n      let o# = 15# *# n#\n      in\n        (\n          bytes# !#        o#, bytes# !#  (o#+#1#), bytes# !#  (o#+#2#),\n          bytes# !#  (o#+#3#), bytes# !#  (o#+#4#), bytes# !#  (o#+#5#),\n          bytes# !#  (o#+#6#), bytes# !#  (o#+#7#), bytes# !#  (o#+#8#),\n          bytes# !#  (o#+#9#), bytes# !# (o#+#10#), bytes# !# (o#+#11#),\n          bytes# !# (o#+#12#), bytes# !# (o#+#13#), bytes# !# (o#+#14#)\n        )\n    \n    bytes# !># n# = let o# = 15# *# n# in \\ s1# -> case (!>#) bytes# o# s1# of\n      (# s2#, e1 #) -> case (!>#) bytes# (o# +# 1#) s2# of\n        (# s3#, e2 #) -> case (!>#) bytes# (o# +# 2#) s3# of\n          (# s4#, e3 #) -> case (!>#) bytes# (o# +# 3#) s4# of\n            (# s5#, e4 #) -> case (!>#) bytes# (o# +# 4#) s5# of\n              (# s6#, e5 #) -> case (!>#) bytes# (o# +# 5#) s6# of\n                (# s7#, e6 #) -> case (!>#) bytes# (o# +# 6#) s7# of\n                  (# s8#, e7 #) -> case (!>#) bytes# (o# +# 7#) s8# of\n                    (# s9#, e8 #) -> case (!>#) bytes# (o# +# 8#) s9# of\n                      (# s10#, e9 #) -> case (!>#) bytes# (o# +# 9#) s10# of\n                        (# s11#, e10 #) -> case (!>#) bytes# (o# +# 10#) s11# of\n                          (# s12#, e11 #) -> case (!>#) bytes# (o# +# 11#) s12# of\n                            (# s13#, e12 #) -> case (!>#) bytes# (o# +# 12#) s13# of\n                              (# s14#, e13 #) -> case (!>#) bytes# (o# +# 13#) s14# of\n                                (# s15#, e14 #) -> case (!>#) bytes# (o# +# 14#) s15# of\n                                  (# s16#, e15 #) -> (# s16#, (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15) #)\n    \n    writeByteArray# mbytes# n# (e1,e2,e3,e4,e5,e6,e7,e8,e9,e10,e11,e12,e13,e14,e15) =\n      \\ s1# -> let o# = 15# *# n# in case writeByteArray# mbytes# o# e1 s1# of\n        s2# -> case writeByteArray# mbytes# (o# +# 1#) e2 s2# of\n          s3# -> case writeByteArray# mbytes# (o# +# 2#) e3 s3# of\n            s4# -> case writeByteArray# mbytes# (o# +# 3#) e4 s4# of\n              s5# -> case writeByteArray# mbytes# (o# +# 4#) e5 s5# of\n                s6# -> case writeByteArray# mbytes# (o# +# 5#) e6 s6# of\n                  s7# -> case writeByteArray# mbytes# (o# +# 6#) e7 s7# of\n                    s8# -> case writeByteArray# mbytes# (o# +# 7#) e8 s8# of\n                      s9# -> case writeByteArray# mbytes# (o# +# 8#) e9 s9# of\n                        s10# -> case writeByteArray# mbytes# (o# +# 9#) e10 s10# of\n                          s11# -> case writeByteArray# mbytes# (o# +# 10#) e11 s11# of\n                            s12# -> case writeByteArray# mbytes# (o# +# 11#) e12 s12# of\n                              s13# -> case writeByteArray# mbytes# (o# +# 12#) e13 s13# of\n                                s14# -> case writeByteArray# mbytes# (o# +# 13#) e14 s14# of\n                                  s15# -> writeByteArray# mbytes# (o# +# 14#) e15 s15#\n    \n    newUnboxed e n# = pnewUnboxed e (15# *# n#)\n\n--------------------------------------------------------------------------------\n\n-- | 'ByteArray#' wrapper.\ndata Wrap = Wrap {unwrap :: ByteArray#}\n\n{- |\n  @since 0.2.1\n  Wrapped empty 'ByteArray#'.\n-}\nlzero# :: Wrap\nlzero# =  runST $ ST $ \\ s1# -> case newByteArray# 0# s1# of\n  (# s2#, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\n    (# s3#, arr# #) -> (# s3#, Wrap arr# #)\n\n{- |\n  @since 0.2.1\n  'ByteArray#' singleton.\n-}\nsingle# :: (Unboxed e) => e -> ByteArray#\nsingle# e = unwrap $ runST $ ST $ \\ s1# -> case newUnboxed' e 1# s1# of\n  (# s2#, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\n    (# s3#, arr# #) -> (# s3#, Wrap arr# #)\n\n{- |\n  @since 0.2.1\n  Create immutable 'Unboxed' array from given list.\n-}\nfromList# :: (Unboxed e) => [e] -> ByteArray#\nfromList# es = let !(I# n#) = length es in fromListN# n# es\n\n{- |\n  @since 0.2.1\n  Create immutable 'Unboxed' array from 'Foldable' stream.\n-}\nfromFoldable# :: (Foldable f, Unboxed e) => f e -> (# Int, ByteArray# #)\nfromFoldable# es = unpack' $ runST $ ST $ \\ s1# -> case fromFoldableM# es s1# of\n    (# s2#, n, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\n      (# s3#, arr# #) -> (# s3#, (n, Wrap arr#) #)\n  where\n    unpack' (i, Wrap arr#) = (# i, arr# #)\n\n{- |\n  @since 0.2.1\n  Create immutable 'Unboxed' array from known size list.\n-}\nfromListN# :: (Unboxed e) => Int# -> [e] -> ByteArray#\nfromListN# n# es = unwrap $ runST $ ST $ \\ s1# -> case newLinearN# n# es s1# of\n  (# s2#, marr# #) -> case unsafeFreezeByteArray# marr# s2# of\n    (# s3#, arr# #) -> (# s3#, Wrap arr# #)\n\n{- |\n  @since 0.2.1\n  Create mutable 'Unboxed' array from given list.\n-}\nnewLinear# :: (Unboxed e) => [e] -> State# s ->\n  (# State# s, MutableByteArray# s #)\nnewLinear# es = let !(I# n#) = length es in newLinearN# n# es\n\n{- |\n  @since 0.2.1\n  Create mutable 'Unboxed' array from known size list.\n-}\nnewLinearN# :: (Unboxed e) => Int# -> [e] -> State# s ->\n  (# State# s, MutableByteArray# s #)\nnewLinearN# c# es = \\ s1# -> case pnewUnboxed es n# s1# of\n    (# s2#, marr# #) ->\n      let\n        go y r = \\ i# s4# -> case writeByteArray# marr# i# y s4# of\n          s5# -> if isTrue# (i# ==# n# -# 1#) then s5# else r (i# +# 1#) s5#\n      in case if n == 0 then s2# else foldr go (\\ _ s# -> s#) es 0# s2# of\n          s3# -> (# s3#, marr# #)\n  where\n    !n@(I# n#) = max 0 (I# c#)\n\n{- |\n  @since 0.2.1\n  Create mutable 'Unboxed' array from 'Foldable' stream.\n-}\nfromFoldableM# :: (Foldable f, Unboxed e) => f e -> State# s ->\n  (# State# s, Int, MutableByteArray# s #)\nfromFoldableM# es = \\ s1# -> case pnewUnboxed es n# s1# of\n    (# s2#, marr# #) ->\n      let\n        go y r = \\ i# s4# -> case writeByteArray# marr# i# y s4# of\n          s5# -> if isTrue# (i# ==# n# -# 1#) then s5# else r (i# +# 1#) s5#\n      in case if n == 0 then s2# else foldr go (\\ _ s# -> s#) es 0# s2# of\n          s3# -> (# s3#, n, marr# #)\n  where\n    !n@(I# n#) = length es\n\n{- |\n  @since 0.2.1\n  Concatenation of two 'Unboxed' arrays.\n-}\nconcat# :: (Unboxed e) => e ->\n  ByteArray# -> Int# -> Int# ->\n  ByteArray# -> Int# -> Int# -> State# s ->\n  (# State# s, Int#, MutableByteArray# s #)\nconcat# e arr1# n1# o1# arr2# n2# o2# = \\ s1# -> case newUnboxed e n# s1# of\n    (# s2#, marr# #) -> case copyUnboxed# e arr1# o1# marr# 0# n1# s2# of\n      s3# -> case copyUnboxed# e arr2# o2# marr# n1# n2# s3# of\n        s4# -> (# s4#, n#, marr# #)\n  where\n    n# = n1# +# n2#\n\n-- | Proxy concatenation of two byte arrays representing 'Unboxed' structures.\npconcat :: (Unboxed e) => proxy e ->\n  ByteArray# -> Int# -> Int# -> ByteArray# -> Int# -> Int# ->\n  State# s -> (# State# s, Int#, MutableByteArray# s #)\npconcat = concat# . fromProxy\n\n--------------------------------------------------------------------------------\n\nrank# :: (Shape i) => i -> Int#\nrank# i = case rank i of I# r# -> r#\n\n{-# INLINE bool_scale #-}\nbool_scale :: Int# -> Int#\nbool_scale n# = (n# +# 7#) `uncheckedIShiftRA#` 3#\n\n{-# INLINE bool_bit #-}\nbool_bit :: Int# -> Word#\nbool_bit n# = case (SIZEOF_HSWORD * 8 - 1) of\n  W# mask# -> int2Word# 1# `uncheckedShiftL#` word2Int# (int2Word# n# `and#` mask#)\n\n{-# INLINE bool_not_bit #-}\nbool_not_bit :: Int# -> Word#\nbool_not_bit n# = case maxBound of W# mb# -> bool_bit n# `xor#` mb#\n\n{-# INLINE bool_index #-}\nbool_index :: Int# -> Int#\n#if   SIZEOF_HSWORD == 4\nbool_index =  (`uncheckedIShiftRA#` 5#)\n#elif SIZEOF_HSWORD == 8\nbool_index =  (`uncheckedIShiftRA#` 6#)\n#endif\n\nconsSizeof :: (a -> b) -> b -> a\nconsSizeof =  \\ _ _ -> undefined\n\n\n"}
{"text": "[STATEMENT]\nlemma prod_mset_multiset_prime_factorization_nat [simp]: \n  \"(x::nat) \\<noteq> 0 \\<Longrightarrow> prod_mset (prime_factorization x) = x\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. x \\<noteq> 0 \\<Longrightarrow> \\<Prod>\\<^sub># (prime_factorization x) = x\n[PROOF STEP]\nby simp"}
{"text": "-- a^7 = b^7 syss a = b\n-- ====================\n\nimport tactic\nimport algebra.order.ring\n\ntheorem ex_1_3_5\n  {\u03b1}\n  [linear_ordered_ring \u03b1]\n  (a b : \u03b1)\n  (h : a^7 = b^7)\n  : a = b :=\n(@strict_mono_pow_bit1 \u03b1 _ 3).injective h\n\n-- Referencia\n-- ==========\n\n-- Mario Carneiro \"if a^7=b^7 then a=b\" https://bit.ly/3oyBS6M\n"}
{"text": "import tactic\n/--------------------------------------------------------------------------\n\nRecall that for any ``P : Prop``, you can use ``false.elim : false \u2192 P``\n  to prove ``P`` from a contradiction.\n\nDelete the ``sorry,`` below and replace them with a legitimate proof.\n\n--------------------------------------------------------------------------/\n\nexample (P Q R : Prop) : P \u2227 false \u2194 false :=\nbegin\n  sorry,\nend\n\ntheorem principle_of_explosion (P Q : Prop) : P \u2227 \u00ac P \u2192 Q :=\nbegin\n  sorry,\nend"}
{"text": "lemmas linear_imp_scaleR = linear_imp_scale"}
{"text": "module ModuleArityMismatch where\n\n module M (A : Set) where\n\n postulate\n   A : Set\n\n module M\u2032 = M A A\n"}
{"text": "classdef(Abstract) AbstractGeometricVectorConstraint < AbstractConstraint\n    %AbstractGeometricVectorConstraint Summary of this class goes here\n    %   Detailed explanation goes here\n\n    properties\n        normFact = 1;\n        vector AbstractGeometricVector\n        event LaunchVehicleEvent\n        eventNode(1,1) ConstraintStateComparisonNodeEnum = ConstraintStateComparisonNodeEnum.FinalState;\n        \n        lb(1,1) double = 0;\n        ub(1,1) double = 0;\n\n        type(1,:) char\n        \n        evalType(1,1) ConstraintEvalTypeEnum = ConstraintEvalTypeEnum.FixedBounds;\n        stateCompType(1,1) ConstraintStateComparisonTypeEnum = ConstraintStateComparisonTypeEnum.Equals;\n        stateCompEvent LaunchVehicleEvent\n        stateCompNode(1,1) ConstraintStateComparisonNodeEnum = ConstraintStateComparisonNodeEnum.FinalState;\n    end\n\n    methods\n        function [lb, ub] = getBounds(obj)\n            lb = obj.lb;\n            ub = obj.ub;\n        end\n        \n        function [c, ceq, value, lwrBnd, uprBnd, type, eventNum, valueStateComp] = evalConstraint(obj, stateLog, celBodyData)           \n            type = obj.getConstraintType();\n            \n            switch obj.eventNode\n                case ConstraintStateComparisonNodeEnum.FinalState\n                    stateLogEntry = stateLog.getLastStateLogForEvent(obj.event);\n                    \n                case ConstraintStateComparisonNodeEnum.InitialState\n                    stateLogEntry = stateLog.getFirstStateLogForEvent(obj.event);\n                \n                otherwise\n                    error('Unknown event node.');\n            end\n\n            if(not(isempty(obj.frame)))\n                frame = obj.frame;\n            else\n                frame = stateLogEntry.centralBody.getBodyCenteredInertialFrame();\n            end\n            \n            value = lvd_GeometricVectorTasks(stateLogEntry, obj.type, obj.vector, frame);\n            \n            if(obj.evalType == ConstraintEvalTypeEnum.StateComparison)\n                switch obj.stateCompNode\n                    case ConstraintStateComparisonNodeEnum.FinalState\n                        stateLogEntryStateComp = stateLog.getLastStateLogForEvent(obj.stateCompEvent);\n\n                    case ConstraintStateComparisonNodeEnum.InitialState\n                        stateLogEntryStateComp = stateLog.getFirstStateLogForEvent(obj.stateCompEvent);\n\n                    otherwise\n                        error('Unknown event node.');\n                end\n\n                valueStateComp = lvd_GeometricVectorTasks(stateLogEntryStateComp, obj.type, obj.vector, frame);\n            else\n                valueStateComp = NaN;\n            end\n            \n            [c, ceq] = obj.computeCAndCeqValues(value, valueStateComp); \n            \n            lwrBnd = obj.lb;\n            uprBnd = obj.ub;\n            \n            eventNum = obj.event.getEventNum();\n        end\n        \n        function sF = getScaleFactor(obj)\n            sF = obj.normFact;\n        end\n        \n        function setScaleFactor(obj, sF)\n            obj.normFact = sF;\n        end\n        \n        function tf = usesStage(obj, stage)\n            tf = false;\n        end\n        \n        function tf = usesEngine(obj, engine)\n            tf = false;\n        end\n        \n        function tf = usesTank(obj, tank)\n            tf = false;\n        end\n        \n        function tf = usesEngineToTankConn(obj, engineToTank)\n            tf = false;\n        end\n        \n        function tf = usesEvent(obj, event)\n            tf = obj.event == event;\n            if(obj.evalType == ConstraintEvalTypeEnum.StateComparison)\n                tf = tf || obj.stateCompEvent == event;\n            end\n        end\n        \n        function tf = usesStopwatch(~, ~)\n            tf = false;\n        end\n        \n        function tf = usesExtremum(~, ~)\n            tf = false;\n        end\n        \n        function tf = usesGroundObj(~, ~)\n            tf = false;\n        end\n        \n        function tf = usesGeometricVector(obj, vector)\n            tf = obj.vector == vector;\n        end\n        \n        function tf = canUseSparseOutput(obj)\n            tf = true;\n        end\n        \n        function event = getConstraintEvent(obj)\n            event = obj.event;\n        end\n                \n        function [unit, lbLim, ubLim, usesLbUb, usesCelBody, usesRefSc] = getConstraintStaticDetails(obj)\n            unit = '';\n            lbLim = 0;\n            ubLim = Inf;\n            usesLbUb = true;\n            usesCelBody = false;\n            usesRefSc = false;\n        end\n        \n        function addConstraintTf = openEditConstraintUI(obj, lvdData)\n            if(lvdData.geometry.vectors.getNumVectors() >= 1)\n%                 addConstraintTf = lvd_EditGeometricVectorConstraintGUI(obj, lvdData);\n\n                output = AppDesignerGUIOutput({false});\n                lvd_EditGeometricVectorConstraintGUI_App(obj, lvdData, output);\n                addConstraintTf = output.output{1};\n            else\n                errordlg('There are currently no geometric vectors in this scenario.  Add at least one new vector first.');\n                \n                addConstraintTf = false;\n            end\n        end\n        \n        function vector = selectConstraintObj(obj, lvdData)\n            [listBoxStr, vectors] = lvdData.geometry.vectors.getListboxStr();\n\n            vector = [];\n            if(isempty(vectors))                \n                warndlg('Cannot create vector value object: no vectors have been created.  Create a vector first.','Vector Value Constraint','modal');\n            else\n                [Selection,ok] = listdlg('PromptString',{'Select a vector:'},...\n                                'SelectionMode','single',...\n                                'Name','Vectors',...\n                                'ListString',listBoxStr);\n                            \n                if(ok == 0)\n                    vector = [];\n                else\n                    vector = vectors(Selection);\n                end\n            end\n        end\n        \n        function useObjFcn = setupForUseAsObjectiveFcn(obj,lvdData)\n            vectorSel = obj.selectConstraintObj(lvdData);\n            \n            if(not(isempty(vectorSel)))\n                obj.vector = vectorSel;\n                useObjFcn = true;\n            else\n                useObjFcn = false;\n            end\n        end\n    end\nend"}
{"text": "/-\nCopyright (c) 2015 Microsoft Corporation. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Leonardo de Moura, Jeremy Avigad, Mario Carneiro\n-/\nimport Mathlib.Tactic.Alias\nimport Mathlib.Tactic.IrreducibleDef\nimport Mathlib.Mathport.Rename\nimport Mathlib.Init.Logic\n\n/-! ### alignments from lean 3 `init.classical` -/\n\nnamespace Classical\n\n#align classical.inhabited_of_nonempty Classical.inhabited_of_nonempty\n#align classical.inhabited_of_exists Classical.inhabited_of_exists\n\nattribute [local instance] propDecidable\nattribute [local instance] decidableInhabited\n\nalias axiomOfChoice \u2190 axiom_of_choice -- TODO: fix in core\nalias propComplete \u2190 prop_complete -- TODO: fix in core\n\n@[elab_as_elim] theorem cases_true_false (p : Prop \u2192 Prop)\n    (h1 : p True) (h2 : p False) (a : Prop) : p a :=\n  Or.elim (prop_complete a) (fun ht : a = True \u21a6 ht.symm \u25b8 h1) fun hf : a = False \u21a6 hf.symm \u25b8 h2\n\ntheorem cases_on (a : Prop) {p : Prop \u2192 Prop} (h1 : p True) (h2 : p False) : p a :=\n  @cases_true_false p h1 h2 a\n\ntheorem cases {p : Prop \u2192 Prop} (h1 : p True) (h2 : p False) (a) : p a := cases_on a h1 h2\n#align classical.cases Classical.cases\n\nalias byCases \u2190 by_cases\nalias byContradiction \u2190 by_contradiction\n\ntheorem eq_false_or_eq_true (a : Prop) : a = False \u2228 a = True := (prop_complete a).symm\n\nend Classical\n"}
{"text": "# Copyright \u00a9 2021, UChicago Argonne, LLC\n# All Rights Reserved.\n\n# This source code is licensed under the BSD-style license found in the\n# LICENSE file in the root directory of this source tree. \n\nusing DataFrames, DataStructures, InteractiveUtils, Logging, Printf\nimport CSV, DelimitedFiles, SCIP, Statistics, Glob\nusing JuMP, MathOptInterface\nconst MOI = MathOptInterface"}
{"text": "variables (a b c d e : \u2115)\nvariable h1 : a = b\nvariable h2 : b = c + 1\nvariable h3 : c = d\nvariable h4 : e = 1 + d\n\ninclude h1 h2 h3 h4\ntheorem T : a = e :=\n  calc\n    a     = b     : by rw h1\n      ... = c + 1 : by rw h2\n      ... = d + 1 : by rw h3\n      ... = 1 + d : by rw add_comm\n      ... = e     : by rw h4\n"}
{"text": "import data.real.irrational\nimport topology.basic\nimport algebra.order.floor\n\n\n--OUTPUT 1\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=\nbegin\n  -- Let $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n  have h1 : \u2200 (i j : \u2124), i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from\n    assume (i j : \u2124) (h : i \u2260 j),\n    have h2 : \u03b1 \u2260 (int.fract (\u03b1 * \u2191i) - int.fract (\u03b1 * \u2191j)) / (i - j), from by {\n      assume h3 : \u03b1 = (int.fract (\u03b1 * \u2191i) - int.fract (\u03b1 * \u2191j)) / (i - j),\n      have h4 : \u03b1 * \u2191i = \u2191(int.nat_abs (\u03b1 * \u2191i)) + int.fract (\u03b1 * \u2191i), from by {\n        rw int.fract_eq_of_nat_abs_lt_one,\n        have h5 : 0 < \u03b1 * \u2191i, from by {\n          apply mul_pos,\n          apply irrational.irrat_pos,\n          exact h\u03b1_irrat,\n          apply int.coe_nat_pos,\n        },\n        exact lt_of_le_of_lt (int.nat_abs_nonneg (\u03b1 * \u2191i)) h5,\n      },\n      have h6 : \u03b1 * \u2191j = \u2191(int.nat_abs (\u03b1 * \u2191j)) + int.fract (\u03b1 * \u2191j), from by {\n        rw int.fract_eq_of_nat_abs_lt_one,\n        have h7 : 0 < \u03b1 * \u2191j, from by {\n          apply mul_pos,\n          apply irrational.irrat_pos,\n          exact h\u03b1_irrat,\n          apply int.coe_nat_pos,\n        },\n        exact lt_of_le_of_lt (int.nat_abs_nonneg (\u03b1 * \u2191j)) h7,\n      },\n      have h8 : (\u03b1 * \u2191i - \u03b1 * \u2191j) = (int.nat_abs (\u03b1 * \u2191i) - int.nat_abs (\u03b1 * \u2191j)) + (int.fract (\u03b1 * \u2191i) - int.fract (\u03b1 * \u2191j)), from by {\n        rw [h4,h6],\n        ring,\n      },\n      have h9 : (\u03b1 * \u2191i - \u03b1 * \u2191j) = (i - j) * \u03b1, from by {\n        rw [\u2190 mul_sub,mul_comm,mul_comm \u2191i \u03b1,mul_comm \u2191j \u03b1],\n      },\n      have h10 : (int.nat_abs (\u03b1 * \u2191i) - int.nat_abs (\u03b1 * \u2191j)) = 0, from by {\n        rw [\u2190 int.coe_nat_eq_coe_nat_iff,\u2190 int.coe_nat_eq_coe_nat_iff],\n        rw [\u2190 int.nat_abs_of_nonneg,\u2190 int.nat_abs_of_nonneg],\n        have h11 : 0 \u2264 \u03b1 * \u2191i, from by {\n          apply mul_nonneg,\n          apply irrational.irrat_pos,\n          exact h\u03b1_irrat,\n          apply int.coe_nat_nonneg,\n        },\n        have h12 : 0 \u2264 \u03b1 * \u2191j, from by {\n          apply mul_nonneg,\n          apply irrational.irrat_pos,\n          exact h\u03b1_irrat,\n          apply int.coe_nat_nonneg,\n        },\n        have h13 : 0 \u2264 i, from by {\n          apply int.coe_nat_nonneg,\n        },\n        have h14 : 0 \u2264 j, from by {\n          apply int.coe_nat_nonneg,\n        },\n        have h15 : 0 \u2264 (i - j), from by {\n          apply sub_nonneg,\n          exact h13,\n          exact h14,\n        },\n        have h16 : 0 \u2264 (\u03b1 * \u2191i - \u03b1 * \u2191j), from by {\n          apply sub_nonneg,\n          exact h11,\n          exact h12,\n        },\n        have h17 : (\u03b1 * \u2191i - \u03b1 * \u2191j) = (i - j) * \u03b1, from by {\n          rw [\u2190 mul_sub,mul_comm,mul_comm \u2191i \u03b1,mul_comm \u2191j \u03b1],\n        },\n        have h18 : (\u03b1 * \u2191i - \u03b1 * \u2191j) = (i - j) * \u03b1, from by {\n          rw [\u2190 mul_sub,mul_comm,mul_comm \u2191i \u03b1,mul_comm \u2191j \u03b1],\n        },\n        have h19 : (i - j) * \u03b1 = 0, from by {\n          rw [\u2190 h17,\u2190 h18],\n          rw [\u2190 int.coe_nat_eq_coe_nat_iff,\u2190 int.coe_nat_eq_coe_nat_iff],\n          rw [\u2190 int.nat_abs_of_nonneg,\u2190 int.nat_abs_of_nonneg],\n          exact h16,\n          exact h15,\n        },\n        have h20 : (i - j) = 0, from by {\n          rw [\u2190 mul_eq_zero,mul_comm,mul_comm \u2191i \u03b1,mul_comm \u2191j \u03b1],\n          exact h19,\n          exact irrational.irrat_pos h\u03b1_irrat,\n        },\n        have h21 : i = j, from by {\n          rw [\u2190 sub_eq_zero,\u2190 h20],\n        },\n        exact h21,\n      },\n      have h22 : (int.fract (\u03b1 * \u2191i) - int.fract (\u03b1 * \u2191j)) = 0, from by {\n        rw [\u2190 int.coe_nat_eq_coe_nat_iff,\u2190 int.coe_nat_eq_coe_nat_iff],\n        rw [\u2190 int.nat_abs_of_nonneg,\u2190 int.nat_abs_of_nonneg],\n        have h23 : 0 \u2264 \u03b1 * \u2191i, from by {\n          apply mul_nonneg,\n          apply irrational.irrat_pos,\n          exact h\u03b1_irrat,\n          apply int.coe_nat_nonneg,\n        },\n        have h24 : 0 \u2264 \u03b1 * \u2191j, from by {\n          apply mul_nonneg,\n          apply irrational.irrat_pos,\n          exact h\u03b1_irrat,\n          apply int.coe_nat_nonneg,\n        },\n        have h25 : 0 \u2264 (\u03b1 * \u2191i - \u03b1 * \u2191j), from by {\n          apply sub_nonneg,\n          exact h23,\n          exact h24,\n        },\n        have h26 : (\u03b1 * \u2191i - \u03b1 * \u2191j) = (i - j) * \u03b1, from by {\n          rw [\u2190 mul_sub,mul_comm,mul_comm \u2191i \u03b1,mul_comm \u2191j \u03b1],\n        },\n        have h27 : (\u03b1 * \u2191i - \u03b1 * \u2191j) = (i - j) * \u03b1, from by {\n          rw [\u2190 mul_sub,mul_comm,mul_comm \u2191i \u03b1,mul_comm \u2191j \u03b1],\n        },\n        have h28 : (i - j) * \u03b1 = 0, from by {\n          rw [\u2190 h26,\u2190 h27],\n          rw [\u2190 int.coe_nat_eq_coe_nat_iff,\u2190 int.coe_nat_eq_coe_nat_iff],\n          rw [\u2190 int.nat_abs_of_nonneg,\u2190 int.nat_abs_of_nonneg],\n          exact h25,\n          exact h10,\n        },\n        have h29 : (i - j) = 0, from by {\n          rw [\u2190 mul_eq_zero,mul_comm,mul_comm \u2191i \u03b1,mul_comm \u2191j \u03b1],\n          exact h28,\n          exact irrational.irrat_pos h\u03b1_irrat,\n        },\n        have h30 : i = j, from by {\n          rw [\u2190 sub_eq_zero,\u2190 h29],\n        },\n        exact h30,\n      },\n      have h31 :\nend --Needs more than 2000 tokens!\n\n--OUTPUT 2\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=\nbegin\n  --Let $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$.\n  have h1 : \u2200 i j : \u2124, i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from by {\n    assume i j h,\n    assume h2 : int.fract (\u03b1 * \u2191i) = int.fract (\u03b1 * \u2191j),\n    have h3 : \u03b1 * \u2191i - \u2191(int.floor (\u03b1 * \u2191i)) = int.fract (\u03b1 * \u2191i), from by {rw \u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191i)))),},\n    have h4 : \u03b1 * \u2191j - \u2191(int.floor (\u03b1 * \u2191j)) = int.fract (\u03b1 * \u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191j)))),},\n    have h5 : \u03b1 = (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j), from by {rw [h3,h4], ring,},\n    have h6 : (i - j) \u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\n    have h7 : (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j) \u2208 \u211a, from by {rw h5, apply_instance,},\n    have h8 : \u03b1 \u2208 \u211a, from by {rw h5, apply_instance,},\n    exact h\u03b1_irrat h8,\n  },\n\n  --If this were not true, then\n  --$$\n  --i \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n  --$$\n  --which yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$.\n  --Hence,\n  --$$\n  --S:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n  --$$\n  --is an infinite subset of $\\left[0,1\\right]$.\n  have h2 : \u2200 i j : \u2124, i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from by {\n    assume i j h,\n    assume h2 : int.fract (\u03b1 * \u2191i) = int.fract (\u03b1 * \u2191j),\n    have h3 : \u03b1 * \u2191i - \u2191(int.floor (\u03b1 * \u2191i)) = int.fract (\u03b1 * \u2191i), from by {rw \u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191i)))),},\n    have h4 : \u03b1 * \u2191j - \u2191(int.floor (\u03b1 * \u2191j)) = int.fract (\u03b1 * \u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191j)))),},\n    have h5 : \u03b1 = (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j), from by {rw [h3,h4], ring,},\n    have h6 : (i - j) \u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\n    have h7 : (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j) \u2208 \u211a, from by {rw h5, apply_instance,},\n    have h8 : \u03b1 \u2208 \u211a, from by {rw h5, apply_instance,},\n    exact h\u03b1_irrat h8,\n  },\n  have h3 : \u2200 i j : \u2124, i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from by {\n    assume i j h,\n    assume h2 : int.fract (\u03b1 * \u2191i) = int.fract (\u03b1 * \u2191j),\n    have h3 : \u03b1 * \u2191i - \u2191(int.floor (\u03b1 * \u2191i)) = int.fract (\u03b1 * \u2191i), from by {rw \u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191i)))),},\n    have h4 : \u03b1 * \u2191j - \u2191(int.floor (\u03b1 * \u2191j)) = int.fract (\u03b1 * \u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191j)))),},\n    have h5 : \u03b1 = (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j), from by {rw [h3,h4], ring,},\n    have h6 : (i - j) \u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\n    have h7 : (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j) \u2208 \u211a, from by {rw h5, apply_instance,},\n    have h8 : \u03b1 \u2208 \u211a, from by {rw h5, apply_instance,},\n    exact h\u03b1_irrat h8,\n  },\n  have h4 : \u2200 i j : \u2124, i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from by {\n    assume i j h,\n    assume h2 : int.fract (\u03b1 * \u2191i) = int.fract (\u03b1 * \u2191j),\n    have h3 : \u03b1 * \u2191i - \u2191(int.floor (\u03b1 * \u2191i)) = int.fract (\u03b1 * \u2191i), from by {rw \u2190 h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191i)))),},\n    have h4 : \u03b1 * \u2191j - \u2191(int.floor (\u03b1 * \u2191j)) = int.fract (\u03b1 * \u2191j), from by {rw h2, rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_add_one (\u03b1 * \u2191j)))),},\n    have h5 : \u03b1 = (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j), from by {rw [h3,h4], ring,},\n    have h6 : (i - j) \u2260 0, from by {intro h7, rw h7 at h, exact h rfl,},\n    have h7 : (int.floor (\u03b1 * \u2191i) - int.floor (\u03b1 * \u2191j)) / (i - j) \u2208 \u211a, from by {rw h5, apply_instance,},\n    have h8 : \u03b1 \u2208 \u211a, from by {rw h5, apply_instance,},\n    exact h\u03b1_irrat h8,\n  },\n  have h5 : \u2200 i j : \u2124, i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from by {\n    assume i j h,\n    assume h2 : int.fract (\u03b1 * \u2191i) = int.fract (\u03b1 * \u2191j),\n    have h3 : \u03b1 * \u2191\nend --Needs more than 2000 tokens!\n\n--OUTPUT 3\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=\nbegin\n  -- Let $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n  -- $$\n  -- i \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n  -- $$\n  -- which yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$. Hence,\n  -- $$\n  -- S:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n  -- $$\n  -- is an infinite subset of $\\left[0,1\\right]$.\n  have h1 : \u2200 i j : \u2124, i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from by {\n    assume i j h,\n    have h2 : \u03b1 = (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) / (i - j), from by {\n      have h3 : \u03b1 * \u2191i = (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i), from by {\n        rw int.fract_eq_of_nat_abs_lt_one,\n        have h4 : (0 : \u211d) < (1 : \u211d), from by {exact zero_lt_one},\n        have h5 : (0 : \u211d) < (\u03b1 * \u2191i), from by {apply mul_pos h4, exact int.coe_nat_pos.mpr (int.coe_nat_ne_zero_iff_pos.mpr h)},\n        have h6 : (0 : \u211d) < int.nat_abs (\u03b1 * \u2191i), from by {apply int.nat_abs_pos.mpr h5},\n        have h7 : (0 : \u211d) < int.nat_abs (\u03b1 * \u2191i) * \u2191i, from by {apply mul_pos h6, exact int.coe_nat_pos.mpr (int.coe_nat_ne_zero_iff_pos.mpr h)},\n        have h8 : (0 : \u211d) < int.nat_abs (\u03b1 * \u2191i) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i), from by {apply add_pos h6 h7},\n        have h9 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {rw \u2190 int.fract_eq_of_nat_abs_lt_one, exact h8},\n        have h10 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {apply add_pos h9 h8},\n        have h11 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i), from by {apply add_pos h10 h7},\n        have h12 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {apply add_pos h11 h8},\n        have h13 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {apply add_pos h12 h8},\n        have h14 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {apply add_pos h13 h8},\n        have h15 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {apply add_pos h14 h8},\n        have h16 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {apply add_pos h15 h8},\n        have h17 : (0 : \u211d) < (\u03b1 * \u2191i) - (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.nat_abs (\u03b1 * \u2191i) * \u2191i) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)) + (int.fract (\u03b1 * \u2191i) + int.nat_abs (\u03b1 * \u2191i)), from by {apply add_pos h16 h8},\n        have h18 : (0 : \u211d) < (\u03b1 * \u2191i) - (int\nend --Needs more than 2000 tokens!\n\n/- FEW SHOT PROMPTS TO CODEX(START)\n/--`theorem`\nPower Set is Closed under Intersection\nLet $S$ be a set.\n\nLet $\\powerset S$ be the power set of $S$.\n\n\nThen:\n:$\\forall A, B \\in \\powerset S: A \\cap B \\in \\powerset S$\n`proof`\nLet $A, B \\in \\powerset S$.\n\nThen by the definition of power set, $A \\subseteq S$ and $B \\subseteq S$.\n\nFrom Intersection is Subset we have that $A \\cap B \\subseteq A$.\n\nIt follows from Subset Relation is Transitive that $A \\cap B \\subseteq S$.\n\nThus $A \\cap B \\in \\powerset S$ and closure is proved.\n{{qed}}\n-/\ntheorem power_set_intersection_closed {\u03b1 : Type*} (S : set \u03b1) : \u2200 A B \u2208 \ud835\udcab S, (A \u2229 B) \u2208 \ud835\udcab S :=\nbegin\n  -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\n  assume (A : set \u03b1) (hA : A \u2208 \ud835\udcab S) (B : set \u03b1) (hB : B \u2208 \ud835\udcab S),\n  -- Then $A \u2286 S$ and $B \u2286 S$, by power set definition\n  have h1 : (A \u2286 S) \u2227 (B \u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\n  -- Then $(A \u2229 B) \u2286 A$, by intersection of set is a subset\n  have h2 : (A \u2229 B) \u2286 A, from by apply set.inter_subset_left,\n  -- Then $(A \u2229 B) \u2286 S$, by subset relation is transitive \n  have h3 : (A \u2229 B) \u2286 S, from by {apply set.subset.trans h2 h1.left},\n  -- Hence $(A \u2229 B) \u2208  \ud835\udcab S$, by power set definition\n  show (A \u2229 B) \u2208  \ud835\udcab S, from by {apply set.mem_powerset h3},\nend\n\n/--`theorem`\nSquare of Sum\n :$\\forall x, y \\in \\R: \\paren {x + y}^2 = x^2 + 2 x y + y^2$\n`proof`\nFollows from the distribution of multiplication over addition:\n\n{{begin-eqn}}\n{{eqn | l = \\left({x + y}\\right)^2\n      | r = \\left({x + y}\\right) \\cdot \\left({x + y}\\right)\n}}\n{{eqn | r = x \\cdot \\left({x + y}\\right) + y \\cdot \\left({x + y}\\right)\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x \\cdot x + x \\cdot y + y \\cdot x + y \\cdot y\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x^2 + 2xy + y^2\n      | c = \n}}\n{{end-eqn}}\n{{qed}}\n-/\ntheorem square_of_sum (x y : \u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \nbegin\n  -- expand the power\n  calc (x + y)^2 = (x+y)*(x+y) : by rw sq\n  -- distributive property of multiplication over addition gives:\n  ... = x*(x+y) + y*(x+y) : by rw add_mul\n  -- applying the above property further gives:\n  ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\n  -- rearranging the terms using commutativity and adding gives:\n  ... = x^2 + 2*x*y + y^2 : by {repeat {rw \u2190 sq}, rw mul_comm y x, ring}\nend\n\n/--`theorem`\nIdentity of Group is Unique\nLet $\\struct {G, \\circ}$ be a group. Then there is a unique identity element $e \\in G$.\n`proof`\nFrom Group has Latin Square Property, there exists a unique $x \\in G$ such that:\n:$a x = b$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = b$\n\nSetting $b = a$, this becomes:\n\nThere exists a unique $x \\in G$ such that:\n:$a x = a$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = a$\n\nThese $x$ and $y$ are both $e$, by definition of identity element.\n{{qed}}\n-/\ntheorem group_identity_unique {G : Type*} [group G] : \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a :=\nbegin\n  -- Group has Latin Square Property\n  have h1 : \u2200 a b : G, \u2203! x : G, a * x = b, from by {\n    assume a b : G, use a\u207b\u00b9 * b, obviously, },\n  have h2 : \u2200 a b : G, \u2203! y : G, y * a = b, from by {\n    assume a b : G, use b * a\u207b\u00b9, obviously, }, \n\n  -- Setting $b = a$, this becomes:\n  have h3 : \u2200 a : G, \u2203! x : G, a * x = a, from \n    assume a : G, h1 a a,\n  have h4 : \u2200 a : G, \u2203! y : G, y * a = a, from\n    assume a : G, h2 a a,\n\n  -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\n  have h5 : \u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\n    exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\n    (mul_one a),\n  have h6 : \u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\n    exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \n\n  show \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a, from by {\n    use (1 : G),\n    have h7 : \u2200 e : G, (\u2200 a : G, e * a = a \u2227 a * e = a) \u2192 e = 1, from by {\n      assume (e : G) (hident : \u2200 a : G, e * a = a \u2227 a * e = a),\n      have h8 : \u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\n        exists_unique.unique (h3 a) (hident a).right\n        (classical.some_spec (exists_unique.exists (h3 a))), \n      have h9 : \u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\n        exists_unique.unique (h4 a) (hident a).left\n        (classical.some_spec (exists_unique.exists (h4 a))),\n      show e = (1 : G), from eq.trans (h9 e) (h6 _),     \n    },\n    exact \u27e8by obviously, h7\u27e9,\n  }\nend\n\n/--`theorem`\nSqueeze Theorem for Real Numbers\nLet $\\sequence {x_n}$, $\\sequence {y_n}$ and $\\sequence {z_n}$ be sequences in $\\R$.\n\nLet $\\sequence {y_n}$ and $\\sequence {z_n}$ both be convergent to the following limit:\n:$\\ds \\lim_{n \\mathop \\to \\infty} y_n = l, \\lim_{n \\mathop \\to \\infty} z_n = l$\n\nSuppose that:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\n\nThen:\n:$x_n \\to l$ as $n \\to \\infty$\nthat is:\n:$\\ds \\lim_{n \\mathop \\to \\infty} x_n = l$\n\n`proof`\nFrom Negative of Absolute Value:\n:$\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n\nLet $\\epsilon > 0$.\n\nWe need to prove that:\n:$\\exists N: \\forall n > N: \\size {x_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that:\n:$\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that:\n:$\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n\n\nLet $N = \\max \\set {N_1, N_2}$.\n\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n:$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n\nBut:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n\nand so:\n:$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n\nSo:\n:$\\forall n > N: \\size {x_n - l} < \\epsilon$\n\nHence the result.\n{{qed}}\n\n-/\ntheorem squeeze_theorem_real_numbers (x y z : \u2115 \u2192 \u211d) (l : \u211d) : \nlet seq_limit : (\u2115 \u2192 \u211d) \u2192 \u211d \u2192 Prop :=  \u03bb (u : \u2115 \u2192 \u211d) (l : \u211d), \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, |u n - l| < \u03b5 in\n seq_limit y l \u2192 seq_limit z l \u2192  (\u2200 n : \u2115, (y n) \u2264 (x n) \u2227 (x n) \u2264 (z n)) \u2192 seq_limit x l :=\nbegin\n  assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \u2200 (n : \u2115), y n \u2264 x n \u2227 x n \u2264 z n) (\u03b5), \n\n  --From Negative of Absolute Value: $\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n  have h5 : \u2200 x, |x - l| < \u03b5 \u2194 (((l - \u03b5) < x) \u2227 (x < (l + \u03b5))), \n  from by \n  {\n    intro x0,\n    have h6 : |x0 - l| < \u03b5 \u2194 ((x0 - l) < \u03b5) \u2227 ((l - x0) < \u03b5), \n    from abs_sub_lt_iff, rw h6,\n    split, \n    rintro \u27e8 S_1, S_2 \u27e9, \n    split; linarith, \n    rintro \u27e8 S_3, S_4 \u27e9, \n    split; linarith,\n    },\n  \n  --Let $\\epsilon > 0$.\n  assume (h7 : \u03b5 > 0),\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that $\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n  cases h2 \u03b5 h7 with N1 h8,\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that $\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n  cases h3 \u03b5 h7 with N2 h9,\n  \n  --Let $N = \\max \\set {N_1, N_2}$.\n  let N := max N1 N2,\n  use N,\n\n  --Then if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n  have h10 : \u2200 n > N, n > N1 \u2227 n > N2 := by {\n    assume n h,\n    split,\n    exact lt_of_le_of_lt (le_max_left N1 N2) h, \n    exact lt_of_le_of_lt (le_max_right N1 N2) h,\n  },\n  \n  --$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n  --$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n  --$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n  --So $\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n  have h11 : \u2200 n > N, (((l - \u03b5) < (y n)) \u2227 ((y n) \u2264 (x n))) \u2227 (((x n) \u2264 (z n)) \u2227 ((z n) < l+\u03b5)), \n  from by {\n    intros n h12,\n    split,\n    {\n\n      have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\n      split,\n      exact h13.left,\n      exact (h4 n).left,\n    },\n    {        \n      have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\n      split,\n      exact (h4 n).right,\n      exact h14.right,\n    },\n    \n  },\n\n  --$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n  have h15 : \u2200 n > N, ((l - \u03b5) < (x n)) \u2227 ((x n) < (l+\u03b5)), \n  from by {\n    intros n1 h16, cases (h11 n1 h16);\n    split; linarith,\n  },\n\n  --So $\\forall n > N: \\size {x_n - l} < \\epsilon$\n  --Hence the result\n  show  \u2200 (n : \u2115), n > N \u2192 |x n - l| < \u03b5, \n  from by {\n    intros n h17,\n    cases h5 (x n) with h18 h19,\n    apply h19, exact h15 n h17,\n  },\nend\n\n/--`theorem`\nDensity of irrational orbit\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\n`proof`\nLet $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n$$\ni \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n$$\nwhich yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$. Hence,\n$$\nS:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n$$\nis an infinite subset of $\\left[0,1\\right]$.\n\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\n\nTo show that $S$ is dense in $[0, 1]$, consider $y \\in[0,1]$, and $\\epsilon>0$. Then by selecting $x \\in S$ such that $\\{x\\}<\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\cdot\\{x\\} \\leq y<(N+1) \\cdot\\{x\\}$, we get: $|y-\\{N x\\}|<\\epsilon$.\n\nQED\n-/\ntheorem  irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=\nFEW SHOT PROMPTS TO CODEX(END)-/\n"}
{"text": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n-/\nimport morphisms.open_immersion\n\n/-!\n\n# Open immersions\n\nA morphism is an open immersions if the underlying map of spaces is an open embedding\n`f : X \u27f6 U \u2286 Y`, and the sheaf map `Y(V) \u27f6 f _* X(V)` is an iso for each `V \u2286 U`.\n\nMost of the theories are developed in `algebraic_geometry/open_immersion`, and we provide the\nremaining theorems analogous to other lemmas in `algebraic_geometry/morphisms/*`.\n\n-/\n\nnoncomputable theory\n\nopen category_theory category_theory.limits opposite topological_space\n\nuniverse u\n\nnamespace algebraic_geometry\n\nvariables {X Y Z : Scheme.{u}} (f : X \u27f6 Y) (g : Y \u27f6 Z)\n\nlemma is_iso_iff_stalk {f : X \u27f6 Y} :\n  is_iso f \u2194\n    is_iso f.1.base \u2227 \u2200 x, is_iso (PresheafedSpace.stalk_map f.1 x) :=\nbegin\n  split,\n  { intro h, exactI \u27e8infer_instance, infer_instance\u27e9 },\n  { rintro \u27e8h\u2081, h\u2082\u27e9, resetI,\n    haveI := is_open_immersion.of_stalk_iso f (Top.homeo_of_iso $ as_iso f.1.base).open_embedding,\n    exact is_open_immersion.to_iso f }\nend\n\nlemma is_iso_respects_iso : morphism_property.respects_iso (@is_iso Scheme _) :=\nby split; { introv H, resetI, apply_instance }\n\nlemma is_iso_is_local_at_target : property_is_local_at_target (@is_iso Scheme _) :=\nbegin\n  constructor,\n  { exact is_iso_respects_iso },\n  { introsI, apply_instance },\n  { introsI X Y f \ud835\udcb0 H,\n    haveI := is_open_immersion_is_local_at_target.3 f \ud835\udcb0 infer_instance,\n    suffices : function.surjective f.1.base,\n    { rw \u2190 Top.epi_iff_surjective f.1.base at this, exactI is_open_immersion.to_iso f },\n    have := congr_arg (coe : opens Y.carrier \u2192 set Y.carrier) \ud835\udcb0.supr_opens_range,\n    rw opens.coe_supr at this,\n    rw set.surjective_iff_surjective_of_Union_eq_univ this,\n    intro i,\n    haveI := (is_iso_respects_iso.arrow_iso_iff\n      (morphism_restrict_opens_range f (\ud835\udcb0.map i))).mpr (H i),\n    have : epi (arrow.mk (f \u2223_ Scheme.hom.opens_range (\ud835\udcb0.map i))).hom.1.base := infer_instance,\n    rw [Top.epi_iff_surjective, arrow.mk_hom, morphism_restrict_val_base] at this,\n    exact this }\nend\n\nlemma is_iso.open_cover_tfae {X Y : Scheme.{u}} (f : X \u27f6 Y) :\n  tfae [is_iso f,\n    \u2203 (\ud835\udcb0 : Scheme.open_cover.{u} Y), \u2200 (i : \ud835\udcb0.J),\n      is_iso (pullback.snd : (\ud835\udcb0.pullback_cover f).obj i \u27f6 \ud835\udcb0.obj i),\n    \u2200 (\ud835\udcb0 : Scheme.open_cover.{u} Y) (i : \ud835\udcb0.J),\n      is_iso (pullback.snd : (\ud835\udcb0.pullback_cover f).obj i \u27f6 \ud835\udcb0.obj i),\n    \u2200 (U : opens Y.carrier), is_iso (f \u2223_ U),\n    \u2200 {U : Scheme} (g : U \u27f6 Y) [is_open_immersion g],\n      is_iso (pullback.snd : pullback f g \u27f6 U),\n    \u2203 {\u03b9 : Type u} (U : \u03b9 \u2192 opens Y.carrier) (hU : supr U = \u22a4),\n      \u2200 i, is_iso (f \u2223_ (U i))] :=\nis_iso_is_local_at_target.open_cover_tfae f\n\nlemma is_iso_of_is_affine_is_iso {X Y : Scheme} [hX : is_affine X] [hY : is_affine Y] (f : X \u27f6 Y)\n  [hf : is_iso (f.1.c.app (op \u22a4))] : is_iso f :=\nbegin\n  rw \u2190 mem_Spec_ess_image at hX hY,\n  have : is_iso (AffineScheme.\u0393.map (@quiver.hom.op AffineScheme _ \u27e8X, hX\u27e9 \u27e8Y, hY\u27e9 f)) := hf,\n  have := @@is_iso_of_reflects_iso _ _ _ _ this _,\n  exact @@functor.map_is_iso _ _ AffineScheme.forget_to_Scheme _ (@@is_iso_of_op _ _ this)\nend\n\nlemma target_affine_locally_affine_and_is_iso :\n  target_affine_locally (\u03bb X Y f hY, is_affine X \u2227 is_iso (Scheme.\u0393.map f.op)) = @is_iso Scheme _ :=\nbegin\n  rw \u2190 is_iso_is_local_at_target.target_affine_locally_eq,\n  congr,\n  ext X Y f hY,\n  split,\n  { rintros \u27e8hX, hf\u27e9, exactI @@is_iso_of_is_affine_is_iso _ _ f hf },\n  { intro hf, exactI \u27e8is_affine_of_iso f, infer_instance\u27e9 }\nend\n\nend algebraic_geometry"}
{"text": "[STATEMENT]\nlemma size_Iff [simp]: \"size (A IFF B) = 2*(size A + size B) + 8\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. size (A IFF B) = 2 * (size A + size B) + 8\n[PROOF STEP]\nby (simp add: Iff_def)"}
{"text": "{-# OPTIONS --safe --warning=error --without-K #-}\n\nopen import LogicalFormulae\nopen import Setoids.Setoids\nopen import Rings.Definition\n\nopen import Agda.Primitive using (Level; lzero; lsuc; _\u2294_)\n\nmodule Rings.Units.Definition {a b : _} {A : Set a} {S : Setoid {a} {b} A} {_+_ _*_ : A \u2192 A \u2192 A} (R : Ring S _+_ _*_) where\n\nopen Setoid S\nopen Ring R\n\nUnit : A \u2192 Set (a \u2294 b)\nUnit r = Sg A (\u03bb s \u2192 (r * s) \u223c 1R)\n"}
{"text": "lemma Cauchy_uniform_iff: \"Cauchy X \\<longleftrightarrow> (\\<forall>P. eventually P uniformity \\<longrightarrow> (\\<exists>N. \\<forall>n\\<ge>N. \\<forall>m\\<ge>N. P (X n, X m)))\""}
{"text": "import fibonacci_world.divides_mul -- hide\n/-\n## Divisibility of a sum\n\nIn the quest for proving an interesting result about Fibonacci numbers\nit will be useful to have the following lemma, that allows to deduce\nthe divibility of a sum from the divisibility of the summands.\n-/\n\n/- Lemma :\nIf $k$ divides $n$ and $m$, then $k$ divides $m + n$.\n-/\nlemma divides_add {k n m : \u2115} (hn : k \u2223 n) (hm : k \u2223 m) : k \u2223 m + n :=\nbegin\n  cases hn with n1 hn1,\n  cases hm with m1 hm1,\n  use n1 + m1,\n  rw hn1,\n  rw hm1,\n  ring,\n\n\n\n  \nend\n\n"}
{"text": "\nimport analysis.normed.normed_field\nimport data.polynomial.taylor\nimport topology.metric_space.cau_seq_filter\nimport topology.algebra.polynomial\n\nsection nonarchimedean\n  variables (\ud835\udd5c : Type) [normed_group \ud835\udd5c]\n\n  /-- A type with a normed group structure is nonarchimedean if it satisfies `\u2225x + y\u2225 \u2264 max \u2225x\u2225 \u2225y\u2225`. -/\n  class nonarchimedean :=\n  (nonarch : \u2200 x y : \ud835\udd5c, \u2225x + y\u2225 \u2264 max (\u2225x\u2225) (\u2225y\u2225))\n\n  variables {\ud835\udd5c} [nonarchimedean \ud835\udd5c]\n\n  /-- The nonarchimedean inequality with addition replaced with subtraction. -/\n  theorem nonarchimedean.nonarch_sub (x y : \ud835\udd5c) : \u2225x - y\u2225 \u2264 max (\u2225x\u2225) (\u2225y\u2225) :=\n    (sub_eq_add_neg x y).symm \u25b8 norm_neg y \u25b8 nonarchimedean.nonarch x (-y)\n\n  /-- The nonarchimedean inequality is equal if the elements being added have different norms. -/\n  theorem nonarchimedean.eq_max_of_ne_norm {x y : \ud835\udd5c} (h : \u2225x\u2225 \u2260 \u2225y\u2225) :\n    \u2225x + y\u2225 = max (\u2225x\u2225) (\u2225y\u2225) :=\n  begin\n    have : \u2200 {x y : \ud835\udd5c}, \u2225x\u2225 > \u2225y\u2225 \u2192 \u2225x + y\u2225 = max (\u2225x\u2225) (\u2225y\u2225),\n    { intros x y h,\n      rw [max_eq_left_of_lt h],\n      have := nonarchimedean.nonarch_sub (x + y) y,\n      rw [\u2190(eq_sub_of_add_eq rfl : x = x + y - y)] at this,\n      apply le_antisymm (max_eq_left_of_lt h \u25b8 nonarchimedean.nonarch x y : \u2225x + y\u2225 \u2264 \u2225x\u2225),\n      cases le_max_iff.mp this with h' h',\n      { exact h' },\n      { exact absurd h' (not_le.mpr h) } },\n    cases h.lt_or_lt with h h,\n    { rw [add_comm, max_comm], exact this h },\n    { exact this h }\n  end\n\n  /-- If the nonarchimedean inequality is not equal, the elements being added have the same norm. -/\n  theorem nonarchimedean.eq_norm_of_ne_max {x y : \ud835\udd5c} (h : \u2225x + y\u2225 \u2260 max (\u2225x\u2225) (\u2225y\u2225)) :\n    \u2225x\u2225 = \u2225y\u2225 := of_not_not (mt nonarchimedean.eq_max_of_ne_norm h)\n\n  /-- A `\u2115`-indexed sequence in a nonarchimedean normed ring is Cauchy iff the difference\n    of its consecutive terms tends to `0`. -/\n  theorem nonarchimedean.cau {\ud835\udd5c} [normed_ring \ud835\udd5c] [nonarchimedean \ud835\udd5c] {s : \u2115 \u2192 \ud835\udd5c} :\n    is_cau_seq norm s \u2194 \u2200 \u03b5 > 0, \u2203 i, \u2200 j \u2265 i, \u2225s (j + 1) - s j\u2225 < \u03b5 :=\n  begin\n    apply forall\u2082_congr, intros \u03b5 h\u03b5,\n    split,\n    { rintro \u27e8i, hi\u27e9, use i, intros j hj,\n      exact sub_add_sub_cancel (s (j + 1)) (s i) (s j) \u25b8 neg_sub (s j) (s i) \u25b8\n        lt_of_le_of_lt (nonarchimedean.nonarch (s (j + 1) - s i) (-(s j - s i)))\n        (max_lt (hi (j + 1) (le_add_right hj)) ((norm_neg (s j - s i)).symm \u25b8 hi j hj)) },\n    { rintro \u27e8i, hi\u27e9, use i, intros j hj,\n      cases le_iff_exists_add.mp hj with k hk,\n      induction k with k ih generalizing j,\n      { rw [(add_zero i \u25b8 hk : j = i), sub_self, norm_zero], exact h\u03b5 },\n      { exact hk.symm \u25b8 (sub_add_sub_cancel (s (i + k + 1)) (s (i + k)) (s i)) \u25b8\n          lt_of_le_of_lt (nonarchimedean.nonarch (s (i + k + 1) - s (i + k)) (s (i + k) - s i))\n          (max_lt (hi (i + k) le_self_add) (ih (i + k) le_self_add rfl)) } }\n  end\nend nonarchimedean\n\nsection\n  variables (\ud835\udd5c : Type) [normed_field \ud835\udd5c] [nonarchimedean \ud835\udd5c]\n\n  /-- The closed unit ball in the nonarchimedean normed field `\ud835\udd5c`. -/\n  def disc : subring \ud835\udd5c := {\n    carrier   := {x | \u2225x\u2225 \u2264 1},\n    mul_mem'  := \u03bb x y hx hy, (norm_mul_le x y).trans (one_mul (1 : \u211d) \u25b8\n      mul_le_mul hx hy (norm_nonneg y) zero_le_one),\n    one_mem'  := norm_one.le,\n    add_mem'  := \u03bb x y hx hy, (nonarchimedean.nonarch x y).trans (max_le hx hy),\n    zero_mem' := norm_zero.le.trans zero_le_one,\n    neg_mem'  := \u03bb x hx, ((norm_neg x).symm \u25b8 hx : \u2225-x\u2225 \u2264 1)\n  }\n\n  namespace disc\n    /-- `disc \ud835\udd5c` inherits the norm of `\ud835\udd5c`. -/\n    instance disc_normed_ring : normed_ring (disc \ud835\udd5c) := {\n      norm := norm \u2218 subtype.val,\n      dist_eq := \u03bb x y, normed_field.dist_eq x.1 y.1 \u25b8 rfl,\n      norm_mul := \u03bb x y, le_of_eq (norm_mul x.1 y.1)\n    }\n\n    section\n      variable {\ud835\udd5c}\n\n      /-- The norm of `disc \ud835\udd5c` equals the norm of the inclusion into `\ud835\udd5c`. -/\n      theorem norm_def (x : disc \ud835\udd5c) : \u2225x\u2225 = \u2225x.1\u2225 := rfl\n\n      /-- All elements in `disc \ud835\udd5c` have norm less than or equal to `1`. -/\n      theorem norm_le_one (x : disc \ud835\udd5c) : \u2225x\u2225 \u2264 1 := x.2\n\n      /-- The norm in `disc \ud835\udd5c` preserves multiplication. -/\n      protected theorem norm_mul (x y : disc \ud835\udd5c) : \u2225x * y\u2225 = \u2225x\u2225 * \u2225y\u2225 :=\n        norm_mul x.1 y.1\n\n      /-- The norm in `disc \ud835\udd5c` preserves exponentiation. -/\n      protected theorem norm_pow (x : disc \ud835\udd5c) (n : \u2115) : \u2225x ^ n\u2225 = \u2225x\u2225 ^ n :=\n        norm_pow x.1 n\n\n      /-- Sequences with all elements having norm `\u2264 1` are Cauchy in `\ud835\udd5c` if and only if they are Cauchy in `disc \ud835\udd5c`. -/\n      theorem disc_is_cau_seq_iff (s : \u2115 \u2192 \ud835\udd5c) (hs : \u2200 n, \u2225s n\u2225 \u2264 1) :\n        is_cau_seq norm s \u2194 is_cau_seq norm (\u03bb n, \u27e8s n, hs n\u27e9 : \u2115 \u2192 disc \ud835\udd5c) := iff.rfl\n\n      /-- The injection of any Cauchy sequence in `disc \ud835\udd5c` into `\ud835\udd5c` is also a Cauchy sequence. -/\n      theorem disc_is_cau_seq {s : \u2115 \u2192 disc \ud835\udd5c} (h : is_cau_seq norm s) : is_cau_seq norm (\u03bb n, (s n).1) :=\n        (disc_is_cau_seq_iff (\u03bb n, (s n).1) (\u03bb n, (s n).2)).mpr h\n\n      variables {x y : disc \ud835\udd5c} (h : \u2225x\u2225 \u2264 \u2225y\u2225)\n      include h\n\n      /-- `disc \ud835\udd5c` inherits division from `\ud835\udd5c`, so long as the denominator has at least the numerator's norm. -/\n      def divide : disc \ud835\udd5c := \u27e8x.1 / y.1,\n      begin\n        change \u2225_\u2225 \u2264 1,\n        rw [norm_div, \u2190norm_def x, \u2190norm_def y],\n        by_cases hy : \u2225y\u2225 = 0,\n        { rw [hy, div_zero], exact zero_le_one },\n        { exact (div_le_one (lt_of_le_of_ne (norm_nonneg y) (ne.symm hy))).mpr h }\n      end\u27e9\n\n      /-- The norm in `disc \ud835\udd5c` preserves division. -/\n      theorem divide.norm : \u2225divide h\u2225 = \u2225x\u2225 / \u2225y\u2225 :=\n        norm_div x.1 y.1\n\n      /-- If the denominator `y` is non-zero, multiplying `divide h` by `y` cancels the division, leaving the numerator `x`. -/\n      theorem divide.mul_cancel (hy : y \u2260 0) : divide h * y = x :=\n        subtype.val_inj.mp (div_mul_cancel x.1 (mt subtype.val_inj.mp hy : y.1 \u2260 (0 : disc \ud835\udd5c).val))\n    end\n\n    /-- `disc \ud835\udd5c` inherits the nonarchimedean inequality from `\ud835\udd5c`. -/\n    instance disc_nonarchimedean : nonarchimedean (disc \ud835\udd5c) :=\n      \u27e8\u03bb x y, (norm_def (x + y)).symm \u25b8 nonarchimedean.nonarch x.1 y.1\u27e9\n\n    /-- The norm in `disc \ud835\udd5c` is an absolute value, thanks to properties inherited from the normed field `\ud835\udd5c`. -/\n    instance disc_norm_is_absolute_value : is_absolute_value (norm : disc \ud835\udd5c \u2192 \u211d) := {\n      abv_nonneg  := norm_nonneg,\n      abv_eq_zero := \u03bb _, norm_eq_zero,\n      abv_add     := \u03bb x y, (normed_field.is_absolute_value.abv_add : \u2200 x y : \ud835\udd5c, \u2225x + y\u2225 \u2264 \u2225x\u2225 + \u2225y\u2225) x y,\n      abv_mul     := disc.norm_mul,\n    }\n\n    /-- `disc \ud835\udd5c` inherits the completeness of `\ud835\udd5c`, i.e. if all Cauchy sequences in `\ud835\udd5c` are convergent,\n      then so are all Cauchy sequences in `disc \ud835\udd5c`. -/\n    instance disc_is_complete [cau_seq.is_complete \ud835\udd5c norm] : cau_seq.is_complete (disc \ud835\udd5c) norm := \u27e8\u03bb s,\n      begin\n        let s' : cau_seq \ud835\udd5c norm := \u27e8\u03bb n, (s n).1, s.2\u27e9,\n        use s'.lim,\n        { cases s'.equiv_lim 1 zero_lt_one with n hn,\n          rw [\u2190sub_add_cancel s'.lim (s' n)],\n          apply le_trans (nonarchimedean.nonarch (s'.lim - s' n) (s' n)),\n          have : \u2225s' n - cau_seq.const norm s'.lim n\u2225 = \u2225s'.lim - s' n\u2225,\n          { rw [\u2190norm_neg, neg_sub, cau_seq.const_apply] },\n          exact max_le (this \u25b8 le_of_lt (hn n (le_refl n))) (s n).2 },\n        { exact s'.equiv_lim }\n      end\u27e9\n  end disc\nend\n\nsection taylor\n  open polynomial\n  variables {R : Type} [comm_ring R]\n\n  /-- Any term of a polynomial sum can be removed and added separately so long as zero terms\n    do not contribute to the sum. -/\n  theorem polynomial.sum_term (n : \u2115) (f : polynomial R) (fn : \u2115 \u2192 R \u2192 polynomial R) (h : \u2200 k, fn k 0 = 0) :\n    f.sum fn = fn n (f.coeff n) + (f.erase n).sum fn :=\n  begin\n    rw [sum_def, sum_def, support_erase],\n    by_cases hn : n \u2208 f.support,\n    { rw [\u2190finset.add_sum_erase f.support (\u03bb n, fn n (f.coeff n)) hn],\n      apply congr_arg, apply finset.sum_congr rfl, intros x hx,\n      rw [erase_ne f n x (finset.ne_of_mem_erase hx)] },\n    { rw [not_mem_support_iff.mp hn, h n, zero_add],\n      exact eq.symm (finset.sum_congr (finset.erase_eq_of_not_mem hn)\n        (\u03bb x hx, congr_arg _ (erase_ne f n x (\u03bb h, absurd (h \u25b8 hx : n \u2208 f.support) hn)))) }\n  end\n\n  /-- Any polynomial `f` can be approximated as a quadratic polynomial centred on a chosen point `t\u2080`. -/\n  theorem taylor\u2082 (f : polynomial R) (t\u2080 : R) : \u2203 err : polynomial R, \u2200 t,\n    f.eval t = f.eval t\u2080 + (t - t\u2080) * f.derivative.eval t\u2080 + (t - t\u2080)^2 * err.eval t :=\n  begin\n    use (((taylor t\u2080 f).erase 0).erase 1).sum (\u03bb i a, C a * (X - C t\u2080) ^ (i - 2)), intro t,\n    have : \u2200 n, C 0 * (X - C t\u2080) ^ n = 0, { intro n, rw [C_0, zero_mul] },\n    conv_lhs { rw [\u2190f.sum_taylor_eq t\u2080, (taylor t\u2080 f).sum_term 0 (\u03bb i a, C a * (X - C t\u2080) ^ i) this,\n      ((taylor t\u2080 f).erase 0).sum_term 1 (\u03bb i a, C a * (X - C t\u2080) ^ i) this, taylor_coeff_zero,\n      erase_ne (taylor t\u2080 f) 0 1 nat.one_ne_zero, taylor_coeff_one], simp only,\n      rw [pow_zero, mul_one, pow_one, \u2190add_assoc, mul_comm, eval_add, eval_add,\n        eval_C, eval_mul, eval_sub, eval_X, eval_C, eval_C] },\n    apply congr_arg,\n    have : (t - t\u2080)^2 = ((X - C t\u2080) ^ 2).eval t := by rw [eval_pow, eval_sub, eval_X, eval_C],\n    rw [this, \u2190eval_mul], apply congr_arg,\n    rw [sum_def, sum_def, finset.mul_sum, finset.sum_congr rfl],\n    intros n hn,\n    conv_rhs { rw [mul_comm, mul_assoc, \u2190pow_add], },\n    have : 2 \u2264 n,\n    { cases n with n,\n      { exfalso, rw [support_erase, support_erase, finset.erase_right_comm] at hn,\n        exact absurd rfl (finset.ne_of_mem_erase hn) },\n      { cases n with n, { rw [support_erase] at hn, exact absurd rfl (finset.ne_of_mem_erase hn) },\n        { simp only [succ_order.succ_le_succ_iff, zero_le'] } } },\n    rw [nat.sub_add_cancel this]\n  end\n\n  /-- Any polynomial `f` can be approximated as a linear polynomial centred on a chosen point `t\u2080`. -/\n  theorem taylor\u2081 (f : polynomial R) (t\u2080 : R) : \u2203 err : polynomial R, \u2200 t,\n    f.eval t = f.eval t\u2080 + (t - t\u2080) * err.eval t :=\n  begin\n    cases taylor\u2082 f t\u2080 with err h,\n    use C (f.derivative.eval t\u2080) + (X - C t\u2080) * err, intro t,\n    rw [h t, eval_add, eval_C, mul_add, \u2190add_assoc, eval_mul,\n      eval_sub, eval_X, eval_C, \u2190mul_assoc, sq]\n  end\n\nend taylor\n\nsection\n  variables {R : Type} [normed_ring R] [is_absolute_value (norm : R \u2192 \u211d)]\n\n  /-- A filter-wise Cauchy sequence is an absolute-value-wise Cauchy sequence.\n    (This already exists in `topology.metric_space.cau_seq_filter`, but only for normed fields,\n    here it is restated for normed rings whose norm is an absolute value). -/\n  theorem cauchy_seq.is_cau_seq' {f : \u2115 \u2192 R} (hf : cauchy_seq f) :\n    is_cau_seq norm f :=\n  begin\n    cases cauchy_iff.1 hf with hf1 hf2,\n    intros \u03b5 h\u03b5,\n    rcases hf2 {x | dist x.1 x.2 < \u03b5} (metric.dist_mem_uniformity h\u03b5) with \u27e8t, \u27e8ht, htsub\u27e9\u27e9,\n    simp at ht, cases ht with N hN,\n    existsi N,\n    intros j hj,\n    rw \u2190dist_eq_norm,\n    apply @htsub (f j, f N),\n    apply set.mk_mem_prod; solve_by_elim [le_refl]\n  end\n\n  variable [cau_seq.is_complete R norm]\n\n  /-- A Cauchy sequence formed by composing a Cauchy sequence with a polynomial. -/\n  noncomputable def polynomial_comp (f : polynomial R) (s : cau_seq R norm) : cau_seq R norm :=\n    \u27e8\u03bb n, f.eval (s n), ((f.continuous.tendsto s.lim).comp s.tendsto_limit).cauchy_seq.is_cau_seq'\u27e9\n\n  /-- The composition of a polynomial with a Cauchy sequence's limit equals the limit of the\n    composition of the polynomial with the Cauchy sequence. -/\n  theorem polynomial_comp_lim (f : polynomial R) (s : cau_seq R norm) : f.eval s.lim = (polynomial_comp f s).lim :=\n    tendsto_nhds_unique ((f.continuous.tendsto s.lim).comp s.tendsto_limit) (polynomial_comp f s).tendsto_limit\n\n  /-- A Cauchy sequence formed by composing a Cauchy sequence with the norm. -/\n  noncomputable def norm_comp (s : cau_seq R norm) : cau_seq \u211d norm :=\n    \u27e8\u03bb n, \u2225s n\u2225, ((continuous_norm.tendsto s.lim).comp s.tendsto_limit).cauchy_seq.is_cau_seq'\u27e9\n\n  /-- The composition of the norm with a Cauchy sequence's limit equals the limit of the\n    composition of the norm with the Cauchy sequence. -/\n  theorem norm_comp_lim (s : cau_seq R norm) : \u2225s.lim\u2225 = (norm_comp s).lim :=\n    tendsto_nhds_unique ((continuous_norm.tendsto s.lim).comp s.tendsto_limit) (norm_comp s).tendsto_limit\nend\n"}
{"text": "parameters (n:Nat)\n  namespace X\n    export\n    foo : Bool\n    foo = True\n\n  U : Bool\n  U = foo\n"}
{"text": "      integer function fun(num)\n      write(6, *) num\n      fun = 10 + num\n      return\n      end\n\n      subroutine sub1(func)\n      implicit none\n      external func\n      integer func\n      integer i\n      save\n      i = func(i)\n      write(6, *) i\n      return\n      end\n\n      subroutine sub2(func)\n      external func\n      integer func\n      i = func(3)\n      write(6, *) i\n      return\n      end\n\n      program prog\n      implicit none\n      external fun\n      integer fun\n      integer i\n      i = fun(1)\n      write(6, *) i\n      call sub1(fun)\n      call sub1(fun)\n      call sub2(fun)\n      end\n"}
{"text": "{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE BangPatterns #-}\n{-# LANGUAGE DataKinds #-}\n{-# LANGUAGE DeriveGeneric #-}\n{-# LANGUAGE DeriveAnyClass #-}\n{-# LANGUAGE FlexibleInstances #-}\n{-# LANGUAGE FunctionalDependencies #-}\n{-# LANGUAGE MultiParamTypeClasses #-}\n{-# LANGUAGE TemplateHaskell #-}\n{-# LANGUAGE TypeFamilies #-}\n{-# LANGUAGE RankNTypes #-}\n{-# LANGUAGE ScopedTypeVariables #-}\n{-# LANGUAGE StandaloneDeriving #-}\n{-# LANGUAGE ViewPatterns #-}\n{-# OPTIONS_HADDOCK show-extensions #-}\n\nmodule NQS.CG\n  ( Operator\n  , NQS.CG.cg\n  , test\n  ) where\n\nimport Data.Complex\nimport Control.Monad.Primitive\n\nimport qualified Data.Vector.Storable as V\nimport qualified Data.Vector.Storable.Mutable as MV\n\nimport Foreign.Storable\n\nimport Lens.Micro\n\nimport NQS.Internal.Types\nimport NQS.Internal.BLAS\n\n\ntype Operator m el = -- forall m. PrimMonad m\n     MDenseVector 'Direct (PrimState m) el -- ^ Input\n  -> MDenseVector 'Direct (PrimState m) el -- ^ Output\n  -> m ()\n\nclass ToComplex a where\n  promoteToComplex :: RealOf a -> a\n\ninstance {-# OVERLAPPABLE #-} (a ~ RealOf a) => ToComplex a where\n  promoteToComplex = id\n\ninstance {-# OVERLAPS #-} (Num a, a ~ RealOf (Complex a)) => ToComplex (Complex a) where\n  promoteToComplex = (:+ 0)\n\ncg :: forall v el m.\n     ( PrimMonad m, v ~ MDenseVector 'Direct\n     , DOTC v el el, AXPY v el, COPY v el\n     , NRM2 v el (RealOf el), SCAL (RealOf el) v el\n     , Storable el, Fractional el, ToComplex el, RealFloat (RealOf el)\n     )\n  => Int -- ^ Max number of iterations\n  -> RealOf el -- ^ Tolerance\n  -> Operator m el -- ^ A\n  -> MDenseVector 'Direct (PrimState m) el -- ^ b\n  -> MDenseVector 'Direct (PrimState m) el -- ^ Initial guess x\n  -> m (Int, RealOf el)\ncg !maxIter !tol operator !b !x0 = do\n  r <- newTempVector n\n  p <- newTempVector n\n  q <- newTempVector n\n  bNorm <- norm b\n  -- This will probably never ever happen, but we should check anyway\n  if bNorm == 0\n    then fill x0 0 >> return (0, 0)\n    else do\n      -- r := b - max * x0\n      copy b r\n      operator x0 q\n      axpy (-1) q r\n      -- Are we done already?\n      norm r >>= \\rNorm -> if rNorm < tol * tol * bNorm\n        then return $! (0, sqrt (rNorm / bNorm))\n        else do\n          -- Start the loop\n          copy r p\n          go bNorm x0 r p q rNorm 0\n  where\n    n = b ^. dim\n    newTempVector size = MDenseVector size 1 <$> newVectorAligned size 64\n    norm x = (\\y -> y * y) <$> nrm2 x\n    go !bNorm !x !r !p !q !\u03c1 !i\n      | i >= maxIter = nrm2 r >>= \\rNorm -> return (i, rNorm / bNorm)\n      | otherwise = do\n        operator p q\n        \u03b1 <- (promoteToComplex \u03c1 /) <$> dotc p q\n        axpy   \u03b1  p x\n        axpy (-\u03b1) q r\n        norm r >>= \\rNorm -> if rNorm < threshold\n          then return (i, sqrt (rNorm / bNorm))\n          else do copy r q\n                  let \u03c1' = rNorm\n                      \u03b2  = \u03c1' / \u03c1\n                  scal \u03b2 p\n                  axpy 1 q p\n                  go bNorm x r p q \u03c1' (i + 1)\n      where threshold :: RealOf el\n            threshold = tol * tol * bNorm\n\ntest :: IO ()\ntest = do\n  let -- operator :: Operator Float\n      operator x y = do\n        aBuff <- newVectorAligned 9 64 :: IO (MV.MVector (PrimState IO) Float)\n        V.copy aBuff $ V.fromList [1, 2, 3, 4, 5, 6, 7, 8, 9]\n        let a = MDenseMatrix 3 3 3 aBuff :: MDenseMatrix 'Row (PrimState IO) Float\n        gemv NoTranspose 1.0 a x 0.0 y\n  bBuff <- V.unsafeThaw $ V.fromList [2, 2, 2 :: Float]\n  xBuff <- V.unsafeThaw $ V.fromList [0, 0, 0 :: Float]\n  let x = MDenseVector 3 1 xBuff :: MDenseVector 'Direct (PrimState IO) Float\n  let b = MDenseVector 3 1 bBuff :: MDenseVector 'Direct (PrimState IO) Float\n  print =<< (NQS.CG.cg 30 (1.0E-8 :: Float) operator b x)\n\n"}
{"text": "/-\nCopyright (c) 2022 Jannis Limperg. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: David Renshaw, Jannis Limperg\n-/\n\nimport Aesop\n\n-- This is an example which is currently challenging for Lean 4 `tauto`.\nexample {\u03b1 : Type} [LE \u03b1] (a b c : \u03b1) (x\u2080 x\u2081 x\u2082 : Prop)\n (this1 : x\u2080 \u2192 x\u2081 \u2192 a \u2264 c)\n (this2 : x\u2081 \u2192 x\u2082 \u2192 b \u2264 a)\n (this3 : x\u2082 \u2192 x\u2080 \u2192 c \u2264 b) :\n    ((x\u2080 \u2227 \u00acb \u2264 a) \u2227 x\u2081 \u2227 \u00acc \u2264 b \u2228\n         (x\u2081 \u2227 \u00acc \u2264 b) \u2227 x\u2082 \u2227 \u00aca \u2264 c \u2228 (x\u2082 \u2227 \u00aca \u2264 c) \u2227 x\u2080 \u2227 \u00acb \u2264 a \u2194\n       (x\u2080 \u2227 x\u2081 \u2228 x\u2081 \u2227 x\u2082 \u2228 x\u2082 \u2227 x\u2080) \u2227\n         \u00ac(c \u2264 b \u2227 b \u2264 a \u2228 b \u2264 a \u2227 a \u2264 c \u2228 a \u2264 c \u2227 c \u2264 b)) :=\nby aesop\n"}
{"text": "/-\nCopyright (c) 2021 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\nimport Lean\n\nsection\nopen Lean Elab Command\n\nsyntax (name := timeCmd)  \"#time \" command : command\n\n/--\nTime the elaboration of a command, and print the result (in milliseconds).\n\nExample usage:\n```\nset_option maxRecDepth 100000 in\n#time example : (List.range 500).length = 500 := rfl\n```\n-/\n@[commandElab timeCmd] def timeCmdElab : CommandElab\n  | `(#time%$tk $stx:command) => do\n    let start \u2190 IO.monoMsNow\n    elabCommand stx\n    logInfoAt tk m!\"time: {(\u2190 IO.monoMsNow) - start}ms\"\n  | _ => throwUnsupportedSyntax\n\nend\n"}
{"text": "Formal statement is: lemma contractible_empty [simp]: \"contractible {}\" Informal statement is: The empty space is contractible."}
{"text": "Reserved Notation \"A 'wimp' B\" (at level 99).\n\nInductive WImp (A B : Prop) : Prop :=\n  | wl : ~A -> A wimp B\n  | wr : ~~B -> A wimp B\nwhere \"A 'wimp' B\" := (WImp A B) : type_scope.\n\nPrint WImp_ind.\n\n\nTheorem problem_1 : forall A B : Prop, A wimp B -> A -> ~~B.\nProof.\n  intro.\n  intro.\n  intro.\n  induction H. contradiction.\n  auto.\nQed.\n\n\n\n\nTheorem problem_2 : forall A B C: Prop, \nA -> A wimp (B wimp C) -> (~~(B wimp C)) wimp C -> ~~C.\nProof.\n  intro.\n  intro.\n  intro.\n  intros.\n  destruct H0.\n  contradiction.\n  destruct H1.\n  contradiction.\n  auto.\nQed.\n\n\n\nAxiom wmp : forall A B : Prop, A wimp B -> A -> ~~B.\n\nTheorem wimp_ind : forall A B P : Prop, (A \\/ ~A) -> (~ A -> P) -> (~ ~ B -> P) -> (A wimp B) -> P.\nProof.\n  intro.\n  intro.\n  intro.\n  intro.\n  intro.\n  intro.\n  intro.\n  Print wmp.\n  destruct H2.\n  auto.\n  auto.\nQed.\n"}
{"text": "def twice : Nat \u2192 Nat := \u03bb n => 2*n\n\ndef foo1 : (\u03bb x : Nat => id (twice (id x))) = twice := by\n  conv in (id _) =>\n    trace_state\n    conv =>\n      enter [1,1]\n      trace_state\n      simp\n      trace_state\n    trace_state  -- `id (twice x)`\n\n\ntheorem foo2 (y : Nat) : (fun x => x + y = 0) = (fun x => False) := by\n  conv =>\n    trace_state\n    conv =>\n      lhs\n      trace_state\n      intro x\n      rw [Nat.add_comm]\n      trace_state\n    trace_state\n  trace_state\n  sorry\n"}
{"text": "[STATEMENT]\nlemma take_bit_int_eq_self:\n  \\<open>take_bit n k = k\\<close> if \\<open>0 \\<le> k\\<close> \\<open>k < 2 ^ n\\<close> for k :: int\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. take_bit n k = k\n[PROOF STEP]\nusing that\n[PROOF STATE]\nproof (prove)\nusing this:\n0 \\<le> k\nk < 2 ^ n\n\ngoal (1 subgoal):\n 1. take_bit n k = k\n[PROOF STEP]\nby (simp add: take_bit_int_eq_self_iff)"}
{"text": "universe u\n\ndef f1 (n m : Nat) (x : Fin n) (h : n = m) : Fin m :=\nh \u25b8 x\n\ndef f2 (n m : Nat) (x : Fin n) (h : m = n) : Fin m :=\nh \u25b8 x\n\ntheorem ex1 {\u03b1 : Sort u} {a b c : \u03b1} (h\u2081 : a = b) (h\u2082 : b = c) : a = c :=\nh\u2082 \u25b8 h\u2081\n\ntheorem ex2 {\u03b1 : Sort u} {a b : \u03b1} (h : a = b) : b = a :=\nh \u25b8 rfl\n\ntheorem ex3 {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : r a b) (h\u2082 : b = c) : r a c :=\nh\u2082 \u25b8 h\u2081\n\ntheorem ex3b {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : r a b) (h\u2082 : b = c) : r a c :=\nh\u2082.symm \u25b8 h\u2081\n\ntheorem ex3c {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : r a b) (h\u2082 : b = c) : r a c :=\nh\u2082.symm.symm \u25b8 h\u2081\n\ntheorem ex4 {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : a = b) (h\u2082 : r b c) : r a c :=\nh\u2081 \u25b8 h\u2082\n\ntheorem ex5 {p : Prop} (h : p = True) : p :=\nh \u25b8 trivial\n\ntheorem ex6 {p : Prop} (h : p = False) : \u00acp :=\nfun hp => h \u25b8 hp\n\ntheorem ex7 {\u03b1} {a b c d : \u03b1} (h\u2081 : a = c) (h\u2082 : b = d) (h\u2083 : c \u2260 d) : a \u2260 b :=\nh\u2081 \u25b8 h\u2082 \u25b8 h\u2083\n\ntheorem ex8 (n m k : Nat) (h : Nat.succ n + m = Nat.succ n + k) : Nat.succ (n + m) = Nat.succ (n + k) :=\nNat.succ_add .. \u25b8 Nat.succ_add .. \u25b8 h\n\ntheorem ex9 (a b : Nat) (h\u2081 : a = a + b) (h\u2082 : a = b) : a = b + a  :=\nh\u2082 \u25b8 h\u2081\n\ntheorem ex10 (a b : Nat) (h : a = b) : b = a :=\nh \u25b8 rfl\n\ndef ex11  {\u03b1 : Type u} {n : Nat} (a : Array \u03b1) (i : Nat) (h\u2081 : a.size = n) (h\u2082 : i < n) : \u03b1 :=\n  a.get \u27e8i, h\u2081 \u25b8 h\u2082\u27e9\n\ntheorem ex12 {\u03b1 : Type u} {n : Nat}\n  (a b : Array \u03b1)\n  (hsz\u2081 : a.size = n) (hsz\u2082 : b.size = n)\n  (h : \u2200 (i : Nat) (hi : i < n), a.getLit i hsz\u2081 hi = b.getLit i hsz\u2082 hi) : a = b :=\nArray.ext a b (hsz\u2081.trans hsz\u2082.symm) fun i hi\u2081 hi\u2082 => h i (hsz\u2081 \u25b8 hi\u2081)\n\ndef toArrayLit {\u03b1 : Type u} (a : Array \u03b1) (n : Nat) (hsz : a.size = n) : Array \u03b1 :=\nList.toArray $ Array.toListLitAux a n hsz n (hsz \u25b8 Nat.leRefl _) []\n\npartial def isEqvAux {\u03b1} (a b : Array \u03b1) (hsz : a.size = b.size) (p : \u03b1 \u2192 \u03b1 \u2192 Bool) (i : Nat) : Bool :=\n  if h : i < a.size then\n     let aidx : Fin a.size := \u27e8i, h\u27e9\n     let bidx : Fin b.size := \u27e8i, hsz \u25b8 h\u27e9\n     match p (a.get aidx) (b.get bidx) with\n     | true  => isEqvAux a b hsz p (i+1)\n     | false => false\n  else\n    true\n"}
{"text": "Formal statement is: lemma map_poly_0 [simp]: \"map_poly f 0 = 0\" Informal statement is: The polynomial $f(0)$ is the zero polynomial."}
{"text": "import data.real.irrational\nimport topology.basic\nimport algebra.order.floor\n\n\n--OUTPUT 1\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=\nbegin\n  --Let $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n  have h1 : \u2200 i j : \u2124, i \u2260 j \u2192 int.fract (\u03b1 * \u2191i) \u2260 int.fract (\u03b1 * \u2191j), from by {\n    assume i j : \u2124,\n    assume h2 : i \u2260 j,\n    assume h3 : int.fract (\u03b1 * \u2191i) = int.fract (\u03b1 * \u2191j),\n    have h4 : \u03b1 * \u2191i - \u2191(int.floor (\u03b1 * \u2191i)) = int.fract (\u03b1 * \u2191i), from by {rw int.fract_eq_of_nonneg (le_of_lt (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\u03b1 * \u2191i))) (int.floor_lt_iff.mpr (lt_of_le_of_lt (int.coe_nat_le_coe_nat_of_le (int.floor_nonneg (\nend --Needs more than 2000 tokens!\n\n/- FEW SHOT PROMPTS TO CODEX(START)\n/--`theorem`\nPower Set is Closed under Intersection\nLet $S$ be a set.\n\nLet $\\powerset S$ be the power set of $S$.\n\n\nThen:\n:$\\forall A, B \\in \\powerset S: A \\cap B \\in \\powerset S$\n`proof`\nLet $A, B \\in \\powerset S$.\n\nThen by the definition of power set, $A \\subseteq S$ and $B \\subseteq S$.\n\nFrom Intersection is Subset we have that $A \\cap B \\subseteq A$.\n\nIt follows from Subset Relation is Transitive that $A \\cap B \\subseteq S$.\n\nThus $A \\cap B \\in \\powerset S$ and closure is proved.\n{{qed}}\n-/\ntheorem power_set_intersection_closed {\u03b1 : Type*} (S : set \u03b1) : \u2200 A B \u2208 \ud835\udcab S, (A \u2229 B) \u2208 \ud835\udcab S :=\nbegin\n  -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\n  assume (A : set \u03b1) (hA : A \u2208 \ud835\udcab S) (B : set \u03b1) (hB : B \u2208 \ud835\udcab S),\n  -- Then $A \u2286 S$ and $B \u2286 S$, by power set definition\n  have h1 : (A \u2286 S) \u2227 (B \u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\n  -- Then $(A \u2229 B) \u2286 A$, by intersection of set is a subset\n  have h2 : (A \u2229 B) \u2286 A, from by apply set.inter_subset_left,\n  -- Then $(A \u2229 B) \u2286 S$, by subset relation is transitive \n  have h3 : (A \u2229 B) \u2286 S, from by {apply set.subset.trans h2 h1.left},\n  -- Hence $(A \u2229 B) \u2208  \ud835\udcab S$, by power set definition\n  show (A \u2229 B) \u2208  \ud835\udcab S, from by {apply set.mem_powerset h3},\nend\n\n/--`theorem`\nSquare of Sum\n :$\\forall x, y \\in \\R: \\paren {x + y}^2 = x^2 + 2 x y + y^2$\n`proof`\nFollows from the distribution of multiplication over addition:\n\n{{begin-eqn}}\n{{eqn | l = \\left({x + y}\\right)^2\n      | r = \\left({x + y}\\right) \\cdot \\left({x + y}\\right)\n}}\n{{eqn | r = x \\cdot \\left({x + y}\\right) + y \\cdot \\left({x + y}\\right)\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x \\cdot x + x \\cdot y + y \\cdot x + y \\cdot y\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x^2 + 2xy + y^2\n      | c = \n}}\n{{end-eqn}}\n{{qed}}\n-/\ntheorem square_of_sum (x y : \u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \nbegin\n  -- expand the power\n  calc (x + y)^2 = (x+y)*(x+y) : by rw sq\n  -- distributive property of multiplication over addition gives:\n  ... = x*(x+y) + y*(x+y) : by rw add_mul\n  -- applying the above property further gives:\n  ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\n  -- rearranging the terms using commutativity and adding gives:\n  ... = x^2 + 2*x*y + y^2 : by {repeat {rw \u2190 sq}, rw mul_comm y x, ring}\nend\n\n/--`theorem`\nIdentity of Group is Unique\nLet $\\struct {G, \\circ}$ be a group. Then there is a unique identity element $e \\in G$.\n`proof`\nFrom Group has Latin Square Property, there exists a unique $x \\in G$ such that:\n:$a x = b$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = b$\n\nSetting $b = a$, this becomes:\n\nThere exists a unique $x \\in G$ such that:\n:$a x = a$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = a$\n\nThese $x$ and $y$ are both $e$, by definition of identity element.\n{{qed}}\n-/\ntheorem group_identity_unique {G : Type*} [group G] : \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a :=\nbegin\n  -- Group has Latin Square Property\n  have h1 : \u2200 a b : G, \u2203! x : G, a * x = b, from by {\n    assume a b : G, use a\u207b\u00b9 * b, obviously, },\n  have h2 : \u2200 a b : G, \u2203! y : G, y * a = b, from by {\n    assume a b : G, use b * a\u207b\u00b9, obviously, }, \n\n  -- Setting $b = a$, this becomes:\n  have h3 : \u2200 a : G, \u2203! x : G, a * x = a, from \n    assume a : G, h1 a a,\n  have h4 : \u2200 a : G, \u2203! y : G, y * a = a, from\n    assume a : G, h2 a a,\n\n  -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\n  have h5 : \u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\n    exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\n    (mul_one a),\n  have h6 : \u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\n    exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \n\n  show \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a, from by {\n    use (1 : G),\n    have h7 : \u2200 e : G, (\u2200 a : G, e * a = a \u2227 a * e = a) \u2192 e = 1, from by {\n      assume (e : G) (hident : \u2200 a : G, e * a = a \u2227 a * e = a),\n      have h8 : \u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\n        exists_unique.unique (h3 a) (hident a).right\n        (classical.some_spec (exists_unique.exists (h3 a))), \n      have h9 : \u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\n        exists_unique.unique (h4 a) (hident a).left\n        (classical.some_spec (exists_unique.exists (h4 a))),\n      show e = (1 : G), from eq.trans (h9 e) (h6 _),     \n    },\n    exact \u27e8by obviously, h7\u27e9,\n  }\nend\n\n/--`theorem`\nSqueeze Theorem for Real Numbers\nLet $\\sequence {x_n}$, $\\sequence {y_n}$ and $\\sequence {z_n}$ be sequences in $\\R$.\n\nLet $\\sequence {y_n}$ and $\\sequence {z_n}$ both be convergent to the following limit:\n:$\\ds \\lim_{n \\mathop \\to \\infty} y_n = l, \\lim_{n \\mathop \\to \\infty} z_n = l$\n\nSuppose that:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\n\nThen:\n:$x_n \\to l$ as $n \\to \\infty$\nthat is:\n:$\\ds \\lim_{n \\mathop \\to \\infty} x_n = l$\n\n`proof`\nFrom Negative of Absolute Value:\n:$\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n\nLet $\\epsilon > 0$.\n\nWe need to prove that:\n:$\\exists N: \\forall n > N: \\size {x_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that:\n:$\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that:\n:$\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n\n\nLet $N = \\max \\set {N_1, N_2}$.\n\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n:$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n\nBut:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n\nand so:\n:$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n\nSo:\n:$\\forall n > N: \\size {x_n - l} < \\epsilon$\n\nHence the result.\n{{qed}}\n\n-/\ntheorem squeeze_theorem_real_numbers (x y z : \u2115 \u2192 \u211d) (l : \u211d) : \nlet seq_limit : (\u2115 \u2192 \u211d) \u2192 \u211d \u2192 Prop :=  \u03bb (u : \u2115 \u2192 \u211d) (l : \u211d), \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, |u n - l| < \u03b5 in\n seq_limit y l \u2192 seq_limit z l \u2192  (\u2200 n : \u2115, (y n) \u2264 (x n) \u2227 (x n) \u2264 (z n)) \u2192 seq_limit x l :=\nbegin\n  assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \u2200 (n : \u2115), y n \u2264 x n \u2227 x n \u2264 z n) (\u03b5), \n\n  --From Negative of Absolute Value: $\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n  have h5 : \u2200 x, |x - l| < \u03b5 \u2194 (((l - \u03b5) < x) \u2227 (x < (l + \u03b5))), \n  from by \n  {\n    intro x0,\n    have h6 : |x0 - l| < \u03b5 \u2194 ((x0 - l) < \u03b5) \u2227 ((l - x0) < \u03b5), \n    from abs_sub_lt_iff, rw h6,\n    split, \n    rintro \u27e8 S_1, S_2 \u27e9, \n    split; linarith, \n    rintro \u27e8 S_3, S_4 \u27e9, \n    split; linarith,\n    },\n  \n  --Let $\\epsilon > 0$.\n  assume (h7 : \u03b5 > 0),\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that $\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n  cases h2 \u03b5 h7 with N1 h8,\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that $\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n  cases h3 \u03b5 h7 with N2 h9,\n  \n  --Let $N = \\max \\set {N_1, N_2}$.\n  let N := max N1 N2,\n  use N,\n\n  --Then if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n  have h10 : \u2200 n > N, n > N1 \u2227 n > N2 := by {\n    assume n h,\n    split,\n    exact lt_of_le_of_lt (le_max_left N1 N2) h, \n    exact lt_of_le_of_lt (le_max_right N1 N2) h,\n  },\n  \n  --$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n  --$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n  --$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n  --So $\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n  have h11 : \u2200 n > N, (((l - \u03b5) < (y n)) \u2227 ((y n) \u2264 (x n))) \u2227 (((x n) \u2264 (z n)) \u2227 ((z n) < l+\u03b5)), \n  from by {\n    intros n h12,\n    split,\n    {\n\n      have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\n      split,\n      exact h13.left,\n      exact (h4 n).left,\n    },\n    {        \n      have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\n      split,\n      exact (h4 n).right,\n      exact h14.right,\n    },\n    \n  },\n\n  --$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n  have h15 : \u2200 n > N, ((l - \u03b5) < (x n)) \u2227 ((x n) < (l+\u03b5)), \n  from by {\n    intros n1 h16, cases (h11 n1 h16);\n    split; linarith,\n  },\n\n  --So $\\forall n > N: \\size {x_n - l} < \\epsilon$\n  --Hence the result\n  show  \u2200 (n : \u2115), n > N \u2192 |x n - l| < \u03b5, \n  from by {\n    intros n h17,\n    cases h5 (x n) with h18 h19,\n    apply h19, exact h15 n h17,\n  },\nend\n\n/--`theorem`\nDensity of irrational orbit\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\n`proof`\nLet $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n$$\ni \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n$$\nwhich yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$. Hence,\n$$\nS:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n$$\nis an infinite subset of $\\left[0,1\\right]$.\n\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\n\nTo show that $S$ is dense in $[0, 1]$, consider $y \\in[0,1]$, and $\\epsilon>0$. Then by selecting $x \\in S$ such that $\\{x\\}<\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\cdot\\{x\\} \\leq y<(N+1) \\cdot\\{x\\}$, we get: $|y-\\{N x\\}|<\\epsilon$.\n\nQED\n-/\ntheorem  irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=\nFEW SHOT PROMPTS TO CODEX(END)-/\n"}
{"text": "import data.complex.basic\nimport data.complex.module\nimport data.fintype.basic\nimport data.real.basic\nimport data.matrix.basic\nimport linear_algebra.matrix\n\nopen_locale matrix big_operators\nopen_locale complex_conjugate\nopen fintype finset matrix complex\n\nuniverses u\n-- variables {\u03b1 : Type u}\n-- variables {m n : Type*} [fintype m] [fintype n] [decidable_eq m] [decidable_eq n] [has_one n]\nvariable (n : \u2115) \n-- namespace matrix\n\nvariables (M : matrix (fin n) (fin n) \u2102)\n\n-- end matrix\n\n-- def make_mat (M : matrix n n \u2102) : matrix n n \u2102 := \u03bb i: n, (\u03bb j : n, (M i j))\n\n-- lemma trace_form (A : matrix n n \u2102) (B : matrix n n \u2102) : \u2211 (i : n), \u2211 (j : n), (A i j)*(B i j) = ( (A.transpose).mul B).trce :=\n-- begin\n--   simp only [matrix.trce, matrix.mul],\n--   -- \u2211 (i j : n), A i j * B i j = \u2211 (x : n), A\u1d40 x \u2b1d\u1d65 \u03bb (j : n), B j x\n--   simp [matrix.transpose, dot_product],\n--   exact sum_comm,\n--   -- \u2211 (i j : n), A i j * B i j = \u2211 (x : n), A\u1d40 x \u2b1d\u1d65 \u03bb (j : n), B j x\n-- end\n\nlemma trace_form (A : matrix (fin n) (fin n) \u2102) (B : matrix (fin n) (fin n) \u2102) : \u2211 (i : (fin n)), \u2211 (j : (fin n)), (A i j)*(B i j) = matrix.trace (fin n) \u2102 \u2102 ( (A.transpose).mul B) :=\nbegin\n  simp only [matrix.trace, matrix.mul],\n  -- \u2211 (i j : n), A i j * B i j = \u2211 (x : n), A\u1d40 x \u2b1d\u1d65 \u03bb (j : n), B j x\n  simp [matrix.transpose, dot_product],\n  exact sum_comm,\n  -- \u2211 (i j : n), A i j * B i j = \u2211 (x : n), A\u1d40 x \u2b1d\u1d65 \u03bb (j : n), B j x\nend\n\nlemma Laplace (A : matrix (fin n.succ) (fin n.succ) \u2102) : \u2200 i : (fin n.succ), det A = \u2211 (j : (fin n.succ)), (A i j)*(-1)^(i+j : \u2115)*det (A.minor i.succ_above j.succ_above) :=\nbegin\n  intro i,\n  have hyp := det_succ_row A i,\n  rw hyp,\n  simp [add_comm, mul_comm],\nend  \n\n\n\n\n\n\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_419\n  (a b : \u211d)\n  (h\u2080 : a = -1)\n  (h\u2081 : b = 5) :\n  -a - b^2 + 3 * (a * b) = -39 :=\nbegin\n  rw [h\u2080, h\u2081],\n  norm_num,\nend"}
{"text": "{-# OPTIONS --type-in-type --guardedness #-}\n\nmodule IO.Exts where\n\nimport IO.Primitive as Prim\nopen import Class.Monad\nopen import Class.Functor\nopen import Data.List\nopen import Data.Nat using (\u2115)\nopen import Data.String\nopen import Data.Sum\nopen import Data.Unit\nopen import Function\nopen import IO using (IO; run; readFiniteFile; lift)\nopen import IO.Instance\nopen import Level\n\nprivate\n  variable\n    A : Set\n\n{-#\n  FOREIGN GHC\n  import Data.Text\n  import System.CPUTime\n  import System.Environment\n  import System.Exit\n  import System.IO\n  import System.IO.Error\n  import System.Process\n#-}\n\npostulate\n  flushStdoutPrim : Prim.IO \u22a4\n  getCPUTimePrim : Prim.IO \u2115\n  putStrErrPrim : String \u2192 Prim.IO \u22a4\n  runShellCmdPrim : String \u2192 List String \u2192 Prim.IO String\n  catchIOErrorPrim : Prim.IO A \u2192 (String \u2192 Prim.IO A) \u2192 Prim.IO A\n\n{-# COMPILE GHC flushStdoutPrim = hFlush stdout #-}\n{-# COMPILE GHC getCPUTimePrim = getCPUTime #-}\n{-# COMPILE GHC putStrErrPrim = hPutStr stderr . unpack #-}\n{-# COMPILE GHC runShellCmdPrim = \\ s t -> pack <$> (readProcess (unpack s) (fmap unpack t) \"\") #-} -- use haskell proc\n{-# COMPILE GHC catchIOErrorPrim = \\ _ a f -> catchIOError a (f . pack . show) #-}\n\nflushStdout : IO \u22a4\nflushStdout = lift flushStdoutPrim\n\ngetCPUTime : IO \u2115\ngetCPUTime = lift getCPUTimePrim\n\nputStrErr : String \u2192 IO \u22a4\nputStrErr s = lift (putStrErrPrim s)\n\nrunShellCmd : String \u2192 List String \u2192 IO String\nrunShellCmd s args = lift (runShellCmdPrim s args)\n\ncatchIOError : IO A \u2192 (String \u2192 IO A) \u2192 IO A\ncatchIOError a f = lift $ catchIOErrorPrim (run a) (run \u2218 f)\n\nreadFiniteFileError : String \u2192 IO (String \u228e String)\nreadFiniteFileError name =\n  catchIOError (inj\u2082 <$> readFiniteFile name) (return \u2218 inj\u2081)\n"}
{"text": "lemma convex_onD_Icc: assumes \"convex_on {x..y} f\" \"x \\<le> (y :: _ :: {real_vector,preorder})\" shows \"\\<And>t. t \\<ge> 0 \\<Longrightarrow> t \\<le> 1 \\<Longrightarrow> f ((1 - t) *\\<^sub>R x + t *\\<^sub>R y) \\<le> (1 - t) * f x + t * f y\""}
{"text": "import data.real.basic\n\ntheorem exo (f: real -> real):\n  (forall x y, f(x^2)-f(y^2)=(x+y)*(f(x)-f(y)))\n  -> (exists m l, forall x, f(x) = m * x + l)\n:=\n  sorry\n"}
{"text": "-- Int\n\ntheorem Int.n_sub_0 (n: Int): n - 0 = n := by\n  cases n <;> rfl\n\ntheorem Int.ge_0_NonNeg (n: Int): n \u2265 0 \u2194 Int.NonNeg n := by\n  simp [GE.ge, LE.le, Int.le]\n  simp [Int.n_sub_0]\n\ntheorem Int.mul_ge_0 (n m: Int): n \u2265 0 \u2192 m \u2265 0 \u2192 n * m \u2265 0 := by\n  rw [Int.ge_0_NonNeg, Int.ge_0_NonNeg, Int.ge_0_NonNeg]\n  intros hn hm;\n  cases hn; cases hm; constructor\n\ntheorem Int.mul_comm (n m: Int): n * m = m * n := by\n  sorry\n\n-- Nat\n\ntheorem Nat.lt_of_add_lt_add_right {a b c: Nat} (h: a + c < b + c):\n    a < b := by\n  sorry\n\ntheorem Nat.minus_plus_one {a: Nat} (h: a > 0):\n    a - 1 + 1 = a := by\n  sorry\n"}
{"text": "(*************************************************************)\n(*   Copyright Dominique Larchey-Wendling [*]                 *)\n(*             Yannick Forster            [+]                 *)\n(*                                                            *)\n(*                             [*] Affiliation LORIA -- CNRS  *)\n(*                             [+] Affiliation Saarland Univ. *)\n(*************************************************************)\n(*      This file is distributed under the terms of the       *)\n(*         CeCILL v2 FREE SOFTWARE LICENSE AGREEMENT          *)\n(*************************************************************)\n\nFrom Undecidability.Shared.Libs.DLW\n  Require Import utils_tac.\n\nRequire Import Undecidability.Synthetic.Undecidability.\nRequire Import Undecidability.Synthetic.ReducibilityFacts.\n\nFrom Undecidability.PCP              Require Import PCP PCP_undec.\nFrom Undecidability.StackMachines    Require Import BSM.\nFrom Undecidability.MinskyMachines   Require Import MM.\n\nFrom Undecidability.ILL \n  Require Import EILL ILL iBPCP_MM MM_EILL EILL_ILL.\n\nRequire Import Undecidability.PCP.Reductions.HaltTM_1_to_PCPb.\n\nImport ReductionChainNotations UndecidabilityNotations.\n\n(* The reduction chain from the CPP 2019, Y. Forster & D. Larchey-Wendling *)\n\nTheorem PCP_chain_ILL : \n  \u23a9 PCP \u2aaf\u2098 PCPb \u2aaf\u2098 iPCPb \u2aaf\u2098 BSM_HALTING \u2aaf\u2098 MM_HALTS_ON_ZERO \u2aaf\u2098 EILL_PROVABILITY \u2aaf\u2098 ILL_PROVABILITY \u23ad.\nProof.\n  msplit 5; ( apply PCP_chain_iPCPb || apply iBPCP_chain_MM || idtac).\n  + apply MM_HALTS_ON_ZERO_EILL_PROVABILITY.\n  + apply EILL_ILL_PROVABILITY.\nQed.\n\nCheck PCP_chain_ILL.\n\n(* Undecidability results *)\n\nLocal Hint Resolve EILL_rILL_cf_PROVABILITY \n                   EILL_rILL_PROVABILITY\n                   EILL_ILL_cf_PROVABILITY\n                 : core.\n\n(* EILL provability using G_eill *)\n\nTheorem EILL_undec : undecidable EILL_PROVABILITY.\nProof. undec from PCP_undec using chain PCP_chain_ILL. Qed.\n\n(* whole ILL with cut *)\n\nTheorem ILL_undec : undecidable ILL_PROVABILITY.\nProof. undec from PCP_undec using chain PCP_chain_ILL. Qed.\n\n(* whole ILL without cut *)\n\nTheorem ILL_cf_undec : undecidable ILL_cf_PROVABILITY.\nProof. undec from EILL_undec; auto. Qed.\n\n(* (!,&,-o) fragment of ILL without cut *)\n\nTheorem rILL_cf_undec : undecidable rILL_cf_PROVABILITY.\nProof. undec from EILL_undec; auto. Qed.\n\n(* (!,&,-o) fragment of ILL with cut *)\n\nTheorem rILL_undec : undecidable rILL_PROVABILITY.\nProof. undec from EILL_undec; auto. Qed.\n"}
{"text": "Require Import Coq.ZArith.ZArith.\nRequire Import Crypto.LegacyArithmetic.Interface.\nRequire Import Crypto.LegacyArithmetic.Double.Core.\nRequire Import Crypto.LegacyArithmetic.Double.Proofs.Decode.\nRequire Import Crypto.LegacyArithmetic.Double.Proofs.ShiftLeftRightTactic.\nRequire Import Crypto.Util.ZUtil.\n(*Require Import Crypto.Util.Tactics.*)\n\nLocal Open Scope Z_scope.\n\nLocal Opaque tuple_decoder.\nLocal Arguments Z.pow !_ !_.\nLocal Arguments Z.mul !_ !_.\n\nSection shr.\n  Context (n : Z) {W}\n          {ldi : load_immediate W}\n          {shl : shift_left_immediate W}\n          {shr : shift_right_immediate W}\n          {or : bitwise_or W}\n          {decode : decoder n W}\n          {isdecode : is_decode decode}\n          {isldi : is_load_immediate ldi}\n          {isshl : is_shift_left_immediate shl}\n          {isshr : is_shift_right_immediate shr}\n          {isor : is_bitwise_or or}.\n\n  Global Instance is_shift_right_immediate_double : is_shift_right_immediate (shr_double n).\n  Proof using Type*.\n    intros r count H; hnf in H.\n    assert (0 < 2^count) by auto with zarith.\n    assert (0 < 2^(n+count)) by auto with zarith.\n    assert (forall n', ~n' + count < n -> 2^n <= 2^(n'+count)) by auto with zarith omega.\n    assert (forall n', ~n' + count < n -> 2^n <= 2^(n'+count)) by auto with zarith omega.\n    unfold shr_double; simpl.\n    generalize (decode_range r).\n    pose proof (decode_range (fst r)).\n    pose proof (decode_range (snd r)).\n    assert (forall n', 2^n <= 2^n' -> 0 <= decode (fst r) < 2^n') by (simpl in *; auto with zarith).\n    assert (forall n', n <= n' -> 0 <= decode (fst r) < 2^n') by auto with zarith omega.\n    autorewrite with simpl_tuple_decoder; push_decode.\n    shift_left_right_t.\n  Qed.\nEnd shr.\n"}
{"text": "{-# OPTIONS --without-K --rewriting #-}\n\nopen import HoTT\n\nmodule homotopy.PathSetIsInitalCover {i} (X : Ptd i)\n    -- and an arbitrary covering\n    {k} (\u2299cov : \u2299Cover X k) where\n\n  open Cover\n\n  private\n    univ-cover = path-set-cover X\n    module \u2299cov = \u2299Cover \u2299cov\n\n  -- Weak initiality by transport.\n  quotient-cover : CoverHom univ-cover \u2299cov.cov\n  quotient-cover _ p = cover-trace \u2299cov.cov \u2299cov.pt p\n\n  -- Strong initiality by path induction.\n  module Uniqueness\n    (cover-hom : CoverHom univ-cover \u2299cov.cov)\n    (pres-pt : cover-hom (pt X) idp\u2080 == \u2299cov.pt)\n    where\n\n    private\n      lemma\u2081 : \u2200 a p \u2192 cover-hom a [ p ] == quotient-cover a [ p ]\n      lemma\u2081 ._ idp = pres-pt\n\n      lemma\u2082 : \u2200 a p \u2192 cover-hom a p == quotient-cover a p\n      lemma\u2082 a = Trunc-elim\n        (\u03bb p \u2192 =-preserves-set (\u2299cov.Fiber-level a))\n        (lemma\u2081 a)\n\n    theorem : cover-hom == quotient-cover\n    theorem = \u03bb= \u03bb a \u2192 \u03bb= $ lemma\u2082 a\n"}
{"text": "\ntheorem Ex006(a b c : Prop): a \u2228 b \u2192 a \u2228 c \u2192 a \u2228 (b \u2227 c) :=\nassume H1:a \u2228 b,\n  assume H2:a \u2228 c,\n  show a \u2228 (b \u2227 c), from or.elim H1 \n    ( \n      assume H :a,\n      show a \u2228 (b \u2227 c), from or.inl H\n    )\n    (\n      assume H: b,\n      show a \u2228 (b \u2227 c), from or.elim H2 \n        (\n          assume HH:a,\n          show a \u2228 (b \u2227 c), from or.inl HH\n        )\n        (\n          assume HH:c,\n          have H3:b \u2227 c, from and.intro H HH,\n          show a \u2228 (b \u2227 c), from or.inr H3\n        )\n    ) \n"}
{"text": "import data.real.basic\nimport game.Completeness.level04\nimport game.Completeness.level02\n\n\nnoncomputable theory\nopen_locale classical\n\ndefinition has_lub (S : set \u211d) := \u2203 x, is_lub S x\n\n--sup(S) - \u03b5 < s < sup(S)\n\n--lemma thinklater (S : set \u211d) (x y \u03b5 : \u211d) (H : has_lub S) (S \u2260 \u2205) (hy : is_sup S y) : \n  --\u2200 \u03b5 > 0, \u2203 x \u2208 S, is_sup S y - \u03b5 < x \u2227 x \u2264 is_sup S y :=\n\nlemma do_now {x : \u211d} {S : set \u211d} (h : S \u2260 \u2205) (Hsup : is_sup S x)  : (\u2200 \u03b5 > 0, \u2203 s \u2208 S, x-\u03b5<s \u2227 s \u2264 x) := \nbegin\n    \n\n    rw is_sup at Hsup, \n    cases Hsup with a ha, \n    rw upper_bound at a,    \n\n    intro \u03b5, intro h, \n    use x, split, swap, \n\n    split, \n    linarith, linarith,\n    \n\n    \n\n\n\n     -- rewrite this level cause I am pretty sure it is written incorrectly \n  \nend\n"}
{"text": "theorem ex1 (p : Prop) (h1 : p) (h2 : p \u2192 False) : \u03b1 := by\n  contradiction\n\ntheorem ex2 (p : Prop) (h1 : p) (h2 : \u00ac p) : \u03b1 := by\n  contradiction\n\ntheorem ex3 (p : Prop) (h1 : id p) (h2 : \u00ac p) : \u03b1 := by\n  contradiction\n\ntheorem ex4 (p : Prop) (h1 : id p) (h2 : id (Not p)) : \u03b1 := by\n  contradiction\n\ntheorem ex5 (h : x+1 = 0) : \u03b1 := by\n  contradiction\n\ntheorem ex6 (h : 0+0 \u2260 0) : \u03b1 := by\n  contradiction\n\ntheorem ex7 (x : \u03b1) (h : Not (x = x)) : \u03b1 := by\n  contradiction\n\ntheorem ex8 (h : 0+0 = 0 \u2192 False) : \u03b1 := by\n  contradiction\n\ntheorem ex9 (h : 10 = 20) : \u03b1 := by\n  contradiction\n\ntheorem ex10 (h : [] = [1, 2, 3]) : \u03b1 := by\n  contradiction\n\ntheorem ex11 (h : id [] = [1, 2, 3]) : \u03b1 := by\n  contradiction\n\ntheorem ex12 (h : False) : \u03b1 := by\n  contradiction\n\ntheorem ex13 (h : id False) : \u03b1 := by\n  contradiction\n\ntheorem ex14 (h : 100000000 \u2264 20) : \u03b1 := by\n  contradiction\n\ntheorem ex15 (x : \u03b1) (h : x = x \u2192 False) : \u03b1 := by\n  contradiction\n\ntheorem ex16 (xs : List \u03b1) (h : xs = [] \u2192 False) : Nonempty \u03b1 := by\n  cases xs using List.rec with\n  | nil      => contradiction\n  | cons x _ => apply Nonempty.intro; assumption\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_109\n  (a b : \u211d)\n  (h\u2080 : 3 * a + 2 * b = 12)\n  (h\u2081 : a = 4) :\n  b = 0 :=\nbegin\n  linarith,\nend"}
{"text": "corollary fps_coeff_residues_bigo: fixes f :: \"complex \\<Rightarrow> complex\" and r :: real assumes \"open A\" \"connected A\" \"cball 0 r \\<subseteq> A\" \"r > 0\" assumes \"f holomorphic_on A - S\" \"S \\<subseteq> ball 0 r\" \"finite S\" \"0 \\<notin> S\" assumes g: \"eventually (\\<lambda>n. g n = -(\\<Sum>z\\<in>S. residue (\\<lambda>z. f z / z ^ Suc n) z)) sequentially\" (is \"eventually (\\<lambda>n. _ = -?g' n) _\") shows \"(\\<lambda>n. (deriv ^^ n) f 0 / fact n - g n) \\<in> O(\\<lambda>n. 1 / r ^ n)\" (is \"(\\<lambda>n. ?c n - _) \\<in> O(_)\")"}
{"text": "lemma of_real_add [simp]: \"of_real (x + y) = of_real x + of_real y\""}
{"text": "[STATEMENT]\nlemma of_hypnat_0 [simp]: \"of_hypnat 0 = 0\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. of_hypnat 0 = 0\n[PROOF STEP]\nby transfer (rule of_nat_0)"}
{"text": "import data.nat.modeq\n\n/-\n(a) Find r with 0 \u2264 r \u2264 10 such that 7^137 \u2261 r mod 11.\n(b) Find r with 0 \u2264 r < 645 such that 2^81 \u2261 r mod 645.\n(c) Find the last two digits of 3^124 (when expressed in decimal notation).\n(d) Show that there is a multiple of 21 which has 241 as its last three digits.\n-/\n\nlemma part_a : \u2203r : \u2115, 0 \u2264 r \u2227 r \u2264 10 \u2227 7^137 \u2261 r [MOD 11] :=\nbegin\n  use 6,\n  unfold nat.modeq,\n  norm_num,\nend\n\nlemma part_b : \u2203r : \u2115, 0 \u2264 r \u2227 r < 645 \u2227 2^81 \u2261 r [MOD 645] :=\nbegin\n  use 242,\n  unfold nat.modeq,\n  norm_num,\nend\n\n-- Once you compute the last two digits, change 37 below to them.\nlemma part_c : 3^124 \u2261 81 [MOD 100] :=\nbegin\n  unfold nat.modeq,\n  norm_num,\nend\n\nlemma part_d : \u2203k : \u2115, 21 \u2223 k \u2227 k \u2261 241 [MOD 1000] :=\nbegin\n  unfold nat.modeq,\n  use 17241,\n  split,\n  {norm_num, },\n  {norm_num, },\nend"}
{"text": "import MyNat.Definition\nimport MultiplicationWorld.Level6 -- succ_mul\nimport MyNat.Multiplication -- mul_succ, mul_zero\nimport AdvancedMultiplicationWorld.Level2 -- eq_zero_or_eq_zero_of_mul_eq_zero\nnamespace MyNat\nopen MyNat\n\n/-!\n# Advanced Multiplication World\n\n## Level 4: `mul_left_cancel`\n\nThis is the last of the bonus multiplication levels. `mul_left_cancel` will be useful in inequality\nworld.\n\nPeople find this level hard. I have probably had more questions about this level than all the other\nlevels put together, in fact. Many levels in this game can just be solved by \"running at it\" -- do\ninduction on one of the variables, keep your head, and you're done. In fact, if you like a\nchallenge, it might be instructive if you stop reading after the end of this paragraph and try\nsolving this level now by induction, seeing the trouble you run into, and reading the rest of these\ncomments afterwards. This level has a sting in the tail. If you are a competent mathematician, try\nand figure out what is going on. Write down a maths proof of the theorem in this level. Exactly what\nstatement do you want to prove by induction? It is subtle.\n\nOk so here are some spoilers. The problem with naively running at it, is that if you try induction\non, say, `c`, then you are imagining `a` and `b` as fixed, and your inductive hypothesis `P(c)` is\n`ab=ac \u27f9 b=c`. So for your inductive step you will be able to assume `ab=ad \u27f9 b=d` and your goal\nwill be to show `ab=a(d+1) \u27f9 b=d+1`. When you also assume `ab=a(d+1)` you will realize that your\ninductive hypothesis is *useless*, because `ab=ad` is not true! The statement `P(c)` (with `a` and\n`b` regarded as constants) is not provable by induction.\n\nWhat you *can* prove by induction is the following *stronger* statement. Imagine `a \u2260 0` as fixed,\nand then prove \"for all `b`, if `ab=ac` then `b=c`\" by induction on `c`. This gives us the extra\nflexibility we require. Note that we are quantifying over all `b` in the inductive hypothesis -- it\nis essential that `b` is not fixed.\n\nYou can do this in two ways in Lean -- before you start the induction you can write `revert b`. The\n`revert` tactic is the opposite of the `intro` tactic; it replaces the `b` in the hypotheses with\n\"for all `b`\" in the goal.\n\nAlternatively, you can write `induction c generalizing b with` as the first line of the proof.\n\nIf you do not modify your technique in this way, then this level seems\nto be impossible (judging by the comments I've had about it!)\n\n## Theorem\nIf `a \u2260 0`, `b` and `c` are natural numbers such that ` ab = ac, ` then `b = c`.\n-/\n\nset_option trace.Meta.Tactic.simp true\ntheorem mul_left_cancel (a b c : MyNat) (ha : a \u2260 0) : a * b = a * c \u2192 b = c := by\n  induction c generalizing b with\n  | zero =>\n    rw [zero_is_0]\n    rw [mul_zero]\n    intro h\n    cases (eq_zero_or_eq_zero_of_mul_eq_zero _ _ h) with\n    | inl h1 =>\n      exfalso\n      apply ha\n      assumption\n    | inr h2 =>\n      assumption\n  | succ d hd =>\n    intro hb\n    cases b with\n    | zero =>\n      rw [zero_is_0] at hb\n      rw [mul_zero] at hb\n      rw [zero_is_0]\n      exfalso\n      apply ha\n      have hb := hb.symm\n      cases (eq_zero_or_eq_zero_of_mul_eq_zero _ _ hb) with\n      | inl h =>\n        exact h\n      | inr h =>\n        exfalso\n        exact succ_ne_zero _ h\n    | succ c =>\n      have h := c = d\n      apply hd\n      rw [mul_succ] at hb\n      rw [mul_succ] at hb\n      apply add_right_cancel _ _ _ hb\n      rw [h]\n\n/-!\nYou should now be ready for [Inequality World](../InequalityWorld.lean.md).\n\n\n-/\n"}
{"text": "/-\nCopyright (c) 2021 Heather Macbeth. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Heather Macbeth\n-/\n\nimport measure_theory.measure.regular\nimport measure_theory.function.simple_func_dense\nimport topology.urysohns_lemma\n\n/-!\n# Approximation in L\u1d56 by continuous functions\n\nThis file proves that bounded continuous functions are dense in `Lp E p \u03bc`, for `1 \u2264 p < \u221e`, if the\ndomain `\u03b1` of the functions is a normal topological space and the measure `\u03bc` is weakly regular.\n\nThe result is presented in several versions:\n* `measure_theory.Lp.bounded_continuous_function_dense`: The subgroup\n  `measure_theory.Lp.bounded_continuous_function` of `Lp E p \u03bc`, the additive subgroup of\n  `Lp E p \u03bc` consisting of equivalence classes containing a continuous representative, is dense in\n  `Lp E p \u03bc`.\n* `bounded_continuous_function.to_Lp_dense_range`: For finite-measure `\u03bc`, the continuous linear\n  map `bounded_continuous_function.to_Lp p \u03bc \ud835\udd5c` from `\u03b1 \u2192\u1d47 E` to `Lp E p \u03bc` has dense range.\n* `continuous_map.to_Lp_dense_range`: For compact `\u03b1` and finite-measure `\u03bc`, the continuous linear\n  map `continuous_map.to_Lp p \u03bc \ud835\udd5c` from `C(\u03b1, E)` to `Lp E p \u03bc` has dense range.\n\nNote that for `p = \u221e` this result is not true:  the characteristic function of the set `[0, \u221e)` in\n`\u211d` cannot be continuously approximated in `L\u221e`.\n\nThe proof is in three steps.  First, since simple functions are dense in `Lp`, it suffices to prove\nthe result for a scalar multiple of a characteristic function of a measurable set `s`. Secondly,\nsince the measure `\u03bc` is weakly regular, the set `s` can be approximated above by an open set and\nbelow by a closed set.  Finally, since the domain `\u03b1` is normal, we use Urysohn's lemma to find a\ncontinuous function interpolating between these two sets.\n\n## Related results\n\nAre you looking for a result on \"directional\" approximation (above or below with respect to an\norder) of functions whose codomain is `\u211d\u22650\u221e` or `\u211d`, by semicontinuous functions?  See the\nVitali-Carath\u00e9odory theorem, in the file `measure_theory.vitali_caratheodory`.\n\n-/\n\nopen_locale ennreal nnreal topological_space bounded_continuous_function\nopen measure_theory topological_space continuous_map\n\nvariables {\u03b1 : Type*} [measurable_space \u03b1] [topological_space \u03b1] [normal_space \u03b1] [borel_space \u03b1]\nvariables (E : Type*) [measurable_space E] [normed_group E] [borel_space E]\n  [second_countable_topology E]\nvariables {p : \u211d\u22650\u221e} [_i : fact (1 \u2264 p)] (hp : p \u2260 \u221e) (\u03bc : measure \u03b1)\n\ninclude _i hp\n\nnamespace measure_theory.Lp\n\nvariables [normed_space \u211d E]\n\n/-- A function in `Lp` can be approximated in `Lp` by continuous functions. -/\nlemma bounded_continuous_function_dense [\u03bc.weakly_regular] :\n  (bounded_continuous_function E p \u03bc).topological_closure = \u22a4 :=\nbegin\n  have hp\u2080 : 0 < p := lt_of_lt_of_le ennreal.zero_lt_one _i.elim,\n  have hp\u2080' : 0 \u2264 1 / p.to_real := div_nonneg zero_le_one ennreal.to_real_nonneg,\n  have hp\u2080'' : 0 < p.to_real,\n  { simpa [\u2190 ennreal.to_real_lt_to_real ennreal.zero_ne_top hp] using hp\u2080 },\n  -- It suffices to prove that scalar multiples of the indicator function of a finite-measure\n  -- measurable set can be approximated by continuous functions\n  suffices :  \u2200 (c : E) {s : set \u03b1} (hs : measurable_set s) (h\u03bcs : \u03bc s < \u22a4),\n    (Lp.simple_func.indicator_const p hs h\u03bcs.ne c : Lp E p \u03bc)\n      \u2208 (bounded_continuous_function E p \u03bc).topological_closure,\n  { rw add_subgroup.eq_top_iff',\n    refine Lp.induction hp _ _ _ _,\n    { exact this },\n    { exact \u03bb f g hf hg hfg', add_subgroup.add_mem _ },\n    { exact add_subgroup.is_closed_topological_closure _ } },\n  -- Let `s` be a finite-measure measurable set, let's approximate `c` times its indicator function\n  intros c s hs hs\u03bc,\n  refine mem_closure_iff_frequently.mpr _,\n  rw metric.nhds_basis_closed_ball.frequently_iff,\n  intros \u03b5 h\u03b5,\n  -- A little bit of pre-emptive work, to find `\u03b7 : \u211d\u22650` which will be a margin small enough for\n  -- our purposes\n  obtain \u27e8\u03b7, h\u03b7_pos, h\u03b7_le\u27e9 : \u2203 \u03b7, 0 < \u03b7 \u2227 (\u2191(\u2225bit0 (\u2225c\u2225)\u2225\u208a * (2 * \u03b7) ^ (1 / p.to_real)) : \u211d) \u2264 \u03b5,\n  { have : filter.tendsto (\u03bb x : \u211d\u22650, \u2225bit0 (\u2225c\u2225)\u2225\u208a * (2 * x) ^ (1 / p.to_real)) (\ud835\udcdd 0) (\ud835\udcdd 0),\n    { have : filter.tendsto (\u03bb x : \u211d\u22650, 2 * x) (\ud835\udcdd 0) (\ud835\udcdd (2 * 0)) := filter.tendsto_id.const_mul 2,\n      convert ((nnreal.continuous_at_rpow_const (or.inr hp\u2080')).tendsto.comp this).const_mul _,\n      simp [hp\u2080''.ne'] },\n    let \u03b5' : \u211d\u22650 := \u27e8\u03b5, h\u03b5.le\u27e9,\n    have h\u03b5' : 0 < \u03b5' := by exact_mod_cast h\u03b5,\n    obtain \u27e8\u03b4, h\u03b4, h\u03b4\u03b5'\u27e9 :=\n      nnreal.nhds_zero_basis.eventually_iff.mp (eventually_le_of_tendsto_lt h\u03b5' this),\n    obtain \u27e8\u03b7, h\u03b7, h\u03b7\u03b4\u27e9 := exists_between h\u03b4,\n    refine \u27e8\u03b7, h\u03b7, _\u27e9,\n    exact_mod_cast h\u03b4\u03b5' h\u03b7\u03b4 },\n  have h\u03b7_pos' : (0 : \u211d\u22650\u221e) < \u03b7 := ennreal.coe_pos.2 h\u03b7_pos,\n  -- Use the regularity of the measure to `\u03b7`-approximate `s` by an open superset and a closed\n  -- subset\n  obtain \u27e8u, su, u_open, \u03bcu\u27e9 : \u2203 u \u2287 s, is_open u \u2227 \u03bc u < \u03bc s + \u2191\u03b7,\n  { refine s.exists_is_open_lt_of_lt _ _,\n    simpa using ennreal.add_lt_add_left hs\u03bc.ne h\u03b7_pos' },\n  obtain \u27e8F, Fs, F_closed, \u03bcF\u27e9 : \u2203 F \u2286 s, is_closed F \u2227 \u03bc s < \u03bc F + \u2191\u03b7 :=\n    hs.exists_is_closed_lt_add hs\u03bc.ne h\u03b7_pos'.ne',\n  have : disjoint u\u1d9c F,\n  { rw [set.disjoint_iff_inter_eq_empty, set.inter_comm, \u2190 set.subset_compl_iff_disjoint],\n    simpa using Fs.trans su },\n  have h_\u03bc_sdiff : \u03bc (u \\ F) \u2264 2 * \u03b7,\n  { have hF\u03bc : \u03bc F < \u22a4 := (measure_mono Fs).trans_lt hs\u03bc,\n    refine ennreal.le_of_add_le_add_left hF\u03bc.ne _,\n    have : \u03bc u < \u03bc F + \u2191\u03b7 + \u2191\u03b7,\n      from \u03bcu.trans (ennreal.add_lt_add_right ennreal.coe_ne_top \u03bcF),\n    convert this.le using 1,\n    { rw [add_comm, \u2190 measure_union, set.diff_union_of_subset (Fs.trans su)],\n      { exact disjoint_sdiff_self_left },\n      { exact (u_open.sdiff F_closed).measurable_set },\n      { exact F_closed.measurable_set } },\n    have : (2:\u211d\u22650\u221e) * \u03b7 = \u03b7 + \u03b7 := by simpa using add_mul (1:\u211d\u22650\u221e) 1 \u03b7,\n    rw this,\n    abel },\n  -- Apply Urysohn's lemma to get a continuous approximation to the characteristic function of\n  -- the set `s`\n  obtain \u27e8g, hgu, hgF, hg_range\u27e9 :=\n    exists_continuous_zero_one_of_closed u_open.is_closed_compl F_closed this,\n  -- Multiply this by `c` to get a continuous approximation to the function `f`; the key point is\n  -- that this is pointwise bounded by the indicator of the set `u \\ F`\n  have g_norm : \u2200 x, \u2225g x\u2225 = g x := \u03bb x, by rw [real.norm_eq_abs, abs_of_nonneg (hg_range x).1],\n  have gc_bd : \u2200 x, \u2225g x \u2022 c - s.indicator (\u03bb x, c) x\u2225 \u2264 \u2225(u \\ F).indicator (\u03bb x, bit0 \u2225c\u2225) x\u2225,\n  { intros x,\n    by_cases hu : x \u2208 u,\n    { rw \u2190 set.diff_union_of_subset (Fs.trans su) at hu,\n      cases hu with hFu hF,\n      { refine (norm_sub_le _ _).trans _,\n        refine (add_le_add_left (norm_indicator_le_norm_self (\u03bb x, c) x) _).trans _,\n        have h\u2080 : g x * \u2225c\u2225 + \u2225c\u2225 \u2264 2 * \u2225c\u2225,\n        { nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c] },\n        have h\u2081 : (2:\u211d) * \u2225c\u2225 = bit0 (\u2225c\u2225) := by simpa using add_mul (1:\u211d) 1 (\u2225c\u2225),\n        simp [hFu, norm_smul, h\u2080, \u2190 h\u2081, g_norm x] },\n      { simp [hgF hF, Fs hF] } },\n    { have : x \u2209 s := \u03bb h, hu (su h),\n      simp [hgu hu, this] } },\n  -- The rest is basically just `ennreal`-arithmetic\n  have gc_snorm : snorm ((\u03bb x, g x \u2022 c) - s.indicator (\u03bb x, c)) p \u03bc\n    \u2264 (\u2191(\u2225bit0 (\u2225c\u2225)\u2225\u208a * (2 * \u03b7) ^ (1 / p.to_real)) : \u211d\u22650\u221e),\n  { refine (snorm_mono_ae (filter.eventually_of_forall gc_bd)).trans _,\n    rw snorm_indicator_const (u_open.sdiff F_closed).measurable_set hp\u2080.ne' hp,\n    push_cast [\u2190 ennreal.coe_rpow_of_nonneg _ hp\u2080'],\n    exact ennreal.mul_left_mono (ennreal.rpow_left_monotone_of_nonneg hp\u2080' h_\u03bc_sdiff) },\n  have gc_cont : continuous (\u03bb x, g x \u2022 c) := g.continuous.smul continuous_const,\n  have gc_mem_\u2112p : mem_\u2112p (\u03bb x, g x \u2022 c) p \u03bc,\n  { have : mem_\u2112p ((\u03bb x, g x \u2022 c) - s.indicator (\u03bb x, c)) p \u03bc :=\n    \u27e8(gc_cont.ae_measurable \u03bc).sub (measurable_const.indicator hs).ae_measurable,\n      gc_snorm.trans_lt ennreal.coe_lt_top\u27e9,\n    simpa using this.add (mem_\u2112p_indicator_const p hs c (or.inr hs\u03bc.ne)) },\n  refine \u27e8gc_mem_\u2112p.to_Lp _, _, _\u27e9,\n  { rw mem_closed_ball_iff_norm,\n    refine le_trans _ h\u03b7_le,\n    rw [simple_func.coe_indicator_const, indicator_const_Lp, \u2190 mem_\u2112p.to_Lp_sub, Lp.norm_to_Lp],\n    exact ennreal.to_real_le_coe_of_le_coe gc_snorm },\n  { rw [set_like.mem_coe, mem_bounded_continuous_function_iff],\n    refine \u27e8bounded_continuous_function.of_normed_group _ gc_cont (\u2225c\u2225) _, rfl\u27e9,\n    intros x,\n    have h\u2080 : g x * \u2225c\u2225 \u2264 \u2225c\u2225,\n    { nlinarith [(hg_range x).1, (hg_range x).2, norm_nonneg c] },\n    simp [norm_smul, g_norm x, h\u2080] },\nend\n\nend measure_theory.Lp\n\nvariables (\ud835\udd5c : Type*) [measurable_space \ud835\udd5c] [normed_field \ud835\udd5c] [opens_measurable_space \ud835\udd5c]\n  [normed_algebra \u211d \ud835\udd5c] [normed_space \ud835\udd5c E]\n\nnamespace bounded_continuous_function\n\nlemma to_Lp_dense_range [\u03bc.weakly_regular] [is_finite_measure \u03bc] :\n  dense_range \u21d1(to_Lp p \u03bc \ud835\udd5c : (\u03b1 \u2192\u1d47 E) \u2192L[\ud835\udd5c] Lp E p \u03bc) :=\nbegin\n  haveI : normed_space \u211d E := restrict_scalars.normed_space \u211d \ud835\udd5c E,\n  rw dense_range_iff_closure_range,\n  suffices : (to_Lp p \u03bc \ud835\udd5c : _ \u2192L[\ud835\udd5c] Lp E p \u03bc).range.to_add_subgroup.topological_closure = \u22a4,\n  { exact congr_arg coe this },\n  simp [range_to_Lp p \u03bc, measure_theory.Lp.bounded_continuous_function_dense E hp],\nend\n\nend bounded_continuous_function\n\nnamespace continuous_map\n\nlemma to_Lp_dense_range [compact_space \u03b1] [\u03bc.weakly_regular] [is_finite_measure \u03bc] :\n  dense_range \u21d1(to_Lp p \u03bc \ud835\udd5c : C(\u03b1, E) \u2192L[\ud835\udd5c] Lp E p \u03bc) :=\nbegin\n  haveI : normed_space \u211d E := restrict_scalars.normed_space \u211d \ud835\udd5c E,\n  rw dense_range_iff_closure_range,\n  suffices : (to_Lp p \u03bc \ud835\udd5c : _ \u2192L[\ud835\udd5c] Lp E p \u03bc).range.to_add_subgroup.topological_closure = \u22a4,\n  { exact congr_arg coe this },\n  simp [range_to_Lp p \u03bc, measure_theory.Lp.bounded_continuous_function_dense E hp]\nend\n\nend continuous_map\n"}
{"text": "import topology.basic\nimport data.real.nnreal\nimport data.real.basic\n\nopen set\n\ntheorem open_set_for_each \n  (X : Type*)\n  [topological_space X]\n  (A : set X) \n  (h\u2080 : \u2200 x \u2208 A, \u2203 (U : set X), is_open U \u2227 x \u2208 U \u2227 U \u2286 A) : \n  is_open A :=\nbegin\n  choose! f hf using h\u2080,\n  have : A = \u22c3 x \u2208 A, f x,\n  {\n    ext p,\n    split, \n    {\n      intro hp,\n      have hfp := hf p hp,\n      rw mem_Union\u2082,\n      use p,\n      exact \u27e8 hp, hfp.2.1 \u27e9,\n    },\n    {\n      intro hp,\n      rw mem_Union\u2082 at hp,\n      cases hp with i hi,\n      cases hi with hia hpfi,\n      have x := hf i hia,\n      exact x.2.2 hpfi,\n    }\n  },\n  rw this,\n  apply is_open_bUnion,\n  intros i hi,\n  exact (hf i hi).1,\nend \n\n\n\ndef intersection_of_topologies {X : Type*} {\u03b9 : Sort*}\n  (f : \u03b9 \u2192 topological_space X) : topological_space X :=\n{ is_open := \u03bb s, \u2200 i, (f i).is_open s,\n  is_open_univ := \n  begin\n    sorry\n  end,\n  is_open_inter := \n  begin\n    intros s t hos hot i,\n    specialize hos i,\n    specialize hot i,\n    exact (f i).is_open_inter s t hos hot,\n  end,\n  is_open_sUnion := sorry }"}
{"text": "/-\nCopyright 2020 Google LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n      http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n -/\nimport measure_theory.measurable_space\n\nimport measure_theory.measure_space\nimport measure_theory.outer_measure\nimport measure_theory.lebesgue_measure\nimport measure_theory.integration\nimport measure_theory.set_integral\nimport measure_theory.borel_space\nimport data.set.countable\nimport formal_ml.nnreal\nimport formal_ml.sum\nimport formal_ml.core\nimport formal_ml.measurable_space\nimport formal_ml.semiring\nimport formal_ml.real_measurable_space\nimport formal_ml.set\nimport formal_ml.filter_util\nimport topology.instances.ennreal\nimport formal_ml.int\nimport formal_ml.with_density_compose_eq_multiply\nimport formal_ml.classical\n\n\nlemma with_density_le_with_density {\u03a9:Type*} {M:measurable_space \u03a9}\n  {\u03bc:measure_theory.measure \u03a9} {x y:\u03a9 \u2192 ennreal} \n  {S:set \u03a9}:\n  measurable_set S \u2192\n  (\u2200 \u03c9 \u2208 S, x \u03c9 \u2264 y \u03c9) \u2192  \n  \u03bc.with_density x S \u2264 \u03bc.with_density y S :=\nbegin\n  intros A3 A4,\n  rw measure_theory.with_density_apply2' \u03bc x S A3,\n  rw measure_theory.with_density_apply2' \u03bc y S A3,\n  apply measure_theory.lintegral_mono,\n\n  rw le_func_def2,\n  intros \u03c9,\n  cases (classical.em (\u03c9 \u2208 S)) with A5 A5,\n  {\n    rw set.indicator_of_mem A5,\n    rw set.indicator_of_mem A5,\n    apply A4 _ A5,\n  },\n  {\n    rw set.indicator_of_not_mem A5,\n    rw set.indicator_of_not_mem A5,\n    apply le_refl _,\n  },\nend\n\n\n--TODO: Remove measurability?\nlemma with_density_sup_of_le {\u03a9:Type*} {M:measurable_space \u03a9}\n  {\u03bc:measure_theory.measure \u03a9} {x y:\u03a9 \u2192 ennreal} \n  {S:set \u03a9}:measurable x \u2192 measurable y \u2192\n  measurable_set S \u2192\n  (\u2200 \u03c9 \u2208 S, x \u03c9 \u2264 y \u03c9) \u2192  \n  \u03bc.with_density (x\u2294y) S = \u03bc.with_density y S :=\nbegin\n  intros A1 A2 A3 A4,\n  rw measure_theory.with_density_apply2' \u03bc (x \u2294 y) S A3,\n  rw measure_theory.with_density_apply2' \u03bc y S A3,\n  have A5:set.indicator S (x \u2294 y) = set.indicator S y,\n  {\n    apply funext,\n    intro \u03c9,\n    cases (classical.em (\u03c9\u2208 S)) with A5A A5A,\n    {\n      rw set.indicator_of_mem A5A,\n      rw set.indicator_of_mem A5A,\n      rw sup_apply,\n      simp [A4 _ A5A],\n    },\n    {\n      rw set.indicator_of_not_mem A5A,\n      rw set.indicator_of_not_mem A5A,\n    },\n  },\n  rw A5,\nend\n\n\nlemma measure_theory.measure.sup_le_apply {\u03a9:Type*}\n  {M:measurable_space \u03a9}\n  {\u03bc \u03bd m:measure_theory.measure \u03a9}\n  {S:set \u03a9}:measurable_set S \u2192\n  (\u03bc \u2264 m) \u2192\n  (\u03bd \u2264 m) \u2192 \n  (\u03bc \u2294 \u03bd) S \u2264 m S :=\nbegin\n  intros A1 A2 A3,\n  have A4:\u03bc \u2294 \u03bd \u2264 m := \n      @sup_le (measure_theory.measure \u03a9) _ \u03bc \u03bd m A2 A3,\n  apply A4,\n  apply A1,\nend\n"}
{"text": "[STATEMENT]\nlemma dbproj_Cons:\n  \"dbproj i ((i,d)#D) = (i,d)#dbproj i D\"\n  \"i \\<noteq> j \\<Longrightarrow> dbproj j ((i,d)#D) = dbproj j D\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. dbproj i ((i, d) # D) = (i, d) # dbproj i D &&& (i \\<noteq> j \\<Longrightarrow> dbproj j ((i, d) # D) = dbproj j D)\n[PROOF STEP]\nunfolding dbproj_def\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. filter (\\<lambda>d. fst d = i) ((i, d) # D) = (i, d) # filter (\\<lambda>d. fst d = i) D &&& (i \\<noteq> j \\<Longrightarrow> filter (\\<lambda>d. fst d = j) ((i, d) # D) = filter (\\<lambda>d. fst d = j) D)\n[PROOF STEP]\nby auto"}
{"text": "/-\nCopyright (c) 2015 Jeremy Avigad. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Jeremy Avigad, Robert Y. Lewis\n-/\nimport algebra.group_power.basic\nimport algebra.invertible\nimport algebra.opposites\nimport data.list.basic\nimport data.int.cast\nimport data.equiv.basic\nimport data.equiv.mul_add\nimport deprecated.group\n\n/-!\n# Lemmas about power operations on monoids and groups\n\nThis file contains lemmas about `monoid.pow`, `group.pow`, `nsmul`, `gsmul`\nwhich require additional imports besides those available in `.basic`.\n-/\n\nuniverses u v w x y z u\u2081 u\u2082\n\nvariables {M : Type u} {N : Type v} {G : Type w} {H : Type x} {A : Type y} {B : Type z}\n  {R : Type u\u2081} {S : Type u\u2082}\n\n/-!\n### (Additive) monoid\n-/\nsection monoid\nvariables [monoid M] [monoid N] [add_monoid A] [add_monoid B]\n\n@[simp] theorem nsmul_one [has_one A] : \u2200 n : \u2115, n \u2022 (1 : A) = n :=\nadd_monoid_hom.eq_nat_cast\n  \u27e8\u03bb n, n \u2022 (1 : A), zero_nsmul _, \u03bb _ _, add_nsmul _ _ _\u27e9\n  (one_nsmul _)\n\n@[simp, priority 500]\ntheorem list.prod_repeat (a : M) (n : \u2115) : (list.repeat a n).prod = a ^ n :=\nbegin\n  induction n with n ih,\n  { rw pow_zero, refl },\n  { rw [list.repeat_succ, list.prod_cons, ih, pow_succ] }\nend\n\n@[simp, priority 500]\ntheorem list.sum_repeat : \u2200 (a : A) (n : \u2115), (list.repeat a n).sum = n \u2022 a :=\n@list.prod_repeat (multiplicative A) _\n\n@[simp, norm_cast] lemma units.coe_pow (u : units M) (n : \u2115) : ((u ^ n : units M) : M) = u ^ n :=\n(units.coe_hom M).map_pow u n\n\ninstance invertible_pow (m : M) [invertible m] (n : \u2115) : invertible (m ^ n) :=\n{ inv_of := \u215f m ^ n,\n  inv_of_mul_self := by rw [\u2190 (commute_inv_of m).symm.mul_pow, inv_of_mul_self, one_pow],\n  mul_inv_of_self := by rw [\u2190 (commute_inv_of m).mul_pow, mul_inv_of_self, one_pow] }\n\nlemma inv_of_pow (m : M) [invertible m] (n : \u2115) [invertible (m ^ n)] :\n  \u215f(m ^ n) = \u215fm ^ n :=\n@invertible_unique M _ (m ^ n) (m ^ n) rfl \u2039_\u203a (invertible_pow m n)\n\nlemma is_unit.pow {m : M} (n : \u2115) : is_unit m \u2192 is_unit (m ^ n) :=\n\u03bb \u27e8u, hu\u27e9, \u27e8u ^ n, by simp *\u27e9\n\n/-- If `x ^ n.succ = 1` then `x` has an inverse, `x^n`. -/\ndef invertible_of_pow_succ_eq_one (x : M) (n : \u2115) (hx : x ^ n.succ = 1) :\n  invertible x :=\n\u27e8x ^ n, (pow_succ' x n).symm.trans hx, (pow_succ x n).symm.trans hx\u27e9\n\n/-- If `x ^ n = 1` then `x` has an inverse, `x^(n - 1)`. -/\ndef invertible_of_pow_eq_one (x : M) (n : \u2115) (hx : x ^ n = 1) (hn : 0 < n) :\n  invertible x :=\nbegin\n  apply invertible_of_pow_succ_eq_one x (n - 1),\n  convert hx,\n  exact nat.sub_add_cancel (nat.succ_le_of_lt hn),\nend\n\nlemma is_unit_of_pow_eq_one (x : M) (n : \u2115) (hx : x ^ n = 1) (hn : 0 < n) :\n  is_unit x :=\nbegin\n  haveI := invertible_of_pow_eq_one x n hx hn,\n  exact is_unit_of_invertible x\nend\n\nend monoid\n\ntheorem nat.nsmul_eq_mul (m n : \u2115) : m \u2022 n = m * n :=\nby induction m with m ih; [rw [zero_nsmul, zero_mul],\n  rw [succ_nsmul', ih, nat.succ_mul]]\n\nsection group\nvariables [group G] [group H] [add_group A] [add_group B]\n\nopen int\n\nlocal attribute [ematch] le_of_lt\nopen nat\n\ntheorem gsmul_one [has_one A] (n : \u2124) : n \u2022 (1 : A) = n :=\nby cases n; simp\n\nlemma gpow_add_one (a : G) : \u2200 n : \u2124, a ^ (n + 1) = a ^ n * a\n| (of_nat n) := by simp [\u2190 int.coe_nat_succ, pow_succ']\n| -[1+0]     := by simp [int.neg_succ_of_nat_eq]\n| -[1+(n+1)] := by rw [int.neg_succ_of_nat_eq, gpow_neg, neg_add, neg_add_cancel_right, gpow_neg,\n  \u2190 int.coe_nat_succ, gpow_coe_nat, gpow_coe_nat, pow_succ _ (n + 1), mul_inv_rev,\n  inv_mul_cancel_right]\n\ntheorem add_one_gsmul : \u2200 (a : A) (i : \u2124), (i + 1) \u2022 a = i \u2022 a + a :=\n@gpow_add_one (multiplicative A) _\n\nlemma gpow_sub_one (a : G) (n : \u2124) : a ^ (n - 1) = a ^ n * a\u207b\u00b9 :=\ncalc a ^ (n - 1) = a ^ (n - 1) * a * a\u207b\u00b9 : (mul_inv_cancel_right _ _).symm\n             ... = a^n * a\u207b\u00b9             : by rw [\u2190 gpow_add_one, sub_add_cancel]\n\nlemma gpow_add (a : G) (m n : \u2124) : a ^ (m + n) = a ^ m * a ^ n :=\nbegin\n  induction n using int.induction_on with n ihn n ihn,\n  case hz : { simp },\n  { simp only [\u2190 add_assoc, gpow_add_one, ihn, mul_assoc] },\n  { rw [gpow_sub_one, \u2190 mul_assoc, \u2190 ihn, \u2190 gpow_sub_one, add_sub_assoc] }\nend\n\nlemma mul_self_gpow (b : G) (m : \u2124) : b*b^m = b^(m+1) :=\nby { conv_lhs {congr, rw \u2190 gpow_one b }, rw [\u2190 gpow_add, add_comm] }\n\nlemma mul_gpow_self (b : G) (m : \u2124) : b^m*b = b^(m+1) :=\nby { conv_lhs {congr, skip, rw \u2190 gpow_one b }, rw [\u2190 gpow_add, add_comm] }\n\ntheorem add_gsmul : \u2200 (a : A) (i j : \u2124), (i + j) \u2022 a = i \u2022 a + j \u2022 a :=\n@gpow_add (multiplicative A) _\n\nlemma gpow_sub (a : G) (m n : \u2124) : a ^ (m - n) = a ^ m * (a ^ n)\u207b\u00b9 :=\nby rw [sub_eq_add_neg, gpow_add, gpow_neg]\n\nlemma sub_gsmul (m n : \u2124) (a : A) : (m - n) \u2022 a = m \u2022 a - n \u2022 a :=\nby simpa only [sub_eq_add_neg] using @gpow_sub (multiplicative A) _ _ _ _\n\ntheorem gpow_one_add (a : G) (i : \u2124) : a ^ (1 + i) = a * a ^ i :=\nby rw [gpow_add, gpow_one]\n\ntheorem one_add_gsmul : \u2200 (a : A) (i : \u2124), (1 + i) \u2022 a = a + i \u2022 a :=\n@gpow_one_add (multiplicative A) _\n\ntheorem gpow_mul_comm (a : G) (i j : \u2124) : a ^ i * a ^ j = a ^ j * a ^ i :=\nby rw [\u2190 gpow_add, \u2190 gpow_add, add_comm]\n\ntheorem gsmul_add_comm : \u2200 (a : A) (i j : \u2124), i \u2022 a + j \u2022 a = j \u2022 a + i \u2022 a :=\n@gpow_mul_comm (multiplicative A) _\n\ntheorem gpow_mul (a : G) (m n : \u2124) : a ^ (m * n) = (a ^ m) ^ n :=\nint.induction_on n (by simp) (\u03bb n ihn, by simp [mul_add, gpow_add, ihn])\n  (\u03bb n ihn, by simp only [mul_sub, gpow_sub, ihn, mul_one, gpow_one])\n\ntheorem gsmul_mul' : \u2200 (a : A) (m n : \u2124), (m * n) \u2022 a = n \u2022 (m \u2022 a) :=\n@gpow_mul (multiplicative A) _\n\ntheorem gpow_mul' (a : G) (m n : \u2124) : a ^ (m * n) = (a ^ n) ^ m :=\nby rw [mul_comm, gpow_mul]\n\ntheorem mul_gsmul (a : A) (m n : \u2124) : (m * n) \u2022 a = m \u2022 (n \u2022 a) :=\nby rw [mul_comm, gsmul_mul']\n\ntheorem gpow_bit0 (a : G) (n : \u2124) : a ^ bit0 n = a ^ n * a ^ n := gpow_add _ _ _\n\ntheorem bit0_gsmul (a : A) (n : \u2124) : bit0 n \u2022 a = n \u2022 a + n \u2022 a :=\n@gpow_bit0 (multiplicative A) _ _ _\n\ntheorem gpow_bit1 (a : G) (n : \u2124) : a ^ bit1 n = a ^ n * a ^ n * a :=\nby rw [bit1, gpow_add, gpow_bit0, gpow_one]\n\ntheorem bit1_gsmul : \u2200 (a : A) (n : \u2124), bit1 n \u2022 a = n \u2022 a + n \u2022 a + a :=\n@gpow_bit1 (multiplicative A) _\n\n@[simp] theorem monoid_hom.map_gpow (f : G \u2192* H) (a : G) (n : \u2124) : f (a ^ n) = f a ^ n :=\nby cases n; simp\n\n@[simp] theorem add_monoid_hom.map_gsmul (f : A \u2192+ B) (a : A) (n : \u2124) : f (n \u2022 a) = n \u2022 f a :=\nf.to_multiplicative.map_gpow a n\n\n@[simp, norm_cast] lemma units.coe_gpow (u : units G) (n : \u2124) : ((u ^ n : units G) : G) = u ^ n :=\n(units.coe_hom G).map_gpow u n\n\nend group\n\nsection ordered_add_comm_group\n\nvariables [ordered_add_comm_group A]\n/-! Lemmas about `gsmul` under ordering,  placed here (rather than in `algebra.group_power.order`\nwith their friends) because they require facts from `data.int.basic`-/\nopen int\n\nlemma gsmul_pos {a : A} (ha : 0 < a) {k : \u2124} (hk : (0:\u2124) < k) : 0 < k \u2022 a :=\nbegin\n  lift k to \u2115 using int.le_of_lt hk,\n  rw gsmul_coe_nat,\n  apply nsmul_pos ha,\n  exact coe_nat_pos.mp hk,\nend\n\ntheorem gsmul_le_gsmul {a : A} {n m : \u2124} (ha : 0 \u2264 a) (h : n \u2264 m) : n \u2022 a \u2264 m \u2022 a :=\ncalc n \u2022 a = n \u2022 a + 0 : (add_zero _).symm\n  ... \u2264 n \u2022 a + (m - n) \u2022 a : add_le_add_left (gsmul_nonneg ha (sub_nonneg.mpr h)) _\n  ... = m \u2022 a : by { rw [\u2190 add_gsmul], simp }\n\ntheorem gsmul_lt_gsmul {a : A} {n m : \u2124} (ha : 0 < a) (h : n < m) : n \u2022 a < m \u2022 a :=\ncalc n \u2022 a = n \u2022 a + 0 : (add_zero _).symm\n  ... < n \u2022 a + (m - n) \u2022 a : add_lt_add_left (gsmul_pos ha (sub_pos.mpr h)) _\n  ... = m \u2022 a : by { rw [\u2190 add_gsmul], simp }\n\nlemma abs_nsmul {\u03b1 : Type*} [linear_ordered_add_comm_group \u03b1] (n : \u2115) (a : \u03b1) :\n  abs (n \u2022 a) = n \u2022 abs a :=\nbegin\n  cases le_total a 0 with hneg hpos,\n  { rw [abs_of_nonpos hneg, \u2190 abs_neg, \u2190 neg_nsmul, abs_of_nonneg],\n    exact nsmul_nonneg (neg_nonneg.mpr hneg) n },\n  { rw [abs_of_nonneg hpos, abs_of_nonneg],\n    exact nsmul_nonneg hpos n }\nend\n\nlemma abs_gsmul {\u03b1 : Type*} [linear_ordered_add_comm_group \u03b1] (n : \u2124) (a : \u03b1) :\n  abs (n \u2022 a) = (abs n) \u2022 abs a :=\nbegin\n  by_cases n0 : 0 \u2264 n,\n  { lift n to \u2115 using n0,\n    simp only [abs_nsmul, coe_nat_abs, gsmul_coe_nat] },\n  { lift (- n) to \u2115 using int.le_of_lt (neg_pos.mpr (not_le.mp n0)) with m h,\n    rw [\u2190 abs_neg (n \u2022 a), \u2190 neg_gsmul, \u2190 abs_neg n, \u2190 h, gsmul_coe_nat, coe_nat_abs,\n      gsmul_coe_nat],\n    exact abs_nsmul m _ },\nend\n\nlemma abs_add_eq_add_abs_le {\u03b1 : Type*} [linear_ordered_add_comm_group \u03b1] {a b : \u03b1} (hle : a \u2264 b) :\n  abs (a + b) = abs a + abs b \u2194 (0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0) :=\nbegin\n  by_cases a0 : 0 \u2264 a; by_cases b0 : 0 \u2264 b,\n  { simp [a0, b0, abs_of_nonneg, add_nonneg a0 b0] },\n  { exact (lt_irrefl (0 : \u03b1) (a0.trans_lt (hle.trans_lt (not_le.mp b0)))).elim },\n  any_goals { simp [(not_le.mp a0).le, (not_le.mp b0).le, abs_of_nonpos, add_nonpos, add_comm] },\n  obtain F := (not_le.mp a0),\n  have : (abs (a + b) = -a + b \u2194 b \u2264 0) \u2194 (abs (a + b) =\n    abs a + abs b \u2194 0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0),\n  { simp [a0, b0, abs_of_neg, abs_of_nonneg, F, F.le] },\n  refine this.mp \u27e8\u03bb h, _, \u03bb h, by simp only [le_antisymm h b0, abs_of_neg F, add_zero]\u27e9,\n  by_cases ba : a + b \u2264 0,\n  { refine le_of_eq (eq_zero_of_neg_eq _),\n    rwa [abs_of_nonpos ba, neg_add_rev, add_comm, add_right_inj] at h },\n  { refine (lt_irrefl (0 : \u03b1) _).elim,\n    rw [abs_of_pos (not_le.mp ba), add_left_inj] at h,\n    rwa eq_zero_of_neg_eq h.symm at F }\nend\n\nlemma abs_add_eq_add_abs_iff {\u03b1 : Type*} [linear_ordered_add_comm_group \u03b1] (a b : \u03b1) :\n  abs (a + b) = abs a + abs b \u2194 (0 \u2264 a \u2227 0 \u2264 b \u2228 a \u2264 0 \u2227 b \u2264 0) :=\nbegin\n  by_cases ab : a \u2264 b,\n  { exact abs_add_eq_add_abs_le ab },\n  { rw [add_comm a, add_comm (abs _), abs_add_eq_add_abs_le ((not_le.mp ab).le), and.comm,\n    @and.comm (b \u2264 0 ) _] }\nend\n\nend ordered_add_comm_group\n\nsection linear_ordered_add_comm_group\nvariable [linear_ordered_add_comm_group A]\n\ntheorem gsmul_le_gsmul_iff {a : A} {n m : \u2124} (ha : 0 < a) : n \u2022 a \u2264 m \u2022 a \u2194 n \u2264 m :=\nbegin\n  refine \u27e8\u03bb h, _, gsmul_le_gsmul $ le_of_lt ha\u27e9,\n  by_contra H,\n  exact lt_irrefl _ (lt_of_lt_of_le (gsmul_lt_gsmul ha (not_le.mp H)) h)\nend\n\ntheorem gsmul_lt_gsmul_iff {a : A} {n m : \u2124} (ha : 0 < a) : n \u2022 a < m \u2022 a \u2194 n < m :=\nbegin\n  refine \u27e8\u03bb h, _, gsmul_lt_gsmul ha\u27e9,\n  by_contra H,\n  exact lt_irrefl _ (lt_of_le_of_lt (gsmul_le_gsmul (le_of_lt ha) $ not_lt.mp H) h)\nend\n\ntheorem nsmul_le_nsmul_iff {a : A} {n m : \u2115} (ha : 0 < a) : n \u2022 a \u2264 m \u2022 a \u2194 n \u2264 m :=\nbegin\n  refine \u27e8\u03bb h, _, nsmul_le_nsmul $ le_of_lt ha\u27e9,\n  by_contra H,\n  exact lt_irrefl _ (lt_of_lt_of_le (nsmul_lt_nsmul ha (not_le.mp H)) h)\nend\n\ntheorem nsmul_lt_nsmul_iff {a : A} {n m : \u2115} (ha : 0 < a) : n \u2022 a < m \u2022 a \u2194 n < m :=\nbegin\n  refine \u27e8\u03bb h, _, nsmul_lt_nsmul ha\u27e9,\n  by_contra H,\n  exact lt_irrefl _ (lt_of_le_of_lt (nsmul_le_nsmul (le_of_lt ha) $ not_lt.mp H) h)\nend\n\nend linear_ordered_add_comm_group\n\n@[simp] lemma with_bot.coe_nsmul [add_monoid A] (a : A) (n : \u2115) :\n  ((n \u2022 a : A) : with_bot A) = n \u2022 a :=\nadd_monoid_hom.map_nsmul \u27e8(coe : A \u2192 with_bot A), with_bot.coe_zero, with_bot.coe_add\u27e9 a n\n\ntheorem nsmul_eq_mul' [semiring R] (a : R) (n : \u2115) : n \u2022 a = a * n :=\nby induction n with n ih; [rw [zero_nsmul, nat.cast_zero, mul_zero],\n  rw [succ_nsmul', ih, nat.cast_succ, mul_add, mul_one]]\n\n@[simp] theorem nsmul_eq_mul [semiring R] (n : \u2115) (a : R) : n \u2022 a = n * a :=\nby rw [nsmul_eq_mul', (n.cast_commute a).eq]\n\ntheorem mul_nsmul_left [semiring R] (a b : R) (n : \u2115) : n \u2022 (a * b) = a * (n \u2022 b) :=\nby rw [nsmul_eq_mul', nsmul_eq_mul', mul_assoc]\n\ntheorem mul_nsmul_assoc [semiring R] (a b : R) (n : \u2115) : n \u2022 (a * b) = n \u2022 a * b :=\nby rw [nsmul_eq_mul, nsmul_eq_mul, mul_assoc]\n\n@[simp, norm_cast] theorem nat.cast_pow [semiring R] (n m : \u2115) : (\u2191(n ^ m) : R) = \u2191n ^ m :=\nbegin\n  induction m with m ih,\n  { rw [pow_zero, pow_zero], exact nat.cast_one },\n  { rw [pow_succ', pow_succ', nat.cast_mul, ih] }\nend\n\n@[simp, norm_cast] theorem int.coe_nat_pow (n m : \u2115) : ((n ^ m : \u2115) : \u2124) = n ^ m :=\nby induction m with m ih; [exact int.coe_nat_one, rw [pow_succ', pow_succ', int.coe_nat_mul, ih]]\n\ntheorem int.nat_abs_pow (n : \u2124) (k : \u2115) : int.nat_abs (n ^ k) = (int.nat_abs n) ^ k :=\nby induction k with k ih; [refl, rw [pow_succ', int.nat_abs_mul, pow_succ', ih]]\n\n-- The next four lemmas allow us to replace multiplication by a numeral with a `gsmul` expression.\n-- They are used by the `noncomm_ring` tactic, to normalise expressions before passing to `abel`.\n\nlemma bit0_mul [ring R] {n r : R} : bit0 n * r = (2 : \u2124) \u2022 (n * r) :=\nby { dsimp [bit0], rw [add_mul, add_gsmul, one_gsmul], }\n\nlemma mul_bit0 [ring R] {n r : R} : r * bit0 n = (2 : \u2124) \u2022 (r * n) :=\nby { dsimp [bit0], rw [mul_add, add_gsmul, one_gsmul], }\n\nlemma bit1_mul [ring R] {n r : R} : bit1 n * r = (2 : \u2124) \u2022 (n * r) + r :=\nby { dsimp [bit1], rw [add_mul, bit0_mul, one_mul], }\n\nlemma mul_bit1 [ring R] {n r : R} : r * bit1 n = (2 : \u2124) \u2022 (r * n) + r :=\nby { dsimp [bit1], rw [mul_add, mul_bit0, mul_one], }\n\n@[simp] theorem gsmul_eq_mul [ring R] (a : R) : \u2200 (n : \u2124), n \u2022 a = n * a\n| (n : \u2115) := by { rw [gsmul_coe_nat, nsmul_eq_mul], refl }\n| -[1+ n] := by simp [nat.cast_succ, neg_add_rev, int.cast_neg_succ_of_nat, add_mul]\n\ntheorem gsmul_eq_mul' [ring R] (a : R) (n : \u2124) : n \u2022 a = a * n :=\nby rw [gsmul_eq_mul, (n.cast_commute a).eq]\n\ntheorem mul_gsmul_left [ring R] (a b : R) (n : \u2124) : n \u2022 (a * b) = a * (n \u2022 b) :=\nby rw [gsmul_eq_mul', gsmul_eq_mul', mul_assoc]\n\ntheorem mul_gsmul_assoc [ring R] (a b : R) (n : \u2124) : n \u2022 (a * b) = n \u2022 a * b :=\nby rw [gsmul_eq_mul, gsmul_eq_mul, mul_assoc]\n\nlemma gsmul_int_int (a b : \u2124) : a \u2022 b = a * b := by simp\n\nlemma gsmul_int_one (n : \u2124) : n \u2022 1 = n := by simp\n\n@[simp, norm_cast] theorem int.cast_pow [ring R] (n : \u2124) (m : \u2115) : (\u2191(n ^ m) : R) = \u2191n ^ m :=\nbegin\n  induction m with m ih,\n  { rw [pow_zero, pow_zero, int.cast_one] },\n  { rw [pow_succ, pow_succ, int.cast_mul, ih] }\nend\n\nlemma neg_one_pow_eq_pow_mod_two [ring R] {n : \u2115} : (-1 : R) ^ n = (-1) ^ (n % 2) :=\nby rw [\u2190 nat.mod_add_div n 2, pow_add, pow_mul]; simp [sq]\n\nsection ordered_semiring\nvariable [ordered_semiring R]\n\n/-- Bernoulli's inequality. This version works for semirings but requires\nadditional hypotheses `0 \u2264 a * a` and `0 \u2264 (1 + a) * (1 + a)`. -/\ntheorem one_add_mul_le_pow' {a : R} (Hsq : 0 \u2264 a * a) (Hsq' : 0 \u2264 (1 + a) * (1 + a))\n  (H : 0 \u2264 2 + a) :\n  \u2200 (n : \u2115), 1 + (n : R) * a \u2264 (1 + a) ^ n\n| 0     := by simp\n| 1     := by simp\n| (n+2) :=\nhave 0 \u2264 (n : R) * (a * a * (2 + a)) + a * a,\n  from add_nonneg (mul_nonneg n.cast_nonneg (mul_nonneg Hsq H)) Hsq,\ncalc 1 + (\u2191(n + 2) : R) * a \u2264 1 + \u2191(n + 2) * a + (n * (a * a * (2 + a)) + a * a) :\n  (le_add_iff_nonneg_right _).2 this\n... = (1 + a) * (1 + a) * (1 + n * a) :\n  by { simp [add_mul, mul_add, bit0, mul_assoc, (n.cast_commute (_ : R)).left_comm],\n       ac_refl }\n... \u2264 (1 + a) * (1 + a) * (1 + a)^n :\n  mul_le_mul_of_nonneg_left (one_add_mul_le_pow' n) Hsq'\n... = (1 + a)^(n + 2) : by simp only [pow_succ, mul_assoc]\n\nprivate lemma pow_lt_pow_of_lt_one_aux {a : R} (h : 0 < a) (ha : a < 1) (i : \u2115) :\n  \u2200 k : \u2115, a ^ (i + k + 1) < a ^ i\n| 0 :=\n  begin\n    rw [\u2190one_mul (a^i), add_zero, pow_succ],\n    exact mul_lt_mul ha (le_refl _) (pow_pos h _) zero_le_one\n  end\n| (k+1) :=\n  begin\n    rw [\u2190one_mul (a^i), pow_succ],\n    apply mul_lt_mul ha _ _ zero_le_one,\n    { apply le_of_lt, apply pow_lt_pow_of_lt_one_aux },\n    { show 0 < a ^ (i + (k + 1) + 0), apply pow_pos h }\n  end\n\nprivate lemma pow_le_pow_of_le_one_aux {a : R}  (h : 0 \u2264 a) (ha : a \u2264 1) (i : \u2115) :\n  \u2200 k : \u2115, a ^ (i + k) \u2264 a ^ i\n| 0 := by simp\n| (k+1) := by { rw [\u2190add_assoc, \u2190one_mul (a^i), pow_succ],\n                exact mul_le_mul ha (pow_le_pow_of_le_one_aux _) (pow_nonneg h _) zero_le_one }\n\nlemma pow_lt_pow_of_lt_one  {a : R} (h : 0 < a) (ha : a < 1)\n  {i j : \u2115} (hij : i < j) : a ^ j < a ^ i :=\nlet \u27e8k, hk\u27e9 := nat.exists_eq_add_of_lt hij in\nby rw hk; exact pow_lt_pow_of_lt_one_aux h ha _ _\n\nlemma pow_lt_pow_iff_of_lt_one {a : R} {n m : \u2115} (hpos : 0 < a) (h : a < 1) :\n  a ^ m < a ^ n \u2194 n < m :=\nbegin\n  have : strict_mono (\u03bb (n : order_dual \u2115), a ^ (id n : \u2115)) := \u03bb m n, pow_lt_pow_of_lt_one hpos h,\n  exact this.lt_iff_lt\nend\n\nlemma pow_le_pow_of_le_one  {a : R} (h : 0 \u2264 a) (ha : a \u2264 1)\n  {i j : \u2115} (hij : i \u2264 j) : a ^ j \u2264 a ^ i :=\nlet \u27e8k, hk\u27e9 := nat.exists_eq_add_of_le hij in\nby rw hk; exact pow_le_pow_of_le_one_aux h ha _ _\n\nlemma pow_le_one {x : R} : \u2200 (n : \u2115) (h0 : 0 \u2264 x) (h1 : x \u2264 1), x ^ n \u2264 1\n| 0     h0 h1 := by rw [pow_zero]\n| (n+1) h0 h1 := by { rw [pow_succ], exact mul_le_one h1 (pow_nonneg h0 _) (pow_le_one n h0 h1) }\n\nend ordered_semiring\n\nsection linear_ordered_semiring\n\nvariables [linear_ordered_semiring R]\n\nlemma sign_cases_of_C_mul_pow_nonneg {C r : R} (h : \u2200 n : \u2115, 0 \u2264 C * r ^ n) :\n  C = 0 \u2228 (0 < C \u2227 0 \u2264 r) :=\nbegin\n  have : 0 \u2264 C, by simpa only [pow_zero, mul_one] using h 0,\n  refine this.eq_or_lt.elim (\u03bb h, or.inl h.symm) (\u03bb hC, or.inr \u27e8hC, _\u27e9),\n  refine nonneg_of_mul_nonneg_left _ hC,\n  simpa only [pow_one] using h 1\nend\n\nend linear_ordered_semiring\n\nsection linear_ordered_ring\n\nvariables [linear_ordered_ring R] {a : R} {n : \u2115}\n\n@[simp] lemma abs_pow (a : R) (n : \u2115) : abs (a ^ n) = abs a ^ n :=\n(pow_abs a n).symm\n\n@[simp] theorem pow_bit1_neg_iff : a ^ bit1 n < 0 \u2194 a < 0 :=\n\u27e8\u03bb h, not_le.1 $ \u03bb h', not_le.2 h $ pow_nonneg h' _,\n  \u03bb h, by { rw [bit1, pow_succ], exact mul_neg_of_neg_of_pos h (pow_bit0_pos h.ne _)}\u27e9\n\n@[simp] theorem pow_bit1_nonneg_iff : 0 \u2264 a ^ bit1 n \u2194 0 \u2264 a :=\nle_iff_le_iff_lt_iff_lt.2 pow_bit1_neg_iff\n\n@[simp] theorem pow_bit1_nonpos_iff : a ^ bit1 n \u2264 0 \u2194 a \u2264 0 :=\nby simp only [le_iff_lt_or_eq, pow_bit1_neg_iff, pow_eq_zero_iff (bit1_pos (zero_le n))]\n\n@[simp] theorem pow_bit1_pos_iff : 0 < a ^ bit1 n \u2194 0 < a :=\nlt_iff_lt_of_le_iff_le pow_bit1_nonpos_iff\n\ntheorem pow_even_nonneg (a : R) (hn : even n) : 0 \u2264 a ^ n :=\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit0_nonneg a k\n\ntheorem pow_even_pos (ha : a \u2260 0) (hn : even n) : 0 < a ^ n :=\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit0_pos ha k\n\ntheorem pow_odd_nonneg (ha : 0 \u2264 a) (hn : odd n) : 0 \u2264 a ^ n :=\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_nonneg_iff.mpr ha\n\ntheorem pow_odd_pos (ha : 0 < a) (hn : odd n) : 0 < a ^ n :=\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_pos_iff.mpr ha\n\ntheorem pow_odd_nonpos (ha : a \u2264 0) (hn : odd n) : a ^ n \u2264 0:=\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_nonpos_iff.mpr ha\n\ntheorem pow_odd_neg (ha : a < 0) (hn : odd n) : a ^ n < 0:=\nby cases hn with k hk; simpa only [hk, two_mul] using pow_bit1_neg_iff.mpr ha\n\nlemma pow_even_abs (a : R) {p : \u2115} (hp : even p) :\n  abs a ^ p = a ^ p :=\nbegin\n  rw [\u2190abs_pow, abs_eq_self],\n  exact pow_even_nonneg _ hp\nend\n\n@[simp] lemma pow_bit0_abs (a : R) (p : \u2115) :\n  abs a ^ bit0 p = a ^ bit0 p :=\npow_even_abs _ (even_bit0 _)\n\nlemma strict_mono_pow_bit1 (n : \u2115) : strict_mono (\u03bb a : R, a ^ bit1 n) :=\nbegin\n  intros a b hab,\n  cases le_total a 0 with ha ha,\n  { cases le_or_lt b 0 with hb hb,\n    { rw [\u2190 neg_lt_neg_iff, \u2190 neg_pow_bit1, \u2190 neg_pow_bit1],\n      exact pow_lt_pow_of_lt_left (neg_lt_neg hab) (neg_nonneg.2 hb) (bit1_pos (zero_le n)) },\n    { exact (pow_bit1_nonpos_iff.2 ha).trans_lt (pow_bit1_pos_iff.2 hb) } },\n  { exact pow_lt_pow_of_lt_left hab ha (bit1_pos (zero_le n)) }\nend\n\n/-- Bernoulli's inequality for `n : \u2115`, `-2 \u2264 a`. -/\ntheorem one_add_mul_le_pow (H : -2 \u2264 a) (n : \u2115) : 1 + (n : R) * a \u2264 (1 + a) ^ n :=\none_add_mul_le_pow' (mul_self_nonneg _) (mul_self_nonneg _) (neg_le_iff_add_nonneg'.1 H) _\n\n/-- Bernoulli's inequality reformulated to estimate `a^n`. -/\ntheorem one_add_mul_sub_le_pow (H : -1 \u2264 a) (n : \u2115) : 1 + (n : R) * (a - 1) \u2264 a ^ n :=\nhave -2 \u2264 a - 1, by rwa [bit0, neg_add, \u2190 sub_eq_add_neg, sub_le_sub_iff_right],\nby simpa only [add_sub_cancel'_right] using one_add_mul_le_pow this n\n\nend linear_ordered_ring\n\n/-- Bernoulli's inequality reformulated to estimate `(n : K)`. -/\ntheorem nat.cast_le_pow_sub_div_sub {K : Type*} [linear_ordered_field K] {a : K} (H : 1 < a)\n  (n : \u2115) :\n  (n : K) \u2264 (a ^ n - 1) / (a - 1) :=\n(le_div_iff (sub_pos.2 H)).2 $ le_sub_left_of_add_le $\n  one_add_mul_sub_le_pow ((neg_le_self $ @zero_le_one K _).trans H.le) _\n\n/-- For any `a > 1` and a natural `n` we have `n \u2264 a ^ n / (a - 1)`. See also\n`nat.cast_le_pow_sub_div_sub` for a stronger inequality with `a ^ n - 1` in the numerator. -/\ntheorem nat.cast_le_pow_div_sub {K : Type*} [linear_ordered_field K] {a : K} (H : 1 < a) (n : \u2115) :\n  (n : K) \u2264 a ^ n / (a - 1) :=\n(n.cast_le_pow_sub_div_sub H).trans $ div_le_div_of_le (sub_nonneg.2 H.le)\n  (sub_le_self _ zero_le_one)\n\nnamespace int\n\nlemma units_sq (u : units \u2124) : u ^ 2 = 1 :=\n(sq u).symm \u25b8 units_mul_self u\n\nalias int.units_sq \u2190 int.units_pow_two\n\nlemma units_pow_eq_pow_mod_two (u : units \u2124) (n : \u2115) : u ^ n = u ^ (n % 2) :=\nby conv {to_lhs, rw \u2190 nat.mod_add_div n 2}; rw [pow_add, pow_mul, units_sq, one_pow, mul_one]\n\n@[simp] lemma nat_abs_sq (x : \u2124) : (x.nat_abs ^ 2 : \u2124) = x ^ 2 :=\nby rw [sq, int.nat_abs_mul_self', sq]\n\nalias int.nat_abs_sq \u2190 int.nat_abs_pow_two\n\nlemma abs_le_self_sq (a : \u2124) : (int.nat_abs a : \u2124) \u2264 a ^ 2 :=\nby { rw [\u2190 int.nat_abs_sq a, sq], norm_cast, apply nat.le_mul_self }\n\nalias int.abs_le_self_sq \u2190 int.abs_le_self_pow_two\n\nlemma le_self_sq (b : \u2124) : b \u2264 b ^ 2 := le_trans (le_nat_abs) (abs_le_self_sq _)\n\nalias int.le_self_sq \u2190 int.le_self_pow_two\n\nend int\n\nvariables (M G A)\n\n/-- Monoid homomorphisms from `multiplicative \u2115` are defined by the image\nof `multiplicative.of_add 1`. -/\ndef powers_hom [monoid M] : M \u2243 (multiplicative \u2115 \u2192* M) :=\n{ to_fun := \u03bb x, \u27e8\u03bb n, x ^ n.to_add, by { convert pow_zero x, exact to_add_one },\n    \u03bb m n, pow_add x m n\u27e9,\n  inv_fun := \u03bb f, f (multiplicative.of_add 1),\n  left_inv := pow_one,\n  right_inv := \u03bb f, monoid_hom.ext $ \u03bb n, by { simp [\u2190 f.map_pow, \u2190 of_add_nsmul] } }\n\n/-- Monoid homomorphisms from `multiplicative \u2124` are defined by the image\nof `multiplicative.of_add 1`. -/\ndef gpowers_hom [group G] : G \u2243 (multiplicative \u2124 \u2192* G) :=\n{ to_fun := \u03bb x, \u27e8\u03bb n, x ^ n.to_add, gpow_zero x, \u03bb m n, gpow_add x m n\u27e9,\n  inv_fun := \u03bb f, f (multiplicative.of_add 1),\n  left_inv := gpow_one,\n  right_inv := \u03bb f, monoid_hom.ext $ \u03bb n, by { simp [\u2190 f.map_gpow, \u2190 of_add_gsmul ] } }\n\n/-- Additive homomorphisms from `\u2115` are defined by the image of `1`. -/\ndef multiples_hom [add_monoid A] : A \u2243 (\u2115 \u2192+ A) :=\n{ to_fun := \u03bb x, \u27e8\u03bb n, n \u2022 x, zero_nsmul x, \u03bb m n, add_nsmul _ _ _\u27e9,\n  inv_fun := \u03bb f, f 1,\n  left_inv := one_nsmul,\n  right_inv := \u03bb f, add_monoid_hom.ext_nat $ one_nsmul (f 1) }\n\n/-- Additive homomorphisms from `\u2124` are defined by the image of `1`. -/\ndef gmultiples_hom [add_group A] : A \u2243 (\u2124 \u2192+ A) :=\n{ to_fun := \u03bb x, \u27e8\u03bb n, n \u2022 x, zero_gsmul x, \u03bb m n, add_gsmul _ _ _\u27e9,\n  inv_fun := \u03bb f, f 1,\n  left_inv := one_gsmul,\n  right_inv := \u03bb f, add_monoid_hom.ext_int $ one_gsmul (f 1) }\n\nvariables {M G A}\n\n@[simp] lemma powers_hom_apply [monoid M] (x : M) (n : multiplicative \u2115) :\n  powers_hom M x n = x ^ n.to_add := rfl\n\n@[simp] lemma powers_hom_symm_apply [monoid M] (f : multiplicative \u2115 \u2192* M) :\n  (powers_hom M).symm f = f (multiplicative.of_add 1) := rfl\n\n@[simp] lemma gpowers_hom_apply [group G] (x : G) (n : multiplicative \u2124) :\n  gpowers_hom G x n = x ^ n.to_add := rfl\n\n@[simp] lemma gpowers_hom_symm_apply [group G] (f : multiplicative \u2124 \u2192* G) :\n  (gpowers_hom G).symm f = f (multiplicative.of_add 1) := rfl\n\n@[simp] lemma multiples_hom_apply [add_monoid A] (x : A) (n : \u2115) :\n  multiples_hom A x n = n \u2022 x := rfl\n\n@[simp] lemma multiples_hom_symm_apply [add_monoid A] (f : \u2115 \u2192+ A) :\n  (multiples_hom A).symm f = f 1 := rfl\n\n@[simp] lemma gmultiples_hom_apply [add_group A] (x : A) (n : \u2124) :\n  gmultiples_hom A x n = n \u2022 x := rfl\n\n@[simp] lemma gmultiples_hom_symm_apply [add_group A] (f : \u2124 \u2192+ A) :\n  (gmultiples_hom A).symm f = f 1 := rfl\n\nlemma monoid_hom.apply_mnat [monoid M] (f : multiplicative \u2115 \u2192* M) (n : multiplicative \u2115) :\n  f n = (f (multiplicative.of_add 1)) ^ n.to_add :=\nby rw [\u2190 powers_hom_symm_apply, \u2190 powers_hom_apply, equiv.apply_symm_apply]\n\n@[ext] lemma monoid_hom.ext_mnat [monoid M] \u2983f g : multiplicative \u2115 \u2192* M\u2984\n  (h : f (multiplicative.of_add 1) = g (multiplicative.of_add 1)) : f = g :=\nmonoid_hom.ext $ \u03bb n, by rw [f.apply_mnat, g.apply_mnat, h]\n\nlemma monoid_hom.apply_mint [group M] (f : multiplicative \u2124 \u2192* M) (n : multiplicative \u2124) :\n  f n = (f (multiplicative.of_add 1)) ^ n.to_add :=\nby rw [\u2190 gpowers_hom_symm_apply, \u2190 gpowers_hom_apply, equiv.apply_symm_apply]\n\n/-! `monoid_hom.ext_mint` is defined in `data.int.cast` -/\n\nlemma add_monoid_hom.apply_nat [add_monoid M] (f : \u2115 \u2192+ M) (n : \u2115) :\n  f n = n \u2022 (f 1) :=\nby rw [\u2190 multiples_hom_symm_apply, \u2190 multiples_hom_apply, equiv.apply_symm_apply]\n\n/-! `add_monoid_hom.ext_nat` is defined in `data.nat.cast` -/\n\nlemma add_monoid_hom.apply_int [add_group M] (f : \u2124 \u2192+ M) (n : \u2124) :\n  f n = n \u2022 (f 1) :=\nby rw [\u2190 gmultiples_hom_symm_apply, \u2190 gmultiples_hom_apply, equiv.apply_symm_apply]\n\n/-! `add_monoid_hom.ext_int` is defined in `data.int.cast` -/\n\nvariables (M G A)\n\n/-- If `M` is commutative, `powers_hom` is a multiplicative equivalence. -/\ndef powers_mul_hom [comm_monoid M] : M \u2243* (multiplicative \u2115 \u2192* M) :=\n{ map_mul' := \u03bb a b, monoid_hom.ext $ by simp [mul_pow],\n  ..powers_hom M}\n\n/-- If `M` is commutative, `gpowers_hom` is a multiplicative equivalence. -/\ndef gpowers_mul_hom [comm_group G] : G \u2243* (multiplicative \u2124 \u2192* G) :=\n{ map_mul' := \u03bb a b, monoid_hom.ext $ by simp [mul_gpow],\n  ..gpowers_hom G}\n\n/-- If `M` is commutative, `multiples_hom` is an additive equivalence. -/\ndef multiples_add_hom [add_comm_monoid A] : A \u2243+ (\u2115 \u2192+ A) :=\n{ map_add' := \u03bb a b, add_monoid_hom.ext $ by simp [nsmul_add],\n  ..multiples_hom A}\n\n/-- If `M` is commutative, `gmultiples_hom` is an additive equivalence. -/\ndef gmultiples_add_hom [add_comm_group A] : A \u2243+ (\u2124 \u2192+ A) :=\n{ map_add' := \u03bb a b, add_monoid_hom.ext $ by simp [gsmul_add],\n  ..gmultiples_hom A}\n\nvariables {M G A}\n\n@[simp] lemma powers_mul_hom_apply [comm_monoid M] (x : M) (n : multiplicative \u2115) :\n  powers_mul_hom M x n = x ^ n.to_add := rfl\n\n@[simp] lemma powers_mul_hom_symm_apply [comm_monoid M] (f : multiplicative \u2115 \u2192* M) :\n  (powers_mul_hom M).symm f = f (multiplicative.of_add 1) := rfl\n\n@[simp] lemma gpowers_mul_hom_apply [comm_group G] (x : G) (n : multiplicative \u2124) :\n  gpowers_mul_hom G x n = x ^ n.to_add := rfl\n\n@[simp] lemma gpowers_mul_hom_symm_apply [comm_group G] (f : multiplicative \u2124 \u2192* G) :\n  (gpowers_mul_hom G).symm f = f (multiplicative.of_add 1) := rfl\n\n@[simp] lemma multiples_add_hom_apply [add_comm_monoid A] (x : A) (n : \u2115) :\n  multiples_add_hom A x n = n \u2022 x := rfl\n\n@[simp] lemma multiples_add_hom_symm_apply [add_comm_monoid A] (f : \u2115 \u2192+ A) :\n  (multiples_add_hom A).symm f = f 1 := rfl\n\n@[simp] lemma gmultiples_add_hom_apply [add_comm_group A] (x : A) (n : \u2124) :\n  gmultiples_add_hom A x n = n \u2022 x := rfl\n\n@[simp] lemma gmultiples_add_hom_symm_apply [add_comm_group A] (f : \u2124 \u2192+ A) :\n  (gmultiples_add_hom A).symm f = f 1 := rfl\n\n/-!\n### Commutativity (again)\n\nFacts about `semiconj_by` and `commute` that require `gpow` or `gsmul`, or the fact that integer\nmultiplication equals semiring multiplication.\n-/\n\nnamespace semiconj_by\n\nsection\n\nvariables [semiring R] {a x y : R}\n\n@[simp] lemma cast_nat_mul_right (h : semiconj_by a x y) (n : \u2115) :\n  semiconj_by a ((n : R) * x) (n * y) :=\nsemiconj_by.mul_right (nat.commute_cast _ _) h\n\n@[simp] lemma cast_nat_mul_left (h : semiconj_by a x y) (n : \u2115) : semiconj_by ((n : R) * a) x y :=\nsemiconj_by.mul_left (nat.cast_commute _ _) h\n\n@[simp] lemma cast_nat_mul_cast_nat_mul (h : semiconj_by a x y) (m n : \u2115) :\n  semiconj_by ((m : R) * a) (n * x) (n * y) :=\n(h.cast_nat_mul_left m).cast_nat_mul_right n\n\nend\n\nvariables [monoid M] [group G] [ring R]\n\n@[simp] lemma units_gpow_right {a : M} {x y : units M} (h : semiconj_by a x y) :\n  \u2200 m : \u2124, semiconj_by a (\u2191(x^m)) (\u2191(y^m))\n| (n : \u2115) := by simp only [gpow_coe_nat, units.coe_pow, h, pow_right]\n| -[1+n] := by simp only [gpow_neg_succ_of_nat, units.coe_pow, units_inv_right, h, pow_right]\n\nvariables {a b x y x' y' : R}\n\n@[simp] lemma cast_int_mul_right (h : semiconj_by a x y) (m : \u2124) :\n  semiconj_by a ((m : \u2124) * x) (m * y) :=\nsemiconj_by.mul_right (int.commute_cast _ _) h\n\n@[simp] lemma cast_int_mul_left (h : semiconj_by a x y) (m : \u2124) : semiconj_by ((m : R) * a) x y :=\nsemiconj_by.mul_left (int.cast_commute _ _) h\n\n@[simp] lemma cast_int_mul_cast_int_mul (h : semiconj_by a x y) (m n : \u2124) :\n  semiconj_by ((m : R) * a) (n * x) (n * y) :=\n(h.cast_int_mul_left m).cast_int_mul_right n\n\nend semiconj_by\n\nnamespace commute\n\nsection\n\nvariables [semiring R] {a b : R}\n\n@[simp] theorem cast_nat_mul_right (h : commute a b) (n : \u2115) : commute a ((n : R) * b) :=\nh.cast_nat_mul_right n\n\n@[simp] theorem cast_nat_mul_left (h : commute a b) (n : \u2115) : commute ((n : R) * a) b :=\nh.cast_nat_mul_left n\n\n@[simp] theorem cast_nat_mul_cast_nat_mul (h : commute a b) (m n : \u2115) :\n  commute ((m : R) * a) (n * b) :=\nh.cast_nat_mul_cast_nat_mul m n\n\n@[simp] theorem self_cast_nat_mul (n : \u2115) : commute a (n * a) :=\n(commute.refl a).cast_nat_mul_right n\n\n@[simp] theorem cast_nat_mul_self (n : \u2115) : commute ((n : R) * a) a :=\n(commute.refl a).cast_nat_mul_left n\n\n@[simp] theorem self_cast_nat_mul_cast_nat_mul (m n : \u2115) : commute ((m : R) * a) (n * a) :=\n(commute.refl a).cast_nat_mul_cast_nat_mul m n\n\nend\n\nvariables [monoid M] [group G] [ring R]\n\n@[simp] lemma units_gpow_right {a : M} {u : units M} (h : commute a u) (m : \u2124) :\n  commute a (\u2191(u^m)) :=\nh.units_gpow_right m\n\n@[simp] lemma units_gpow_left {u : units M} {a : M} (h : commute \u2191u a) (m : \u2124) :\n  commute (\u2191(u^m)) a :=\n(h.symm.units_gpow_right m).symm\n\nvariables {a b : R}\n\n@[simp] lemma cast_int_mul_right (h : commute a b) (m : \u2124) : commute a (m * b) :=\nh.cast_int_mul_right m\n\n@[simp] lemma cast_int_mul_left (h : commute a b) (m : \u2124) : commute ((m : R) * a) b :=\nh.cast_int_mul_left m\n\nlemma cast_int_mul_cast_int_mul (h : commute a b) (m n : \u2124) : commute ((m : R) * a) (n * b) :=\nh.cast_int_mul_cast_int_mul m n\n\nvariables (a) (m n : \u2124)\n\n@[simp] theorem self_cast_int_mul : commute a (n * a) := (commute.refl a).cast_int_mul_right n\n\n@[simp] theorem cast_int_mul_self : commute ((n : R) * a) a := (commute.refl a).cast_int_mul_left n\n\ntheorem self_cast_int_mul_cast_int_mul : commute ((m : R) * a) (n * a) :=\n(commute.refl a).cast_int_mul_cast_int_mul m n\n\nend commute\n\nsection multiplicative\n\nopen multiplicative\n\n@[simp] lemma nat.to_add_pow (a : multiplicative \u2115) (b : \u2115) : to_add (a ^ b) = to_add a * b :=\nbegin\n  induction b with b ih,\n  { erw [pow_zero, to_add_one, mul_zero] },\n  { simp [*, pow_succ, add_comm, nat.mul_succ] }\nend\n\n@[simp] lemma nat.of_add_mul (a b : \u2115) : of_add (a * b) = of_add a ^ b :=\n(nat.to_add_pow _ _).symm\n\n@[simp] lemma int.to_add_pow (a : multiplicative \u2124) (b : \u2115) : to_add (a ^ b) = to_add a * b :=\nby induction b; simp [*, mul_add, pow_succ, add_comm]\n\n@[simp] lemma int.to_add_gpow (a : multiplicative \u2124) (b : \u2124) : to_add (a ^ b) = to_add a * b :=\nint.induction_on b (by simp)\n  (by simp [gpow_add, mul_add] {contextual := tt})\n  (by simp [gpow_add, mul_add, sub_eq_add_neg, -int.add_neg_one] {contextual := tt})\n\n@[simp] lemma int.of_add_mul (a b : \u2124) : of_add (a * b) = of_add a ^ b :=\n(int.to_add_gpow _ _).symm\n\nend multiplicative\n\nnamespace units\n\nvariables [monoid M]\n\nlemma conj_pow (u : units M) (x : M) (n : \u2115) : (\u2191u * x * \u2191(u\u207b\u00b9))^n = u * x^n * \u2191(u\u207b\u00b9) :=\n(divp_eq_iff_mul_eq.2 ((u.mk_semiconj_by x).pow_right n).eq.symm).symm\n\nlemma conj_pow' (u : units M) (x : M) (n : \u2115) : (\u2191(u\u207b\u00b9) * x * u)^n = \u2191(u\u207b\u00b9) * x^n * u:=\n(u\u207b\u00b9).conj_pow x n\n\nopen opposite\n\n/-- Moving to the opposite monoid commutes with taking powers. -/\n@[simp] lemma op_pow (x : M) (n : \u2115) : op (x ^ n) = (op x) ^ n :=\nbegin\n  induction n with n h,\n  { simp },\n  { rw [pow_succ', op_mul, h, pow_succ] }\nend\n\n@[simp] lemma unop_pow (x : M\u1d52\u1d56) (n : \u2115) : unop (x ^ n) = (unop x) ^ n :=\nbegin\n  induction n with n h,\n  { simp },\n  { rw [pow_succ', unop_mul, h, pow_succ] }\nend\n\nend units\n"}
{"text": "import Mathlib.Tactic.GuardGoalNums\n\nexample : true \u2227 true := by\n  constructor\n  guard_goal_nums 2\n  all_goals {constructor}\n\nexample : (true \u2227 true) \u2227 (true \u2227 true) := by\n  constructor <;> constructor\n  guard_goal_nums 4\n  all_goals {constructor}\n"}
{"text": "theory deMorgan3\n  imports Main\nbegin\n  text\\<open> Apply style \\<close>\nlemma lem_k_1 : \" (\\<not>p \\<or> \\<not>q)\\<longrightarrow> \\<not>(p \\<and> q)\"\n    apply (rule impI)\n  apply (erule disjE)\n   apply (rule notI)\n  apply (erule notE)\n   apply (erule conjE)\n   apply assumption\n  apply (rule notI)\n  apply (erule conjE)\n  apply (erule notE)\n  apply assumption\n  done \nend"}
{"text": "myTestRule {\n   msifilesystem_rename( \"/tmp/raw/tests\", \"/tmp/raw/\", \"/tmp/processed/\" );\n   writeLine(\"stdout\",\"done\");\n}\nOUTPUT ruleExecOut\n\n"}
{"text": "module MachineLearning.NeuralNetwork.TopologyTest\n(\n  tests\n)\n\nwhere\n\nimport Test.Framework (testGroup)\nimport Test.Framework.Providers.HUnit\nimport Test.HUnit\nimport Test.HUnit.Approx\nimport Test.HUnit.Plus\nimport qualified Numeric.LinearAlgebra as LA\nimport MachineLearning.NeuralNetwork.Topology\nimport qualified MachineLearning.NeuralNetwork.TopologyMaker as TM\n\nnnt = TM.makeTopology TM.ASigmoid TM.LLogistic 15 2 [10]\n\nflattenTest = do\n  theta <- initializeThetaIO nnt\n  let theta' = flatten $ unflatten nnt theta\n      norm = LA.norm_2 (theta - theta')\n  assertApproxEqual \"flatten\" 1e-10 0 norm\n\ntests = [ testGroup \"flatten\" [\n            testCase \"flatten\" flattenTest\n            ]\n        ]\n"}
{"text": "Require Export SystemFR.Syntax.\n\nRequire Export SystemFR.Tactics.\nRequire Export SystemFR.ListSetLemmas.\nRequire Export SystemFR.AssocList.\nRequire Export SystemFR.ListUtils.\nRequire Export SystemFR.EqualWithRelation.\nRequire Export SystemFR.EquivalentWithRelation.\n\nRequire Import PeanoNat.\n\nOpen Scope list_scope.\n\nFixpoint idrel (l: list nat) :=\n  match l with\n  | nil => nil\n  | x :: xs => (x,x) :: idrel xs\n  end.\n\nLemma idrel_lookup:\n  forall l x,\n    x \u2208 l ->\n    lookup PeanoNat.Nat.eq_dec (idrel l) x = Some x.\nProof.\n  induction l; steps.\nQed.\n\nLemma idrel_lookup_swap:\n  forall l x,\n    x \u2208 l ->\n    lookup PeanoNat.Nat.eq_dec (swap (idrel l)) x = Some x.\nProof.\n  induction l; steps.\nQed.\n\nLemma equal_with_idrel:\n  forall t, equal_with_relation type_var (idrel (pfv t type_var)) t t.\nProof.\n  intros; apply equal_with_relation_refl2; steps;\n    eauto using idrel_lookup, idrel_lookup_swap.\nQed.\n\nLemma idrel_lookup_fail:\n  forall l x,\n    (x \u2208 l -> False) ->\n    lookup PeanoNat.Nat.eq_dec (idrel l) x = None.\nProof.\n  induction l; steps.\nQed.\n\nLemma idrel_lookup_swap_fail:\n  forall l x,\n    (x \u2208 l -> False) ->\n    lookup PeanoNat.Nat.eq_dec (swap (idrel l)) x = None.\nProof.\n  induction l; steps.\nQed.\n\nLemma support_idrel:\n  forall l, support (idrel l) = l.\nProof.\n  induction l; steps.\nQed.\n\nLemma range_idrel:\n  forall l, range (idrel l) = l.\nProof.\n  induction l; steps.\nQed.\n\nLemma support_swap:\n  forall l, support (swap l) = range l.\nProof.\n  induction l; steps.\nQed.\n\nLemma range_swap:\n  forall l, range (swap l) = support l.\nProof.\n  induction l; steps.\nQed.\n\nLemma equivalent_rc_refl:\n  forall rc, equivalent_rc rc rc.\nProof.\n  unfold equivalent_rc; steps.\nQed.\n\nLemma equivalent_with_idrel:\n  forall T (l: list nat) (x: nat) \u03c1 t (equiv: T -> T -> Prop),\n    (x \u2208 l -> False) ->\n    (forall v, equiv v v) ->\n    equivalent_with_relation (idrel l) \u03c1 ((x,t) :: \u03c1) equiv.\nProof.\n  unfold equivalent_with_relation;\n    repeat step || t_lookup ||\n           rewrite support_idrel in * ||\n           rewrite support_swap in * ||\n           rewrite range_idrel in * ||\n           rewrite range_swap in * ||\n           (rewrite idrel_lookup in * by auto) ||\n           (rewrite idrel_lookup_swap_fail in * by auto) ||\n           apply equivalent_with_right.\nQed.\n\nLemma equivalent_with_idrel2:\n  forall T (l: list nat) (x: nat) \u03c1 t (equiv: T -> T -> Prop),\n    (x \u2208 l -> False) ->\n    (forall v, equiv v v) ->\n    equivalent_with_relation (idrel l) ((x,t) :: \u03c1) \u03c1 equiv.\nProof.\n  unfold equivalent_with_relation;\n    repeat step || t_lookup ||\n           rewrite support_idrel in * ||\n           rewrite support_swap in * ||\n           rewrite range_idrel in * ||\n           rewrite range_swap in * ||\n           (rewrite idrel_lookup in * by auto) ||\n           (rewrite idrel_lookup_swap_fail in * by auto) ||\n           apply equivalent_with_left.\nQed.\n\nLtac t_idrel :=\n  rewrite support_idrel in * ||\n  rewrite support_swap in * ||\n  rewrite range_idrel in * ||\n  rewrite range_swap in * ||\n  (rewrite idrel_lookup in * by auto) ||\n  (rewrite idrel_lookup_swap_fail in * by auto).\n\nLemma equivalent_with_relation_permute:\n  forall T \u03c11 \u03c12 v M l (equiv: T -> T -> Prop),\n    ~(M \u2208 support \u03c11) ->\n    (forall v, equiv v v) ->\n    equivalent_with_relation\n      ((M, M) :: idrel l)\n      (\u03c11 ++ (M, v) :: \u03c12)\n      ((M, v) :: \u03c11 ++ \u03c12)\n      equiv\n.\nProof.\n  unfold equivalent_with_relation, equivalent_with;\n    repeat match goal with\n           | |- exists r, Some ?R = Some r /\\ _ => exists R\n           | |- exists r, _ /\\ equivalent_rc r ?R => exists R\n           | H: _ |- _ => rewrite lookup_remove2 in H by steps\n           | _ => rewrite lookup_remove2 by steps\n           | _ => step || t_lookup_rewrite || t_idrel || t_lookup || list_utils ||\n                 rewrite obvious_lookup in * by steps ||\n                 t_lookupor || t_lookup_same\n           end;\n    eauto.\nQed.\n\nLemma idrel_lookup2:\n  forall x y l eq_dec, lookup eq_dec (idrel l) x = Some y -> x = y /\\ x \u2208 l.\nProof.\n  induction l; repeat step || eapply_any || instantiate_any.\nQed.\n\nLtac t_idrel_lookup2 :=\n  match goal with\n  | H: lookup _ (idrel ?l) ?x = Some ?y |- _ => pose proof (idrel_lookup2 _ _ _ _ H); clear H\n  end.\n\nLemma swap_idrel:\n  forall l, swap (idrel l) = idrel l.\nProof.\n  induction l; steps.\nQed.\n\nLemma equivalent_with_relation_permute2:\n  forall T \u03c11 \u03c12 v X Y l (equiv: T -> T -> Prop),\n    ~(X \u2208 support \u03c11) ->\n    (forall v, equiv v v) ->\n    equivalent_with_relation\n      ((Y, X) :: idrel l)\n      ((Y, v) :: \u03c11 ++ \u03c12)\n      (\u03c11 ++ (X, v) :: \u03c12)\n      equiv\n.\nProof.\n  unfold equivalent_with_relation, equivalent_with;\n    repeat match goal with\n           | |- exists r, Some ?R = Some r /\\ _ => exists R\n           | |- exists r, _ /\\ equivalent_rc r ?R => exists R\n           | H: _ |- _ => rewrite lookup_remove2 in H by steps\n           | _ => rewrite lookup_remove2 by steps\n           | _ => step || t_lookup_rewrite || t_idrel || t_lookup || list_utils ||\n                 rewrite obvious_lookup in * by steps ||\n                 t_lookupor || t_lookup_same\n           end;\n    eauto.\nQed.\n"}
{"text": "From Coq.Unicode Require Import Utf8.\nFrom Coq.Lists Require Import List.\nFrom Coq.Relations Require Import Relations.\nFrom Coq.micromega Require Import Lia.\n\nClass valid_language {expr : Type}\n    (is_val : expr \u2192 Prop)\n    (is_ectx : (expr \u2192 expr) \u2192 Prop)\n    (head_step : expr \u2192 expr \u2192 Prop) : Type :=\nValidLang {\n  is_val_no_head_step : \u2200 v, is_val v \u2192 \u2200 e', \u00ac head_step v e';\n  is_val_under_ectx : \u2200 e K , is_ectx K \u2192 is_val (K e) \u2192 is_val e;\n  is_ectx_id : is_ectx (\u03bb e, e);\n  is_val_dec : \u2200 e, is_val e \u2228 \u00ac is_val e;\n  ectx_head_step : \u2200 K e e', is_ectx K \u2192 head_step (K e) e' \u2192 (\u2200 f, K f = f) \u2228 is_val e;\n  ectx_inj : \u2200 K e e', is_ectx K \u2192 K e = K e' \u2192 e = e';\n  ectx_compose : \u2200 K K', is_ectx K \u2192 is_ectx K' \u2192 is_ectx (\u03bb e, K (K' e));\n  ectxs_nesting : \u2200 K e K' e',\n      is_ectx K \u2192\n      is_ectx K' \u2192\n      K e = K' e' \u2192\n      \u00ac is_val e \u2192\n      \u00ac is_val e' \u2192\n      (\u2203 K'', is_ectx K'' \u2227 \u2200 f, K f = K' (K'' f)) \u2228 (\u2203 K'', is_ectx K'' \u2227 \u2200 f, K' f = K (K'' f))\n}.\n\nInductive step {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} :\n  expr \u2192 expr \u2192 Prop :=\n| Step K e1 e2 : is_ectx K \u2192 head_step e1 e2 \u2192 step (K e1) (K e2).\n\nDefinition steps {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} :=\n  clos_refl_trans _ step.\n\nInductive nsteps {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} :\n  nat \u2192 expr \u2192 expr \u2192 Prop :=\n| NSO e : nsteps 0 e e\n| NSS n e1 e2 e3 : step e1 e2 \u2192 nsteps n e2 e3 \u2192 nsteps (S n) e1 e3.\n\nDefinition det_head_step\n  {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} e e' :=\n  head_step e e' \u2227 \u2200 e'', head_step e e'' \u2192 e'' = e'.\n\nDefinition det_step\n  {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step} e e' :=\n  step e e' \u2227 \u2200 e'', step e e'' \u2192 e'' = e'.\n\nSection language.\n  Context {expr is_val is_ectx head_step} `{@valid_language expr is_val is_ectx head_step}.\n\n  Lemma nsteps_refl e : nsteps 0 e e.\n  Proof. constructor; fail. Qed.\n\n  Lemma step_nsteps e e' : step e e' \u2192 nsteps 1 e e'.\n  Proof. econstructor; [eassumption|econstructor]. Qed.\n\n  Lemma nsteps_trans n n' e e' e'' : nsteps n e e' \u2192 nsteps n' e' e'' \u2192 nsteps (n + n') e e''.\n  Proof.\n    induction 1; [trivial; fail|].\n    simpl.\n    econstructor; [eassumption|auto].\n  Qed.\n\n  Lemma nsteps_take_step n e e' e'' :\n    step e e' \u2192 nsteps n e' e'' \u2192 nsteps (S n) e e''.\n  Proof. intros ? ?; eapply (nsteps_trans 1); [apply step_nsteps|]; eauto. Qed.\n\n  Lemma steps_ind (P : expr \u2192 expr \u2192 Prop) :\n    (\u2200 e, P e e) \u2192\n    (\u2200 e e' e'', step e e' \u2192 steps e' e'' \u2192 P e' e'' \u2192 P e e'') \u2192\n    \u2200 e e', steps e e' \u2192 P e e'.\n  Proof.\n    intros Hrfl Hstp e e' Hsteps.\n    apply clos_rt_rt1n_iff in Hsteps.\n    induction Hsteps; [apply Hrfl|].\n    eapply Hstp; [eassumption|apply clos_rt_rt1n_iff; assumption|assumption].\n  Qed.\n\n  Lemma steps_refl e : steps e e.\n  Proof. constructor; fail. Qed.\n\n  Lemma step_steps e e' : step e e' \u2192 steps e e'.\n  Proof. constructor; assumption. Qed.\n\n  Lemma steps_trans e e' e'' : steps e e' \u2192 steps e' e'' \u2192 steps e e''.\n  Proof. econstructor; eauto; fail. Qed.\n\n  Lemma steps_nsteps e e' : steps e e' \u2192 \u2203 n, nsteps n e e'.\n  Proof.\n    induction 1 as [| |? ? ? ? [n Hn] ? [k Hk]];\n      [eexists; eapply step_nsteps; assumption|exists 0; apply nsteps_refl|].\n    eexists (_ + _); eapply nsteps_trans; eauto.\n  Qed.\n\n  Lemma nsteps_steps n e e' : nsteps n e e' \u2192 steps e e'.\n  Proof.\n    induction 1; [econstructor; fail|eapply steps_trans; [apply step_steps; eassumption|trivial]].\n  Qed.\n\n  Lemma val_no_step e : is_val e \u2192 \u2200 e', \u00ac step e e'.\n  Proof.\n    intros He e' Hstp.\n    inversion Hstp as [K e1 e2 HK Hhs]; subst; clear Hstp.\n    apply is_val_under_ectx in He; [|assumption].\n    eapply is_val_no_head_step; eauto.\n  Qed.\n\n  Lemma val_steps_eq e e' : is_val e \u2192 steps e e' \u2192 e = e'.\n  Proof.\n    intros Hiv Hstps; revert Hiv.\n    pattern e; pattern e'.\n    match goal with\n    | |- (\u03bb e', (\u03bb e, ?P) _) _ => simpl; apply (steps_ind (\u03bb e e', P))\n    end; [| |assumption]; clear e' e Hstps.\n    - trivial.\n    - intros ???????.\n      exfalso; eapply val_no_step; eauto.\n  Qed.\n\n  Lemma head_step_step e e' : head_step e e' \u2192 step e e'.\n  Proof. intros; eapply (Step (\u03bb e, e)); [apply is_ectx_id|assumption]. Qed.\n\n  Lemma ectx_step e e' K : is_ectx K \u2192 step e e' \u2192 step (K e) (K e').\n  Proof.\n    intros ?; inversion 1 as [K' e1 e2]; subst.\n    eapply (Step (\u03bb e, K (K' e))); [apply ectx_compose; assumption|assumption].\n  Qed.\n\n  Lemma ectx_steps e e' K : is_ectx K \u2192 steps e e' \u2192 steps (K e) (K e').\n  Proof.\n    intros HK Hstep.\n    pattern e; pattern e'.\n    match goal with\n    | |- (\u03bb e2, (\u03bb e1, ?P) _) _ => simpl; apply (steps_ind (\u03bb e1 e2, P))\n    end; [| |assumption]; clear e e' Hstep.\n    - intros ?; apply steps_refl.\n    - intros e e' e'' Hstep Hsteps HKsteps.\n      eapply steps_trans; [apply step_steps, ectx_step|]; eassumption.\n  Qed.\n\n  Lemma steps_eq_or_step_iff e e' : steps e e' \u2194 e = e' \u2228 \u2203 e'', step e e'' \u2227 steps e'' e'.\n  Proof.\n    split.\n    - intros Hsteps; apply clos_rt_rt1n_iff in Hsteps.\n      inversion Hsteps as [|??? Hsteps']; [eauto; fail|].\n      apply clos_rt_rt1n_iff in Hsteps'; eauto.\n    - intros [->|[? [? ?]]]; apply clos_rt_rt1n_iff;\n        [constructor; fail|econstructor; [|apply clos_rt_rt1n_iff]]; eauto.\n  Qed.\n\n  Lemma step_under_ectx K e e' :\n    is_ectx K \u2192 step (K e) e' \u2192\n    (is_val e) \u2228 (\u2203 e'', step e e'' \u2227 e' = K e'').\n  Proof.\n    intros HK Hstp.\n    destruct (is_val_dec e) as [Hiv|Hniv].\n    - auto.\n    - right.\n      inversion Hstp as [K' e1 e2 HK' Hhs HKe1e]; subst.\n      destruct (ectxs_nesting _ _ _ _ HK' HK HKe1e) as [[K'' [HK''1 HK''2]]|[K'' [HK''1 HK''2]]];\n      [intros ?; contradict Hhs; apply is_val_no_head_step; assumption|assumption| |].\n      + rewrite HK''2 in HKe1e.\n        apply ectx_inj in HKe1e; [|assumption].\n        subst.\n        exists (K'' e2); rewrite HK''2; split; [|reflexivity].\n        constructor; trivial.\n      + rewrite HK''2 in HKe1e.\n        apply ectx_inj in HKe1e; [|assumption].\n        subst.\n        pose proof Hhs as Hhs'.\n        apply ectx_head_step in Hhs as [Hhs|Hhs]; [|tauto|assumption].\n        rewrite Hhs in Hhs'.\n        exists e2; split; [apply head_step_step; assumption|].\n        rewrite HK''2, Hhs; trivial.\n  Qed.\n\n  Definition Safe (P : expr \u2192 Prop) (e : expr) :=\n    \u2200 e', steps e e' \u2192 (is_val e' \u2227 P e') \u2228 \u2203 e'', step e' e''.\n\n  Lemma Safe_mono (P Q : expr \u2192 Prop) e : (\u2200 v, P v \u2192 Q v) \u2192 Safe P e \u2192 Safe Q e.\n  Proof. unfold Safe; firstorder. Qed.\n\n  Lemma Safe_val (P : expr \u2192 Prop) e : is_val e \u2192 P e \u2192 Safe P e.\n  Proof.\n    unfold Safe; intros He HPe e' Hstp.\n    left.\n    apply val_steps_eq in Hstp; subst; auto.\n  Qed.\n\n  Lemma Safe_val_inv (P : expr \u2192 Prop) e : is_val e \u2192 Safe P e \u2192 P e.\n  Proof.\n    unfold Safe; intros He HSf.\n    destruct (HSf e) as [|[e' He']]; [apply steps_refl|tauto|].\n    contradict He'; apply val_no_step; trivial.\n  Qed.\n\n  Lemma Safe_step (P : expr \u2192 Prop) e e' : step e e' \u2192 Safe P e \u2192 Safe P e'.\n  Proof.\n    intros Hstep HSf ei Hsteps.\n    apply HSf.\n    apply steps_eq_or_step_iff; eauto.\n  Qed.\n\n  Lemma det_head_step_det_step e e' : det_head_step e e' \u2192 det_step e e'.\n  Proof.\n    intros [Hhs Hdt]; split; [apply head_step_step; assumption|].\n    intros e'' Hstp.\n    inversion Hstp as [? ? ? ? Hhs']; subst.\n    apply ectx_head_step in Hhs as [Hid|Hvl]; [| |assumption].\n    - rewrite Hid; rewrite Hid in Hdt. apply Hdt; assumption.\n    - contradict Hhs'; apply is_val_no_head_step; trivial.\n  Qed.\n\n  Lemma Safe_det_step_back (P : expr \u2192 Prop) e e' : det_step e e' \u2192 Safe P e' \u2192 Safe P e.\n  Proof.\n    intros Hdstep HSf ei Hsteps.\n    apply steps_eq_or_step_iff in Hsteps as [->|(e'' & He''1 & He''2)].\n    - right; eexists; apply Hdstep.\n    - apply Hdstep in He''1; subst.\n      apply HSf; assumption.\n  Qed.\n\n  Lemma Safe_head_step_back (P : expr \u2192 Prop) e e' : det_head_step e e' \u2192 Safe P e' \u2192 Safe P e.\n  Proof.\n    intros.\n    eapply Safe_det_step_back; [apply det_head_step_det_step|]; eassumption.\n  Qed.\n\n  Lemma steps_under_ectx K e e' :\n    is_ectx K \u2192 steps (K e) e' \u2192\n    (\u2203 e'', e' = K e'' \u2227 steps e e'') \u2228 \u2203 v, is_val v \u2227 steps e v \u2227 steps (K v) e'.\n  Proof.\n    intros HK [n Hstps]%steps_nsteps.\n    revert e e' HK Hstps.\n    induction n; intros e e' HK Hstps.\n    - inversion Hstps; subst; left; eexists _; split; [eauto|apply steps_refl].\n    - inversion Hstps as [|? ? ex]; subst.\n      destruct (step_under_ectx K e ex) as [|(e'' & He''1 & He''2)];\n        [assumption|assumption| |subst].\n      + right; eexists e; split; [assumption|].\n        split; [apply steps_refl|eapply nsteps_steps; eassumption].\n      + destruct (IHn e'' e') as [(? & -> &?)|(?&?&?&?)]; [assumption|assumption| |].\n        * left; eexists; split; [reflexivity|eapply steps_trans; [apply step_steps|]; eauto].\n        * right; eexists _; split; [eassumption|].\n          split; [eapply steps_trans; [apply step_steps|]; eauto|assumption].\n  Qed.\n\n  Lemma Safe_bind (P Q : expr \u2192 Prop) e K :\n    is_ectx K \u2192 Safe P e \u2192 (\u2200 v, is_val v \u2192 P v \u2192 Safe Q (K v)) \u2192 Safe Q (K e).\n  Proof.\n    intros HK He HKSf e' Hstps.\n    apply steps_under_ectx in Hstps as [(e'' & -> & He'')|(v & Hv & Hv1 & Hv2)]; [| |assumption].\n    - apply He in He'' as [[Hie'' HPe'']|[e3 He3]].\n      + eapply HKSf; [eassumption|eassumption|apply steps_refl].\n      + right; eexists; apply ectx_step; eauto.\n    - apply He in Hv1 as [[]|[]]; [|exfalso; eapply val_no_step; eauto; fail].\n      eapply HKSf; [eassumption|assumption|assumption].\n  Qed.\n\n  Definition Normalizes (P : expr \u2192 Prop) (e : expr) := \u2203 v, is_val v \u2227 steps e v \u2227 P v.\n\n  Lemma Normalizes_mono (P Q : expr \u2192 Prop) e : (\u2200 v, P v \u2192 Q v) \u2192 Normalizes P e \u2192 Normalizes Q e.\n  Proof. unfold Safe; firstorder. Qed.\n\n  Lemma Normalizes_val (P : expr \u2192 Prop) e : is_val e \u2192 P e \u2192 Normalizes P e.\n  Proof.\n    intros ? ?; eexists; repeat split; [eassumption|apply steps_refl|eassumption].\n  Qed.\n\n  Lemma Normalizses_val_inv (P : expr \u2192 Prop) e : is_val e \u2192 Normalizes P e \u2192 P e.\n  Proof.\n    intros Hiv (e' & He'1 & He'2 & He'3).\n    apply val_steps_eq in He'2; [subst; trivial|assumption].\n  Qed.\n\n  Lemma Normalizes_step_back (P : expr \u2192 Prop) e e' : step e e' \u2192 Normalizes P e' \u2192 Normalizes P e.\n  Proof.\n    intros Hstep (v & Hv1 & Hv2 & Hv3).\n    exists v; repeat split; [assumption| |assumption].\n    apply steps_eq_or_step_iff; eauto.\n  Qed.\n\n  Lemma Normalizes_head_step_back (P : expr \u2192 Prop) e e' :\n    head_step e e' \u2192 Normalizes P e' \u2192 Normalizes P e.\n  Proof.\n    intros Hstep (v & Hv1 & Hv2 & Hv3).\n    exists v; repeat split; [assumption| |assumption].\n    apply steps_eq_or_step_iff; eauto using head_step_step.\n  Qed.\n\n  Lemma Normalizes_det_step (P : expr \u2192 Prop) e e' :\n    det_step e e' \u2192 Normalizes P e \u2192 Normalizes P e'.\n  Proof.\n    intros Hdstep (v & Hv1 & Hv2 & Hv3).\n    exists v; repeat split; [assumption| |assumption].\n    apply steps_eq_or_step_iff in Hv2 as [->|(e'' & He''1 & He''2)].\n    - destruct Hdstep as [Hstp%val_no_step ?]; tauto.\n    - pose proof He''1 as ->%Hdstep; assumption.\n  Qed.\n\n  Lemma Normalizes_bind (P Q : expr \u2192 Prop) e K :\n    is_ectx K \u2192 Normalizes P e \u2192 (\u2200 v, is_val v \u2192 P v \u2192 Normalizes Q (K v)) \u2192 Normalizes Q (K e).\n  Proof.\n    intros HK He HKnrm.\n    destruct He as (v & Hv1 & Hv2 & Hv3).\n    destruct (HKnrm v) as (w & Hw1 & Hw2 & Hw3); [assumption|assumption|].\n    exists w; repeat split; [assumption| |assumption].\n    eapply steps_trans; [|eassumption].\n    apply ectx_steps; assumption.\n  Qed.\n\n  Lemma val_nsteps_eq n e e' : is_val e \u2192 nsteps n e e' \u2192 n = 0 \u2227 e = e'.\n  Proof.\n    inversion 2; subst; [split; reflexivity|].\n    exfalso; eapply val_no_step; eauto.\n  Qed.\n\n  Lemma nsteps_eq_or_step_iff n e e' :\n    nsteps n e e' \u2194 (n = 0 \u2227 e = e') \u2228 \u2203 n' e'', n = S n' \u2227 step e e'' \u2227 nsteps n' e'' e'.\n  Proof.\n    split.\n    - intros Hsteps.\n      inversion Hsteps; subst.\n      + left; auto.\n      + right; eexists _, _; split; [reflexivity|]; split; [eassumption|eassumption].\n    - intros [[-> ->]|(?&?&->&?&?)]; [constructor|econstructor; eauto].\n  Qed.\n\n  Lemma ectx_nsteps n e e' K : is_ectx K \u2192 nsteps n e e' \u2192 nsteps n (K e) (K e').\n  Proof. induction 2; econstructor; eauto using ectx_step. Qed.\n\n  Definition SISafe (P : nat \u2192 expr \u2192 Prop) (n : nat) (e : expr) :=\n    \u2200 k e', k \u2264 n \u2192 nsteps k e e' \u2192 (is_val e' \u2227 P (n - k) e') \u2228 \u2203 e'', step e' e''.\n\n  Lemma SISafe_mono (P Q : nat \u2192 expr \u2192 Prop) n e :\n    (\u2200 n' v, n' \u2264 n \u2192 P n' v \u2192 Q n' v) \u2192 SISafe P n e \u2192 SISafe Q n e.\n  Proof.\n    intros HPQ HSf ??? Hstps.\n    apply HSf in Hstps as [?|?]; [|auto; fail|lia].\n    left; split; [tauto|apply HPQ; [lia|tauto]].\n  Qed.\n\n  Lemma SISafe_down_closed (P : nat \u2192 expr \u2192 Prop) n n' e :\n    n' \u2264 n \u2192 (\u2200 k k' e, k' \u2264 k \u2192 k \u2264 n \u2192 P k e \u2192 P k' e) \u2192 SISafe P n e \u2192 SISafe P n' e.\n  Proof.\n    intros Hle HP Hne z e' Hz Hnstps.\n    destruct (\u03bb Hle, Hne z e' Hle Hnstps) as [[? ?]|]; [lia| |right; assumption].\n    left; split; [assumption|].\n    eapply HP; [| |eassumption]; [lia|lia].\n  Qed.\n\n  Lemma SISafe_down_closed' (P : nat \u2192 expr \u2192 Prop) n n' e :\n    \u00ac is_val e \u2192 n' \u2264 n \u2192 (\u2200 k k' e, k' \u2264 k \u2192 k < n \u2192 P k e \u2192 P k' e) \u2192 SISafe P n e \u2192 SISafe P n' e.\n  Proof.\n    intros Hniv Hle HP Hne z e' Hz Hnstps.\n    destruct (\u03bb Hle, Hne z e' Hle Hnstps) as [[? ?]|]; [lia| |right; assumption].\n    inversion Hnstps; subst; [tauto|].\n    left; split; [assumption|].\n    eapply HP; [| |eassumption]; [lia|lia].\n  Qed.\n\n  Lemma SISafe_val (P : nat \u2192 expr \u2192 Prop) n e : is_val e \u2192 P n e \u2192 SISafe P n e.\n  Proof.\n    intros He HPe k e' Hk Hstp.\n    left.\n    apply val_nsteps_eq in Hstp as [? ?]; subst; [|assumption].\n    replace (n - 0) with n by lia; auto.\n  Qed.\n\n  Lemma SISafe_val_inv (P : nat \u2192 expr \u2192 Prop) n e : is_val e \u2192 SISafe P n e \u2192 P n e.\n  Proof.\n    unfold Safe; intros He HSf.\n    destruct (HSf 0 e) as [[Hiv HP]|[e' He']]; [lia|apply nsteps_refl| |].\n    - replace (n - 0) with n in HP by lia; trivial.\n    - contradict He'; apply val_no_step; trivial.\n  Qed.\n\n  Lemma SISafe_step (P : nat \u2192 expr \u2192 Prop) e e' n :\n    step e e' \u2192 SISafe P (S n) e \u2192 SISafe P n e'.\n  Proof.\n    intros Hstep HSf k ei Hk Hsteps.\n    apply (HSf (S k)); [lia|].\n    econstructor; eauto.\n  Qed.\n\n  Lemma SISafe_det_step_back (P : nat \u2192 expr \u2192 Prop) e e' n :\n    det_step e e' \u2192 (0 < n \u2192 SISafe P (n - 1) e') \u2192 SISafe P n e.\n  Proof.\n    intros Hdstep HSf k ei Hk Hsteps.\n    apply nsteps_eq_or_step_iff in Hsteps as [[-> ->]|(m & e'' & -> & He''1 & He''2)].\n    - right; eexists; apply Hdstep.\n    - apply Hdstep in He''1; subst.\n      destruct n as [|n]; [lia|].\n      pose proof (\u03bb H, HSf H m ei) as HSf'. simpl in *.\n      replace (n - 0) with n in HSf' by lia.\n      apply HSf'; [lia|lia|assumption].\n  Qed.\n\n  Lemma SISafe_head_step_back (P : nat \u2192 expr \u2192 Prop) e e' n :\n    det_head_step e e' \u2192 (0 < n \u2192 SISafe P (n - 1) e') \u2192 SISafe P n e.\n  Proof.\n    intros.\n    eapply SISafe_det_step_back; [apply det_head_step_det_step|]; eassumption.\n  Qed.\n\n  Lemma nsteps_under_ectx n K e e' :\n    is_ectx K \u2192 nsteps n (K e) e' \u2192\n    (\u2203 e'', e' = K e'' \u2227 nsteps n e e'') \u2228\n      \u2203 k v, k \u2264 n \u2227 is_val v \u2227 nsteps k e v \u2227 nsteps (n - k) (K v) e'.\n  Proof.\n    revert e e'.\n    induction n; intros e e' HK Hstps.\n    - inversion Hstps; subst; left; eexists _; split; [eauto|econstructor].\n    - inversion Hstps as [|? ? ex]; subst.\n      destruct (step_under_ectx K e ex) as [|(e'' & He''1 & He''2)];\n        [assumption|assumption| |subst].\n      + right; eexists 0, e; split; [lia|split]; [assumption|].\n        split; [econstructor|].\n        rewrite PeanoNat.Nat.sub_0_r; trivial.\n      + destruct (IHn e'' e') as [(? & -> &?)|(?&?&?&?&?&?)]; [assumption|assumption| |].\n        * left; eexists; split; [reflexivity|econstructor; eauto].\n        * right; eexists (S _), _; repeat split; [|eassumption| |eassumption]; [lia|].\n          econstructor; eauto.\n  Qed.\n\n  Lemma SISafe_bind (P Q : nat \u2192 expr \u2192 Prop) e K n :\n    is_ectx K \u2192\n    SISafe P n e \u2192\n    (\u2200 k v, k \u2264 n \u2192 is_val v \u2192 P k v \u2192 SISafe Q k (K v)) \u2192\n    SISafe Q n (K e).\n  Proof.\n    intros HK He HKSf k e' Hk Hstps.\n    apply nsteps_under_ectx in Hstps as [(e'' & -> & He'')|(m & ? & v & Hv & Hv1 & Hv2)];\n      [| |assumption].\n    - apply He in He'' as [[Hie'' HPe'']|[e3 He3]]; [| |lia].\n      + apply HKSf in HPe''; [|lia|assumption].\n        pose proof (HPe'' 0) as HPe3.\n        replace (n - k - 0) with (n - k) in HPe3 by lia.\n        apply HPe3; [lia|]; apply nsteps_refl.\n      + right; eexists; apply ectx_step; eauto.\n    - apply He in Hv1 as [[? HPkv]|[]]; [|exfalso; eapply val_no_step; eauto; fail|lia].\n      apply HKSf in HPkv; [|lia|assumption].\n      specialize (HPkv (k - m) e'); simpl in *.\n      replace (n - m - (k - m)) with (n - k) in HPkv by lia.\n      apply HPkv; [lia |assumption].\n  Qed.\n\n  Lemma SISafe_adequacy P e : (\u2200 n, SISafe (\u03bb _ v, P v) n e) \u2192 Safe P e.\n  Proof.\n    intros HSI e' [n Hstps]%steps_nsteps.\n    eapply (HSI n); [|eassumption]; lia.\n  Qed.\n\nEnd language.\n"}
{"text": "lemmas linear_scaleR_left = linear_scale_left"}
{"text": "(** Proof that for every two-parameter uncurried function, there\n    exists an equivalent curried function *)\n\nDefinition curry (f : Type * Type -> Type) x y := f (x, y).\n\nTheorem curry_exists :\n  forall (f : (Type * Type) -> Type) x y, exists g, f (x, y) = g x y.\nProof.\n  intros.\n  exists (curry f).\n  unfold curry.\n  reflexivity.\nQed.\n"}
{"text": "------------------------------------------------------------------------\n-- The Agda standard library\n--\n-- Basic definitions for morphisms between algebraic structures\n------------------------------------------------------------------------\n\n{-# OPTIONS --without-K --safe #-}\n\nopen import Relation.Binary.Core\n\nmodule Algebra.Morphism.Definitions\n  {a} (A : Set a)     -- The domain of the morphism\n  {b} (B : Set b)     -- The codomain of the morphism\n  {\u2113} (_\u2248_ : Rel B \u2113)  -- The equality relation over the codomain\n  where\n\nopen import Algebra.Core\nopen import Function.Core\n\n------------------------------------------------------------------------\n-- Basic definitions\n\nHomomorphic\u2080 : (A \u2192 B) \u2192 A \u2192 B \u2192 Set _\nHomomorphic\u2080 \u27e6_\u27e7 \u2219 \u2218 = \u27e6 \u2219 \u27e7 \u2248 \u2218\n\nHomomorphic\u2081 : (A \u2192 B) \u2192 Op\u2081 A \u2192 Op\u2081 B \u2192 Set _\nHomomorphic\u2081 \u27e6_\u27e7 \u2219_ \u2218_ = \u2200 x \u2192 \u27e6 \u2219 x \u27e7 \u2248 (\u2218 \u27e6 x \u27e7)\n\nHomomorphic\u2082 : (A \u2192 B) \u2192 Op\u2082 A \u2192 Op\u2082 B \u2192 Set _\nHomomorphic\u2082 \u27e6_\u27e7 _\u2219_ _\u2218_ = \u2200 x y \u2192 \u27e6 x \u2219 y \u27e7 \u2248 (\u27e6 x \u27e7 \u2218 \u27e6 y \u27e7)\n\n\n\n------------------------------------------------------------------------\n-- DEPRECATED NAMES\n------------------------------------------------------------------------\n-- Please use the new names as continuing support for the old names is\n-- not guaranteed.\n\n-- Version 1.3\n\nMorphism : Set _\nMorphism = A \u2192 B\n\n{-# WARNING_ON_USAGE Morphism\n\"Warning: Morphism was deprecated in v1.3.\nPlease use the standard function notation (e.g. A \u2192 B) instead.\"\n#-}\n"}
{"text": "lemma snd_quot_of_fract_to_fract [simp]: \"snd (quot_of_fract (to_fract x)) = 1\""}
{"text": "typealias IntegerVector{I<:Integer} Vector{I}\ntypealias RealVector{N<:Real} Vector{N}\ntypealias RealMatrix{N<:Real} Matrix{N}\n\ntypealias RealLowerTriangular{T<:Real, S<:AbstractMatrix} LowerTriangular{T, S}\n\nmultivecs{T}(::Type{T}, n::Int) = [T[] for _ =1:n]\n"}
{"text": "open nat\n\nexample (P : \u2115 \u2192 Prop) (h\u2080 : P 0) (h\u2081 : \u2200 n, P (succ n)) (m : \u2115) :\n  P m :=\nbegin\n  cases m with m',\n  exact h\u2080,\n  exact h\u2081 m'\nend\n"}
{"text": "[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : Discrete PUnit \u2964 C\n\u22a2 \u2200 \u2983X Y : Discrete PUnit\u2984 (f : X \u27f6 Y),\n    ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f \u226b\n        (fun x =>\n            match x with\n            | { as := PUnit.unit } =>\n              \ud835\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\n          Y =\n      (fun x =>\n            match x with\n            | { as := PUnit.unit } =>\n              \ud835\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\n          X \u226b\n        F.map f\n[PROOFSTEP]\nintro X Y f\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : Discrete PUnit \u2964 C\nX Y : Discrete PUnit\nf : X \u27f6 Y\n\u22a2 ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f \u226b\n      (fun x =>\n          match x with\n          | { as := PUnit.unit } =>\n            \ud835\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\n        Y =\n    (fun x =>\n          match x with\n          | { as := PUnit.unit } =>\n            \ud835\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\n        X \u226b\n      F.map f\n[PROOFSTEP]\nmatch X, Y, f with\n| .mk A, .mk B, .up g => aesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : Discrete PUnit \u2964 C\nX Y : Discrete PUnit\nf : X \u27f6 Y\nA B : PUnit\ng : PLift ({ as := A }.as = { as := B }.as)\n\u22a2 ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map { down := g } \u226b\n      (fun x =>\n          match x with\n          | { as := PUnit.unit } =>\n            \ud835\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\n        { as := B } =\n    (fun x =>\n          match x with\n          | { as := PUnit.unit } =>\n            \ud835\udfd9 (((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).obj { as := PUnit.unit }))\n        { as := A } \u226b\n      F.map { down := g }\n[PROOFSTEP]\naesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cone F\nj j' : J\nf : j \u27f6 j'\n\u22a2 NatTrans.app c.\u03c0 j \u226b F.map f = NatTrans.app c.\u03c0 j'\n[PROOFSTEP]\nrw [\u2190 c.\u03c0.naturality f]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cone F\nj j' : J\nf : j \u27f6 j'\n\u22a2 ((const J).obj c.pt).map f \u226b NatTrans.app c.\u03c0 j' = NatTrans.app c.\u03c0 j'\n[PROOFSTEP]\napply id_comp\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : Discrete PUnit \u2964 C\n\u22a2 \u2200 \u2983X Y : Discrete PUnit\u2984 (f : X \u27f6 Y),\n    F.map f \u226b\n        (fun x =>\n            match x with\n            | { as := PUnit.unit } => \ud835\udfd9 (F.obj { as := PUnit.unit }))\n          Y =\n      (fun x =>\n            match x with\n            | { as := PUnit.unit } => \ud835\udfd9 (F.obj { as := PUnit.unit }))\n          X \u226b\n        ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f\n[PROOFSTEP]\nintro X Y f\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : Discrete PUnit \u2964 C\nX Y : Discrete PUnit\nf : X \u27f6 Y\n\u22a2 F.map f \u226b\n      (fun x =>\n          match x with\n          | { as := PUnit.unit } => \ud835\udfd9 (F.obj { as := PUnit.unit }))\n        Y =\n    (fun x =>\n          match x with\n          | { as := PUnit.unit } => \ud835\udfd9 (F.obj { as := PUnit.unit }))\n        X \u226b\n      ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map f\n[PROOFSTEP]\nmatch X, Y, f with\n| .mk A, .mk B, .up g => aesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : Discrete PUnit \u2964 C\nX Y : Discrete PUnit\nf : X \u27f6 Y\nA B : PUnit\ng : PLift ({ as := A }.as = { as := B }.as)\n\u22a2 F.map { down := g } \u226b\n      (fun x =>\n          match x with\n          | { as := PUnit.unit } => \ud835\udfd9 (F.obj { as := PUnit.unit }))\n        { as := B } =\n    (fun x =>\n          match x with\n          | { as := PUnit.unit } => \ud835\udfd9 (F.obj { as := PUnit.unit }))\n        { as := A } \u226b\n      ((const (Discrete PUnit)).obj (F.obj { as := PUnit.unit })).map { down := g }\n[PROOFSTEP]\naesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cocone F\nj j' : J\nf : j \u27f6 j'\n\u22a2 F.map f \u226b NatTrans.app c.\u03b9 j' = NatTrans.app c.\u03b9 j\n[PROOFSTEP]\nrw [c.\u03b9.naturality f]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cocone F\nj j' : J\nf : j \u27f6 j'\n\u22a2 NatTrans.app c.\u03b9 j \u226b ((const J).obj c.pt).map f = NatTrans.app c.\u03b9 j\n[PROOFSTEP]\napply comp_id\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\n\u22a2 ((fun c => { fst := op c.pt, snd := c.\u03c0 }) \u226b fun c => { pt := c.fst.unop, \u03c0 := c.snd }) = \ud835\udfd9 (Cone F)\n[PROOFSTEP]\nfunext X\n[GOAL]\ncase h\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\nX : Cone F\n\u22a2 ((fun c => { fst := op c.pt, snd := c.\u03c0 }) \u226b fun c => { pt := c.fst.unop, \u03c0 := c.snd }) X = \ud835\udfd9 (Cone F) X\n[PROOFSTEP]\ncases X\n[GOAL]\ncase h.mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\npt\u271d : C\n\u03c0\u271d : (const J).obj pt\u271d \u27f6 F\n\u22a2 ((fun c => { fst := op c.pt, snd := c.\u03c0 }) \u226b fun c => { pt := c.fst.unop, \u03c0 := c.snd }) { pt := pt\u271d, \u03c0 := \u03c0\u271d } =\n    \ud835\udfd9 (Cone F) { pt := pt\u271d, \u03c0 := \u03c0\u271d }\n[PROOFSTEP]\nrfl\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\n\u22a2 ((fun c => { pt := c.fst.unop, \u03c0 := c.snd }) \u226b fun c => { fst := op c.pt, snd := c.\u03c0 }) =\n    \ud835\udfd9 ((X : C\u1d52\u1d56) \u00d7 (Functor.cones F).obj X)\n[PROOFSTEP]\nfunext X\n[GOAL]\ncase h\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\nX : (X : C\u1d52\u1d56) \u00d7 (Functor.cones F).obj X\n\u22a2 ((fun c => { pt := c.fst.unop, \u03c0 := c.snd }) \u226b fun c => { fst := op c.pt, snd := c.\u03c0 }) X =\n    \ud835\udfd9 ((X : C\u1d52\u1d56) \u00d7 (Functor.cones F).obj X) X\n[PROOFSTEP]\ncases X\n[GOAL]\ncase h.mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\nfst\u271d : C\u1d52\u1d56\nsnd\u271d : (Functor.cones F).obj fst\u271d\n\u22a2 ((fun c => { pt := c.fst.unop, \u03c0 := c.snd }) \u226b fun c => { fst := op c.pt, snd := c.\u03c0 }) { fst := fst\u271d, snd := snd\u271d } =\n    \ud835\udfd9 ((X : C\u1d52\u1d56) \u00d7 (Functor.cones F).obj X) { fst := fst\u271d, snd := snd\u271d }\n[PROOFSTEP]\nrfl\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\n\u22a2 ((fun c => { fst := c.pt, snd := c.\u03b9 }) \u226b fun c => { pt := c.fst, \u03b9 := c.snd }) = \ud835\udfd9 (Cocone F)\n[PROOFSTEP]\nfunext X\n[GOAL]\ncase h\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\nX : Cocone F\n\u22a2 ((fun c => { fst := c.pt, snd := c.\u03b9 }) \u226b fun c => { pt := c.fst, \u03b9 := c.snd }) X = \ud835\udfd9 (Cocone F) X\n[PROOFSTEP]\ncases X\n[GOAL]\ncase h.mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\npt\u271d : C\n\u03b9\u271d : F \u27f6 (const J).obj pt\u271d\n\u22a2 ((fun c => { fst := c.pt, snd := c.\u03b9 }) \u226b fun c => { pt := c.fst, \u03b9 := c.snd }) { pt := pt\u271d, \u03b9 := \u03b9\u271d } =\n    \ud835\udfd9 (Cocone F) { pt := pt\u271d, \u03b9 := \u03b9\u271d }\n[PROOFSTEP]\nrfl\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\n\u22a2 ((fun c => { pt := c.fst, \u03b9 := c.snd }) \u226b fun c => { fst := c.pt, snd := c.\u03b9 }) =\n    \ud835\udfd9 ((X : C) \u00d7 (Functor.cocones F).obj X)\n[PROOFSTEP]\nfunext X\n[GOAL]\ncase h\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\nX : (X : C) \u00d7 (Functor.cocones F).obj X\n\u22a2 ((fun c => { pt := c.fst, \u03b9 := c.snd }) \u226b fun c => { fst := c.pt, snd := c.\u03b9 }) X =\n    \ud835\udfd9 ((X : C) \u00d7 (Functor.cocones F).obj X) X\n[PROOFSTEP]\ncases X\n[GOAL]\ncase h.mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF\u271d F : J \u2964 C\nfst\u271d : C\nsnd\u271d : (Functor.cocones F).obj fst\u271d\n\u22a2 ((fun c => { pt := c.fst, \u03b9 := c.snd }) \u226b fun c => { fst := c.pt, snd := c.\u03b9 }) { fst := fst\u271d, snd := snd\u271d } =\n    \ud835\udfd9 ((X : C) \u00d7 (Functor.cocones F).obj X) { fst := fst\u271d, snd := snd\u271d }\n[PROOFSTEP]\nrfl\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc c' : Cone F\nf g : c \u27f6 c'\nw : f.Hom = g.Hom\n\u22a2 f = g\n[PROOFSTEP]\ncases f\n[GOAL]\ncase mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc c' : Cone F\ng : c \u27f6 c'\nHom\u271d : c.pt \u27f6 c'.pt\nw\u271d : \u2200 (j : J), Hom\u271d \u226b NatTrans.app c'.\u03c0 j = NatTrans.app c.\u03c0 j\nw : (mk Hom\u271d).Hom = g.Hom\n\u22a2 mk Hom\u271d = g\n[PROOFSTEP]\ncases g\n[GOAL]\ncase mk.mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc c' : Cone F\nHom\u271d\u00b9 : c.pt \u27f6 c'.pt\nw\u271d\u00b9 : \u2200 (j : J), Hom\u271d\u00b9 \u226b NatTrans.app c'.\u03c0 j = NatTrans.app c.\u03c0 j\nHom\u271d : c.pt \u27f6 c'.pt\nw\u271d : \u2200 (j : J), Hom\u271d \u226b NatTrans.app c'.\u03c0 j = NatTrans.app c.\u03c0 j\nw : (mk Hom\u271d\u00b9).Hom = (mk Hom\u271d).Hom\n\u22a2 mk Hom\u271d\u00b9 = mk Hom\u271d\n[PROOFSTEP]\ncongr\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF K : J \u2964 C\nc d : Cone K\nf : c \u27f6 d\ni : IsIso f.Hom\n\u22a2 f \u226b ConeMorphism.mk (inv f.Hom) = \ud835\udfd9 c \u2227 ConeMorphism.mk (inv f.Hom) \u226b f = \ud835\udfd9 d\n[PROOFSTEP]\naesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\ne : K \u224c J\ns : Cone (e.functor \u22d9 F)\n\u22a2 \u2200 (j : K),\n    NatTrans.app\n        (((whiskering e.inverse \u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \u22d9 whiskering e.functor).obj s).\u03c0 j =\n      (Iso.refl\n            (((whiskering e.inverse \u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \u22d9 whiskering e.functor).obj\n                s).pt).hom \u226b\n        NatTrans.app ((\ud835\udfed (Cone (e.functor \u22d9 F))).obj s).\u03c0 j\n[PROOFSTEP]\nintro k\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\ne : K \u224c J\ns : Cone (e.functor \u22d9 F)\nk : K\n\u22a2 NatTrans.app\n      (((whiskering e.inverse \u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \u22d9 whiskering e.functor).obj s).\u03c0 k =\n    (Iso.refl\n          (((whiskering e.inverse \u22d9 postcompose (Equivalence.invFunIdAssoc e F).hom) \u22d9 whiskering e.functor).obj\n              s).pt).hom \u226b\n      NatTrans.app ((\ud835\udfed (Cone (e.functor \u22d9 F))).obj s).\u03c0 k\n[PROOFSTEP]\nsimpa [e.counit_app_functor] using s.w (e.unitInv.app k)\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nA : Cone F\n\u22a2 \u2200 \u2983X Y : J\u2984 (f : X \u27f6 Y),\n    ((const J).obj (G.obj A.pt)).map f \u226b (fun j => G.map (NatTrans.app A.\u03c0 j)) Y =\n      (fun j => G.map (NatTrans.app A.\u03c0 j)) X \u226b (F \u22d9 G).map f\n[PROOFSTEP]\nintros\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nA : Cone F\nX\u271d Y\u271d : J\nf\u271d : X\u271d \u27f6 Y\u271d\n\u22a2 ((const J).obj (G.obj A.pt)).map f\u271d \u226b (fun j => G.map (NatTrans.app A.\u03c0 j)) Y\u271d =\n    (fun j => G.map (NatTrans.app A.\u03c0 j)) X\u271d \u226b (F \u22d9 G).map f\u271d\n[PROOFSTEP]\nerw [\u2190 G.map_comp]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nA : Cone F\nX\u271d Y\u271d : J\nf\u271d : X\u271d \u27f6 Y\u271d\n\u22a2 ((const J).obj (G.obj A.pt)).map f\u271d \u226b (fun j => G.map (NatTrans.app A.\u03c0 j)) Y\u271d =\n    G.map (NatTrans.app A.\u03c0 X\u271d \u226b F.map f\u271d)\n[PROOFSTEP]\naesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nX\u271d Y\u271d : Cone F\nf : X\u271d \u27f6 Y\u271d\nj : J\n\u22a2 G.map f.Hom \u226b\n      NatTrans.app ((fun A => { pt := G.obj A.pt, \u03c0 := NatTrans.mk fun j => G.map (NatTrans.app A.\u03c0 j) }) Y\u271d).\u03c0 j =\n    NatTrans.app ((fun A => { pt := G.obj A.pt, \u03c0 := NatTrans.mk fun j => G.map (NatTrans.app A.\u03c0 j) }) X\u271d).\u03c0 j\n[PROOFSTEP]\nsimp [-ConeMorphism.w, \u2190 f.w j]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d\u00b9 : Full G\ninst\u271d : Faithful G\nX\u271d Y\u271d : Cone F\nt : (functoriality F G).obj X\u271d \u27f6 (functoriality F G).obj Y\u271d\nj : J\n\u22a2 G.map (G.preimage t.Hom \u226b NatTrans.app Y\u271d.\u03c0 j) = G.map (NatTrans.app X\u271d.\u03c0 j)\n[PROOFSTEP]\nsimpa using t.w j\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d : Faithful G\nc c' : Cone F\nf g : c \u27f6 c'\ne : (functoriality F G).map f = (functoriality F G).map g\n\u22a2 f = g\n[PROOFSTEP]\napply ConeMorphism.ext f g\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d : Faithful G\nc c' : Cone F\nf g : c \u27f6 c'\ne : (functoriality F G).map f = (functoriality F G).map g\n\u22a2 f.Hom = g.Hom\n[PROOFSTEP]\nlet f := ConeMorphism.mk.inj e\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d : Faithful G\nc c' : Cone F\nf\u271d g : c \u27f6 c'\ne : (functoriality F G).map f\u271d = (functoriality F G).map g\nf : G.map f\u271d.Hom = G.map g.Hom := ConeMorphism.mk.inj e\n\u22a2 f\u271d.Hom = g.Hom\n[PROOFSTEP]\napply G.map_injective f\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d : ReflectsIsomorphisms F\nK : J \u2964 C\n\u22a2 ReflectsIsomorphisms (functoriality K F)\n[PROOFSTEP]\nconstructor\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d : ReflectsIsomorphisms F\nK : J \u2964 C\n\u22a2 \u2200 {A B : Cone K} (f : A \u27f6 B) [inst : IsIso ((functoriality K F).map f)], IsIso f\n[PROOFSTEP]\nintro A B f _\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d\u00b9 : ReflectsIsomorphisms F\nK : J \u2964 C\nA B : Cone K\nf : A \u27f6 B\ninst\u271d : IsIso ((functoriality K F).map f)\n\u22a2 IsIso f\n[PROOFSTEP]\nhaveI : IsIso (F.map f.Hom) := (Cones.forget (K \u22d9 F)).map_isIso ((Cones.functoriality K F).map f)\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d\u00b9 : ReflectsIsomorphisms F\nK : J \u2964 C\nA B : Cone K\nf : A \u27f6 B\ninst\u271d : IsIso ((functoriality K F).map f)\nthis : IsIso (F.map f.Hom)\n\u22a2 IsIso f\n[PROOFSTEP]\nhaveI := ReflectsIsomorphisms.reflects F f.Hom\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d\u00b9 : ReflectsIsomorphisms F\nK : J \u2964 C\nA B : Cone K\nf : A \u27f6 B\ninst\u271d : IsIso ((functoriality K F).map f)\nthis\u271d : IsIso (F.map f.Hom)\nthis : IsIso f.Hom\n\u22a2 IsIso f\n[PROOFSTEP]\napply cone_iso_of_hom_iso\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc c' : Cocone F\nf g : c \u27f6 c'\nw : f.Hom = g.Hom\n\u22a2 f = g\n[PROOFSTEP]\ncases f\n[GOAL]\ncase mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc c' : Cocone F\ng : c \u27f6 c'\nHom\u271d : c.pt \u27f6 c'.pt\nw\u271d : \u2200 (j : J), NatTrans.app c.\u03b9 j \u226b Hom\u271d = NatTrans.app c'.\u03b9 j\nw : (mk Hom\u271d).Hom = g.Hom\n\u22a2 mk Hom\u271d = g\n[PROOFSTEP]\ncases g\n[GOAL]\ncase mk.mk\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc c' : Cocone F\nHom\u271d\u00b9 : c.pt \u27f6 c'.pt\nw\u271d\u00b9 : \u2200 (j : J), NatTrans.app c.\u03b9 j \u226b Hom\u271d\u00b9 = NatTrans.app c'.\u03b9 j\nHom\u271d : c.pt \u27f6 c'.pt\nw\u271d : \u2200 (j : J), NatTrans.app c.\u03b9 j \u226b Hom\u271d = NatTrans.app c'.\u03b9 j\nw : (mk Hom\u271d\u00b9).Hom = (mk Hom\u271d).Hom\n\u22a2 mk Hom\u271d\u00b9 = mk Hom\u271d\n[PROOFSTEP]\ncongr\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF K : J \u2964 C\nc d : Cocone K\nf : c \u27f6 d\ni : IsIso f.Hom\n\u22a2 f \u226b CoconeMorphism.mk (inv f.Hom) = \ud835\udfd9 c \u2227 CoconeMorphism.mk (inv f.Hom) \u226b f = \ud835\udfd9 d\n[PROOFSTEP]\naesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\ne : K \u224c J\ns : Cocone (e.functor \u22d9 F)\nk : K\n\u22a2 NatTrans.app\n        (((whiskering e.inverse \u22d9\n                  precompose\n                    ((leftUnitor F).inv \u226b whiskerRight e.counitIso.inv F \u226b (associator e.inverse e.functor F).inv)) \u22d9\n                whiskering e.functor).obj\n            s).\u03b9\n        k \u226b\n      (Iso.refl\n          (((whiskering e.inverse \u22d9\n                    precompose\n                      ((leftUnitor F).inv \u226b whiskerRight e.counitIso.inv F \u226b (associator e.inverse e.functor F).inv)) \u22d9\n                  whiskering e.functor).obj\n              s).pt).hom =\n    NatTrans.app ((\ud835\udfed (Cocone (e.functor \u22d9 F))).obj s).\u03b9 k\n[PROOFSTEP]\nsimpa [e.counitInv_app_functor k] using s.w (e.unit.app k)\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nA : Cocone F\n\u22a2 \u2200 \u2983X Y : J\u2984 (f : X \u27f6 Y),\n    (F \u22d9 G).map f \u226b (fun j => G.map (NatTrans.app A.\u03b9 j)) Y =\n      (fun j => G.map (NatTrans.app A.\u03b9 j)) X \u226b ((const J).obj (G.obj A.pt)).map f\n[PROOFSTEP]\nintros\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nA : Cocone F\nX\u271d Y\u271d : J\nf\u271d : X\u271d \u27f6 Y\u271d\n\u22a2 (F \u22d9 G).map f\u271d \u226b (fun j => G.map (NatTrans.app A.\u03b9 j)) Y\u271d =\n    (fun j => G.map (NatTrans.app A.\u03b9 j)) X\u271d \u226b ((const J).obj (G.obj A.pt)).map f\u271d\n[PROOFSTEP]\nerw [\u2190 G.map_comp]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nA : Cocone F\nX\u271d Y\u271d : J\nf\u271d : X\u271d \u27f6 Y\u271d\n\u22a2 G.map (F.map f\u271d \u226b NatTrans.app A.\u03b9 Y\u271d) =\n    (fun j => G.map (NatTrans.app A.\u03b9 j)) X\u271d \u226b ((const J).obj (G.obj A.pt)).map f\u271d\n[PROOFSTEP]\naesop_cat\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nX\u271d Y\u271d : Cocone F\nf : X\u271d \u27f6 Y\u271d\n\u22a2 \u2200 (j : J),\n    NatTrans.app ((fun A => { pt := G.obj A.pt, \u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\u03b9 j) }) X\u271d).\u03b9 j \u226b\n        G.map f.Hom =\n      NatTrans.app ((fun A => { pt := G.obj A.pt, \u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\u03b9 j) }) Y\u271d).\u03b9 j\n[PROOFSTEP]\nintros\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\nX\u271d Y\u271d : Cocone F\nf : X\u271d \u27f6 Y\u271d\nj\u271d : J\n\u22a2 NatTrans.app ((fun A => { pt := G.obj A.pt, \u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\u03b9 j) }) X\u271d).\u03b9 j\u271d \u226b\n      G.map f.Hom =\n    NatTrans.app ((fun A => { pt := G.obj A.pt, \u03b9 := NatTrans.mk fun j => G.map (NatTrans.app A.\u03b9 j) }) Y\u271d).\u03b9 j\u271d\n[PROOFSTEP]\nrw [\u2190 Functor.map_comp, CoconeMorphism.w]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d\u00b9 : Full G\ninst\u271d : Faithful G\nX\u271d Y\u271d : Cocone F\nt : (functoriality F G).obj X\u271d \u27f6 (functoriality F G).obj Y\u271d\nj : J\n\u22a2 G.map (NatTrans.app X\u271d.\u03b9 j \u226b G.preimage t.Hom) = G.map (NatTrans.app Y\u271d.\u03b9 j)\n[PROOFSTEP]\nsimpa using t.w j\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d : Faithful G\nX Y : Cocone F\nf g : X \u27f6 Y\ne : (functoriality F G).map f = (functoriality F G).map g\n\u22a2 f = g\n[PROOFSTEP]\napply CoconeMorphism.ext\n[GOAL]\ncase w\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d : Faithful G\nX Y : Cocone F\nf g : X \u27f6 Y\ne : (functoriality F G).map f = (functoriality F G).map g\n\u22a2 f.Hom = g.Hom\n[PROOFSTEP]\nlet h := CoconeMorphism.mk.inj e\n[GOAL]\ncase w\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ninst\u271d : Faithful G\nX Y : Cocone F\nf g : X \u27f6 Y\ne : (functoriality F G).map f = (functoriality F G).map g\nh : G.map f.Hom = G.map g.Hom := CoconeMorphism.mk.inj e\n\u22a2 f.Hom = g.Hom\n[PROOFSTEP]\napply G.map_injective h\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nG : C \u2964 D\ne : C \u224c D\nf : (F \u22d9 e.functor) \u22d9 e.inverse \u2245 F :=\n  associator F e.functor e.inverse \u226a\u226b isoWhiskerLeft F e.unitIso.symm \u226a\u226b rightUnitor F\nc : Cocone (F \u22d9 e.functor)\nj : J\n\u22a2 NatTrans.app\n        (((functoriality (F \u22d9 e.functor) e.inverse \u22d9 (precomposeEquivalence f.symm).functor) \u22d9\n                functoriality F e.functor).obj\n            c).\u03b9\n        j \u226b\n      (e.counitIso.app c.pt).hom =\n    NatTrans.app ((\ud835\udfed (Cocone (F \u22d9 e.functor))).obj c).\u03b9 j\n[PROOFSTEP]\nsimp [\u2190 Equivalence.counitInv_app_functor]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d : ReflectsIsomorphisms F\nK : J \u2964 C\n\u22a2 ReflectsIsomorphisms (functoriality K F)\n[PROOFSTEP]\nconstructor\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2074 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u00b3 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b2 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b9 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d : ReflectsIsomorphisms F\nK : J \u2964 C\n\u22a2 \u2200 {A B : Cocone K} (f : A \u27f6 B) [inst : IsIso ((functoriality K F).map f)], IsIso f\n[PROOFSTEP]\nintro A B f _\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d\u00b9 : ReflectsIsomorphisms F\nK : J \u2964 C\nA B : Cocone K\nf : A \u27f6 B\ninst\u271d : IsIso ((functoriality K F).map f)\n\u22a2 IsIso f\n[PROOFSTEP]\nhaveI : IsIso (F.map f.Hom) := (Cocones.forget (K \u22d9 F)).map_isIso ((Cocones.functoriality K F).map f)\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d\u00b9 : ReflectsIsomorphisms F\nK : J \u2964 C\nA B : Cocone K\nf : A \u27f6 B\ninst\u271d : IsIso ((functoriality K F).map f)\nthis : IsIso (F.map f.Hom)\n\u22a2 IsIso f\n[PROOFSTEP]\nhaveI := ReflectsIsomorphisms.reflects F f.Hom\n[GOAL]\ncase reflects\nJ : Type u\u2081\ninst\u271d\u2075 : Category.{v\u2081, u\u2081} J\nK\u271d : Type u\u2082\ninst\u271d\u2074 : Category.{v\u2082, u\u2082} K\u271d\nC : Type u\u2083\ninst\u271d\u00b3 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d\u00b2 : Category.{v\u2084, u\u2084} D\nF\u271d : J \u2964 C\nG F : C \u2964 D\ninst\u271d\u00b9 : ReflectsIsomorphisms F\nK : J \u2964 C\nA B : Cocone K\nf : A \u27f6 B\ninst\u271d : IsIso ((functoriality K F).map f)\nthis\u271d : IsIso (F.map f.Hom)\nthis : IsIso f.Hom\n\u22a2 IsIso f\n[PROOFSTEP]\napply cocone_iso_of_hom_iso\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX Y : Cocone F\nf : X \u27f6 Y\nj : J\u1d52\u1d56\n\u22a2 f.Hom.op \u226b NatTrans.app (Cocone.op X).\u03c0 j = NatTrans.app (Cocone.op Y).\u03c0 j\n[PROOFSTEP]\napply Quiver.Hom.unop_inj\n[GOAL]\ncase a\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX Y : Cocone F\nf : X \u27f6 Y\nj : J\u1d52\u1d56\n\u22a2 (f.Hom.op \u226b NatTrans.app (Cocone.op X).\u03c0 j).unop = (NatTrans.app (Cocone.op Y).\u03c0 j).unop\n[PROOFSTEP]\ndsimp\n[GOAL]\ncase a\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX Y : Cocone F\nf : X \u27f6 Y\nj : J\u1d52\u1d56\n\u22a2 NatTrans.app X.\u03b9 j.unop \u226b f.Hom = NatTrans.app Y.\u03b9 j.unop\n[PROOFSTEP]\napply CoconeMorphism.w\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX Y : (Cone F.op)\u1d52\u1d56\nf : X \u27f6 Y\nj : J\n\u22a2 NatTrans.app ((fun c => Cone.unop c.unop) X).\u03b9 j \u226b f.unop.Hom.unop = NatTrans.app ((fun c => Cone.unop c.unop) Y).\u03b9 j\n[PROOFSTEP]\napply Quiver.Hom.op_inj\n[GOAL]\ncase a\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX Y : (Cone F.op)\u1d52\u1d56\nf : X \u27f6 Y\nj : J\n\u22a2 (NatTrans.app ((fun c => Cone.unop c.unop) X).\u03b9 j \u226b f.unop.Hom.unop).op =\n    (NatTrans.app ((fun c => Cone.unop c.unop) Y).\u03b9 j).op\n[PROOFSTEP]\ndsimp\n[GOAL]\ncase a\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX Y : (Cone F.op)\u1d52\u1d56\nf : X \u27f6 Y\nj : J\n\u22a2 f.unop.Hom \u226b NatTrans.app X.unop.\u03c0 (op j) = NatTrans.app Y.unop.\u03c0 (op j)\n[PROOFSTEP]\napply ConeMorphism.w\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : (Cone F.op)\u1d52\u1d56\n\u22a2 (Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop } \u22d9\n          Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\n      c \u2245\n    (\ud835\udfed (Cone F.op)\u1d52\u1d56).obj c\n[PROOFSTEP]\ninduction c\n[GOAL]\ncase h\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX\u271d : Cone F.op\n\u22a2 (Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop } \u22d9\n          Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\n      (op X\u271d) \u2245\n    (\ud835\udfed (Cone F.op)\u1d52\u1d56).obj (op X\u271d)\n[PROOFSTEP]\napply Iso.op\n[GOAL]\ncase h.\u03b1\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX\u271d : Cone F.op\n\u22a2 X\u271d \u2245\n    Cocone.op\n      ((Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop }).obj\n        (op X\u271d))\n[PROOFSTEP]\nexact Cones.ext (Iso.refl _)\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nX Y : (Cone F.op)\u1d52\u1d56\nf : X \u27f6 Y\n\u22a2 ((Functor.mk { obj := fun c => Cone.unop c.unop, map := fun {X Y} f => CoconeMorphism.mk f.unop.Hom.unop } \u22d9\n                Functor.mk\n                  { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\n            f \u226b\n          ((fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c) Y).hom).unop.Hom =\n    (((fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c) X).hom \u226b\n          (\ud835\udfed (Cone F.op)\u1d52\u1d56).map f).unop.Hom\n[PROOFSTEP]\nsimp\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cocone F\n\u22a2 (Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\n        (NatTrans.app (NatIso.ofComponents fun c => Cocones.ext (Iso.refl ((\ud835\udfed (Cocone F)).obj c).pt)).hom c) \u226b\n      NatTrans.app (NatIso.ofComponents fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c).hom\n        ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj c) =\n    \ud835\udfd9 ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj c)\n[PROOFSTEP]\napply Quiver.Hom.unop_inj\n[GOAL]\ncase a\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cocone F\n\u22a2 ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\n          (NatTrans.app (NatIso.ofComponents fun c => Cocones.ext (Iso.refl ((\ud835\udfed (Cocone F)).obj c).pt)).hom c) \u226b\n        NatTrans.app (NatIso.ofComponents fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c).hom\n          ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\n            c)).unop =\n    (\ud835\udfd9\n        ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\n          c)).unop\n[PROOFSTEP]\napply ConeMorphism.ext\n[GOAL]\ncase a.w\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cocone F\n\u22a2 ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).map\n            (NatTrans.app (NatIso.ofComponents fun c => Cocones.ext (Iso.refl ((\ud835\udfed (Cocone F)).obj c).pt)).hom c) \u226b\n          NatTrans.app (NatIso.ofComponents fun c => Opposite.rec' (fun X => Iso.op (Cones.ext (Iso.refl X.pt))) c).hom\n            ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\n              c)).unop.Hom =\n    (\ud835\udfd9\n          ((Functor.mk { obj := fun c => op (Cocone.op c), map := fun {X Y} f => (ConeMorphism.mk f.Hom.op).op }).obj\n            c)).unop.Hom\n[PROOFSTEP]\ndsimp\n[GOAL]\ncase a.w\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\nc : Cocone F\n\u22a2 \ud835\udfd9 (op c.pt) \u226b \ud835\udfd9 (op c.pt) = \ud835\udfd9 (op c.pt)\n[PROOFSTEP]\napply comp_id\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\u1d52\u1d56\nc : Cone F.leftOp\nj : J\n\u22a2 NatTrans.app (coconeOfConeLeftOp c).\u03b9 j = (NatTrans.app c.\u03c0 (op j)).op\n[PROOFSTEP]\ndsimp only [coconeOfConeLeftOp]\n[GOAL]\nJ : Type u\u2081\ninst\u271d\u00b3 : Category.{v\u2081, u\u2081} J\nK : Type u\u2082\ninst\u271d\u00b2 : Category.{v\u2082, u\u2082} K\nC : Type u\u2083\ninst\u271d\u00b9 : Category.{v\u2083, u\u2083} C\nD : Type u\u2084\ninst\u271d : Category.{v\u2084, u\u2084} D\nF : J \u2964 C\u1d52\u1d56\nc : Cone F.leftOp\nj : J\n\u22a2 NatTrans.app (NatTrans.removeLeftOp c.\u03c0) j = (NatTrans.app c.\u03c0 (op j)).op\n[PROOFSTEP]\nsimp\n"}
{"text": "lemma interior_UNIV [simp]: \"interior UNIV = UNIV\""}
{"text": "Check Engine Light - What Does It Mean?\nThe Check Engine Light (CEL) is an integral part of your vehicle\u2019s Onboard Diagnostics System. The problem is that an illuminated CEL can mean pretty much anything: Your gas cap could be loose or, in a worst case scenario, your engine could be malfunctioning.\nReally, the CEL is merely an indicator something in or on the vehicle is (most likely) not performing as it should. Once the vehicle\u2019s electronic control system finds a problem it cannot adjust it will illuminate the warning light and store a code in its memory indicating the problem.\nIn 1996 vehicle manufacturers were required to adopt standardized diagnostic trouble codes, and nowadays mechanics can quickly diagnose problems simply by inserting a device into the vehicle that reads these codes (called a \u2018Code Reader\u2019). In fact, mechanically inclined readers can even purchase a Code Reader at a hardware store and insert and read the vehicles code themselves.\nHowever, there a few things to consider before you purchase a code reader: For example, the problem isn\u2019t always what\u2019s indicated in the code. The code could indicate a faulty battery, when in fact the wires connected to the battery have simply been frayed over time. Purchasing a new battery might also be a good idea, but the CEL likely won\u2019t turn off until the faulty wires are also replaced.\nIn truth, your dealer or mechanic is best suited to fix your CEL. They have invested thousands in equipment to be able to properly service your vehicle and no one knows your vehicle better than a certified mechanic.\nBest of all, the ODB scan is (likely) covered under your factory warranty, so you won\u2019t pay a cent. Those not covered under warranty will pay $125 at WallceChev, which includes a full scan, diagnostic assessment, and work order. We\u2019ll also fully explain the problem, what caused it and the steps to get you back on the road, safely.\nIgnoring the problem can also be a bad idea: We frequently see vehicles with repairs that could be avoided had the issue been diagnosed earlier. A healthy car is a happy car!\nNow that you know how to turn off the CEL\u2026 do you know what could cause your Check Engline Light to switch on?"}
{"text": "(*  Author: Lukas Bulwahn <lukas.bulwahn-at-gmail.com> *)\n\nsection \\<open>Cardinality of Number Partitions\\<close>\n\ntheory Card_Number_Partitions\nimports Number_Partition\nbegin\n\nsubsection \\<open>The Partition Function\\<close>\n\nfun Partition :: \"nat \\<Rightarrow> nat \\<Rightarrow> nat\"\nwhere\n  \"Partition 0 0 = 1\"\n| \"Partition 0 (Suc k) = 0\"\n| \"Partition (Suc m) 0 = 0\"\n| \"Partition (Suc m) (Suc k) = Partition m k + Partition (m - k) (Suc k)\"\n\nlemma Partition_less:\n  assumes \"m < k\"\n  shows \"Partition m k = 0\"\nusing assms by (induct m k rule: Partition.induct) auto\n\nlemma Partition_sum_Partition_diff:\n  assumes \"k \\<le> m\"\n  shows \"Partition m k = (\\<Sum>i\\<le>k. Partition (m - k) i)\"\nusing assms by (induct m k rule: Partition.induct) auto\n\nlemma Partition_parts1:\n  \"Partition (Suc m) (Suc 0) = 1\"\nby (induct m) auto\n\nlemma Partition_diag:\n  \"Partition (Suc m) (Suc m) = 1\"\nby (induct m) auto\n\nlemma Partition_diag1:\n  \"Partition (Suc (Suc m)) (Suc m) = 1\"\nby (induct m) auto\n\nlemma Partition_parts2:\n  shows \"Partition m 2 = m div 2\"\nproof (induct m rule: nat_less_induct)\n  fix m\n  assume hypothesis: \"\\<forall>n<m. Partition n 2 = n div 2\"\n  have \"(m = 0 \\<or> m = 1) \\<or> m \\<ge> 2\" by auto\n  from this show \"Partition m 2 = m div 2\"\n  proof\n    assume \"m = 0 \\<or> m = 1\"\n    from this show ?thesis by (auto simp add: numerals(2))\n  next\n    assume \"2 \\<le> m\"\n    from this obtain m' where m': \"m = Suc (Suc m')\" by (metis add_2_eq_Suc le_Suc_ex)\n    from hypothesis this have \"Partition m' 2 = m' div 2\" by simp\n    from this m' show ?thesis\n      using Partition_parts1 Partition.simps(4)[of \"Suc m'\" \"Suc 0\"] div2_Suc_Suc\n      by (simp add: numerals(2) del: Partition.simps)\n  qed\nqed\n\nsubsection \\<open>Cardinality of Number Partitions\\<close>\n\nlemma set_rewrite1:\n  \"{p. p partitions Suc m \\<and> sum p {..Suc m} = Suc k \\<and> p 1 \\<noteq> 0}\n    = (\\<lambda>p. p(1 := p 1 + 1)) ` {p. p partitions m \\<and> sum p {..m} = k}\" (is \"?S = ?T\")\nproof\n  {\n    fix p\n    assume assms: \"p partitions Suc m\" \"sum p {..Suc m} = Suc k\" \"0 < p 1\"\n    have \"p(1 := p 1 - 1) partitions m\"\n      using assms by (metis partitions_remove1 diff_Suc_1)\n    moreover have \"(\\<Sum>i\\<le>m. (p(1 := p 1 - 1)) i) = k\"\n      using assms by (metis count_remove1 diff_Suc_1)\n    ultimately have \"p(1 := p 1 - 1) \\<in> {p. p partitions m \\<and> sum p {..m} = k}\" by simp\n    moreover have \"p = p(1 := p 1 - 1, 1 := (p(1 := p 1 - 1)) 1 + 1)\"\n      using \\<open>0 < p 1\\<close> by auto\n    ultimately have \"p \\<in> (\\<lambda>p. p(1 := p 1 + 1)) ` {p. p partitions m \\<and> sum p {..m} = k}\" by blast\n  }\n  from this show \"?S \\<subseteq> ?T\" by blast\nnext\n  {\n    fix p\n    assume assms: \"p partitions m\" \"sum p {..m} = k\"\n    have \"(p(1 := p 1 + 1)) partitions Suc m\" (is ?g1)\n      using assms by (metis partitions_insert1 Suc_eq_plus1 zero_less_one)\n    moreover have \"sum (p(1 := p 1 + 1)) {..Suc m} = Suc k\" (is ?g2)\n      using assms by (metis count_insert1 Suc_eq_plus1)\n    moreover have \"(p(1 := p 1 + 1)) 1 \\<noteq> 0\" (is ?g3) by auto\n    ultimately have \"?g1 \\<and> ?g2 \\<and> ?g3\" by simp\n  }\n  from this show \"?T \\<subseteq> ?S\" by auto\nqed\n\nlemma set_rewrite2:\n  \"{p. p partitions m \\<and> sum p {..m} = k \\<and> p 1 = 0}\n    = (\\<lambda>p. (\\<lambda>i. p (i - 1))) ` {p. p partitions (m - k) \\<and> sum p {..m - k} = k}\"\n  (is \"?S = ?T\")\nproof\n  {\n    fix p\n    assume assms: \"p partitions m\" \"sum p {..m} = k\" \"p 1 = 0\"\n    have \"(\\<lambda>i. p (i + 1)) partitions m - k\"\n      using assms partitions_decrease1 by blast\n    moreover from assms have \"sum (\\<lambda>i. p (i + 1)) {..m - k} = k\"\n      using assms count_decrease1 by blast\n    ultimately have \"(\\<lambda>i. p (i + 1)) \\<in> {p. p partitions m - k \\<and> sum p {..m - k} = k}\" by simp\n    moreover have \"p = (\\<lambda>i. p ((i - 1) + 1))\"\n    proof (rule ext)\n      fix i show \"p i = p (i - 1 + 1)\"\n        using assms by (cases i) (auto elim!: partitionsE)\n    qed\n    ultimately have \"p \\<in> (\\<lambda>p. (\\<lambda>i. p (i - 1))) ` {p. p partitions m - k \\<and> sum p {..m - k} = k}\" by auto\n  }\n  from this show \"?S \\<subseteq> ?T\" by auto\nnext\n   {\n     fix p\n     assume assms: \"p partitions m - k\" \"sum p {..m - k} = k\"\n     from assms have \"(\\<lambda>i. p (i - 1)) partitions m\" (is ?g1)\n       using partitions_increase1 by blast\n     moreover from assms have \"(\\<Sum>i\\<le>m. p (i - 1)) = k\" (is ?g2)\n       using count_increase1 by blast\n     moreover from assms have \"p 0 = 0\" (is ?g3)\n       by (auto elim!: partitionsE)\n     ultimately have \"?g1 \\<and> ?g2 \\<and> ?g3\" by simp\n   }\n   from this show \"?T \\<subseteq> ?S\" by auto\nqed\n\ntheorem card_partitions_k_parts:\n  \"card {p. p partitions n \\<and> (\\<Sum>i\\<le>n. p i) = k} = Partition n k\"\nproof (induct n k rule: Partition.induct)\n  case 1\n  have eq: \"{p. p = (\\<lambda>x. 0) \\<and> p 0 = 0} = {(\\<lambda>x. 0)}\" by auto\n  show \"card {p. p partitions 0 \\<and> sum p {..0} = 0} = Partition 0 0\"\n    by (simp add: partitions_zero eq)\nnext\n  case (2 k)\n  have eq: \"{p. p = (\\<lambda>x. 0) \\<and> p 0 = Suc k} = {}\" by auto\n  show \"card {p. p partitions 0 \\<and> sum p {..0} = Suc k} = Partition 0 (Suc k)\"\n    by (simp add: partitions_zero eq)\nnext\n  case (3 m)\n  have eq: \"{p. p partitions Suc m \\<and> sum p {..Suc m} = 0} = {}\"\n    by (fastforce elim!: partitionsE simp add: le_Suc_eq)\n  from this show \"card {p. p partitions Suc m \\<and> sum p {..Suc m} = 0} = Partition (Suc m) 0\"\n    by (simp only: Partition.simps card_empty)\nnext\n  case (4 m k)\n  let ?set1 = \"{p. p partitions Suc m \\<and> sum p {..Suc m} = Suc k \\<and> p 1 \\<noteq> 0}\"\n  let ?set2 = \"{p. p partitions Suc m \\<and> sum p {..Suc m} = Suc k \\<and> p 1 = 0}\"\n  have \"finite {p. p partitions Suc m}\"\n    by (simp add: finite_partitions)\n  from this have finite_sets: \"finite ?set1\" \"finite ?set2\" by simp+\n  have set_eq: \"{p. p partitions Suc m \\<and> sum p {..Suc m} = Suc k} = ?set1 \\<union> ?set2\" by auto\n  have disjoint: \"?set1 \\<inter> ?set2 = {}\" by auto\n  have inj1: \"inj_on (\\<lambda>p. p(1 := p 1 + 1)) {p. p partitions m \\<and> sum p {..m} = k}\"\n    by (auto intro!: inj_onI) (metis diff_Suc_1 fun_upd_idem_iff fun_upd_upd)\n  have inj2: \"inj_on (\\<lambda>p i. p (i - 1)) {p. p partitions m - k \\<and> sum p {..m - k} = Suc k}\"\n    by (auto intro!: inj_onI simp add: fun_eq_iff) (metis add_diff_cancel_right')\n  have card1: \"card ?set1 = Partition m k\"\n    using inj1 4(1) by (simp only: set_rewrite1 card_image)\n  have card2: \"card ?set2 = Partition (m - k) (Suc k)\"\n    using inj2 4(2) by (simp only: set_rewrite2 card_image diff_Suc_Suc)\n  have \"card {p. p partitions Suc m \\<and> sum p {..Suc m} = Suc k} = Partition m k + Partition (m - k) (Suc k)\"\n    using finite_sets disjoint by (simp only: set_eq card_Un_disjoint card1 card2)\n  from this show \"card {p. p partitions Suc m \\<and> sum p {..Suc m} = Suc k} = Partition (Suc m) (Suc k)\"\n    by auto\nqed\n\ntheorem card_partitions:\n  \"card {p. p partitions n} = (\\<Sum>k\\<le>n. Partition n k)\"\nproof -\n  have seteq: \"{p. p partitions n} = \\<Union>((\\<lambda>k. {p. p partitions n \\<and> (\\<Sum>i\\<le>n. p i) = k}) ` {..n})\"\n    by (auto intro: partitions_parts_bounded)\n  have finite: \"\\<And>k. finite {p. p partitions n \\<and> sum p {..n} = k}\"\n    by (simp add: finite_partitions)\n  have \"card {p. p partitions n} = card (\\<Union>((\\<lambda>k. {p. p partitions n \\<and> (\\<Sum>i\\<le>n. p i) = k}) ` {..n}))\"\n    using finite by (simp add: seteq)\n  also have \"... = (\\<Sum>x\\<le>n. card {p. p partitions n \\<and> sum p {..n} = x})\"\n    using finite by (subst card_UN_disjoint) auto\n  also have \"... = (\\<Sum>k\\<le>n. Partition n k)\"\n    by (simp add: card_partitions_k_parts)\n  finally show ?thesis .\nqed\n\nlemma card_partitions_atmost_k_parts:\n  \"card {p. p partitions n \\<and> sum p {..n} \\<le> k} = Partition (n + k) k\"\nproof -\n  have \"card {p. p partitions n \\<and> sum p {..n} \\<le> k} =\n    card (\\<Union>((\\<lambda>k'. {p. p partitions n \\<and> sum p {..n} = k'}) ` {..k}))\"\n  proof -\n    have \"{p. p partitions n \\<and> sum p {..n} \\<le> k} =\n      (\\<Union>k'\\<le>k. {p. p partitions n \\<and> sum p {..n} = k'})\" by auto\n    from this show ?thesis by simp\n  qed\n  also have \"card (\\<Union>((\\<lambda>k'. {p. p partitions n \\<and> sum p {..n} = k'}) ` {..k})) =\n    sum (\\<lambda>k'. card {p. p partitions n \\<and> sum p {..n} = k'}) {..k}\"\n    using finite_partitions_k_parts by (subst card_UN_disjoint) auto\n  also have \"\\<dots> = sum (\\<lambda>k'. Partition n k') {..k}\"\n    using card_partitions_k_parts by simp\n  also have \"\\<dots> = Partition (n + k) k\"\n    using Partition_sum_Partition_diff by simp\n  finally show ?thesis .\nqed\n\nsubsection \\<open>Cardinality of Number Partitions as Multisets of Natural Numbers\\<close>\n\nlemma bij_betw_multiset_number_partition_with_size:\n  \"bij_betw count {N. number_partition n N \\<and> size N = k} {p. p partitions n \\<and> sum p {..n} = k}\"\nproof (rule bij_betw_byWitness[where f'=\"Abs_multiset\"])\n  show \"\\<forall>N\\<in>{N. number_partition n N \\<and> size N = k}. Abs_multiset (count N) = N\"\n    using count_inverse by blast\n  show \"\\<forall>p\\<in>{p. p partitions n \\<and> sum p {..n} = k}. count (Abs_multiset p) = p\"\n    by (auto simp add: multiset_def partitions_imp_finite_elements)\n  show \"count ` {N. number_partition n N \\<and> size N = k} \\<subseteq> {p. p partitions n \\<and> sum p {..n} = k}\"\n    by (auto simp add: count_partitions_iff size_nat_multiset_eq) \n  show \"Abs_multiset ` {p. p partitions n \\<and> sum p {..n} = k} \\<subseteq> {N. number_partition n N \\<and> size N = k}\"\n    using partitions_iff_Abs_multiset size_nat_multiset_eq partitions_imp_multiset by fastforce\nqed\n\nlemma bij_betw_multiset_number_partition_with_atmost_size:\n  \"bij_betw count {N. number_partition n N \\<and> size N \\<le> k} {p. p partitions n \\<and> sum p {..n} \\<le> k}\"\nproof (rule bij_betw_byWitness[where f'=\"Abs_multiset\"])\n  show \"\\<forall>N\\<in>{N. number_partition n N \\<and> size N \\<le> k}. Abs_multiset (count N) = N\"\n    using count_inverse by blast\n  show \"\\<forall>p\\<in>{p. p partitions n \\<and> sum p {..n} \\<le> k}. count (Abs_multiset p) = p\"\n    by (auto simp add: multiset_def partitions_imp_finite_elements)\n  show \"count ` {N. number_partition n N \\<and> size N \\<le> k} \\<subseteq> {p. p partitions n \\<and> sum p {..n} \\<le> k}\"\n    by (auto simp add: count_partitions_iff size_nat_multiset_eq)\n  show \"Abs_multiset ` {p. p partitions n \\<and> sum p {..n} \\<le> k} \\<subseteq> {N. number_partition n N\\<and> size N \\<le> k}\"\n    using partitions_iff_Abs_multiset size_nat_multiset_eq partitions_imp_multiset by fastforce\nqed\n\ntheorem card_number_partitions_with_atmost_k_parts:\n  shows \"card {N. number_partition n N \\<and> size N \\<le> x} = Partition (n + x) x\"\nproof -\n  have \"bij_betw count {N. number_partition n N \\<and> size N \\<le> x} {p. p partitions n \\<and> sum p {..n} \\<le> x}\"\n    by (rule bij_betw_multiset_number_partition_with_atmost_size)\n  from this have \"card {N. number_partition n N \\<and> size N \\<le> x} = card {p. p partitions n \\<and> sum p {..n} \\<le> x}\"\n    by (rule bij_betw_same_card)\n  also have \"card {p. p partitions n \\<and> sum p {..n} \\<le> x} = Partition (n + x) x\"\n    by (rule card_partitions_atmost_k_parts)\n  finally show ?thesis .\nqed\n\ntheorem card_partitions_with_k_parts:\n  \"card {N. number_partition n N \\<and> size N = k} = Partition n k\"\nproof -\n  have \"bij_betw count {N. number_partition n N \\<and> size N = k} {p. p partitions n \\<and> sum p {..n} = k}\"\n    by (rule bij_betw_multiset_number_partition_with_size)\n  from this have \"card {N. number_partition n N \\<and> size N = k} = card {p. p partitions n \\<and> sum p {..n} = k}\"\n    by (rule bij_betw_same_card)\n  also have \"\\<dots> = Partition n k\" by (rule card_partitions_k_parts)\n  finally show ?thesis .\nqed\n\nsubsection \\<open>Cardinality of Number Partitions with only 1-parts\\<close>\n\nlemma number_partition1_eq_replicate_mset:\n  \"{N. (\\<forall>n. n\\<in># N \\<longrightarrow> n = 1) \\<and> number_partition n N} = {replicate_mset n 1}\"\nproof\n  show \"{N. (\\<forall>n. n \\<in># N \\<longrightarrow> n = 1) \\<and> number_partition n N} \\<subseteq> {replicate_mset n 1}\"\n  proof\n    fix N\n    assume N: \"N \\<in> {N. (\\<forall>n. n \\<in># N \\<longrightarrow> n = 1) \\<and> number_partition n N}\"\n    have \"N = replicate_mset n 1\"\n    proof (rule multiset_eqI)\n      fix i\n      have \"count N 1 = sum_mset N\"\n      proof cases\n        assume \"N = {#}\"\n        from this show ?thesis by auto\n      next\n        assume \"N \\<noteq> {#}\"\n        from this N have \"1 \\<in># N\" by blast\n        from this N show ?thesis\n          by (auto simp add: sum_mset_sum_count sum.remove[where x=\"1\"] simp del: One_nat_def)\n      qed\n      from N this show \"count N i = count (replicate_mset n 1) i\"\n        unfolding number_partition_def by (auto intro: count_inI)\n    qed\n    from this show \"N \\<in> {replicate_mset n 1}\" by simp\n  qed\nnext\n  show \"{replicate_mset n 1} \\<subseteq> {N. (\\<forall>n. n \\<in># N \\<longrightarrow> n = 1) \\<and> number_partition n N}\"\n    unfolding number_partition_def by auto\nqed\n\n\n\nlemma card_number_partitions_with_only_parts_1_eq_0:\n  assumes \"x < n\"\n  shows \"card {N. (\\<forall>n. n\\<in># N \\<longrightarrow> n = 1) \\<and> number_partition n N \\<and> size N \\<le> x} = 0\" (is \"card ?N = _\")\nproof -\n  have \"\\<forall>N \\<in> {N. (\\<forall>n. n \\<in># N \\<longrightarrow> n = 1) \\<and> number_partition n N}. size N = n\"\n    unfolding number_partition1_eq_replicate_mset by simp\n  from this number_partition1_eq_replicate_mset\\<open>x < n\\<close> have \"?N = {}\" by auto\n  from this show ?thesis by (simp only: card_empty)\nqed\n\nend\n"}
{"text": "lemmas swap_apply1 = swap_apply(1)"}
{"text": "(* Practice of Natural Deduction *)\n(* http://rainyday.blog.so-net.ne.jp/2017-09-24 *)\n\ntheory NaturalDeduction\n  imports Main\nbegin\n\ntheorem Example_1_4:\n  (*fixes P Q*)\n  assumes 1: \"P \\<and> Q\"\n  assumes 2: \"R\"\n  shows \"Q \\<and> R\"\nproof -\n  have 3: \"Q\" using 1 by (rule conjunct2)\n  show 4: \"Q \\<and> R\" using 3 2 by (rule conjI)\nqed\n\nfind_theorems \"\\<not>\\<not> _ \\<Longrightarrow> _\"              (* notnotD *)\ntheorem notnotI: \"P \\<Longrightarrow> \\<not>\\<not> P\" by auto\n\ntheorem Example_1_5:\n  assumes 1: \"P\"\n  assumes 2: \"\\<not>\\<not> (Q \\<and> R)\"\n  shows \"\\<not>\\<not> P \\<and> R\"\nproof -\n  have 3: \"\\<not>\\<not> P\" using 1 by (rule notnotI)\n  have 4: \"Q \\<and> R\" using 2 by (rule notnotD)\n  have 5: \"R\" using 4 by (rule conjunct2)\n  show 6: \"\\<not>\\<not> P \\<and> R\" using 3 5 by (rule conjI)\nqed\n\ntheorem  mp: \"(P\\<Longrightarrow>Q) \\<Longrightarrow> P \\<Longrightarrow> Q\" by auto\ntheorem  mt: \"(P\\<Longrightarrow>Q) \\<Longrightarrow> \\<not> Q \\<Longrightarrow> \\<not> P\" by auto\n\ntheorem Example_1_7:\n  assumes 1: \"P \\<Longrightarrow> (Q \\<Longrightarrow> R)\"\n  assumes 2: \"P\"\n  assumes 3: \"\\<not> R\"\n  shows \"\\<not> Q\"\nproof -\n  have 4: \"Q \\<Longrightarrow> R\" using 1 2 by (rule mp)\n  show 5: \"\\<not> Q\" using 4 3 by (rule mt)\nqed\n\ntheorem Example_1_9:\n  assumes 1: \"\\<not> Q \\<Longrightarrow> \\<not> P\"\n  shows \"P \\<Longrightarrow> \\<not>\\<not> Q\"\nproof -\n  assume 2: \"P\"\n  have 3: \"\\<not>\\<not> P\" using 2 by (rule notnotI)\n  show 4: \"\\<not>\\<not> Q\" using 1 3 by (rule mt)\nqed\n\ntheorem Example_1_11:\n  shows \"(Q \\<Longrightarrow> R) \\<Longrightarrow> (( \\<not> Q \\<Longrightarrow> \\<not> P) \\<Longrightarrow> (P \\<Longrightarrow> R))\"\nproof -\n  assume 1: \"Q \\<Longrightarrow> R\"\n  show \"(\\<not> Q \\<Longrightarrow> \\<not> P) \\<Longrightarrow> (P \\<Longrightarrow> R)\"\n  proof -\n    assume 2: \"\\<not> Q \\<Longrightarrow> \\<not> P\"\n    show \"P \\<Longrightarrow> R\"\n    proof -\n      assume 3: \"P\"\n      have 4: \"\\<not>\\<not> P\" using 3 by (rule notnotI)\n      have 5: \"\\<not>\\<not> Q\" using 2 4 by (rule mt)\n      have 6: \"Q\" using 5 by (rule notnotD)\n      show 7: \"R\" using 1 6 by (rule mp)\n    qed\n  qed\nqed\n\ntheorem Example_1_11':\n  shows \"(Q \\<Longrightarrow> R) \\<Longrightarrow> ((\\<not> Q \\<Longrightarrow> \\<not> P) \\<Longrightarrow> (P \\<Longrightarrow> R))\"\nproof-\n  assume 1: \"Q \\<Longrightarrow> R\"\n  assume 2: \"\\<not> Q \\<Longrightarrow> \\<not> P\"\n  assume 3: \"P\"\n  have 4: \"\\<not>\\<not> P\" using 3 by (rule notnotI)\n  have 5: \"\\<not>\\<not> Q\" using 2 4 by (rule mt)\n  have 6: \"Q\" using 5 by (rule notnotD)\n  show 7: \"R\" using 1 6 by (rule mp)\nqed\n\nfind_theorems \"_ \\<Longrightarrow> _ \\<or> _\"  (* disjI1 , disjI2 *)\ntheorem disjE: \"P \\<or> Q \\<Longrightarrow> (P \\<Longrightarrow> R) \\<Longrightarrow> (Q \\<Longrightarrow> R) \\<Longrightarrow> R\" by auto\n\ntheorem Example_1_16:\n  assumes 1: \"Q \\<Longrightarrow> R\"\n  shows \"P \\<or> Q \\<Longrightarrow> P \\<or> R\"\nproof -\n  assume 2: \"P \\<or> Q\"\n  show \"P \\<or> R\"\n  proof -\n    have 34: \"P \\<Longrightarrow> P \\<or> R\"\n    proof -\n      assume 3: \"P\"\n      show 4: \"P \\<or> R\" using 3 by (rule disjI1)\n    qed\n    have 57: \"Q \\<Longrightarrow> P \\<or> R\"\n    proof -\n      assume 5: \"Q\"\n      have 6: \"R\" using 1 5 by (rule mp)\n      show 7: \"P \\<or> R\" using 6 by (rule disjI2)\n    qed\n    show \"P \\<or> R\" using 2 34 57 by (rule disjE)\n  qed\nqed\n\ntheorem Example_copy:\n  shows \"P \\<Longrightarrow> (Q \\<Longrightarrow> P)\"\nproof -\n  assume 1: \"P\"\n  show \"Q \\<Longrightarrow> P\"\n  proof -\n    assume 2: \"Q\"\n    show 3: \"P\" using 1 by assumption\n  qed\nqed\n\ntheorem Example_1_21:\n  assumes 1: \"P \\<Longrightarrow> Q\"\n  assumes 2: \"P \\<Longrightarrow> \\<not>Q\"\n  shows \"\\<not> P\"\nproof -\n  have 36: \"P \\<Longrightarrow> False\"\n  proof -\n    assume 3: \"P\"\n    have 4: \"Q\" using 1 3 by (rule mp)\n    have 5: \"\\<not> Q\" using 2 3 by (rule mp)\n    show 6: \"False\" using 5 4 by (rule notE)\n  qed\n  show \"\\<not> P\" using 36 by (rule notI)\nqed\n\nend\n"}
{"text": "import data.real.irrational\nimport topology.basic\nimport algebra.order.floor\n\n\n--OUTPUT 1\ntheorem irrational_orbit_dense {\u03b1 : \u211d} (h\u03b1_irrat : irrational \u03b1) : closure ((\u03bb m : \u2124, int.fract (\u03b1 * \u2191m)) '' (@set.univ \u2124)) = set.Icc 0 1 :=density_of_irrational_orbit (\u03b1 : \u211d) (h\u03b1 : \u00ac is_rat \u03b1) : \u2200 y \u2208 Icc 0 1, \u2203 x \u2208 Icc 0 1, x \u2260 y \u2227 x \u2208 {i \u2022 \u03b1 | i \u2208 \u2124} :=\nbegin\n  assume y h,\n  have h1 : \u2200 i j : \u2124, i \u2260 j \u2192 {i \u2022 \u03b1} \u2260 {j \u2022 \u03b1}, from by {\n    assume i j h2,\n    assume h3 : {i \u2022 \u03b1} = {j \u2022 \u03b1},\n    have h4 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = {i \u2022 \u03b1}, from by {rw h3},\n    have h5 : j \u2022 \u03b1 - (j \u2022 \u03b1).floor = {j \u2022 \u03b1}, from by {rw h3},\n    have h6 : \u03b1 = (i \u2022 \u03b1).floor - (j \u2022 \u03b1).floor / (i - j), from by {rw [h4,h5], ring},\n    have h7 : \u03b1 \u2208 \u211a, from by {apply quotient.exact h6},\n    exact h\u03b1 h7,\n  },\n  have h2 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 \u2260 j \u2022 \u03b1, from by {\n    assume i j h3,\n    assume h4 : i \u2022 \u03b1 = j \u2022 \u03b1,\n    have h5 : i = j, from by {rw [h4,mul_eq_mul_iff_left h\u03b1]},\n    exact h3 h5,\n  },\n  have h3 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 - (i \u2022 \u03b1).floor \u2260 j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {\n    assume i j h4,\n    assume h5 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor,\n    have h6 : i \u2022 \u03b1 = j \u2022 \u03b1, from by {rw h5, ring},\n    exact h2 i j h4 h6,\n  },\n  have h4 : \u2200 i j : \u2124, i \u2260 j \u2192 {i \u2022 \u03b1} \u2260 {j \u2022 \u03b1}, from by {\n    assume i j h5,\n    assume h6 : {i \u2022 \u03b1} = {j \u2022 \u03b1},\n    have h7 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = {i \u2022 \u03b1}, from by {rw h6},\n    have h8 : j \u2022 \u03b1 - (j \u2022 \u03b1).floor = {j \u2022 \u03b1}, from by {rw h6},\n    have h9 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {rw [h7,h8]},\n    exact h3 i j h5 h9,\n  },\n  have h5 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 \u2260 j \u2022 \u03b1, from by {\n    assume i j h6,\n    assume h7 : i \u2022 \u03b1 = j \u2022 \u03b1,\n    have h8 : i = j, from by {rw [h7,mul_eq_mul_iff_left h\u03b1]},\n    exact h6 h8,\n  },\n  have h6 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 - (i \u2022 \u03b1).floor \u2260 j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {\n    assume i j h7,\n    assume h8 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor,\n    have h9 : i \u2022 \u03b1 = j \u2022 \u03b1, from by {rw h8, ring},\n    exact h5 i j h7 h9,\n  },\n  have h7 : \u2200 i j : \u2124, i \u2260 j \u2192 {i \u2022 \u03b1} \u2260 {j \u2022 \u03b1}, from by {\n    assume i j h8,\n    assume h9 : {i \u2022 \u03b1} = {j \u2022 \u03b1},\n    have h10 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = {i \u2022 \u03b1}, from by {rw h9},\n    have h11 : j \u2022 \u03b1 - (j \u2022 \u03b1).floor = {j \u2022 \u03b1}, from by {rw h9},\n    have h12 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {rw [h10,h11]},\n    exact h6 i j h8 h12,\n  },\n  have h8 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 \u2260 j \u2022 \u03b1, from by {\n    assume i j h9,\n    assume h10 : i \u2022 \u03b1 = j \u2022 \u03b1,\n    have h11 : i = j, from by {rw [h10,mul_eq_mul_iff_left h\u03b1]},\n    exact h9 h11,\n  },\n  have h9 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 - (i \u2022 \u03b1).floor \u2260 j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {\n    assume i j h10,\n    assume h11 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor,\n    have h12 : i \u2022 \u03b1 = j \u2022 \u03b1, from by {rw h11, ring},\n    exact h8 i j h10 h12,\n  },\n  have h10 : \u2200 i j : \u2124, i \u2260 j \u2192 {i \u2022 \u03b1} \u2260 {j \u2022 \u03b1}, from by {\n    assume i j h11,\n    assume h12 : {i \u2022 \u03b1} = {j \u2022 \u03b1},\n    have h13 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = {i \u2022 \u03b1}, from by {rw h12},\n    have h14 : j \u2022 \u03b1 - (j \u2022 \u03b1).floor = {j \u2022 \u03b1}, from by {rw h12},\n    have h15 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {rw [h13,h14]},\n    exact h9 i j h11 h15,\n  },\n  have h11 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 \u2260 j \u2022 \u03b1, from by {\n    assume i j h12,\n    assume h13 : i \u2022 \u03b1 = j \u2022 \u03b1,\n    have h14 : i = j, from by {rw [h13,mul_eq_mul_iff_left h\u03b1]},\n    exact h12 h14,\n  },\n  have h12 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 - (i \u2022 \u03b1).floor \u2260 j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {\n    assume i j h13,\n    assume h14 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor,\n    have h15 : i \u2022 \u03b1 = j \u2022 \u03b1, from by {rw h14, ring},\n    exact h11 i j h13 h15,\n  },\n  have h13 : \u2200 i j : \u2124, i \u2260 j \u2192 {i \u2022 \u03b1} \u2260 {j \u2022 \u03b1}, from by {\n    assume i j h14,\n    assume h15 : {i \u2022 \u03b1} = {j \u2022 \u03b1},\n    have h16 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = {i \u2022 \u03b1}, from by {rw h15},\n    have h17 : j \u2022 \u03b1 - (j \u2022 \u03b1).floor = {j \u2022 \u03b1}, from by {rw h15},\n    have h18 : i \u2022 \u03b1 - (i \u2022 \u03b1).floor = j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {rw [h16,h17]},\n    exact h12 i j h14 h18,\n  },\n  have h14 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 \u2260 j \u2022 \u03b1, from by {\n    assume i j h15,\n    assume h16 : i \u2022 \u03b1 = j \u2022 \u03b1,\n    have h17 : i = j, from by {rw [h16,mul_eq_mul_iff_left h\u03b1]},\n    exact h15 h17,\n  },\n  have h15 : \u2200 i j : \u2124, i \u2260 j \u2192 i \u2022 \u03b1 - (i \u2022 \u03b1).floor \u2260 j \u2022 \u03b1 - (j \u2022 \u03b1).floor, from by {\n    assume i j h16,\n    assume h17 : i \u2022 \u03b1 - (i \u2022\nend --Needs more than 2000 tokens!\n\n/- FEW SHOT PROMPTS TO CODEX(START)\n/--`theorem`\nPower Set is Closed under Intersection\nLet $S$ be a set.\n\nLet $\\powerset S$ be the power set of $S$.\n\n\nThen:\n:$\\forall A, B \\in \\powerset S: A \\cap B \\in \\powerset S$\n`proof`\nLet $A, B \\in \\powerset S$.\n\nThen by the definition of power set, $A \\subseteq S$ and $B \\subseteq S$.\n\nFrom Intersection is Subset we have that $A \\cap B \\subseteq A$.\n\nIt follows from Subset Relation is Transitive that $A \\cap B \\subseteq S$.\n\nThus $A \\cap B \\in \\powerset S$ and closure is proved.\n{{qed}}\n-/\ntheorem power_set_intersection_closed {\u03b1 : Type*} (S : set \u03b1) : \u2200 A B \u2208 \ud835\udcab S, (A \u2229 B) \u2208 \ud835\udcab S :=\nbegin\n  -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\n  assume (A : set \u03b1) (hA : A \u2208 \ud835\udcab S) (B : set \u03b1) (hB : B \u2208 \ud835\udcab S),\n  -- Then $A \u2286 S$ and $B \u2286 S$, by power set definition\n  have h1 : (A \u2286 S) \u2227 (B \u2286 S), from by {split,apply set.subset_of_mem_powerset,exact hA,apply set.subset_of_mem_powerset,exact hB},\n  -- Then $(A \u2229 B) \u2286 A$, by intersection of set is a subset\n  have h2 : (A \u2229 B) \u2286 A, from by apply set.inter_subset_left,\n  -- Then $(A \u2229 B) \u2286 S$, by subset relation is transitive \n  have h3 : (A \u2229 B) \u2286 S, from by {apply set.subset.trans h2 h1.left},\n  -- Hence $(A \u2229 B) \u2208  \ud835\udcab S$, by power set definition\n  show (A \u2229 B) \u2208  \ud835\udcab S, from by {apply set.mem_powerset h3},\nend\n\n/--`theorem`\nSquare of Sum\n :$\\forall x, y \\in \\R: \\paren {x + y}^2 = x^2 + 2 x y + y^2$\n`proof`\nFollows from the distribution of multiplication over addition:\n\n{{begin-eqn}}\n{{eqn | l = \\left({x + y}\\right)^2\n      | r = \\left({x + y}\\right) \\cdot \\left({x + y}\\right)\n}}\n{{eqn | r = x \\cdot \\left({x + y}\\right) + y \\cdot \\left({x + y}\\right)\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x \\cdot x + x \\cdot y + y \\cdot x + y \\cdot y\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x^2 + 2xy + y^2\n      | c = \n}}\n{{end-eqn}}\n{{qed}}\n-/\ntheorem square_of_sum (x y : \u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \nbegin\n  -- expand the power\n  calc (x + y)^2 = (x+y)*(x+y) : by rw sq\n  -- distributive property of multiplication over addition gives:\n  ... = x*(x+y) + y*(x+y) : by rw add_mul\n  -- applying the above property further gives:\n  ... = x*x + x*y + y*x + y*y : by {rw [mul_comm x (x+y),mul_comm y (x+y)], rw [add_mul,add_mul], ring}\n  -- rearranging the terms using commutativity and adding gives:\n  ... = x^2 + 2*x*y + y^2 : by {repeat {rw \u2190 sq}, rw mul_comm y x, ring}\nend\n\n/--`theorem`\nIdentity of Group is Unique\nLet $\\struct {G, \\circ}$ be a group. Then there is a unique identity element $e \\in G$.\n`proof`\nFrom Group has Latin Square Property, there exists a unique $x \\in G$ such that:\n:$a x = b$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = b$\n\nSetting $b = a$, this becomes:\n\nThere exists a unique $x \\in G$ such that:\n:$a x = a$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = a$\n\nThese $x$ and $y$ are both $e$, by definition of identity element.\n{{qed}}\n-/\ntheorem group_identity_unique {G : Type*} [group G] : \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a :=\nbegin\n  -- Group has Latin Square Property\n  have h1 : \u2200 a b : G, \u2203! x : G, a * x = b, from by {\n    assume a b : G, use a\u207b\u00b9 * b, obviously, },\n  have h2 : \u2200 a b : G, \u2203! y : G, y * a = b, from by {\n    assume a b : G, use b * a\u207b\u00b9, obviously, }, \n\n  -- Setting $b = a$, this becomes:\n  have h3 : \u2200 a : G, \u2203! x : G, a * x = a, from \n    assume a : G, h1 a a,\n  have h4 : \u2200 a : G, \u2203! y : G, y * a = a, from\n    assume a : G, h2 a a,\n\n  -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\n  have h5 : \u2200 a : G, classical.some (h3 a).exists = (1 : G), from assume a :G,\n    exists_unique.unique (h3 a) (classical.some_spec (exists_unique.exists (h3 a)))\n    (mul_one a),\n  have h6 : \u2200 a : G, classical.some (h4 a).exists = (1 : G), from assume a : G,\n    exists_unique.unique (h4 a) (classical.some_spec (exists_unique.exists (h4 a))) (one_mul a), \n\n  show \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a, from by {\n    use (1 : G),\n    have h7 : \u2200 e : G, (\u2200 a : G, e * a = a \u2227 a * e = a) \u2192 e = 1, from by {\n      assume (e : G) (hident : \u2200 a : G, e * a = a \u2227 a * e = a),\n      have h8 : \u2200 a : G, e = classical.some (h3 a).exists, from assume (a : G),\n        exists_unique.unique (h3 a) (hident a).right\n        (classical.some_spec (exists_unique.exists (h3 a))), \n      have h9 : \u2200 a : G, e = classical.some (h4 a).exists, from assume (a : G),\n        exists_unique.unique (h4 a) (hident a).left\n        (classical.some_spec (exists_unique.exists (h4 a))),\n      show e = (1 : G), from eq.trans (h9 e) (h6 _),     \n    },\n    exact \u27e8by obviously, h7\u27e9,\n  }\nend\n\n/--`theorem`\nSqueeze Theorem for Real Numbers\nLet $\\sequence {x_n}$, $\\sequence {y_n}$ and $\\sequence {z_n}$ be sequences in $\\R$.\n\nLet $\\sequence {y_n}$ and $\\sequence {z_n}$ both be convergent to the following limit:\n:$\\ds \\lim_{n \\mathop \\to \\infty} y_n = l, \\lim_{n \\mathop \\to \\infty} z_n = l$\n\nSuppose that:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\n\nThen:\n:$x_n \\to l$ as $n \\to \\infty$\nthat is:\n:$\\ds \\lim_{n \\mathop \\to \\infty} x_n = l$\n\n`proof`\nFrom Negative of Absolute Value:\n:$\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n\nLet $\\epsilon > 0$.\n\nWe need to prove that:\n:$\\exists N: \\forall n > N: \\size {x_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that:\n:$\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n\nAs $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that:\n:$\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n\n\nLet $N = \\max \\set {N_1, N_2}$.\n\nThen if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n:$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n\nBut:\n:$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n\nSo:\n:$\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n\nand so:\n:$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n\nSo:\n:$\\forall n > N: \\size {x_n - l} < \\epsilon$\n\nHence the result.\n{{qed}}\n\n-/\ntheorem squeeze_theorem_real_numbers (x y z : \u2115 \u2192 \u211d) (l : \u211d) : \nlet seq_limit : (\u2115 \u2192 \u211d) \u2192 \u211d \u2192 Prop :=  \u03bb (u : \u2115 \u2192 \u211d) (l : \u211d), \u2200 \u03b5 > 0, \u2203 N, \u2200 n > N, |u n - l| < \u03b5 in\n seq_limit y l \u2192 seq_limit z l \u2192  (\u2200 n : \u2115, (y n) \u2264 (x n) \u2227 (x n) \u2264 (z n)) \u2192 seq_limit x l :=\nbegin\n  assume seq_limit (h2 : seq_limit y l) (h3 : seq_limit z l) (h4 : \u2200 (n : \u2115), y n \u2264 x n \u2227 x n \u2264 z n) (\u03b5), \n\n  --From Negative of Absolute Value: $\\size {x - l} < \\epsilon \\iff l - \\epsilon < x < l + \\epsilon$\n  have h5 : \u2200 x, |x - l| < \u03b5 \u2194 (((l - \u03b5) < x) \u2227 (x < (l + \u03b5))), \n  from by \n  {\n    intro x0,\n    have h6 : |x0 - l| < \u03b5 \u2194 ((x0 - l) < \u03b5) \u2227 ((l - x0) < \u03b5), \n    from abs_sub_lt_iff, rw h6,\n    split, \n    rintro \u27e8 S_1, S_2 \u27e9, \n    split; linarith, \n    rintro \u27e8 S_3, S_4 \u27e9, \n    split; linarith,\n    },\n  \n  --Let $\\epsilon > 0$.\n  assume (h7 : \u03b5 > 0),\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} y_n = l$ we know that $\\exists N_1: \\forall n > N_1: \\size {y_n - l} < \\epsilon$\n  cases h2 \u03b5 h7 with N1 h8,\n\n  --As $\\ds \\lim_{n \\mathop \\to \\infty} z_n = l$ we know that $\\exists N_2: \\forall n > N_2: \\size {z_n - l} < \\epsilon$\n  cases h3 \u03b5 h7 with N2 h9,\n  \n  --Let $N = \\max \\set {N_1, N_2}$.\n  let N := max N1 N2,\n  use N,\n\n  --Then if $n > N$, it follows that $n > N_1$ and $n > N_2$.\n  have h10 : \u2200 n > N, n > N1 \u2227 n > N2 := by {\n    assume n h,\n    split,\n    exact lt_of_le_of_lt (le_max_left N1 N2) h, \n    exact lt_of_le_of_lt (le_max_right N1 N2) h,\n  },\n  \n  --$\\forall n > N: l - \\epsilon < y_n < l + \\epsilon$\n  --$\\forall n > N: l - \\epsilon < z_n < l + \\epsilon$\n  --$\\forall n \\in \\N: y_n \\le x_n \\le z_n$\n  --So $\\forall n > N: l - \\epsilon < y_n \\le x_n \\le z_n < l + \\epsilon$\n  have h11 : \u2200 n > N, (((l - \u03b5) < (y n)) \u2227 ((y n) \u2264 (x n))) \u2227 (((x n) \u2264 (z n)) \u2227 ((z n) < l+\u03b5)), \n  from by {\n    intros n h12,\n    split,\n    {\n\n      have h13 := (h8 n (h10 n h12).left), rw h5 (y n) at h13,\n      split,\n      exact h13.left,\n      exact (h4 n).left,\n    },\n    {        \n      have h14 := (h9 n (h10 n h12).right),rw h5 (z n) at h14,\n      split,\n      exact (h4 n).right,\n      exact h14.right,\n    },\n    \n  },\n\n  --$\\forall n > N: l - \\epsilon < x_n < l + \\epsilon$\n  have h15 : \u2200 n > N, ((l - \u03b5) < (x n)) \u2227 ((x n) < (l+\u03b5)), \n  from by {\n    intros n1 h16, cases (h11 n1 h16);\n    split; linarith,\n  },\n\n  --So $\\forall n > N: \\size {x_n - l} < \\epsilon$\n  --Hence the result\n  show  \u2200 (n : \u2115), n > N \u2192 |x n - l| < \u03b5, \n  from by {\n    intros n h17,\n    cases h5 (x n) with h18 h19,\n    apply h19, exact h15 n h17,\n  },\nend\n\n/--`theorem`\nDensity of irrational orbit\nThe fractional parts of the integer multiples of an irrational number form a dense subset of the unit interval\n`proof`\nLet $\\alpha$ be an irrational number. Then for distinct $i, j \\in \\mathbb{Z}$, we must have $\\{i \\alpha\\} \\neq\\{j \\alpha\\}$. If this were not true, then\n$$\ni \\alpha-\\lfloor i \\alpha\\rfloor=\\{i \\alpha\\}=\\{j \\alpha\\}=j \\alpha-\\lfloor j \\alpha\\rfloor,\n$$\nwhich yields the false statement $\\alpha=\\frac{\\lfloor i \\alpha\\rfloor-\\lfloor j \\alpha\\rfloor}{i-j} \\in \\mathbb{Q}$. Hence,\n$$\nS:=\\{\\{i \\alpha\\} \\mid i \\in \\mathbb{Z}\\}\n$$\nis an infinite subset of $\\left[0,1\\right]$.\n\nBy the Bolzano-Weierstrass theorem, $S$ has a limit point in $[0, 1]$. One can thus find pairs of elements of $S$ that are arbitrarily close. Since (the absolute value of) the difference of any two elements of $S$ is also an element of $S$, it follows that $0$ is a limit point of $S$.\n\nTo show that $S$ is dense in $[0, 1]$, consider $y \\in[0,1]$, and $\\epsilon>0$. Then by selecting $x \\in S$ such that $\\{x\\}<\\epsilon$ (which exists as $0$ is a limit point), and $N$ such that $N \\cdot\\{x\\} \\leq y<(N+1) \\cdot\\{x\\}$, we get: $|y-\\{N x\\}|<\\epsilon$.\n\nQED\n-/\ntheorem \nFEW SHOT PROMPTS TO CODEX(END)-/\n"}
{"text": "/-\nCopyright (c) 2020 Ruben Van de Velde. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\n-/\nimport Mathlib.Data.Int.Order.Units\nimport Mathlib.NumberTheory.Zsqrtd.Basic\nimport Mathlib.RingTheory.Prime\nimport Flt.Primes\n\ntheorem Zsqrtd.exists {d : \u2124} (a : \u2124\u221ad) (him : a.im \u2260 0) :\n    \u2203 c : \u2124\u221ad, a.norm = c.norm \u2227 0 \u2264 c.re \u2227 c.im \u2260 0 :=\n  by\n  cases' le_or_lt a.re 0 with hre hre\n  \u00b7 use -a\n    simp only [hre, him, Zsqrtd.norm_neg, eq_self_iff_true, Zsqrtd.neg_im, Zsqrtd.neg_re,\n      and_self_iff, neg_nonneg, Ne.def, not_false_iff, neg_eq_zero]\n  \u00b7 use a\n    simp only [hre.le, him, eq_self_iff_true, and_self_iff, Ne.def, not_false_iff]\n#align zsqrtd.exists Zsqrtd.exists\n\n-- Edwards p49 step (2')\ntheorem factors2 {a : \u2124\u221a(-3)} (heven : Even a.norm) : \u2203 b : \u2124\u221a(-3), a.norm = 4 * b.norm :=\n  by\n  have hparity : Even a.re \u2194 Even a.im := by\n    simpa [two_ne_zero, Zsqrtd.norm_def, parity_simps] using heven\n  simp only [iff_iff_and_or_not_and_not, \u2190 Int.odd_iff_not_even] at hparity\n  obtain \u27e8\u27e8c, hc\u27e9, \u27e8d, hd\u27e9\u27e9 | \u27e8hre, him\u27e9 := hparity\n  \u00b7 use \u27e8c, d\u27e9\n    simp only [Zsqrtd.norm_def, hc, hd]\n    ring\n  \u00b7 cases' Int.four_dvd_add_or_sub_of_odd hre him with h4 h4\n    \u00b7 obtain \u27e8v, hv\u27e9 := h4\n      use \u27e8v - a.im, v\u27e9\n      rw [eq_comm, \u2190 sub_eq_iff_eq_add] at hv\n      simp only [Zsqrtd.norm_def, \u2190 hv]\n      ring\n    \u00b7 obtain \u27e8v, hv\u27e9 := h4\n      use \u27e8v + a.im, v\u27e9\n      rw [sub_eq_iff_eq_add] at hv\n      simp only [Zsqrtd.norm_def, hv]\n      ring\n#align factors2 factors2\n\ntheorem Spts.mul_of_dvd' {a p : \u2124\u221a(-3)} (hdvd : p.norm \u2223 a.norm) (hpprime : Prime p.norm) :\n    \u2203 u : \u2124\u221a(-3), a = p * u \u2228 a = star p * u :=\n  by\n  obtain \u27e8f, hf\u27e9 := hdvd\n  have h0 : p.norm \u2223 p.re * a.im - a.re * p.im \u2228 p.norm \u2223 p.re * a.im + a.re * p.im :=\n    by\n    apply hpprime.dvd_or_dvd\n    convert dvd_mul_right p.norm (a.im ^ 2 - p.im ^ 2 * f) using 1\n    trans a.im ^ 2 * p.norm - p.im ^ 2 * (p.norm * f)\n    \u00b7 rw [\u2190 hf, Zsqrtd.norm_def, Zsqrtd.norm_def]\n      ring\n    \u00b7 rw [Zsqrtd.norm_def]\n      ring\n  obtain \u27e8A, HA\u27e9 : \u2203 A : Units \u2124, p.norm \u2223 p.re * a.im + A * a.re * p.im := by\n    cases' h0 with h0 h0 <;> [(use -1), (use 1)] <;> convert h0 using 1 <;>\n      simp only [Units.val_neg, Units.val_one, neg_mul, one_mul]\n    ring\n  have HAsq : (A : \u2124) ^ 2 = 1 := by\n    calc\n      (A : \u2124) ^ 2 = ((A ^ 2 : Units \u2124) : \u2124) := (Units.val_pow_eq_pow_val _ _).symm\n      _ = ((1 : Units \u2124) : \u2124) := (congr_arg _ (Int.units_sq A))\n      _ = 1 := Units.val_one\n      \n  \u00b7 set X : \u2124\u221a(-3) := \u27e8p.re * a.re - A * 3 * p.im * a.im, p.re * a.im + A * a.re * p.im\u27e9 with HX\n    obtain \u27e8U, HU\u27e9 : (p.norm : \u2124\u221a(-3)) \u2223 X :=\n      by\n      rw [Zsqrtd.coe_int_dvd_iff]\n      refine' \u27e8_, HA\u27e9\n      apply @Prime.dvd_of_dvd_pow _ _ _ hpprime _ 2\n      have : X.re ^ 2 = X.norm - 3 * X.im ^ 2 :=\n        by\n        rw [Zsqrtd.norm_def]\n        ring\n      rw [this]\n      apply dvd_sub\n      \u00b7 use a.norm\n        trans\n          (p.re * a.re) ^ 2 + (A : \u2124) ^ 2 * (3 * p.im * a.im) ^ 2 +\n            3 * ((p.re * a.im) ^ 2 + (A : \u2124) ^ 2 * (a.re * p.im) ^ 2)\n        \u00b7 simp only [Zsqrtd.norm_def]\n          ring\n        \u00b7 simp only [Zsqrtd.norm_def, HAsq]\n          ring\n      \u00b7 apply dvd_mul_of_dvd_right\n        exact dvd_pow HA two_ne_zero\n    use U\n    suffices a = \u27e8p.re, -A * p.im\u27e9 * U by\n      apply Or.imp _ _ (Int.units_eq_one_or A).symm <;> rintro rfl <;> simpa [Zsqrtd.ext] using this\n    apply Zsqrtd.eq_of_smul_eq_smul_left hpprime.ne_zero\n    have : p.norm = p.re ^ 2 + 3 * (A : \u2124) ^ 2 * p.im ^ 2 :=\n      by\n      rw [Zsqrtd.norm_def, HAsq]\n      ring\n    rw [mul_comm _ U, \u2190 mul_assoc, \u2190 HU, HX]\n    simp only [Zsqrtd.ext, neg_mul, add_zero, Zsqrtd.coe_int_re, MulZeroClass.zero_mul, mul_neg,\n      Zsqrtd.mul_im, Zsqrtd.mul_re, neg_neg, MulZeroClass.mul_zero, neg_zero, Zsqrtd.coe_int_im,\n      this]\n    constructor <;> ring\n#align spts.mul_of_dvd' Spts.mul_of_dvd'\n\n-- Edwards p49 step (3')\ntheorem Spts.mul_of_dvd'' {a p : \u2124\u221a(-3)} (hdvd : p.norm \u2223 a.norm) (hpprime : Prime p.norm) :\n    \u2203 u : \u2124\u221a(-3), (a = p * u \u2228 a = star p * u) \u2227 a.norm = p.norm * u.norm :=\n  by\n  obtain \u27e8u, hu\u27e9 := Spts.mul_of_dvd' hdvd hpprime\n  refine' \u27e8u, hu, _\u27e9\n  obtain rfl | rfl := hu\n  \u00b7 rw [Zsqrtd.norm_mul]\n  \u00b7 rw [Zsqrtd.norm_mul, Zsqrtd.norm_conj]\n#align spts.mul_of_dvd'' Spts.mul_of_dvd''\n\n-- Edwards p49 step (4'), contraposed\ntheorem factors' (a : \u2124\u221a(-3)) (f : \u2124) (g : \u2124) (hodd : Odd f) (hgpos : g \u2260 0)\n    (hfactor : f * g = a.norm)\n    (hnotform : \u2200 f' : \u2124, f' \u2223 g \u2192 Odd f' \u2192 \u2203 p : \u2124\u221a(-3), abs f' = p.norm) :\n    \u2203 p : \u2124\u221a(-3), abs f = p.norm :=\n  by\n  induction' hg : g.natAbs using Nat.strong_induction_on with g'' IH generalizing a g\n  subst g''\n  dsimp at IH\n  by_cases H : Even (Zsqrtd.norm a)\n  \u00b7 obtain \u27e8c, hc\u27e9 := factors2 H\n    have : 4 \u2223 g := by\n      apply IsCoprime.dvd_of_dvd_mul_left\n      \u00b7 show IsCoprime _ f\n        rw [Int.odd_iff_not_even, even_iff_two_dvd, \u2190 Int.prime_two.coprime_iff_not_dvd] at hodd\n        convert hodd.pow_left\n        rw [sq]\n        norm_num\n      \u00b7 rw [hfactor, hc]\n        exact dvd_mul_right _ _\n    obtain \u27e8g', rfl\u27e9 := this\n    have hg'pos : g' \u2260 0 := right_ne_zero_of_mul hgpos\n    refine' IH g'.natAbs _ c g' hg'pos _ _ rfl\n    \u00b7 rw [Int.natAbs_mul]\n      apply lt_mul_of_one_lt_left (Int.natAbs_pos.mpr hg'pos)\n      norm_num\n    \u00b7 rw [\u2190 mul_right_inj' (four_ne_zero' \u2124), \u2190 hc, \u2190 hfactor, mul_left_comm]\n    \u00b7 intro f' hf'dvd hf'odd\n      refine' hnotform f' _ hf'odd\n      exact hf'dvd.mul_left _\n  \u00b7 by_cases h : |g| = 1\n    \u00b7 apply_fun abs  at hfactor\n      rw [abs_mul, h, mul_one, abs_of_nonneg (Zsqrtd.norm_nonneg (by norm_num) a)] at hfactor\n      exact \u27e8_, hfactor\u27e9\n    \u00b7 rw [Int.abs_eq_natAbs, \u2190 Int.ofNat_one, Int.coe_nat_inj'] at h\n      obtain \u27e8p, pprime, pdvd\u27e9 := Int.exists_prime_and_dvd h\n      have : p \u2223 a.norm := by\n        rw [\u2190 hfactor]\n        exact pdvd.mul_left _\n      have podd : Odd p :=\n        Int.odd_iff_not_even.mpr\n          (by\n            intro X\n            apply H\n            apply even_iff_two_dvd.mpr\n            apply dvd_trans _ this\n            apply even_iff_two_dvd.mp X)\n      obtain \u27e8A, HA\u27e9 := hnotform p pdvd podd\n      have pprime' := pprime.abs\n      rw [HA] at pprime'\n      have pdvd' : A.norm \u2223 a.norm := by\n        rw [\u2190 hfactor, \u2190 HA, abs_dvd]\n        exact dvd_mul_of_dvd_right pdvd _\n      obtain \u27e8c, -, hcd\u27e9 := Spts.mul_of_dvd'' pdvd' pprime'\n      obtain \u27e8q, rfl\u27e9 := pdvd\n      have hqpos : q \u2260 0 := right_ne_zero_of_mul hgpos\n      have : (p.sign * q).natAbs = q.natAbs := by\n        rw [Int.natAbs_mul, Int.natAbs_sign_of_nonzero pprime.ne_zero, one_mul]\n      refine' IH q.natAbs _ c (p.sign * q) _ _ _ this\n      \u00b7 rw [Int.natAbs_mul]\n        apply lt_mul_of_one_lt_left (Int.natAbs_pos.mpr hqpos)\n        rw [Int.prime_iff_natAbs_prime] at pprime\n        exact pprime.one_lt\n      \u00b7 rwa [\u2190 Int.natAbs_eq_zero, this, Int.natAbs_eq_zero]\n      \u00b7\n        rw [\u2190 mul_right_inj' pprime'.ne_zero, \u2190 hcd, mul_left_comm, \u2190 hfactor, \u2190 HA, \u2190\n          mul_assoc (|p|), mul_comm (|p|), Int.sign_mul_abs]\n      \u00b7 intro f' hf'dvd hf'odd\n        refine' hnotform f' _ hf'odd\n        rw [\u2190 Int.dvd_natAbs, this, Int.dvd_natAbs] at hf'dvd\n        exact hf'dvd.mul_left _\n#align factors' factors'\n\ntheorem Zqrtd.factor_div (a : \u2124\u221a(-3)) {x : \u2124} (hodd : Odd x) :\n    \u2203 c m : \u2124\u221a(-3), a = c + m * x \u2227 c.norm < x ^ 2 :=\n  by\n  obtain \u27e8m, c, ha, hc\u27e9 := Int.factor_div a.re x hodd\n  obtain \u27e8n, d, hb, hd\u27e9 := Int.factor_div a.im x hodd\n  set c' : \u2124\u221a(-3) := \u27e8c, d\u27e9\n  refine' \u27e8c', \u27e8m, n\u27e9, _, _\u27e9\n  \u00b7\n    simp only [Zsqrtd.ext, ha, hb, add_zero, Zsqrtd.coe_int_re, eq_self_iff_true, Zsqrtd.mul_im,\n      zero_add, Zsqrtd.add_im, and_self_iff, Zsqrtd.mul_re, MulZeroClass.mul_zero, Zsqrtd.add_re,\n      Zsqrtd.coe_int_im]\n  \u00b7 rw [\u2190 mul_lt_mul_left (by norm_num : (0 : \u2124) < 4)]\n    calc\n      4 * c'.norm = (2 * c) ^ 2 + 3 * (2 * d) ^ 2 :=\n        by\n        rw [Zsqrtd.norm_def]\n        ring\n      _ < x ^ 2 + 3 * x ^ 2 := (add_lt_add ?_ ?_)\n      _ = 4 * x ^ 2 := by ring\n      \n    \u00b7 rw [mul_pow, \u2190 Int.natAbs_pow_two c, \u2190 Int.natAbs_pow_two x, \u2190 mul_pow]\n      norm_cast\n      exact Nat.pow_lt_pow_of_lt_left hc zero_lt_two\n    \u00b7 rw [mul_pow, \u2190 Int.natAbs_pow_two d, \u2190 Int.natAbs_pow_two x, \u2190 mul_pow,\n        mul_lt_mul_left (by norm_num : (0 : \u2124) < 3)]\n      norm_cast\n      exact Nat.pow_lt_pow_of_lt_left hd zero_lt_two\n#align zqrtd.factor_div Zqrtd.factor_div\n\ntheorem Zqrtd.factor_div' (a : \u2124\u221a(-3)) {x : \u2124} (hodd : Odd x) (h : 1 < |x|)\n    (hcoprime : IsCoprime a.re a.im) (hfactor : x \u2223 a.norm) :\n    \u2203 c m : \u2124\u221a(-3),\n      a = c + m * x \u2227 c.norm < x ^ 2 \u2227 c \u2260 0 \u2227 \u2203 y, c.norm = x * y \u2227 y.natAbs < x.natAbs :=\n  by\n  obtain \u27e8c, m, rfl, h2\u27e9 := Zqrtd.factor_div a hodd\n  refine' \u27e8c, m, rfl, h2, _, _\u27e9\n  \u00b7 rintro rfl\n    apply h.ne'\n    rw [\u2190 Int.isUnit_iff_abs_eq]\n    apply hcoprime.isUnit_of_dvd' <;>\n      simp only [zero_add, mul_comm m, Zsqrtd.smul_re, Zsqrtd.smul_im, dvd_mul_right]\n  \u00b7 obtain \u27e8y, hy\u27e9 : x \u2223 c.norm :=\n      by\n      set e : \u2124 := m.re ^ 2 * x + 2 * m.re * c.re + 3 * m.im ^ 2 * x + 6 * m.im * c.im with he\n      convert dvd_sub hfactor (dvd_mul_right x e)\n      rw [he, Zsqrtd.norm_def, Zsqrtd.norm_def]\n      simp only [Zsqrtd.coe_int_re, Zsqrtd.mul_im, Zsqrtd.add_im, Zsqrtd.mul_re, Zsqrtd.add_re,\n        Zsqrtd.coe_int_im]\n      ring\n    refine' \u27e8y, hy, _\u27e9\n    have h0'' : 0 < x.natAbs := by\n      zify\n      exact zero_lt_one.trans h\n    rw [\u2190 mul_lt_mul_left h0'', \u2190 pow_two, \u2190 Int.natAbs_mul, \u2190 hy]\n    zify\n    rwa [\u2190 Int.coe_natAbs x, Int.natAbs_pow_two x, \u2190 Int.coe_natAbs,\n      Int.natAbs_of_nonneg (Zsqrtd.norm_nonneg (by norm_num) c)]\n#align zqrtd.factor_div' Zqrtd.factor_div'\n\n-- Edwards p50 step (5')\ntheorem factors (a : \u2124\u221a(-3)) (x : \u2124) (hcoprime : IsCoprime a.re a.im) (hodd : Odd x)\n    (hfactor : x \u2223 a.norm) : \u2203 c : \u2124\u221a(-3), abs x = c.norm :=\n  by\n  induction' hx' : x.natAbs using Nat.strong_induction_on with x' IH generalizing a x\n  subst hx'\n  have hneg1 : 1 \u2264 a.norm := by\n    rw [\u2190 Int.sub_one_lt_iff, sub_self]\n    apply lt_of_le_of_ne (Zsqrtd.norm_nonneg (by norm_num) a)\n    rw [Ne.def, eq_comm, Zsqrtd.norm_eq_zero_iff (by norm_num : (-3 : \u2124) < 0)]\n    rintro rfl\n    rw [Zsqrtd.zero_im, Zsqrtd.zero_re] at hcoprime\n    exact not_isCoprime_zero_zero hcoprime\n  have h0 : x \u2260 0 := by\n    rintro rfl\n    simp only [even_zero, not_true, Int.odd_iff_not_even] at hodd\n  have h0' : 1 \u2264 abs x := by rwa [\u2190 Int.sub_one_lt_iff, sub_self, abs_pos]\n  cases' h0'.eq_or_lt with h h\n  \u00b7 rw [\u2190 h]\n    refine' \u27e8\u27e81, 0\u27e9, _\u27e9\n    norm_num [Zsqrtd.norm_def]\n  obtain \u27e8c', m, rfl, -, h1, \u27e8y, hy, h3\u27e9\u27e9 := Zqrtd.factor_div' a hodd h hcoprime hfactor\n  have h4 : c'.norm \u2260 0 := by rwa [Ne.def, Zsqrtd.norm_eq_zero_iff (by norm_num) c']\n  set g := Int.gcd c'.re c'.im with hg\n  have hgpos : 0 < g := by rwa [hg, Zsqrtd.gcd_pos_iff]\n  obtain \u27e8C', HC', HCDcoprime\u27e9 := Zsqrtd.exists_coprime_of_gcd_pos hgpos\n  have h5 : x * y = (g : \u2124) ^ 2 * C'.norm := by\n    rw [\u2190 hy, HC', Zsqrtd.norm_mul, Zsqrtd.norm_int_cast, \u2190 pow_two]\n  obtain \u27e8z, hz\u27e9 : (g : \u2124) ^ 2 \u2223 y :=\n    by\n    have : (g : \u2124) ^ 2 \u2223 x * y := by\n      rw [h5]\n      exact dvd_mul_right _ _\n    apply IsCoprime.dvd_of_dvd_mul_left _ this\n    apply isCoprime_of_prime_dvd\n    \u00b7 contrapose! h0\n      exact h0.2\n    intro p hpprime hpdvdleft hpdvdright\n    have : \u2191p \u2223 c' + m * x := by\n      rw [HC']\n      exact\n        dvd_add\n          (dvd_mul_of_dvd_left\n            ((Zsqrtd.coe_int_dvd_coe_int _ _).mpr (hpprime.dvd_of_dvd_pow hpdvdleft)) _)\n          (dvd_mul_of_dvd_right ((Zsqrtd.coe_int_dvd_coe_int _ _).mpr hpdvdright) _)\n    have := Zsqrtd.coprime_of_dvd_coprime hcoprime this\n    simp only [Zsqrtd.coe_int_re, isCoprime_zero_right, Zsqrtd.coe_int_im, hpprime.not_unit] at this\n  have h6 : x * z = C'.norm :=\n    by\n    have hgnezero := Int.coe_nat_ne_zero_iff_pos.mpr hgpos\n    apply Int.eq_of_mul_eq_mul_left (pow_ne_zero 2 hgnezero)\n    rw [\u2190 h5, hz, mul_left_comm]\n  have h8 : z \u2260 0 := by\n    apply right_ne_zero_of_mul\n    apply right_ne_zero_of_mul\n    rwa [h6, \u2190 h5, \u2190 hy]\n  refine' factors' _ x z hodd h8 h6 _\n  intro w hwdvd hwodd\n  refine' IH w.natAbs _ C' w HCDcoprime hwodd _ rfl\n  \u00b7\n    calc\n      w.natAbs \u2264 z.natAbs :=\n        Nat.le_of_dvd (Int.natAbs_pos.mpr h8) (Int.natAbs_dvd_natAbs.mpr hwdvd)\n      _ \u2264 y.natAbs := by\n        rw [hz, Int.natAbs_mul]\n        exact Nat.le_mul_of_pos_left (pow_pos hgpos 2)\n      _ < x.natAbs := h3\n      \n  \u00b7 rw [\u2190 h6]\n    exact dvd_mul_of_dvd_right hwdvd x\n#align factors factors\n\ntheorem Spts.eq_one {a : \u2124\u221a(-3)} (h : a.norm = 1) : abs a.re = 1 \u2227 a.im = 0 :=\n  by\n  suffices H : abs a.re = 1\n  \u00b7 refine' \u27e8H, _\u27e9\n    rw [Zsqrtd.norm_def, mul_assoc, \u2190 Int.natAbs_mul_self' a.re, \u2190 Int.abs_eq_natAbs, H, one_mul,\n      neg_mul, sub_neg_eq_add, add_right_eq_self, mul_eq_zero, mul_self_eq_zero] at h\n    exact h.resolve_left three_ne_zero\n  contrapose! h\n  cases' lt_or_gt_of_ne h with H H\n  \u00b7 have : a.re = 0 := by rwa [\u2190 Int.abs_lt_one_iff]\n    simp only [Zsqrtd.norm_def, this, MulZeroClass.zero_mul, zero_sub, neg_mul, neg_neg]\n    by_cases hb : a.im = 0\n    \u00b7 simp only [hb, not_false_iff, zero_ne_one, MulZeroClass.mul_zero]\n    \u00b7 have : 1 \u2264 abs a.im := by rwa [\u2190 Int.abs_lt_one_iff, not_lt] at hb\n      have : 1 \u2264 a.im ^ 2 := by\n        rw [\u2190 sq_abs]\n        exact pow_le_pow_of_le_left zero_le_one this 2\n      linarith\n  \u00b7 apply ne_of_gt\n    rw [Zsqrtd.norm_def, neg_mul, neg_mul, sub_neg_eq_add]\n    apply lt_add_of_lt_of_nonneg\n    \u00b7 rw [\u2190 sq, \u2190 sq_abs]\n      exact pow_lt_pow_of_lt_left H zero_le_one zero_lt_two\n    \u00b7 rw [mul_assoc]\n      exact mul_nonneg zero_lt_three.le (mul_self_nonneg _)\n#align spts.eq_one Spts.eq_one\n\ntheorem Spts.eq_one' {a : \u2124\u221a(-3)} (h : a.norm = 1) : a = 1 \u2228 a = -1 := by\n  simp only [Zsqrtd.ext, Zsqrtd.one_re, Zsqrtd.one_im, Zsqrtd.neg_im, Zsqrtd.neg_re, neg_zero, \u2190\n    or_and_right, \u2190 abs_eq (zero_le_one' \u2124), Spts.eq_one h, eq_self_iff_true, and_self_iff]\n#align spts.eq_one' Spts.eq_one'\n\ntheorem Spts.ne_zero_of_coprime' (a : \u2124\u221a(-3)) (hcoprime : IsCoprime a.re a.im) : a.norm \u2260 0 :=\n  by\n  contrapose! hcoprime with H\n  obtain \u27e8rfl, rfl\u27e9 := (Zsqrtd.norm_eq_zero_iff (by norm_num) _).mp H\n  exact not_isCoprime_zero_zero\n#align spts.ne_zero_of_coprime' Spts.ne_zero_of_coprime'\n\ntheorem Spts.pos_of_coprime' {a : \u2124\u221a(-3)} (hcoprime : IsCoprime a.re a.im) : 0 < a.norm :=\n  by\n  apply lt_of_le_of_ne\n  \u00b7 apply Zsqrtd.norm_nonneg\n    norm_num\n  \u00b7 apply Ne.symm -- Porting note: `symm` fails\n    exact Spts.ne_zero_of_coprime' _ hcoprime\n#align spts.pos_of_coprime' Spts.pos_of_coprime'\n\ntheorem Spts.one_lt_of_im_ne_zero (a : \u2124\u221a(-3)) (hb : a.im \u2260 0) : 1 < a.norm :=\n  by\n  apply lt_of_le_of_ne\n  \u00b7 rw [\u2190 Int.sub_one_lt_iff, sub_self]\n    apply lt_of_le_of_ne (Zsqrtd.norm_nonneg (by norm_num) a)\n    contrapose! hb\n    rw [eq_comm, Zsqrtd.norm_eq_zero_iff (by norm_num) a] at hb\n    rw [hb, Zsqrtd.zero_im]\n  \u00b7 intro H\n    exact hb (Spts.eq_one H.symm).2\n#align spts.one_lt_of_im_ne_zero Spts.one_lt_of_im_ne_zero\n\ntheorem Spts.not_two (a : \u2124\u221a(-3)) : a.norm \u2260 2 :=\n  by\n  rw [Zsqrtd.norm_def]\n  obtain him | him := eq_or_ne a.im 0\n  \u00b7 rw [him, MulZeroClass.mul_zero, sub_zero, \u2190 Int.natAbs_mul_self, \u2190 sq]\n    norm_cast\n    apply (Nat.pow_left_strictMono one_le_two).monotone.ne_of_lt_of_lt_nat 1 <;> norm_num\n  \u00b7 apply ne_of_gt\n    apply lt_add_of_nonneg_of_lt (mul_self_nonneg a.re)\n    rw [\u2190 Int.add_one_le_iff]\n    rw [mul_assoc, neg_mul_eq_neg_mul, neg_neg]\n    refine' le_mul_of_one_le_right zero_lt_three.le _\n    rwa [\u2190 Int.sub_one_lt_iff, sub_self, mul_self_pos]\n#align spts.not_two Spts.not_two\n\ntheorem Spts.four {p : \u2124\u221a(-3)} (hfour : p.norm = 4) (hq : p.im \u2260 0) : abs p.re = 1 \u2227 abs p.im = 1 :=\n  by\n  suffices p.re ^ 2 = 1 \u2227 p.im ^ 2 = 1 by\n    apply And.imp _ _ this <;>\n      \u00b7 intro h\n        rwa [\u2190 sq_eq_sq (abs_nonneg (_ : \u2124)) zero_le_one, one_pow, sq_abs]\n  have hq : p.im ^ 2 = 1 := by\n    apply le_antisymm\n    \u00b7 contrapose! hfour with hq'\n      apply ne_of_gt\n      rw [\u2190 Int.add_one_le_iff] at hq'\n      calc\n        4 < 3 * 2 := by norm_num\n        _ \u2264 3 * p.im ^ 2 := (Int.mul_le_mul_of_nonneg_left hq' (by norm_num))\n        _ \u2264 p.re ^ 2 + 3 * p.im ^ 2 := (le_add_of_nonneg_left (pow_two_nonneg p.re))\n        _ = p.norm := by\n          rw [Zsqrtd.norm_def]\n          ring\n        \n    \u00b7 rw [\u2190 Int.sub_one_lt_iff, sub_self]\n      exact sq_pos_of_ne_zero _ hq\n  refine' \u27e8_, hq\u27e9\n  calc\n    p.re ^ 2 = p.re ^ 2 + 3 * p.im ^ 2 - 3 := by rw [hq, mul_one, add_sub_cancel]\n    _ = p.norm - 3 := by\n      rw [Zsqrtd.norm_def]\n      ring\n    _ = 1 := by\n      rw [hfour]\n      norm_num\n    \n#align spts.four Spts.four\n\ntheorem Spts.four_of_coprime {p : \u2124\u221a(-3)} (hcoprime : IsCoprime p.re p.im) (hfour : p.norm = 4) :\n    abs p.re = 1 \u2227 abs p.im = 1 := by\n  apply Spts.four hfour\n  rintro him\n  rw [him, isCoprime_zero_right, Int.isUnit_iff_abs_eq] at hcoprime\n  rw [Zsqrtd.norm_def, him, MulZeroClass.mul_zero, sub_zero, \u2190 sq, \u2190 sq_abs, hcoprime] at hfour\n  norm_num at hfour\n#align spts.four_of_coprime Spts.four_of_coprime\n"}
{"text": "[GOAL]\n\u22a2 StrictConvexOn \u211d univ exp\n[PROOFSTEP]\napply strictConvexOn_of_slope_strict_mono_adjacent convex_univ\n[GOAL]\n\u22a2 \u2200 {x y z : \u211d}, x \u2208 univ \u2192 z \u2208 univ \u2192 x < y \u2192 y < z \u2192 (exp y - exp x) / (y - x) < (exp z - exp y) / (z - y)\n[PROOFSTEP]\nrintro x y z - - hxy hyz\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\n\u22a2 (exp y - exp x) / (y - x) < (exp z - exp y) / (z - y)\n[PROOFSTEP]\ntrans exp y\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\n\u22a2 (exp y - exp x) / (y - x) < exp y\n[PROOFSTEP]\nhave h1 : 0 < y - x := by linarith\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\n\u22a2 0 < y - x\n[PROOFSTEP]\nlinarith\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\n\u22a2 (exp y - exp x) / (y - x) < exp y\n[PROOFSTEP]\nhave h2 : x - y < 0 := by linarith\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\n\u22a2 x - y < 0\n[PROOFSTEP]\nlinarith\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 (exp y - exp x) / (y - x) < exp y\n[PROOFSTEP]\nrw [div_lt_iff h1]\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 exp y - exp x < exp y * (y - x)\n[PROOFSTEP]\ncalc\n  exp y - exp x = exp y - exp y * exp (x - y) := by rw [\u2190 exp_add]; ring_nf\n  _ = exp y * (1 - exp (x - y)) := by ring\n  _ < exp y * -(x - y) := by gcongr; linarith [add_one_lt_exp_of_nonzero h2.ne]\n  _ = exp y * (y - x) := by ring\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 exp y - exp x = exp y - exp y * exp (x - y)\n[PROOFSTEP]\nrw [\u2190 exp_add]\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 exp y - exp x = exp y - exp (y + (x - y))\n[PROOFSTEP]\nring_nf\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 exp y - exp y * exp (x - y) = exp y * (1 - exp (x - y))\n[PROOFSTEP]\nring\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 exp y * (1 - exp (x - y)) < exp y * -(x - y)\n[PROOFSTEP]\ngcongr\n[GOAL]\ncase bc\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 1 - exp (x - y) < -(x - y)\n[PROOFSTEP]\nlinarith [add_one_lt_exp_of_nonzero h2.ne]\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < y - x\nh2 : x - y < 0\n\u22a2 exp y * -(x - y) = exp y * (y - x)\n[PROOFSTEP]\nring\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\n\u22a2 exp y < (exp z - exp y) / (z - y)\n[PROOFSTEP]\nhave h1 : 0 < z - y := by linarith\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\n\u22a2 0 < z - y\n[PROOFSTEP]\nlinarith\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 exp y < (exp z - exp y) / (z - y)\n[PROOFSTEP]\nrw [lt_div_iff h1]\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 exp y * (z - y) < exp z - exp y\n[PROOFSTEP]\ncalc\n  exp y * (z - y) < exp y * (exp (z - y) - 1) := by\n    gcongr _ * ?_\n    linarith [add_one_lt_exp_of_nonzero h1.ne']\n  _ = exp (z - y) * exp y - exp y := by ring\n  _ \u2264 exp z - exp y := by rw [\u2190 exp_add]; ring_nf; rfl\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 exp y * (z - y) < exp y * (exp (z - y) - 1)\n[PROOFSTEP]\ngcongr _ * ?_\n[GOAL]\ncase bc\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 z - y < exp (z - y) - 1\n[PROOFSTEP]\nlinarith [add_one_lt_exp_of_nonzero h1.ne']\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 exp y * (exp (z - y) - 1) = exp (z - y) * exp y - exp y\n[PROOFSTEP]\nring\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 exp (z - y) * exp y - exp y \u2264 exp z - exp y\n[PROOFSTEP]\nrw [\u2190 exp_add]\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 exp (z - y + y) - exp y \u2264 exp z - exp y\n[PROOFSTEP]\nring_nf\n[GOAL]\nx y z : \u211d\nhxy : x < y\nhyz : y < z\nh1 : 0 < z - y\n\u22a2 exp z - exp y \u2264 exp z - exp y\n[PROOFSTEP]\nrfl\n[GOAL]\nn : \u2115\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ n\n[PROOFSTEP]\ninduction' n with k IH\n[GOAL]\ncase zero\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ Nat.zero\n[PROOFSTEP]\nexact convexOn_const (1 : \u211d) (convex_Ici _)\n[GOAL]\ncase succ\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ Nat.succ k\n[PROOFSTEP]\nrefine' \u27e8convex_Ici _, _\u27e9\n[GOAL]\ncase succ\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\n\u22a2 \u2200 \u2983x : \u211d\u2984,\n    x \u2208 Ici 0 \u2192\n      \u2200 \u2983y : \u211d\u2984,\n        y \u2208 Ici 0 \u2192\n          \u2200 \u2983a b : \u211d\u2984,\n            0 \u2264 a \u2192\n              0 \u2264 b \u2192\n                a + b = 1 \u2192\n                  (fun x => x ^ Nat.succ k) (a \u2022 x + b \u2022 y) \u2264\n                    a \u2022 (fun x => x ^ Nat.succ k) x + b \u2022 (fun x => x ^ Nat.succ k) y\n[PROOFSTEP]\nrintro a (ha : 0 \u2264 a) b (hb : 0 \u2264 b) \u03bc \u03bd h\u03bc h\u03bd h\n[GOAL]\ncase succ\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 (fun x => x ^ Nat.succ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ Nat.succ k) a + \u03bd \u2022 (fun x => x ^ Nat.succ k) b\n[PROOFSTEP]\nhave H := IH.2 ha hb h\u03bc h\u03bd h\n[GOAL]\ncase succ\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\n\u22a2 (fun x => x ^ Nat.succ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ Nat.succ k) a + \u03bd \u2022 (fun x => x ^ Nat.succ k) b\n[PROOFSTEP]\nhave : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd :=\n  by\n  cases' le_or_lt a b with hab hab\n  \u00b7 have : a ^ k \u2264 b ^ k := by gcongr\n    have : 0 \u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\n    positivity\n  \u00b7 have : b ^ k \u2264 a ^ k := by gcongr\n    have : 0 \u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\n    positivity\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\ncases' le_or_lt a b with hab hab\n[GOAL]\ncase inl\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : a \u2264 b\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\nhave : a ^ k \u2264 b ^ k := by gcongr\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : a \u2264 b\n\u22a2 a ^ k \u2264 b ^ k\n[PROOFSTEP]\ngcongr\n[GOAL]\ncase inl\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : a \u2264 b\nthis : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\nhave : 0 \u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : a \u2264 b\nthis : a ^ k \u2264 b ^ k\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a)\n[PROOFSTEP]\nnlinarith\n[GOAL]\ncase inl\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : a \u2264 b\nthis\u271d : a ^ k \u2264 b ^ k\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a)\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\npositivity\n[GOAL]\ncase inr\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : b < a\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\nhave : b ^ k \u2264 a ^ k := by gcongr\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : b < a\n\u22a2 b ^ k \u2264 a ^ k\n[PROOFSTEP]\ngcongr\n[GOAL]\ncase inr\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : b < a\nthis : b ^ k \u2264 a ^ k\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\nhave : 0 \u2264 (b ^ k - a ^ k) * (b - a) := by nlinarith\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : b < a\nthis : b ^ k \u2264 a ^ k\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a)\n[PROOFSTEP]\nnlinarith\n[GOAL]\ncase inr\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nhab : b < a\nthis\u271d : b ^ k \u2264 a ^ k\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a)\n\u22a2 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\npositivity\n[GOAL]\ncase succ\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 (fun x => x ^ Nat.succ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ Nat.succ k) a + \u03bd \u2022 (fun x => x ^ Nat.succ k) b\n[PROOFSTEP]\ncalc\n  (\u03bc * a + \u03bd * b) ^ k.succ = (\u03bc * a + \u03bd * b) * (\u03bc * a + \u03bd * b) ^ k := pow_succ _ _\n  _ \u2264 (\u03bc * a + \u03bd * b) * (\u03bc * a ^ k + \u03bd * b ^ k) := by gcongr; exact H\n  _ \u2264 (\u03bc * a + \u03bd * b) * (\u03bc * a ^ k + \u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd := by linarith\n  _ = (\u03bc + \u03bd) * (\u03bc * a ^ k.succ + \u03bd * b ^ k.succ) := by rw [Nat.succ_eq_add_one]; ring\n  _ = \u03bc * a ^ k.succ + \u03bd * b ^ k.succ := by rw [h]; ring\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 (\u03bc * a + \u03bd * b) * (\u03bc * a + \u03bd * b) ^ k \u2264 (\u03bc * a + \u03bd * b) * (\u03bc * a ^ k + \u03bd * b ^ k)\n[PROOFSTEP]\ngcongr\n[GOAL]\ncase h\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 (\u03bc * a + \u03bd * b) ^ k \u2264 \u03bc * a ^ k + \u03bd * b ^ k\n[PROOFSTEP]\nexact H\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 (\u03bc * a + \u03bd * b) * (\u03bc * a ^ k + \u03bd * b ^ k) \u2264\n    (\u03bc * a + \u03bd * b) * (\u03bc * a ^ k + \u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n[PROOFSTEP]\nlinarith\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 (\u03bc * a + \u03bd * b) * (\u03bc * a ^ k + \u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd =\n    (\u03bc + \u03bd) * (\u03bc * a ^ Nat.succ k + \u03bd * b ^ Nat.succ k)\n[PROOFSTEP]\nrw [Nat.succ_eq_add_one]\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 (\u03bc * a + \u03bd * b) * (\u03bc * a ^ k + \u03bd * b ^ k) + (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd =\n    (\u03bc + \u03bd) * (\u03bc * a ^ (k + 1) + \u03bd * b ^ (k + 1))\n[PROOFSTEP]\nring\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 (\u03bc + \u03bd) * (\u03bc * a ^ Nat.succ k + \u03bd * b ^ Nat.succ k) = \u03bc * a ^ Nat.succ k + \u03bd * b ^ Nat.succ k\n[PROOFSTEP]\nrw [h]\n[GOAL]\nk : \u2115\nIH : ConvexOn \u211d (Ici 0) fun x => x ^ k\na : \u211d\nha : 0 \u2264 a\nb : \u211d\nhb : 0 \u2264 b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nH : (fun x => x ^ k) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ k) a + \u03bd \u2022 (fun x => x ^ k) b\nthis : 0 \u2264 (b ^ k - a ^ k) * (b - a) * \u03bc * \u03bd\n\u22a2 1 * (\u03bc * a ^ Nat.succ k + \u03bd * b ^ Nat.succ k) = \u03bc * a ^ Nat.succ k + \u03bd * b ^ Nat.succ k\n[PROOFSTEP]\nring\n[GOAL]\nn : \u2115\nhn : Even n\n\u22a2 ConvexOn \u211d univ fun x => x ^ n\n[PROOFSTEP]\nrefine' \u27e8convex_univ, _\u27e9\n[GOAL]\nn : \u2115\nhn : Even n\n\u22a2 \u2200 \u2983x : \u211d\u2984,\n    x \u2208 univ \u2192\n      \u2200 \u2983y : \u211d\u2984,\n        y \u2208 univ \u2192\n          \u2200 \u2983a b : \u211d\u2984,\n            0 \u2264 a \u2192\n              0 \u2264 b \u2192 a + b = 1 \u2192 (fun x => x ^ n) (a \u2022 x + b \u2022 y) \u2264 a \u2022 (fun x => x ^ n) x + b \u2022 (fun x => x ^ n) y\n[PROOFSTEP]\nrintro a - b - \u03bc \u03bd h\u03bc h\u03bd h\n[GOAL]\nn : \u2115\nhn : Even n\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 (fun x => x ^ n) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ n) a + \u03bd \u2022 (fun x => x ^ n) b\n[PROOFSTEP]\nobtain \u27e8k, rfl\u27e9 :=\n  hn.exists_two_nsmul\n    _\n      -- Porting note: added type ascription to LHS\n[GOAL]\ncase intro\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\n\u22a2 (fun x => x ^ (2 \u2022 k)) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ (2 \u2022 k)) a + \u03bd \u2022 (fun x => x ^ (2 \u2022 k)) b\n[PROOFSTEP]\nhave : (0 : \u211d) \u2264 (a - b) ^ 2 * \u03bc * \u03bd := by positivity\n[GOAL]\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\n\u22a2 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n[PROOFSTEP]\npositivity\n[GOAL]\ncase intro\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 (fun x => x ^ (2 \u2022 k)) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => x ^ (2 \u2022 k)) a + \u03bd \u2022 (fun x => x ^ (2 \u2022 k)) b\n[PROOFSTEP]\ncalc\n  (\u03bc * a + \u03bd * b) ^ (2 * k) = ((\u03bc * a + \u03bd * b) ^ 2) ^ k := by rw [pow_mul]\n  _ \u2264 ((\u03bc + \u03bd) * (\u03bc * a ^ 2 + \u03bd * b ^ 2)) ^ k := by gcongr; linarith\n  _ = (\u03bc * a ^ 2 + \u03bd * b ^ 2) ^ k := by rw [h]; ring\n  _ \u2264 \u03bc * (a ^ 2) ^ k + \u03bd * (b ^ 2) ^ k := ?_\n  _ \u2264 \u03bc * a ^ (2 * k) + \u03bd * b ^ (2 * k) := by ring_nf;\n    rfl\n      -- Porting note: `rw [mem_Ici]` was `dsimp`\n[GOAL]\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 (\u03bc * a + \u03bd * b) ^ (2 * k) = ((\u03bc * a + \u03bd * b) ^ 2) ^ k\n[PROOFSTEP]\nrw [pow_mul]\n[GOAL]\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 ((\u03bc * a + \u03bd * b) ^ 2) ^ k \u2264 ((\u03bc + \u03bd) * (\u03bc * a ^ 2 + \u03bd * b ^ 2)) ^ k\n[PROOFSTEP]\ngcongr\n[GOAL]\ncase hab\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 (\u03bc * a + \u03bd * b) ^ 2 \u2264 (\u03bc + \u03bd) * (\u03bc * a ^ 2 + \u03bd * b ^ 2)\n[PROOFSTEP]\nlinarith\n[GOAL]\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 ((\u03bc + \u03bd) * (\u03bc * a ^ 2 + \u03bd * b ^ 2)) ^ k = (\u03bc * a ^ 2 + \u03bd * b ^ 2) ^ k\n[PROOFSTEP]\nrw [h]\n[GOAL]\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 (1 * (\u03bc * a ^ 2 + \u03bd * b ^ 2)) ^ k = (\u03bc * a ^ 2 + \u03bd * b ^ 2) ^ k\n[PROOFSTEP]\nring\n[GOAL]\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 \u03bc * (a ^ 2) ^ k + \u03bd * (b ^ 2) ^ k \u2264 \u03bc * a ^ (2 * k) + \u03bd * b ^ (2 * k)\n[PROOFSTEP]\nring_nf\n[GOAL]\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 \u03bc * a ^ (k * 2) + \u03bd * b ^ (k * 2) \u2264 \u03bc * a ^ (k * 2) + \u03bd * b ^ (k * 2)\n[PROOFSTEP]\nrfl\n  -- Porting note: `rw [mem_Ici]` was `dsimp`\n[GOAL]\ncase intro\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 (\u03bc * a ^ 2 + \u03bd * b ^ 2) ^ k \u2264 \u03bc * (a ^ 2) ^ k + \u03bd * (b ^ 2) ^ k\n[PROOFSTEP]\nrefine' (convexOn_pow k).2 _ _ h\u03bc h\u03bd h\n[GOAL]\ncase intro.refine'_1\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 a ^ 2 \u2208 Ici 0\n[PROOFSTEP]\nrw [mem_Ici]\n[GOAL]\ncase intro.refine'_2\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 b ^ 2 \u2208 Ici 0\n[PROOFSTEP]\nrw [mem_Ici]\n[GOAL]\ncase intro.refine'_1\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 0 \u2264 a ^ 2\n[PROOFSTEP]\npositivity\n[GOAL]\ncase intro.refine'_2\na b \u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nk : \u2115\nhn : Even (2 \u2022 k)\nthis : 0 \u2264 (a - b) ^ 2 * \u03bc * \u03bd\n\u22a2 0 \u2264 b ^ 2\n[PROOFSTEP]\npositivity\n[GOAL]\nn : \u2115\n\u22a2 ConvexOn \u211d (Ioi 0) fun x => x ^ \u2191n\n[PROOFSTEP]\nsimp_rw [zpow_ofNat]\n[GOAL]\nn : \u2115\n\u22a2 ConvexOn \u211d (Ioi 0) fun x => x ^ n\n[PROOFSTEP]\nexact (convexOn_pow n).subset Ioi_subset_Ici_self (convex_Ioi _)\n[GOAL]\nn : \u2115\n\u22a2 ConvexOn \u211d (Ioi 0) fun x => x ^ -[n+1]\n[PROOFSTEP]\nsimp_rw [zpow_negSucc]\n[GOAL]\nn : \u2115\n\u22a2 ConvexOn \u211d (Ioi 0) fun x => (x ^ (n + 1))\u207b\u00b9\n[PROOFSTEP]\nrefine' \u27e8convex_Ioi _, _\u27e9\n[GOAL]\nn : \u2115\n\u22a2 \u2200 \u2983x : \u211d\u2984,\n    x \u2208 Ioi 0 \u2192\n      \u2200 \u2983y : \u211d\u2984,\n        y \u2208 Ioi 0 \u2192\n          \u2200 \u2983a b : \u211d\u2984,\n            0 \u2264 a \u2192\n              0 \u2264 b \u2192\n                a + b = 1 \u2192\n                  (fun x => (x ^ (n + 1))\u207b\u00b9) (a \u2022 x + b \u2022 y) \u2264\n                    a \u2022 (fun x => (x ^ (n + 1))\u207b\u00b9) x + b \u2022 (fun x => (x ^ (n + 1))\u207b\u00b9) y\n[PROOFSTEP]\nrintro a (ha : 0 < a) b (hb : 0 < b) \u03bc \u03bd h\u03bc h\u03bd h\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 (fun x => (x ^ (n + 1))\u207b\u00b9) (\u03bc \u2022 a + \u03bd \u2022 b) \u2264 \u03bc \u2022 (fun x => (x ^ (n + 1))\u207b\u00b9) a + \u03bd \u2022 (fun x => (x ^ (n + 1))\u207b\u00b9) b\n[PROOFSTEP]\nfield_simp [ha.ne', hb.ne']\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 1 / (\u03bc * a + \u03bd * b) ^ (n + 1) \u2264 (\u03bc * b ^ (n + 1) + \u03bd * a ^ (n + 1)) / (a ^ (n + 1) * b ^ (n + 1))\n[PROOFSTEP]\nrw [div_le_div_iff]\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 1 * (a ^ (n + 1) * b ^ (n + 1)) \u2264 (\u03bc * b ^ (n + 1) + \u03bd * a ^ (n + 1)) * (\u03bc * a + \u03bd * b) ^ (n + 1)\n[PROOFSTEP]\ncalc\n  (1 : \u211d) * (a ^ (n + 1) * b ^ (n + 1)) = ((\u03bc + \u03bd) ^ 2 * (a * b)) ^ (n + 1) := by rw [h]; ring\n  _ \u2264 ((\u03bc * b + \u03bd * a) * (\u03bc * a + \u03bd * b)) ^ (n + 1) := ?_\n  _ = (\u03bc * b + \u03bd * a) ^ (n + 1) * (\u03bc * a + \u03bd * b) ^ (n + 1) := by rw [mul_pow]\n  _ \u2264 (\u03bc * b ^ (n + 1) + \u03bd * a ^ (n + 1)) * (\u03bc * a + \u03bd * b) ^ (n + 1) := ?_\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 1 * (a ^ (n + 1) * b ^ (n + 1)) = ((\u03bc + \u03bd) ^ 2 * (a * b)) ^ (n + 1)\n[PROOFSTEP]\nrw [h]\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 1 * (a ^ (n + 1) * b ^ (n + 1)) = (1 ^ 2 * (a * b)) ^ (n + 1)\n[PROOFSTEP]\nring\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 ((\u03bc * b + \u03bd * a) * (\u03bc * a + \u03bd * b)) ^ (n + 1) = (\u03bc * b + \u03bd * a) ^ (n + 1) * (\u03bc * a + \u03bd * b) ^ (n + 1)\n[PROOFSTEP]\nrw [mul_pow]\n[GOAL]\ncase calc_1\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 ((\u03bc + \u03bd) ^ 2 * (a * b)) ^ (n + 1) \u2264 ((\u03bc * b + \u03bd * a) * (\u03bc * a + \u03bd * b)) ^ (n + 1)\n[PROOFSTEP]\ngcongr(?_ : \u211d) ^ _\n[GOAL]\ncase calc_1.hab\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 (\u03bc + \u03bd) ^ 2 * (a * b) \u2264 (\u03bc * b + \u03bd * a) * (\u03bc * a + \u03bd * b)\n[PROOFSTEP]\nhave : (0 : \u211d) \u2264 \u03bc * \u03bd * (a - b) ^ 2 := by positivity\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 0 \u2264 \u03bc * \u03bd * (a - b) ^ 2\n[PROOFSTEP]\npositivity\n[GOAL]\ncase calc_1.hab\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nthis : 0 \u2264 \u03bc * \u03bd * (a - b) ^ 2\n\u22a2 (\u03bc + \u03bd) ^ 2 * (a * b) \u2264 (\u03bc * b + \u03bd * a) * (\u03bc * a + \u03bd * b)\n[PROOFSTEP]\nlinarith\n[GOAL]\ncase calc_2\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 (\u03bc * b + \u03bd * a) ^ (n + 1) * (\u03bc * a + \u03bd * b) ^ (n + 1) \u2264\n    (\u03bc * b ^ (n + 1) + \u03bd * a ^ (n + 1)) * (\u03bc * a + \u03bd * b) ^ (n + 1)\n[PROOFSTEP]\ngcongr\n[GOAL]\ncase calc_2.h\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 (\u03bc * b + \u03bd * a) ^ (n + 1) \u2264 \u03bc * b ^ (n + 1) + \u03bd * a ^ (n + 1)\n[PROOFSTEP]\napply (convexOn_pow (n + 1)).2 hb.le ha.le h\u03bc h\u03bd h\n[GOAL]\ncase b0\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 0 < (\u03bc * a + \u03bd * b) ^ (n + 1)\n[PROOFSTEP]\nhave : 0 < \u03bc * a + \u03bd * b := by cases le_or_lt a b <;> nlinarith\n[GOAL]\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 0 < \u03bc * a + \u03bd * b\n[PROOFSTEP]\ncases le_or_lt a b\n[GOAL]\ncase inl\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nh\u271d : a \u2264 b\n\u22a2 0 < \u03bc * a + \u03bd * b\n[PROOFSTEP]\nnlinarith\n[GOAL]\ncase inr\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nh\u271d : b < a\n\u22a2 0 < \u03bc * a + \u03bd * b\n[PROOFSTEP]\nnlinarith\n[GOAL]\ncase b0\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\nthis : 0 < \u03bc * a + \u03bd * b\n\u22a2 0 < (\u03bc * a + \u03bd * b) ^ (n + 1)\n[PROOFSTEP]\npositivity\n[GOAL]\ncase d0\nn : \u2115\na : \u211d\nha : 0 < a\nb : \u211d\nhb : 0 < b\n\u03bc \u03bd : \u211d\nh\u03bc : 0 \u2264 \u03bc\nh\u03bd : 0 \u2264 \u03bd\nh : \u03bc + \u03bd = 1\n\u22a2 0 < a ^ (n + 1) * b ^ (n + 1)\n[PROOFSTEP]\npositivity\n[GOAL]\n\u22a2 StrictConcaveOn \u211d (Ioi 0) log\n[PROOFSTEP]\napply strictConcaveOn_of_slope_strict_anti_adjacent (convex_Ioi (0 : \u211d))\n[GOAL]\n\u22a2 \u2200 {x y z : \u211d}, x \u2208 Ioi 0 \u2192 z \u2208 Ioi 0 \u2192 x < y \u2192 y < z \u2192 (log z - log y) / (z - y) < (log y - log x) / (y - x)\n[PROOFSTEP]\nrintro x y z (hx : 0 < x) (hz : 0 < z) hxy hyz\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\n\u22a2 (log z - log y) / (z - y) < (log y - log x) / (y - x)\n[PROOFSTEP]\nhave hy : 0 < y := hx.trans hxy\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 (log z - log y) / (z - y) < (log y - log x) / (y - x)\n[PROOFSTEP]\ntrans y\u207b\u00b9\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 (log z - log y) / (z - y) < y\u207b\u00b9\n[PROOFSTEP]\nhave h : 0 < z - y := by linarith\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 0 < z - y\n[PROOFSTEP]\nlinarith\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\n\u22a2 (log z - log y) / (z - y) < y\u207b\u00b9\n[PROOFSTEP]\nrw [div_lt_iff h]\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\n\u22a2 log z - log y < y\u207b\u00b9 * (z - y)\n[PROOFSTEP]\nhave hyz' : 0 < z / y := by positivity\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\n\u22a2 0 < z / y\n[PROOFSTEP]\npositivity\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\nhyz' : 0 < z / y\n\u22a2 log z - log y < y\u207b\u00b9 * (z - y)\n[PROOFSTEP]\nhave hyz'' : z / y \u2260 1 := by\n  contrapose! h\n  rw [div_eq_one_iff_eq hy.ne'] at h \n  simp [h]\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\nhyz' : 0 < z / y\n\u22a2 z / y \u2260 1\n[PROOFSTEP]\ncontrapose! h\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhyz' : 0 < z / y\nh : z / y = 1\n\u22a2 z - y \u2264 0\n[PROOFSTEP]\nrw [div_eq_one_iff_eq hy.ne'] at h \n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhyz' : 0 < z / y\nh : z = y\n\u22a2 z - y \u2264 0\n[PROOFSTEP]\nsimp [h]\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\nhyz' : 0 < z / y\nhyz'' : z / y \u2260 1\n\u22a2 log z - log y < y\u207b\u00b9 * (z - y)\n[PROOFSTEP]\ncalc\n  log z - log y = log (z / y) := by rw [\u2190 log_div hz.ne' hy.ne']\n  _ < z / y - 1 := (log_lt_sub_one_of_pos hyz' hyz'')\n  _ = y\u207b\u00b9 * (z - y) := by field_simp [hy.ne']\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\nhyz' : 0 < z / y\nhyz'' : z / y \u2260 1\n\u22a2 log z - log y = log (z / y)\n[PROOFSTEP]\nrw [\u2190 log_div hz.ne' hy.ne']\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < z - y\nhyz' : 0 < z / y\nhyz'' : z / y \u2260 1\n\u22a2 z / y - 1 = y\u207b\u00b9 * (z - y)\n[PROOFSTEP]\nfield_simp [hy.ne']\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 y\u207b\u00b9 < (log y - log x) / (y - x)\n[PROOFSTEP]\nhave h : 0 < y - x := by linarith\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 0 < y - x\n[PROOFSTEP]\nlinarith\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\n\u22a2 y\u207b\u00b9 < (log y - log x) / (y - x)\n[PROOFSTEP]\nrw [lt_div_iff h]\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\n\u22a2 y\u207b\u00b9 * (y - x) < log y - log x\n[PROOFSTEP]\nhave hxy' : 0 < x / y := by positivity\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\n\u22a2 0 < x / y\n[PROOFSTEP]\npositivity\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\n\u22a2 y\u207b\u00b9 * (y - x) < log y - log x\n[PROOFSTEP]\nhave hxy'' : x / y \u2260 1 := by\n  contrapose! h\n  rw [div_eq_one_iff_eq hy.ne'] at h \n  simp [h]\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\n\u22a2 x / y \u2260 1\n[PROOFSTEP]\ncontrapose! h\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhxy' : 0 < x / y\nh : x / y = 1\n\u22a2 y - x \u2264 0\n[PROOFSTEP]\nrw [div_eq_one_iff_eq hy.ne'] at h \n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhxy' : 0 < x / y\nh : x = y\n\u22a2 y - x \u2264 0\n[PROOFSTEP]\nsimp [h]\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\nhxy'' : x / y \u2260 1\n\u22a2 y\u207b\u00b9 * (y - x) < log y - log x\n[PROOFSTEP]\ncalc\n  y\u207b\u00b9 * (y - x) = 1 - x / y := by field_simp [hy.ne']\n  _ < -log (x / y) := by linarith [log_lt_sub_one_of_pos hxy' hxy'']\n  _ = -(log x - log y) := by rw [log_div hx.ne' hy.ne']\n  _ = log y - log x := by ring\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\nhxy'' : x / y \u2260 1\n\u22a2 y\u207b\u00b9 * (y - x) = 1 - x / y\n[PROOFSTEP]\nfield_simp [hy.ne']\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\nhxy'' : x / y \u2260 1\n\u22a2 1 - x / y < -log (x / y)\n[PROOFSTEP]\nlinarith [log_lt_sub_one_of_pos hxy' hxy'']\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\nhxy'' : x / y \u2260 1\n\u22a2 -log (x / y) = -(log x - log y)\n[PROOFSTEP]\nrw [log_div hx.ne' hy.ne']\n[GOAL]\nx y z : \u211d\nhx : 0 < x\nhz : 0 < z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nh : 0 < y - x\nhxy' : 0 < x / y\nhxy'' : x / y \u2260 1\n\u22a2 -(log x - log y) = log y - log x\n[PROOFSTEP]\nring\n[GOAL]\ns : \u211d\nhs : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\n\u22a2 1 + p * s < (1 + s) ^ p\n[PROOFSTEP]\nrcases eq_or_lt_of_le hs with (rfl | hs)\n[GOAL]\ncase inl\np : \u211d\nhp : 1 < p\nhs : -1 \u2264 -1\nhs' : -1 \u2260 0\n\u22a2 1 + p * -1 < (1 + -1) ^ p\n[PROOFSTEP]\nhave : p \u2260 0 := by positivity\n[GOAL]\np : \u211d\nhp : 1 < p\nhs : -1 \u2264 -1\nhs' : -1 \u2260 0\n\u22a2 p \u2260 0\n[PROOFSTEP]\npositivity\n[GOAL]\ncase inl\np : \u211d\nhp : 1 < p\nhs : -1 \u2264 -1\nhs' : -1 \u2260 0\nthis : p \u2260 0\n\u22a2 1 + p * -1 < (1 + -1) ^ p\n[PROOFSTEP]\nsimpa [zero_rpow this]\n[GOAL]\ncase inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\n\u22a2 1 + p * s < (1 + s) ^ p\n[PROOFSTEP]\nhave hs1 : 0 < 1 + s := by linarith\n[GOAL]\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\n\u22a2 0 < 1 + s\n[PROOFSTEP]\nlinarith\n[GOAL]\ncase inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\n\u22a2 1 + p * s < (1 + s) ^ p\n[PROOFSTEP]\ncases' le_or_lt (1 + p * s) 0 with hs2 hs2\n[GOAL]\ncase inr.inl\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 1 + p * s \u2264 0\n\u22a2 1 + p * s < (1 + s) ^ p\n[PROOFSTEP]\nexact hs2.trans_lt (rpow_pos_of_pos hs1 _)\n[GOAL]\ncase inr.inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\n\u22a2 1 + p * s < (1 + s) ^ p\n[PROOFSTEP]\nrw [rpow_def_of_pos hs1, \u2190 exp_log hs2]\n[GOAL]\ncase inr.inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\n\u22a2 exp (log (1 + p * s)) < exp (log (1 + s) * p)\n[PROOFSTEP]\napply exp_strictMono\n[GOAL]\ncase inr.inr.a\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\n\u22a2 log (1 + p * s) < log (1 + s) * p\n[PROOFSTEP]\nhave hp : 0 < p := by positivity\n[GOAL]\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\n\u22a2 0 < p\n[PROOFSTEP]\npositivity\n[GOAL]\ncase inr.inr.a\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\n\u22a2 log (1 + p * s) < log (1 + s) * p\n[PROOFSTEP]\nhave hs3 : 1 + s \u2260 1 := by contrapose! hs'; linarith\n[GOAL]\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\n\u22a2 1 + s \u2260 1\n[PROOFSTEP]\ncontrapose! hs'\n[GOAL]\ns : \u211d\nhs\u271d : -1 \u2264 s\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs' : 1 + s = 1\n\u22a2 s = 0\n[PROOFSTEP]\nlinarith\n[GOAL]\ncase inr.inr.a\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\n\u22a2 log (1 + p * s) < log (1 + s) * p\n[PROOFSTEP]\nhave hs4 : 1 + p * s \u2260 1 := by contrapose! hs'; nlinarith\n[GOAL]\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\n\u22a2 1 + p * s \u2260 1\n[PROOFSTEP]\ncontrapose! hs'\n[GOAL]\ns : \u211d\nhs\u271d : -1 \u2264 s\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs' : 1 + p * s = 1\n\u22a2 s = 0\n[PROOFSTEP]\nnlinarith\n[GOAL]\ncase inr.inr.a\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs' : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\n\u22a2 log (1 + p * s) < log (1 + s) * p\n[PROOFSTEP]\ncases' lt_or_gt_of_ne hs' with hs' hs'\n[GOAL]\ncase inr.inr.a.inl\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s < 0\n\u22a2 log (1 + p * s) < log (1 + s) * p\n[PROOFSTEP]\nrw [\u2190 div_lt_iff hp, \u2190 div_lt_div_right_of_neg hs']\n  -- Porting note: previously we could write `zero_lt_one` inline,\n      -- but now Lean doesn't guess we are talking about `1` fast enough.\n[GOAL]\ncase inr.inr.a.inl\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s < 0\n\u22a2 log (1 + s) / s < log (1 + p * s) / p / s\n[PROOFSTEP]\nhaveI : (1 : \u211d) \u2208 Ioi 0 := zero_lt_one\n[GOAL]\ncase inr.inr.a.inl\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s < 0\nthis : 1 \u2208 Ioi 0\n\u22a2 log (1 + s) / s < log (1 + p * s) / p / s\n[PROOFSTEP]\nconvert strictConcaveOn_log_Ioi.secant_strict_mono this hs2 hs1 hs4 hs3 _ using 1\n[GOAL]\ncase h.e'_3\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s < 0\nthis : 1 \u2208 Ioi 0\n\u22a2 log (1 + s) / s = (log (1 + s) - log 1) / (1 + s - 1)\n[PROOFSTEP]\nfield_simp [log_one]\n[GOAL]\ncase h.e'_4\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s < 0\nthis : 1 \u2208 Ioi 0\n\u22a2 log (1 + p * s) / p / s = (log (1 + p * s) - log 1) / (1 + p * s - 1)\n[PROOFSTEP]\nfield_simp [log_one]\n[GOAL]\ncase inr.inr.a.inl\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s < 0\nthis : 1 \u2208 Ioi 0\n\u22a2 1 + p * s < 1 + s\n[PROOFSTEP]\nnlinarith\n[GOAL]\ncase inr.inr.a.inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s > 0\n\u22a2 log (1 + p * s) < log (1 + s) * p\n[PROOFSTEP]\nrw [\u2190 div_lt_iff hp, \u2190 div_lt_div_right hs']\n  -- Porting note: previously we could write `zero_lt_one` inline,\n      -- but now Lean doesn't guess we are talking about `1` fast enough.\n[GOAL]\ncase inr.inr.a.inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s > 0\n\u22a2 log (1 + p * s) / p / s < log (1 + s) / s\n[PROOFSTEP]\nhaveI : (1 : \u211d) \u2208 Ioi 0 := zero_lt_one\n[GOAL]\ncase inr.inr.a.inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s > 0\nthis : 1 \u2208 Ioi 0\n\u22a2 log (1 + p * s) / p / s < log (1 + s) / s\n[PROOFSTEP]\nconvert strictConcaveOn_log_Ioi.secant_strict_mono this hs1 hs2 hs3 hs4 _ using 1\n[GOAL]\ncase h.e'_3\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s > 0\nthis : 1 \u2208 Ioi 0\n\u22a2 log (1 + p * s) / p / s = (log (1 + p * s) - log 1) / (1 + p * s - 1)\n[PROOFSTEP]\nfield_simp [log_one, hp.ne']\n[GOAL]\ncase h.e'_4\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s > 0\nthis : 1 \u2208 Ioi 0\n\u22a2 log (1 + s) / s = (log (1 + s) - log 1) / (1 + s - 1)\n[PROOFSTEP]\nfield_simp [log_one]\n[GOAL]\ncase inr.inr.a.inr\ns : \u211d\nhs\u271d : -1 \u2264 s\nhs'\u271d : s \u2260 0\np : \u211d\nhp\u271d : 1 < p\nhs : -1 < s\nhs1 : 0 < 1 + s\nhs2 : 0 < 1 + p * s\nhp : 0 < p\nhs3 : 1 + s \u2260 1\nhs4 : 1 + p * s \u2260 1\nhs' : s > 0\nthis : 1 \u2208 Ioi 0\n\u22a2 1 + s < 1 + p * s\n[PROOFSTEP]\nnlinarith\n[GOAL]\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp : 1 \u2264 p\n\u22a2 1 + p * s \u2264 (1 + s) ^ p\n[PROOFSTEP]\nrcases eq_or_lt_of_le hp with (rfl | hp)\n[GOAL]\ncase inl\ns : \u211d\nhs : -1 \u2264 s\nhp : 1 \u2264 1\n\u22a2 1 + 1 * s \u2264 (1 + s) ^ 1\n[PROOFSTEP]\nsimp\n[GOAL]\ncase inr\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 1 + p * s \u2264 (1 + s) ^ p\n[PROOFSTEP]\nby_cases hs' : s = 0\n[GOAL]\ncase pos\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhs' : s = 0\n\u22a2 1 + p * s \u2264 (1 + s) ^ p\n[PROOFSTEP]\nsimp [hs']\n[GOAL]\ncase neg\ns : \u211d\nhs : -1 \u2264 s\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\nhs' : \u00acs = 0\n\u22a2 1 + p * s \u2264 (1 + s) ^ p\n[PROOFSTEP]\nexact (one_add_mul_self_lt_rpow_one_add hs hs' hp).le\n[GOAL]\np : \u211d\nhp : 1 < p\n\u22a2 StrictConvexOn \u211d (Ici 0) fun x => x ^ p\n[PROOFSTEP]\napply strictConvexOn_of_slope_strict_mono_adjacent (convex_Ici (0 : \u211d))\n[GOAL]\np : \u211d\nhp : 1 < p\n\u22a2 \u2200 {x y z : \u211d}, x \u2208 Ici 0 \u2192 z \u2208 Ici 0 \u2192 x < y \u2192 y < z \u2192 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nrintro x y z (hx : 0 \u2264 x) (hz : 0 \u2264 z) hxy hyz\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\n\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave hy : 0 < y := by linarith\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\n\u22a2 0 < y\n[PROOFSTEP]\nlinarith\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\n\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave hy' : 0 < y ^ p := rpow_pos_of_pos hy _\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\n\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave H1 : y ^ (p - 1 + 1) = y ^ (p - 1) * y := rpow_add_one hy.ne' _\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ (p - 1 + 1) = y ^ (p - 1) * y\n\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nring_nf at H1 \n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\n\u22a2 (y ^ p - x ^ p) / (y - x) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\ntrans p * y ^ (p - 1)\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\n\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\n[PROOFSTEP]\nhave h3 : 0 < y - x := by linarith only [hxy]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\n\u22a2 0 < y - x\n[PROOFSTEP]\nlinarith only [hxy]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\n\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\n[PROOFSTEP]\nhave hyx'' : x / y < 1 := by rwa [div_lt_one hy]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\n\u22a2 x / y < 1\n[PROOFSTEP]\nrwa [div_lt_one hy]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\n\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\n[PROOFSTEP]\nhave hyx''' : x / y - 1 < 0 := by linarith only [hyx'']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\n\u22a2 x / y - 1 < 0\n[PROOFSTEP]\nlinarith only [hyx'']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\n\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\n[PROOFSTEP]\nhave hyx'''' : 0 \u2264 x / y := by positivity\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\n\u22a2 0 \u2264 x / y\n[PROOFSTEP]\npositivity\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\n\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\n[PROOFSTEP]\nhave hyx''''' : -1 \u2264 x / y - 1 := by linarith only [hyx'''']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\n\u22a2 -1 \u2264 x / y - 1\n[PROOFSTEP]\nlinarith only [hyx'''']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\n\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\n[PROOFSTEP]\nhave : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1) := by\n  linarith [one_add_mul_self_lt_rpow_one_add hyx''''' hyx'''.ne hp]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\n\u22a2 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\n[PROOFSTEP]\nlinarith [one_add_mul_self_lt_rpow_one_add hyx''''' hyx'''.ne hp]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\n\u22a2 (y ^ p - x ^ p) / (y - x) < p * y ^ (p - 1)\n[PROOFSTEP]\nrw [div_lt_iff h3, \u2190 div_lt_div_right hy']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\n\u22a2 (y ^ p - x ^ p) / y ^ p < p * y ^ (p - 1) * (y - x) / y ^ p\n[PROOFSTEP]\nconvert this using 1\n[GOAL]\ncase h.e'_3\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\n\u22a2 (y ^ p - x ^ p) / y ^ p = 1 - (1 + (x / y - 1)) ^ p\n[PROOFSTEP]\nhave H : (x / y) ^ p = x ^ p / y ^ p := div_rpow hx hy.le _\n[GOAL]\ncase h.e'_3\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\nH : (x / y) ^ p = x ^ p / y ^ p\n\u22a2 (y ^ p - x ^ p) / y ^ p = 1 - (1 + (x / y - 1)) ^ p\n[PROOFSTEP]\nring_nf at H \u22a2\n[GOAL]\ncase h.e'_3\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\nH : (x * y\u207b\u00b9) ^ p = x ^ p * (y ^ p)\u207b\u00b9\n\u22a2 -(x ^ p * (y ^ p)\u207b\u00b9) + y ^ p * (y ^ p)\u207b\u00b9 = 1 - (x * y\u207b\u00b9) ^ p\n[PROOFSTEP]\nfield_simp [hy.ne', hy'.ne'] at H \u22a2\n[GOAL]\ncase h.e'_3\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\nH : (x / y) ^ p * y ^ p = x ^ p\n\u22a2 -x ^ p + y ^ p = (1 - (x / y) ^ p) * y ^ p\n[PROOFSTEP]\nlinear_combination H\n[GOAL]\ncase h.e'_4\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\n\u22a2 p * y ^ (p - 1) * (y - x) / y ^ p = -p * (x / y - 1)\n[PROOFSTEP]\nring_nf at H1 \u22a2\n[GOAL]\ncase h.e'_4\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\n\u22a2 p * y ^ (-1 + p) * y * (y ^ p)\u207b\u00b9 - p * y ^ (-1 + p) * x * (y ^ p)\u207b\u00b9 = p - p * x * y\u207b\u00b9\n[PROOFSTEP]\nfield_simp [hy.ne', hy'.ne']\n[GOAL]\ncase h.e'_4\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nh3 : 0 < y - x\nhyx'' : x / y < 1\nhyx''' : x / y - 1 < 0\nhyx'''' : 0 \u2264 x / y\nhyx''''' : -1 \u2264 x / y - 1\nthis : 1 - (1 + (x / y - 1)) ^ p < -p * (x / y - 1)\n\u22a2 (p * y ^ (-1 + p) * y - p * y ^ (-1 + p) * x) * y = (p * y - p * x) * y ^ p\n[PROOFSTEP]\nlinear_combination p * (-y + x) * H1\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\n\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave hyz' : 0 < z - y := by linarith only [hyz]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\n\u22a2 0 < z - y\n[PROOFSTEP]\nlinarith only [hyz]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\n\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave hyz'' : 1 < z / y := by rwa [one_lt_div hy]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\n\u22a2 1 < z / y\n[PROOFSTEP]\nrwa [one_lt_div hy]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\n\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave hyz''' : 0 < z / y - 1 := by linarith only [hyz'']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\n\u22a2 0 < z / y - 1\n[PROOFSTEP]\nlinarith only [hyz'']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\n\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave hyz'''' : -1 \u2264 z / y - 1 := by linarith only [hyz'']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\n\u22a2 -1 \u2264 z / y - 1\n[PROOFSTEP]\nlinarith only [hyz'']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\n\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nhave : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1 := by\n  linarith [one_add_mul_self_lt_rpow_one_add hyz'''' hyz'''.ne' hp]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\n\u22a2 p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\n[PROOFSTEP]\nlinarith [one_add_mul_self_lt_rpow_one_add hyz'''' hyz'''.ne' hp]\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\n\u22a2 p * y ^ (p - 1) < (z ^ p - y ^ p) / (z - y)\n[PROOFSTEP]\nrw [lt_div_iff hyz', \u2190 div_lt_div_right hy']\n[GOAL]\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\n\u22a2 p * y ^ (p - 1) * (z - y) / y ^ p < (z ^ p - y ^ p) / y ^ p\n[PROOFSTEP]\nconvert this using 1\n[GOAL]\ncase h.e'_3\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\n\u22a2 p * y ^ (p - 1) * (z - y) / y ^ p = p * (z / y - 1)\n[PROOFSTEP]\nring_nf at H1 \u22a2\n[GOAL]\ncase h.e'_3\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\n\u22a2 -(p * y ^ (-1 + p) * y * (y ^ p)\u207b\u00b9) + p * y ^ (-1 + p) * z * (y ^ p)\u207b\u00b9 = -p + p * z * y\u207b\u00b9\n[PROOFSTEP]\nfield_simp [hy.ne', hy'.ne'] at H1 \u22a2\n[GOAL]\ncase h.e'_3\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\n\u22a2 (-(p * y ^ (-1 + p) * y * y ^ p) + p * y ^ (-1 + p) * z * y ^ p) * y = (-(p * y) + p * z) * (y ^ p * y ^ p)\n[PROOFSTEP]\nlinear_combination p * (y - z) * y ^ p * H1\n[GOAL]\ncase h.e'_4\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\n\u22a2 (z ^ p - y ^ p) / y ^ p = (1 + (z / y - 1)) ^ p - 1\n[PROOFSTEP]\nhave H : (z / y) ^ p = z ^ p / y ^ p := div_rpow hz hy.le _\n[GOAL]\ncase h.e'_4\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\nH : (z / y) ^ p = z ^ p / y ^ p\n\u22a2 (z ^ p - y ^ p) / y ^ p = (1 + (z / y - 1)) ^ p - 1\n[PROOFSTEP]\nring_nf at H \u22a2\n[GOAL]\ncase h.e'_4\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\nH : (z * y\u207b\u00b9) ^ p = z ^ p * (y ^ p)\u207b\u00b9\n\u22a2 z ^ p * (y ^ p)\u207b\u00b9 - y ^ p * (y ^ p)\u207b\u00b9 = -1 + (z * y\u207b\u00b9) ^ p\n[PROOFSTEP]\nfield_simp [hy.ne', hy'.ne'] at H \u22a2\n[GOAL]\ncase h.e'_4\np : \u211d\nhp : 1 < p\nx y z : \u211d\nhx : 0 \u2264 x\nhz : 0 \u2264 z\nhxy : x < y\nhyz : y < z\nhy : 0 < y\nhy' : 0 < y ^ p\nH1 : y ^ p = y ^ (-1 + p) * y\nhyz' : 0 < z - y\nhyz'' : 1 < z / y\nhyz''' : 0 < z / y - 1\nhyz'''' : -1 \u2264 z / y - 1\nthis : p * (z / y - 1) < (1 + (z / y - 1)) ^ p - 1\nH : (z / y) ^ p * y ^ p = z ^ p\n\u22a2 z ^ p - y ^ p = (-1 + (z / y) ^ p) * y ^ p\n[PROOFSTEP]\nlinear_combination -H\n[GOAL]\np : \u211d\nhp : 1 \u2264 p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p\n[PROOFSTEP]\nrcases eq_or_lt_of_le hp with (rfl | hp)\n[GOAL]\ncase inl\nhp : 1 \u2264 1\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ 1\n[PROOFSTEP]\nsimpa using convexOn_id (convex_Ici _)\n[GOAL]\ncase inr\np : \u211d\nhp\u271d : 1 \u2264 p\nhp : 1 < p\n\u22a2 ConvexOn \u211d (Ici 0) fun x => x ^ p\n[PROOFSTEP]\nexact (strictConvexOn_rpow hp).convexOn\n[GOAL]\n\u22a2 StrictConcaveOn \u211d (Iio 0) log\n[PROOFSTEP]\nrefine' \u27e8convex_Iio _, _\u27e9\n[GOAL]\n\u22a2 \u2200 \u2983x : \u211d\u2984,\n    x \u2208 Iio 0 \u2192\n      \u2200 \u2983y : \u211d\u2984,\n        y \u2208 Iio 0 \u2192 x \u2260 y \u2192 \u2200 \u2983a b : \u211d\u2984, 0 < a \u2192 0 < b \u2192 a + b = 1 \u2192 a \u2022 log x + b \u2022 log y < log (a \u2022 x + b \u2022 y)\n[PROOFSTEP]\nrintro x (hx : x < 0) y (hy : y < 0) hxy a b ha hb hab\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 a \u2022 log x + b \u2022 log y < log (a \u2022 x + b \u2022 y)\n[PROOFSTEP]\nhave hx' : 0 < -x := by linarith\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\n\u22a2 0 < -x\n[PROOFSTEP]\nlinarith\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\n\u22a2 a \u2022 log x + b \u2022 log y < log (a \u2022 x + b \u2022 y)\n[PROOFSTEP]\nhave hy' : 0 < -y := by linarith\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\n\u22a2 0 < -y\n[PROOFSTEP]\nlinarith\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\n\u22a2 a \u2022 log x + b \u2022 log y < log (a \u2022 x + b \u2022 y)\n[PROOFSTEP]\nhave hxy' : -x \u2260 -y := by contrapose! hxy; linarith\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\n\u22a2 -x \u2260 -y\n[PROOFSTEP]\ncontrapose! hxy\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy : -x = -y\n\u22a2 x = y\n[PROOFSTEP]\nlinarith\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy' : -x \u2260 -y\n\u22a2 a \u2022 log x + b \u2022 log y < log (a \u2022 x + b \u2022 y)\n[PROOFSTEP]\ncalc\n  a \u2022 log x + b \u2022 log y = a \u2022 log (-x) + b \u2022 log (-y) := by simp_rw [log_neg_eq_log]\n  _ < log (a \u2022 -x + b \u2022 -y) := (strictConcaveOn_log_Ioi.2 hx' hy' hxy' ha hb hab)\n  _ = log (-(a \u2022 x + b \u2022 y)) := by congr 1; simp only [Algebra.id.smul_eq_mul]; ring\n  _ = _ := by rw [log_neg_eq_log]\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy' : -x \u2260 -y\n\u22a2 a \u2022 log x + b \u2022 log y = a \u2022 log (-x) + b \u2022 log (-y)\n[PROOFSTEP]\nsimp_rw [log_neg_eq_log]\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy' : -x \u2260 -y\n\u22a2 log (a \u2022 -x + b \u2022 -y) = log (-(a \u2022 x + b \u2022 y))\n[PROOFSTEP]\ncongr 1\n[GOAL]\ncase e_x\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy' : -x \u2260 -y\n\u22a2 a \u2022 -x + b \u2022 -y = -(a \u2022 x + b \u2022 y)\n[PROOFSTEP]\nsimp only [Algebra.id.smul_eq_mul]\n[GOAL]\ncase e_x\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy' : -x \u2260 -y\n\u22a2 a * -x + b * -y = -(a * x + b * y)\n[PROOFSTEP]\nring\n[GOAL]\nx : \u211d\nhx : x < 0\ny : \u211d\nhy : y < 0\nhxy : x \u2260 y\na b : \u211d\nha : 0 < a\nhb : 0 < b\nhab : a + b = 1\nhx' : 0 < -x\nhy' : 0 < -y\nhxy' : -x \u2260 -y\n\u22a2 log (-(a \u2022 x + b \u2022 y)) = log (a \u2022 x + b \u2022 y)\n[PROOFSTEP]\nrw [log_neg_eq_log]\n"}
{"text": "/-\nCopyright (c) 2022 Andrew Yang. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Andrew Yang\n\n! This file was ported from Lean 3 source module algebra.gcd_monoid.integrally_closed\n! leanprover-community/mathlib commit 2032a878972d5672e7c27c957e7a6e297b044973\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Algebra.GcdMonoid.Basic\nimport Mathbin.RingTheory.IntegrallyClosed\nimport Mathbin.RingTheory.Polynomial.Eisenstein.Basic\n\n/-!\n\n# GCD domains are integrally closed\n\n-/\n\n\nopen BigOperators Polynomial\n\nvariable {R A : Type _} [CommRing R] [IsDomain R] [GCDMonoid R] [CommRing A] [Algebra R A]\n\ntheorem IsLocalization.surj_of_gcd_domain (M : Submonoid R) [IsLocalization M A] (z : A) :\n    \u2203 a b : R, IsUnit (gcd a b) \u2227 z * algebraMap R A b = algebraMap R A a :=\n  by\n  obtain \u27e8x, \u27e8y, hy\u27e9, rfl\u27e9 := IsLocalization.mk'_surjective M z\n  obtain \u27e8x', y', hx', hy', hu\u27e9 := extract_gcd x y\n  use x', y', hu\n  rw [mul_comm, IsLocalization.mul_mk'_eq_mk'_of_mul]\n  convert IsLocalization.mk'_mul_cancel_left _ _ using 2\n  \u00b7 rw [Subtype.coe_mk, hy', \u2190 mul_comm y', mul_assoc]\n    conv_lhs => rw [hx']\n  \u00b7 infer_instance\n#align is_localization.surj_of_gcd_domain IsLocalization.surj_of_gcd_domain\n\ninstance (priority := 100) GCDMonoid.toIsIntegrallyClosed : IsIntegrallyClosed R :=\n  \u27e8fun X \u27e8p, hp\u2081, hp\u2082\u27e9 =>\n    by\n    obtain \u27e8x, y, hg, he\u27e9 := IsLocalization.surj_of_gcd_domain (nonZeroDivisors R) X\n    have :=\n      Polynomial.dvd_pow_natDegree_of_eval\u2082_eq_zero (IsFractionRing.injective R <| FractionRing R)\n        hp\u2081 y x _ hp\u2082 (by rw [mul_comm, he])\n    have : IsUnit y := by\n      rw [isUnit_iff_dvd_one, \u2190 one_pow]\n      exact\n        (dvd_gcd this <| dvd_refl y).trans\n          (gcd_pow_left_dvd_pow_gcd.trans <| pow_dvd_pow_of_dvd (isUnit_iff_dvd_one.1 hg) _)\n    use x * (this.unit\u207b\u00b9 : _)\n    erw [map_mul, \u2190 Units.coe_map_inv, eq_comm, Units.eq_mul_inv_iff_mul_eq]\n    exact he\u27e9\n#align gcd_monoid.to_is_integrally_closed GCDMonoid.toIsIntegrallyClosed\n\n"}
{"text": "import Aoc\nimport Data.List\nimport Data.List1\nimport Data.Strings\nimport Data.SortedMap\nimport Debug.Trace\n\ndata Production = Terminal String | NTs (List (List Int))\nShow Production where\n  show (Terminal s) = show s\n  show (NTs s) = show s\n\nRules : Type\nRules = SortedMap Int Production\n\ntoRules : List (Int, Production) -> Rules\ntoRules = fromList\n\nparseRule : String -> Maybe (Int, Production)\nparseRule s = do\n  (sn:::[rest]) <- pure (split (==':') s) | _ => Nothing\n  n <- parsePositive {a=Int} sn\n  case split (=='\"') rest of\n    (\" \":::[t,\"\"]) => Just (n, Terminal t)\n    _ =>\n      let parseChain = traverse parsePositive . forget . split (==' ') . trim\n      in case traverse parseChain . forget . split (=='|') . trim $ rest of\n        Just nts => Just (n, NTs nts)\n        Nothing => Nothing\n\nmunch : Eq a => List a -> List a -> Maybe (List a)\nmunch [] ys = Just ys\nmunch (x::xs) [] = Nothing\nmunch (x::xs) (y::ys) = if x == y then munch xs ys else Nothing\n\nmutual\n  matches : Rules -> Int -> List Char -> List (List Char)\n  matches rs k cs =\n    case lookup k rs of\n      Nothing => []\n      Just (Terminal t) => toList $ munch (unpack t) cs\n      Just (NTs alts) => do\n        alt <- alts\n        matchesSeq rs alt cs\n\n  matchesSeq : Rules -> List Int -> List Char -> List (List Char)\n  matchesSeq rs [] cs = [cs]\n  matchesSeq rs (k::ks) cs = do\n    cs' <- matches rs k cs\n    matchesSeq rs ks cs'\n\nmatchesFully : Rules -> Int -> String -> Bool\nmatchesFully rs k s = any (==[]) $ matches rs k (unpack s)\n\nmain : IO ()\nmain = do\n  (ls1:::[ls2]) <- readParagraphs | _ => putStrLn \"paragraph parse error\"\n  Just rules <- pure $ toRules <$> traverse parseRule ls1 | _ => putStrLn \"rule parse error\"\n  putStr \"*   \"; printLn $ count (matchesFully rules 0) ls2\n  let rules' = insert 8 (NTs [[42,8],[42]]) $ insert 11 (NTs [[42,31],[42,11,31]]) $ rules\n  putStr \"**  \"; printLn $ count (matchesFully rules' 0) ls2\n\n"}
{"text": "section \"Setup of Environment for CAVA Model Checker\"\ntheory CAVA_Base\n  imports \n  Collections.CollectionsV1  (*-- {* Compatibility with ICF 1.0 *}*)\n  Collections.Refine_Dflt      \n\n  Statistics (*-- {* Collecting statistics by instrumenting the formalization *}*)\n\n  CAVA_Code_Target (*-- {* Code Generator Setup *}*)\nbegin\n\nhide_const (open) CollectionsV1.ahs_rel\n\n(*\n(* Select-function that selects element from set *)\n(* TODO: Move! Is select properly integrated into autoref? *)\n  definition select where\n    \"select S \\<equiv> if S={} then RETURN None else RES {Some s | s. s\\<in>S}\"\n\nlemma select_correct: \n  \"select X \\<le> SPEC (\\<lambda>r. case r of None \\<Rightarrow> X={} | Some x \\<Rightarrow> x\\<in>X)\"\n  unfolding select_def\n  apply (refine_rcg refine_vcg)\n  by auto\n*)\n  \n  text \\<open>Cleaning up the namespace a bit\\<close>\n  \n  hide_type (open) Word.word\n  no_notation test_bit (infixl \"!!\" 100)\n\n  text \\<open>Some custom setup in cava, that does not match HOL defaults:\\<close>\n  declare Let_def[simp add]\n\nend\n"}
{"text": "-- An ATP local hint cannot be equal to the conjecture in which it is\n-- used.\n\n-- This error is detected by Syntax.Translation.ConcreteToAbstract.\n\nmodule ATPBadLocalHint1 where\n\npostulate\n  D : Set\n  p : D\n\n{-# ATP prove p p #-}\n"}
{"text": "lemma add_assoc' {\u03b1 : Type} [add_semigroup \u03b1] :\n  \u2200 (a b c : \u03b1), a + (b + c) = a + b + c :=\nbegin\n  intros a b c, rewrite add_assoc\nend\n\nlemma mul_assoc' {\u03b1 : Type} [comm_semigroup \u03b1] :\n  \u2200 (a b c : \u03b1), a * (b * c) = a * b * c :=\nbegin \n  intros a b c, rewrite mul_assoc \nend\n\n#check add_right_comm\nlemma mul_comm_assoc {\u03b1 : Type} [comm_semigroup \u03b1] : \n  \u2200 a b c : \u03b1, (a * b) * c = (a * c) * b := \nbegin\n  intros a b c, rewrite mul_assoc, \n  rewrite mul_comm b c, \n  rewrite mul_assoc\nend\n\nlemma mul_add_mul_add {\u03b1 : Type} [ring \u03b1] (t c x d : \u03b1) : \n  (t + c * x) + (d * x)  = t + ((c + d) * x) := \nbegin\n  rewrite add_assoc,\n  rewrite add_mul\nend"}
{"text": "inductive Tree (\u03b2 : Type v) where\n  | leaf\n  | node (left : Tree \u03b2) (key : Nat) (value : \u03b2) (right : Tree \u03b2)\n  deriving Repr\n\ndef Tree.find? (t : Tree \u03b2) (k : Nat) : Option \u03b2 :=\n  match t with\n  | leaf => none\n  | node left key value right =>\n    if k < key then\n      left.find? k\n    else if key < k then\n      right.find? k\n    else\n      some value\n\ndef Tree.insert (t : Tree \u03b2) (k : Nat) (v : \u03b2) : Tree \u03b2 :=\n  match t with\n  | leaf => node leaf k v leaf\n  | node left key value right =>\n    if k < key then\n      node (left.insert k v) key value right\n    else if key < k then\n      node left key value (right.insert k v)\n    else\n      node left k v right\n\ninductive ForallTree (p : Nat \u2192 \u03b2 \u2192 Prop) : Tree \u03b2 \u2192 Prop\n  | leaf : ForallTree p .leaf\n  | node :\n     ForallTree p left \u2192\n     p key value \u2192\n     ForallTree p right \u2192\n     ForallTree p (.node left key value right)\n\ninductive BST : Tree \u03b2 \u2192 Prop\n  | leaf : BST .leaf\n  | node :\n     {value : \u03b2} \u2192\n     ForallTree (fun k v => k < key) left \u2192\n     ForallTree (fun k v => key < k) right \u2192\n     BST left \u2192 BST right \u2192\n     BST (.node left key value right)\n\ndef BinTree (\u03b2 : Type u) := { t : Tree \u03b2 // BST t }\n\ndef BinTree.mk : BinTree \u03b2 :=\n  \u27e8.leaf, .leaf\u27e9\n\ndef BinTree.find? (b : BinTree \u03b2) (k : Nat) : Option \u03b2 :=\n  b.val.find? k\n\ndef BinTree.insert (b : BinTree \u03b2) (k : Nat) (v : \u03b2) : BinTree \u03b2 :=\n  \u27e8b.val.insert k v, sorry\u27e9\n\nattribute [local simp]\n  BinTree.mk BinTree.find?\n  BinTree.insert Tree.find? Tree.insert\n\ntheorem BinTree.find_insert (b : BinTree \u03b2) (k : Nat) (v : \u03b2)\n        : (b.insert k v).find? k = some v := by\n  let \u27e8t, h\u27e9 := b; simp\n  induction t with simp\n  | node left key value right ihl ihr =>\n    by_cases k < key <;> simp [*]\n    . cases h; apply ihl; done\n    . sorry\n"}
{"text": "@test problem2(4e6) == 4613732\n"}
{"text": "import Smt\n\ntheorem triv' : 0 + 1 = 1 := by\n  smt\n  simp_all\n"}
{"text": "lemma closure_closure [simp]: \"closure (closure S) = closure S\""}
{"text": "example : 2 + 3 = 5 :=\nbegin\n  generalize : 3 = x,\n  sorry\nend\n"}
{"text": "function this = orderfields(this, vals);\n\n    for index = 1:length(this)\n        this(index).EEG = orderfields(this(index).EEG, vals);\n    end;\n"}
{"text": "[STATEMENT]\nlemma mopup_bef_erase[simp]: \"mopup_bef_erase_a (s, l, []) lm n ires \\<Longrightarrow> \n                        mopup_bef_erase_a (s, l, [Bk]) lm n ires\"\n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0; \\<not> Suc (Suc s) \\<le> 2 *n;\n     mopup_bef_erase_a (s, l, []) lm n ires\\<rbrakk>\n    \\<Longrightarrow>  mopup_jump_over1 (s', Bk # l, []) lm n ires\"\n  \"mopup_bef_erase_b (s, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []\"\n  \"\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; \n               s mod 2 \\<noteq> Suc 0; \n               mopup_bef_erase_b (s, l, Bk # xs) lm n ires; r = Bk # xs\\<rbrakk> \n           \\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, xs) lm n ires\"\n  \"\\<lbrakk>mopup_bef_erase_b (s, l, []) lm n ires\\<rbrakk> \\<Longrightarrow> \n                   mopup_bef_erase_a (s - Suc 0, Bk # l, []) lm n ires\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. ((mopup_bef_erase_a (s, l, []) lm n ires \\<Longrightarrow> mopup_bef_erase_a (s, l, [Bk]) lm n ires) &&& (\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 = Suc 0; \\<not> Suc (Suc s) \\<le> 2 * n; mopup_bef_erase_a (s, l, []) lm n ires\\<rbrakk> \\<Longrightarrow> mopup_jump_over1 (s', Bk # l, []) lm n ires)) &&& (mopup_bef_erase_b (s, l, Oc # xs) lm n ires \\<Longrightarrow> l \\<noteq> []) &&& (\\<lbrakk>n < length lm; 0 < s; s \\<le> 2 * n; s mod 2 \\<noteq> Suc 0; mopup_bef_erase_b (s, l, Bk # xs) lm n ires; r = Bk # xs\\<rbrakk> \\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, xs) lm n ires) &&& (mopup_bef_erase_b (s, l, []) lm n ires \\<Longrightarrow> mopup_bef_erase_a (s - Suc 0, Bk # l, []) lm n ires)\n[PROOF STEP]\nby(auto simp: mopup_bef_erase_b.simps mopup_bef_erase_a.simps)"}
{"text": ";;; -*- syntax: common-lisp; package: KEIM; base: 10; mode: Theory -*-\n;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;\n;;                                                                          ;;\n;;   Copyright (C) 1998 by AG Siekmann, Fachbereich Informatik,             ;;\n;;   Universitaet des Saarlandes, Saarbruecken, Germany.                    ;;\n;;   All rights reserved.                                                   ;;\n;;   For information about this program, write to:                          ;;\n;;     KEIM Project                                                         ;;\n;;     AG Siekmann/FB Informatik                                            ;;\n;;     Universitaet des Saarlandes                                          ;;\n;;     Postfach 1150                                                        ;;\n;;     D-66041 Saarbruecken                                                 ;;\n;;     Germany                                                              ;;\n;;   electronic mail: keim@ags.uni-sb.de                                     ;;\n;;                                                                          ;;\n;;   The author makes no representations about the suitability of this      ;;\n;;   software for any purpose.  It is provided \"AS IS\" without express or   ;;\n;;   implied warranty.  In particular, it must be understood that this      ;;\n;;   software is an experimental version, and is not suitable for use in    ;;\n;;   any safety-critical application, and the author denies a license for   ;;\n;;   such use.                                                              ;;\n;;                                                                          ;;\n;;   You may use, copy, modify and distribute this software for any         ;;\n;;   noncommercial and non-safety-critical purpose.  Use of this software   ;;\n;;   in a commercial product is not included under this license.  You must  ;;\n;;   maintain this copyright statement in all copies of this software that  ;;\n;;   you modify or distribute.                                              ;;\n;; ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;; ;;\n(in-package :omega)\n\n\n;Beispiel aus LIMIT\n;(th~deftheorem absval-idempotence\n;               (in limit)\n;               (conclusion\n;                (forall (lam (a num)\n;                             (= (absval (absval a))\n;                                (absval a)))))\n;               (help \"The idempotence of |.| \"))\n\n\n\n\n(th~deftheorem fact1\n\t       (in lock-res)\n\t       (conclusion\n\t\t(forall (lam (x (o form)) (forall (lam (y (o (o form)))\n\t\t\t\t(implies (in x y)\n\t\t\t\t\t (derivable x y crule-set)))))))\n\t       (help \"Theorem for the fact, that every element of a set of clauses is derivable.\"))\n\n(th~deftheorem fact2\n               (in lock-res)\n               (conclusion\n                (forall (lam (y (o (o form)))\n                            (implies (and (forall (lam (x (o form))\n                                                       (implies (in x y) (setunit x))))\n                                          (unsat-cl-set y))\n                                     (derivable empty-cl y crule-set)))))\n               (help \"Theorem for the fact, that resolvable unit cluase, result in the empty clause.\"))\n\n;(th~deftheorem fact2\n;               (in lock-res)\n;               (conclusion\n;                (forall (lam (cs (o (o form)))\n;                  (implies\n;                   (exists (lam (x (o form))\n;                           (exists (lam (y (o form))\n;                                   (and (and (and (setunit x) (setunit y))\n;                                             (resolvable-s x y))\n;                                        (and (cs x) (cs y)))))))\n;                   (derivable empty-cl cs crule-set))))))\n\n\n(th~deftheorem fact3\n\t       (in lock-res)\n\t       (conclusion\n\t\t(forall (lam (klm (o (o form))) (forall (lam (gkl (o form))\n                           (implies\n                            (and (in klm all-clause-sets)\n                                 (exists (lam  (kl1 (o form)) (and (klm kl1) (card>2 kl1)))))\n                            (exists (lam (kl (o form)) (exists (lam (l form)\n                                (and (and (implies\n                                           (derivable\n                                            gkl\n                                            (union (setminus klm (singleton kl))\n                                                   (singleton (setminus kl (singleton l))))\n                                            crule-set)\n                                           (or (derivable gkl klm crule-set)\n                                               (derivable (union gkl (singleton l))\n                                                          klm crule-set)))\n                                          (kl l))\n                                     (and (klm kl)\n                                          (card>2 kl)))))))))))))\n\t       (help \"A calculus independet formulation of the Disjunction Lemma\"))\n\n\n(th~defaxiom fact4\n\t     (in lock-res)\n\t     (formula (forall (lam (klm (o (o form))) (forall (lam (kl (o form))\n\t\t\t     (forall (lam (l form)\n\t\t\t       (implies\n\t\t\t\t(and\n\t\t\t\t (and (klm kl) (kl l))\n\t\t\t\t (and (derivable\n\t\t\t\t       (union empty-cl (singleton l))     \n\t\t\t\t       klm  \n\t\t\t\t       crule-set)\n\t\t\t\t      (derivable\n\t\t\t\t       empty-cl\n\t\t\t\t       (union (setminus klm (singleton kl))\n\t\t\t\t\t      (singleton (singleton l)))\n\t\t\t\t       crule-set)))\n\t\t\t\t (derivable empty-cl klm crule-set)))))))))\n\t     (help \"A formula helping to close the eln-technique application.\"))\n\n\n\n(th~deftheorem leq-thm-1\n\t       (in lock-res)\n\t       (conclusion\n\t\t(forall (lam (x num) (forall (lam (y num)\n\t\t\t     (implies (and (nat x) (nat y))\n\t\t\t\t      (equiv (leq x y)\n\t\t\t\t\t      (or (= x y)\n\t\t\t\t\t\t  (leq (s x) y))))))))))\n\n(th~deftheorem card2\n\t       (in lock-res)\n\t       (conclusion\n\t\t(forall (lam (as (o form)) \n\t\t\t     (implies (card>2 as)\n\t\t\t\t      (exists (lam (el form)\n\t\t\t\t\t\t   (as el))))))))\n\n"}
{"text": "/-\nCopyright (c) 2021 Adam Topaz. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Adam Topaz\n-/\nimport topology.category.Profinite.basic\nimport topology.locally_constant.basic\nimport topology.discrete_quotient\n\n/-!\n# Cofiltered limits of profinite sets.\n\nThis file contains some theorems about cofiltered limits of profinite sets.\n\n## Main Results\n\n- `exists_clopen_of_cofiltered` shows that any clopen set in a cofiltered limit of profinite\n  sets is the pullback of a clopen set from one of the factors in the limit.\n- `exists_locally_constant` shows that any locally constant function from a cofiltered limit\n  of profinite sets factors through one of the components.\n-/\n\n\nnamespace Profinite\n\nopen_locale classical\nopen category_theory\nopen category_theory.limits\n\nuniverse u\nvariables {J : Type u} [small_category J] [is_cofiltered J]\n  {F : J \u2964 Profinite.{u}} (C : cone F) (hC : is_limit C)\n\ninclude hC\n\n/--\nIf `X` is a cofiltered limit of profinite sets, then any clopen subset of `X` arises from\na clopen set in one of the terms in the limit.\n-/\ntheorem exists_clopen_of_cofiltered {U : set C.X} (hU : is_clopen U) :\n  \u2203 (j : J) (V : set (F.obj j)) (hV : is_clopen V), U = C.\u03c0.app j \u207b\u00b9' V :=\nbegin\n  -- First, we have the topological basis of the cofiltered limit obtained by pulling back\n  -- clopen sets from the factors in the limit. By continuity, all such sets are again clopen.\n  have hB := Top.is_topological_basis_cofiltered_limit.{u}\n    (F \u22d9 Profinite.to_Top)\n    (Profinite.to_Top.map_cone C)\n    (is_limit_of_preserves _ hC)\n    (\u03bb j, {W | is_clopen W})\n    _ (\u03bb i, is_clopen_univ) (\u03bb i U1 U2 hU1 hU2, hU1.inter hU2) _,\n  rotate,\n  { intros i,\n    change topological_space.is_topological_basis\n      {W : set (F.obj i) | is_clopen W},\n    apply is_topological_basis_clopen },\n  { rintros i j f V (hV : is_clopen _),\n    refine \u27e8hV.1.preimage _, hV.2.preimage _\u27e9;\n    continuity },\n  -- Using this, since `U` is open, we can write `U` as a union of clopen sets all of which\n  -- are preimages of clopens from the factors in the limit.\n  obtain \u27e8S,hS,h\u27e9 := hB.open_eq_sUnion hU.1,\n  clear hB,\n  let j : S \u2192 J := \u03bb s, (hS s.2).some,\n  let V : \u03a0 (s : S), set (F.obj (j s)) := \u03bb s, (hS s.2).some_spec.some,\n  have hV : \u2200 (s : S), is_clopen (V s) \u2227 s.1 = C.\u03c0.app (j s) \u207b\u00b9' (V s) :=\n    \u03bb s, (hS s.2).some_spec.some_spec,\n  -- Since `U` is also closed, hence compact, it is covered by finitely many of the\n  -- clopens constructed in the previous step.\n  have := hU.2.is_compact.elim_finite_subcover (\u03bb s : S, C.\u03c0.app (j s) \u207b\u00b9' (V s)) _ _,\n  rotate,\n  { intros s,\n    refine (hV s).1.1.preimage _,\n    continuity },\n  { dsimp only,\n    rw h,\n    rintro x \u27e8T,hT,hx\u27e9,\n    refine \u27e8_,\u27e8\u27e8T,hT\u27e9,rfl\u27e9,_\u27e9,\n    dsimp only,\n    rwa \u2190 (hV \u27e8T,hT\u27e9).2 },\n  -- We thus obtain a finite set `G : finset J` and a clopen set of `F.obj j` for each\n  -- `j \u2208 G` such that `U` is the union of the preimages of these clopen sets.\n  obtain \u27e8G,hG\u27e9 := this,\n  -- Since `J` is cofiltered, we can find a single `j0` dominating all the `j \u2208 G`.\n  -- Pulling back all of the sets from the previous step to `F.obj j0` and taking a union,\n  -- we obtain a clopen set in `F.obj j0` which works.\n  obtain \u27e8j0,hj0\u27e9 := is_cofiltered.inf_objs_exists (G.image j),\n  let f : \u03a0 (s : S) (hs : s \u2208 G), j0 \u27f6 j s :=\n    \u03bb s hs, (hj0 (finset.mem_image.mpr \u27e8s,hs,rfl\u27e9)).some,\n  let W : S \u2192 set (F.obj j0) := \u03bb s,\n    if hs : s \u2208 G then F.map (f s hs) \u207b\u00b9' (V s) else set.univ,\n  -- Conclude, using the `j0` and the clopen set of `F.obj j0` obtained above.\n  refine \u27e8j0, \u22c3 (s : S) (hs : s \u2208 G), W s, _, _\u27e9,\n  { apply is_clopen_bUnion_finset,\n    intros s hs,\n    dsimp only [W],\n    rw dif_pos hs,\n    refine \u27e8(hV s).1.1.preimage _, (hV s).1.2.preimage _\u27e9;\n    continuity },\n  { ext x,\n    split,\n    { intro hx,\n      simp_rw [set.preimage_Union, set.mem_Union],\n      obtain \u27e8_, \u27e8s,rfl\u27e9, _, \u27e8hs, rfl\u27e9, hh\u27e9 := hG hx,\n      refine \u27e8s, hs, _\u27e9,\n      dsimp only [W] at hh \u22a2,\n      rwa [dif_pos hs, \u2190 set.preimage_comp, \u2190 Profinite.coe_comp, C.w] },\n    { intro hx,\n      simp_rw [set.preimage_Union, set.mem_Union] at hx,\n      obtain \u27e8s,hs,hx\u27e9 := hx,\n      rw h,\n      refine \u27e8s.1,s.2,_\u27e9,\n      rw (hV s).2,\n      dsimp only [W] at hx,\n      rwa [dif_pos hs, \u2190 set.preimage_comp, \u2190 Profinite.coe_comp, C.w] at hx } }\nend\n\nlemma exists_locally_constant_fin_two (f : locally_constant C.X (fin 2)) :\n  \u2203 (j : J) (g : locally_constant (F.obj j) (fin 2)), f = g.comap (C.\u03c0.app _) :=\nbegin\n  let U := f \u207b\u00b9' {0},\n  have hU : is_clopen U := f.is_locally_constant.is_clopen_fiber _,\n  obtain \u27e8j,V,hV,h\u27e9 := exists_clopen_of_cofiltered C hC hU,\n  use [j, locally_constant.of_clopen hV],\n  apply locally_constant.locally_constant_eq_of_fiber_zero_eq,\n  rw locally_constant.coe_comap _ _ (C.\u03c0.app j).continuous,\n  conv_rhs { rw set.preimage_comp },\n  rw [locally_constant.of_clopen_fiber_zero hV, \u2190 h],\nend\n\n\n\ntheorem exists_locally_constant_finite_nonempty {\u03b1 : Type*} [finite \u03b1] [nonempty \u03b1]\n  (f : locally_constant C.X \u03b1) :\n  \u2203 (j : J) (g : locally_constant (F.obj j) \u03b1), f = g.comap (C.\u03c0.app _) :=\nbegin\n  inhabit \u03b1,\n  obtain \u27e8j,gg,h\u27e9 := exists_locally_constant_finite_aux _ hC f,\n  let \u03b9 : \u03b1 \u2192 \u03b1 \u2192 fin 2 := \u03bb a b, if a = b then 0 else 1,\n  let \u03c3 : (\u03b1 \u2192 fin 2) \u2192 \u03b1 := \u03bb f, if h : \u2203 (a : \u03b1), \u03b9 a = f then h.some else arbitrary _,\n  refine \u27e8j, gg.map \u03c3, _\u27e9,\n  ext,\n  rw locally_constant.coe_comap _ _ (C.\u03c0.app j).continuous,\n  dsimp [\u03c3],\n  have h1 : \u03b9 (f x) = gg (C.\u03c0.app j x),\n  { change f.map (\u03bb a b, if a = b then (0 : fin 2) else 1) x = _,\n    rw [h, locally_constant.coe_comap _ _ (C.\u03c0.app j).continuous] },\n  have h2 : \u2203 a : \u03b1, \u03b9 a = gg (C.\u03c0.app j x) := \u27e8f x, h1\u27e9,\n  rw dif_pos h2,\n  apply_fun \u03b9,\n  { rw h2.some_spec,\n    exact h1 },\n  { intros a b hh,\n    apply_fun (\u03bb e, e a) at hh,\n    dsimp [\u03b9] at hh,\n    rw if_pos rfl at hh,\n    split_ifs at hh with hh1 hh1,\n    { exact hh1.symm },\n    { exact false.elim (bot_ne_top hh) } }\nend\n\n/-- Any locally constant function from a cofiltered limit of profinite sets factors through\none of the components. -/\ntheorem exists_locally_constant {\u03b1 : Type*} (f : locally_constant C.X \u03b1) :\n  \u2203 (j : J) (g : locally_constant (F.obj j) \u03b1), f = g.comap (C.\u03c0.app _) :=\nbegin\n  let S := f.discrete_quotient,\n  let ff : S \u2192 \u03b1 := f.lift,\n  casesI is_empty_or_nonempty S,\n  { suffices : \u2203 j, is_empty (F.obj j),\n    { refine this.imp (\u03bb j hj, _),\n      refine \u27e8\u27e8hj.elim, \u03bb A, _\u27e9, _\u27e9,\n      { convert is_open_empty,\n        exact @set.eq_empty_of_is_empty _ hj _ },\n      { ext x,\n        exact hj.elim' (C.\u03c0.app j x) } },\n    simp only [\u2190 not_nonempty_iff, \u2190 not_forall],\n    intros h,\n    haveI : \u2200 j : J, nonempty ((F \u22d9 Profinite.to_Top).obj j) := h,\n    haveI : \u2200 j : J, t2_space ((F \u22d9 Profinite.to_Top).obj j) := \u03bb j,\n      (infer_instance : t2_space (F.obj j)),\n    haveI : \u2200 j : J, compact_space ((F \u22d9 Profinite.to_Top).obj j) := \u03bb j,\n      (infer_instance : compact_space (F.obj j)),\n    have cond := Top.nonempty_limit_cone_of_compact_t2_cofiltered_system\n      (F \u22d9 Profinite.to_Top),\n    suffices : nonempty C.X, from is_empty.false (S.proj this.some),\n    let D := Profinite.to_Top.map_cone C,\n    have hD : is_limit D := is_limit_of_preserves Profinite.to_Top hC,\n    have CD := (hD.cone_point_unique_up_to_iso (Top.limit_cone_is_limit.{u} _)).inv,\n    exact cond.map CD },\n  { let f' : locally_constant C.X S := \u27e8S.proj, S.proj_is_locally_constant\u27e9,\n    obtain \u27e8j, g', hj\u27e9 := exists_locally_constant_finite_nonempty _ hC f',\n    refine \u27e8j, \u27e8ff \u2218 g', g'.is_locally_constant.comp _\u27e9,_\u27e9,\n    ext1 t,\n    apply_fun (\u03bb e, e t) at hj,\n    rw locally_constant.coe_comap _ _ (C.\u03c0.app j).continuous at hj \u22a2,\n    dsimp at hj \u22a2,\n    rw \u2190 hj,\n    refl },\nend\n\nend Profinite\n"}
{"text": "test_msi_sync_to_archive {\n\n    *err = errormsg(\n               msisync_to_archive(\n                   \"comp_resc;cache_resc\",\n                   \"/tmp/cache_resc/home/rods/file1\",\n                   \"/tempZone/home/rods/file1\" ),\n                   *msg );\n    if( 0 != *err ) {\n        writeLine( \"stdout\", \"Error - [*msg], *err\" );\n    } else {\n        writeLine( \"stdout\", \"success?\" );\n    }\n\n}\n\nINPUT null\nOUTPUT ruleExecOut\n\n"}
{"text": "import Data.List\nimport Data.List1\nimport Data.String\n\nimport System.File\n\nsimulate1 : Nat -> Nat -> Nat\nsimulate1 0 c = 1\nsimulate1 (S n) 0 = simulate1 n 6 + simulate1 n 8\nsimulate1 (S n) (S c) = simulate1 n c\n\nrun : String -> IO ()\nrun s = do let l = group $ sort $ catMaybes $ parsePositive {a=Nat} <$> (forget $ split (== ',') s)\n           let n = sum $ (\\l@(c ::: _) => (length $ forget $ l) * simulate1 256 c) <$> l\n           putStrLn $ show n\n\nmain : IO ()\nmain = do Right s <- readFile \"input.txt\"\n            | Left err => putStrLn $ show err\n          run s\n\n"}
{"text": "universe u\n\ndef f1 (n m : Nat) (x : Fin n) (h : n = m) : Fin m :=\nh \u25b8 x\n\ndef f2 (n m : Nat) (x : Fin n) (h : m = n) : Fin m :=\nh \u25b8 x\n\ntheorem ex1 {\u03b1 : Sort u} {a b c : \u03b1} (h\u2081 : a = b) (h\u2082 : b = c) : a = c :=\nh\u2082 \u25b8 h\u2081\n\ntheorem ex2 {\u03b1 : Sort u} {a b : \u03b1} (h : a = b) : b = a :=\nh \u25b8 rfl\n\ntheorem ex3 {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : r a b) (h\u2082 : b = c) : r a c :=\nh\u2082 \u25b8 h\u2081\n\ntheorem ex3b {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : r a b) (h\u2082 : b = c) : r a c :=\nh\u2082.symm \u25b8 h\u2081\n\ntheorem ex3c {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : r a b) (h\u2082 : b = c) : r a c :=\nh\u2082.symm.symm \u25b8 h\u2081\n\ntheorem ex4 {\u03b1 : Sort u} {a b c : \u03b1} (r : \u03b1 \u2192 \u03b1 \u2192 Prop) (h\u2081 : a = b) (h\u2082 : r b c) : r a c :=\nh\u2081 \u25b8 h\u2082\n\ntheorem ex5 {p : Prop} (h : p = True) : p :=\nh \u25b8 trivial\n\ntheorem ex6 {p : Prop} (h : p = False) : \u00acp :=\nfun hp => h \u25b8 hp\n\ntheorem ex7 {\u03b1} {a b c d : \u03b1} (h\u2081 : a = c) (h\u2082 : b = d) (h\u2083 : c \u2260 d) : a \u2260 b :=\nh\u2081 \u25b8 h\u2082 \u25b8 h\u2083\n\ntheorem ex8 (n m k : Nat) (h : Nat.succ n + m = Nat.succ n + k) : Nat.succ (n + m) = Nat.succ (n + k) :=\nNat.succ_add .. \u25b8 Nat.succ_add .. \u25b8 h\n\ntheorem ex9 (a b : Nat) (h\u2081 : a = a + b) (h\u2082 : a = b) : a = b + a  :=\nh\u2082 \u25b8 h\u2081\n\ntheorem ex10 (a b : Nat) (h : a = b) : b = a :=\nh \u25b8 rfl\n\ndef ex11  {\u03b1 : Type u} {n : Nat} (a : Array \u03b1) (i : Nat) (h\u2081 : a.size = n) (h\u2082 : i < n) : \u03b1 :=\n  a.get \u27e8i, h\u2081 \u25b8 h\u2082\u27e9\n\ntheorem ex12 {\u03b1 : Type u} {n : Nat}\n  (a b : Array \u03b1)\n  (hsz\u2081 : a.size = n) (hsz\u2082 : b.size = n)\n  (h : \u2200 (i : Nat) (hi : i < n), a.getLit i hsz\u2081 hi = b.getLit i hsz\u2082 hi) : a = b :=\nArray.ext a b (hsz\u2081.trans hsz\u2082.symm) fun i hi\u2081 hi\u2082 => h i (hsz\u2081 \u25b8 hi\u2081)\n\ndef toArrayLit {\u03b1 : Type u} (a : Array \u03b1) (n : Nat) (hsz : a.size = n) : Array \u03b1 :=\nList.toArray $ Array.toListLitAux a n hsz n (hsz \u25b8 Nat.le_refl _) []\n\npartial def isEqvAux {\u03b1} (a b : Array \u03b1) (hsz : a.size = b.size) (p : \u03b1 \u2192 \u03b1 \u2192 Bool) (i : Nat) : Bool :=\n  if h : i < a.size then\n     let aidx : Fin a.size := \u27e8i, h\u27e9\n     let bidx : Fin b.size := \u27e8i, hsz \u25b8 h\u27e9\n     match p (a.get aidx) (b.get bidx) with\n     | true  => isEqvAux a b hsz p (i+1)\n     | false => false\n  else\n    true\n"}
{"text": "module mod1\n#ifdef _OPENACC\ninteger, parameter :: bla = 10\n#endif\nend module mod1\n"}
{"text": "From stdpp Require Export BVbase tactics.\nFrom stdpp Require Import options.\n\nSection definitions.\n  Context {A T : Type} `{EqDecision A}.\n  Global Instance fn_insert : Insert A T (A \u2192 T) :=\n    \u03bb a t f b, if decide (a = b) then t else f b.\n  Global Instance fn_alter : Alter A T (A \u2192 T) :=\n    \u03bb (g : T \u2192 T) a f b, if decide (a = b) then g (f a) else f b.\nEnd definitions.\n\n(* TODO: For now, we only have the properties here that do not need a notion\n   of equality of functions. *)\n\nSection functions.\n  Context {A T : Type} `{!EqDecision A}.\n\n  Lemma fn_lookup_insert (f : A \u2192 T) a t : <[a:=t]>f a = t.\n  Proof. unfold insert, fn_insert. by destruct (decide (a = a)). Qed.\n  Lemma fn_lookup_insert_rev  (f : A \u2192 T) a t1 t2 :\n    <[a:=t1]>f a = t2 \u2192 t1 = t2.\n  Proof. rewrite fn_lookup_insert. congruence. Qed.\n  Lemma fn_lookup_insert_ne (f : A \u2192 T) a b t : a \u2260 b \u2192 <[a:=t]>f b = f b.\n  Proof. unfold insert, fn_insert. by destruct (decide (a = b)). Qed.\n\n  Lemma fn_lookup_alter (g : T \u2192 T) (f : A \u2192 T) a : alter g a f a = g (f a).\n  Proof. unfold alter, fn_alter. by destruct (decide (a = a)). Qed.\n  Lemma fn_lookup_alter_ne (g : T \u2192 T) (f : A \u2192 T) a b :\n    a \u2260 b \u2192 alter g a f b = f b.\n  Proof. unfold alter, fn_alter. by destruct (decide (a = b)). Qed.\nEnd functions.\n"}
{"text": "import LeanCodePrompts.AesopSearch\nimport Lean\nopen Lean Meta Elab\n\nopaque sillyN  : Nat\nopaque sillyM : Nat\n\naxiom n_is_m : sillyN = sillyM\n\ninductive MyEmpty : Type\n\ntheorem MyEmpty.eql (a b : MyEmpty) : a = b := by\n  cases a\n  \n\n\nelab \"test_aesop\" : tactic => do\n  Tactic.liftMetaTactic (\n    runAesop 0.5 #[``MyEmpty.eql] #[``Nat.add_comm] #[``n_is_m]\n    )\n\nset_option trace.leanaide.proof.info true \n\nset_option trace.aesop.proof true \nset_option trace.aesop.steps true \nset_option trace.aesop.steps.tree true \nset_option trace.aesop.steps.ruleSelection true \nset_option trace.aesop.steps.ruleFailures true \n\n\nexample (a b : MyEmpty): a = b := by\n  test_aesop -- uses `apply MyEmpty.eql`\n\n\nexample : sillyN + 1 = sillyM + 1 := by\n  test_aesop -- uses `rw [n_is_m]`\n\nexample : \u03b1 \u2192 \u03b1 := by\n  aesop\n\nset_option pp.rawOnError true\nset_option trace.Translate.info true\n\nexample : \u03b1 \u2192 \u03b1 := by\n  test_aesop\n\nexample (x: List Nat) : (3 :: x).length = x.length + 1 := by\n  test_aesop\n\n\nexample (x y: Nat) : x + y = y + x := by\n  test_aesop -- uses `Nat.add_comm`\n"}
{"text": "/-\nCopyright (c) 2022 Mario Carneiro. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Mario Carneiro\n-/\nimport Std.Logic\n\n/--\nAn alternative constructor for `LawfulMonad` which has more\ndefaultable fields in the common case.\n-/\ntheorem LawfulMonad.mk' (m : Type u \u2192 Type v) [Monad m]\n    (id_map : \u2200 {\u03b1} (x : m \u03b1), id <$> x = x)\n    (pure_bind : \u2200 {\u03b1 \u03b2} (x : \u03b1) (f : \u03b1 \u2192 m \u03b2), pure x >>= f = f x)\n    (bind_assoc : \u2200 {\u03b1 \u03b2 \u03b3} (x : m \u03b1) (f : \u03b1 \u2192 m \u03b2) (g : \u03b2 \u2192 m \u03b3),\n      x >>= f >>= g = x >>= fun x => f x >>= g)\n    (map_const : \u2200 {\u03b1 \u03b2} (x : \u03b1) (y : m \u03b2),\n      Functor.mapConst x y = Function.const \u03b2 x <$> y := by intros; rfl)\n    (seqLeft_eq : \u2200 {\u03b1 \u03b2} (x : m \u03b1) (y : m \u03b2),\n      x <* y = (x >>= fun a => y >>= fun _ => pure a) := by intros; rfl)\n    (seqRight_eq : \u2200 {\u03b1 \u03b2} (x : m \u03b1) (y : m \u03b2), x *> y = (x >>= fun _ => y) := by intros; rfl)\n    (bind_pure_comp : \u2200 {\u03b1 \u03b2} (f : \u03b1 \u2192 \u03b2) (x : m \u03b1),\n      x >>= (fun y => pure (f y)) = f <$> x := by intros; rfl)\n    (bind_map : \u2200 {\u03b1 \u03b2} (f : m (\u03b1 \u2192 \u03b2)) (x : m \u03b1), f >>= (. <$> x) = f <*> x := by intros; rfl)\n    : LawfulMonad m :=\n  have map_pure {\u03b1 \u03b2} (g : \u03b1 \u2192 \u03b2) (x : \u03b1) : g <$> (pure x : m \u03b1) = pure (g x) := by\n    rw [\u2190 bind_pure_comp]; simp [pure_bind]\n  { id_map, bind_pure_comp, bind_map, pure_bind, bind_assoc, map_pure,\n    comp_map := by simp [\u2190 bind_pure_comp, bind_assoc, pure_bind]\n    pure_seq := by intros; rw [\u2190 bind_map]; simp [pure_bind]\n    seq_pure := by intros; rw [\u2190 bind_map]; simp [map_pure, bind_pure_comp]\n    seq_assoc := by simp [\u2190 bind_pure_comp, \u2190 bind_map, bind_assoc, pure_bind]\n    map_const := funext fun x => funext (map_const x)\n    seqLeft_eq := by simp [seqLeft_eq, \u2190 bind_map, \u2190 bind_pure_comp, pure_bind, bind_assoc]\n    seqRight_eq := fun x y => by\n      rw [seqRight_eq, \u2190 bind_map, \u2190 bind_pure_comp, bind_assoc]; simp [pure_bind, id_map] }\n\ninstance : LawfulMonad (Except \u03b5) := LawfulMonad.mk'\n  (id_map := fun x => by cases x <;> rfl)\n  (pure_bind := fun a f => rfl)\n  (bind_assoc := fun a f g => by cases a <;> rfl)\n\ninstance : LawfulApplicative (Except \u03b5) := inferInstance\ninstance : LawfulFunctor (Except \u03b5) := inferInstance\n\ninstance : LawfulMonad Option := LawfulMonad.mk'\n  (id_map := fun x => by cases x <;> rfl)\n  (pure_bind := fun x f => rfl)\n  (bind_assoc := fun x f g => by cases x <;> rfl)\n  (bind_pure_comp := fun f x => by cases x <;> rfl)\n\ninstance : LawfulApplicative Option := inferInstance\ninstance : LawfulFunctor Option := inferInstance\n\n/-!\n## SatisfiesM\n\nThe `SatisfiesM` predicate works over an arbitrary (lawful) monad / applicative / functor,\nand enables Hoare-like reasoning over monadic expressions. For example, given a monadic\nfunction `f : \u03b1 \u2192 m \u03b2`, to say that the return value of `f` satisfies `Q` whenever\nthe input satisfies `P`, we write `\u2200 a, P a \u2192 SatisfiesM Q (f a)`.\n-/\n\n/--\n`SatisfiesM p (x : m \u03b1)` lifts propositions over a monad. It asserts that `x` may as well\nhave the type `x : m {a // p a}`, because there exists some `m {a // p a}` whose image is `x`.\nSo `p` is the postcondition of the monadic value.\n-/\ndef SatisfiesM {m : Type u \u2192 Type v} [Functor m] (p : \u03b1 \u2192 Prop) (x : m \u03b1) : Prop :=\n  \u2203 x' : m {a // p a}, Subtype.val <$> x' = x\n\nnamespace SatisfiesM\n\n/-- If `p` is always true, then every `x` satisfies it. -/\ntheorem of_true [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (h : \u2200 a, p a) : SatisfiesM p x :=\n  \u27e8(fun a => \u27e8a, h a\u27e9) <$> x, by simp [\u2190 comp_map, Function.comp]\u27e9\n\n/--\nIf `p` is always true, then every `x` satisfies it.\n(This is the strongest postcondition version of `of_true`.)\n-/\nprotected theorem trivial [Applicative m] [LawfulApplicative m] {x : m \u03b1} :\n  SatisfiesM (fun _ => True) x := of_true fun _ => trivial\n\n/-- The `SatisfiesM p x` predicate is monotonic in `p`. -/\ntheorem imp [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (h : SatisfiesM p x) (H : \u2200 {a}, p a \u2192 q a) : SatisfiesM q x :=\n  let \u27e8x, h\u27e9 := h; \u27e8(fun \u27e8a, h\u27e9 => \u27e8_, H h\u27e9) <$> x, by rw [\u2190 h, \u2190 comp_map]; rfl\u27e9\n\n/-- `SatisfiesM` distributes over `<$>`, general version. -/\nprotected theorem map [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM p x) (hf : \u2200 {a}, p a \u2192 q (f a)) : SatisfiesM q (f <$> x) := by\n  let \u27e8x', hx\u27e9 := hx\n  refine \u27e8(fun \u27e8a, h\u27e9 => \u27e8f a, hf h\u27e9) <$> x', ?_\u27e9\n  rw [\u2190 hx]; simp [\u2190 comp_map, Function.comp]\n\n/--\n`SatisfiesM` distributes over `<$>`, strongest postcondition version.\n(Use this for reasoning forward from assumptions.)\n-/\ntheorem map_post [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM p x) : SatisfiesM (fun b => \u2203 a, p a \u2227 b = f a) (f <$> x) :=\n  hx.map fun h => \u27e8_, h, rfl\u27e9\n\n/--\n`SatisfiesM` distributes over `<$>`, weakest precondition version.\n(Use this for reasoning backward from the goal.)\n-/\ntheorem map_pre [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM (fun a => p (f a)) x) : SatisfiesM p (f <$> x) :=\n  hx.map fun h => h\n\n/-- `SatisfiesM` distributes over `mapConst`, general version. -/\nprotected theorem mapConst [Functor m] [LawfulFunctor m] {x : m \u03b1}\n    (hx : SatisfiesM q x) (ha : \u2200 {b}, q b \u2192 p a) : SatisfiesM p (Functor.mapConst a x) :=\n  map_const (f := m) \u25b8 hx.map ha\n\n/-- `SatisfiesM` distributes over `pure`, general version / weakest precondition version. -/\nprotected theorem pure [Applicative m] [LawfulApplicative m]\n    (h : p a) : SatisfiesM (m := m) p (pure a) := \u27e8pure \u27e8_, h\u27e9, by simp\u27e9\n\n/-- `SatisfiesM` distributes over `<*>`, general version. -/\nprotected theorem seq [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM p\u2081 f) (hx : SatisfiesM p\u2082 x)\n    (H : \u2200 {f a}, p\u2081 f \u2192 p\u2082 a \u2192 q (f a)) : SatisfiesM q (f <*> x) := by\n  match f, x, hf, hx with | _, _, \u27e8f, rfl\u27e9, \u27e8x, rfl\u27e9 => ?_\n  refine \u27e8(fun \u27e8a, h\u2081\u27e9 \u27e8b, h\u2082\u27e9 => \u27e8a b, H h\u2081 h\u2082\u27e9) <$> f <*> x, ?_\u27e9\n  simp only [\u2190 pure_seq]; simp [SatisfiesM, seq_assoc]\n  simp only [\u2190 pure_seq]; simp [seq_assoc, Function.comp]\n\n/-- `SatisfiesM` distributes over `<*>`, strongest postcondition version. -/\nprotected theorem seq_post [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM p\u2081 f) (hx : SatisfiesM p\u2082 x) :\n    SatisfiesM (fun c => \u2203 f a, p\u2081 f \u2227 p\u2082 a \u2227 c = f a) (f <*> x) :=\n  hf.seq hx fun  hf ha => \u27e8_, _, hf, ha, rfl\u27e9\n\n/--\n`SatisfiesM` distributes over `<*>`, weakest precondition version 1.\n(Use this when `x` and the goal are known and `f` is a subgoal.)\n-/\nprotected theorem seq_pre [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM (fun f => \u2200 {a}, p\u2082 a \u2192 q (f a)) f) (hx : SatisfiesM p\u2082 x) :\n    SatisfiesM q (f <*> x) :=\n  hf.seq hx fun hf ha => hf ha\n\n/--\n`SatisfiesM` distributes over `<*>`, weakest precondition version 2.\n(Use this when `f` and the goal are known and `x` is a subgoal.)\n-/\nprotected theorem seq_pre' [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hf : SatisfiesM p\u2081 f) (hx : SatisfiesM (fun a => \u2200 {f}, p\u2081 f \u2192 q (f a)) x) :\n    SatisfiesM q (f <*> x) :=\n  hf.seq hx fun hf ha => ha hf\n\n/-- `SatisfiesM` distributes over `<*`, general version. -/\nprotected theorem seqLeft [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hx : SatisfiesM p\u2081 x) (hy : SatisfiesM p\u2082 y)\n    (H : \u2200 {a b}, p\u2081 a \u2192 p\u2082 b \u2192 q a) : SatisfiesM q (x <* y) :=\n  seqLeft_eq x y \u25b8 (hx.map fun h _ => H h).seq_pre hy\n\n/-- `SatisfiesM` distributes over `*>`, general version. -/\nprotected theorem seqRight [Applicative m] [LawfulApplicative m] {x : m \u03b1}\n    (hx : SatisfiesM p\u2081 x) (hy : SatisfiesM p\u2082 y)\n    (H : \u2200 {a b}, p\u2081 a \u2192 p\u2082 b \u2192 q b) : SatisfiesM q (x *> y) :=\n  seqRight_eq x y \u25b8 (hx.map fun h _ => H h).seq_pre hy\n\n/-- `SatisfiesM` distributes over `>>=`, general version. -/\nprotected theorem bind [Monad m] [LawfulMonad m] {f : \u03b1 \u2192 m \u03b2}\n    (hx : SatisfiesM p x) (hf : \u2200 a, p a \u2192 SatisfiesM q (f a)) :\n    SatisfiesM q (x >>= f) := by\n  match x, hx with | _, \u27e8x, rfl\u27e9 => ?_\n  have g a ha := Classical.indefiniteDescription _ (hf a ha)\n  refine \u27e8x >>= fun \u27e8a, h\u27e9 => g a h, ?_\u27e9\n  simp [\u2190 bind_pure_comp]; congr; funext \u27e8a, h\u27e9; simp [\u2190 (g a h).2, \u2190 bind_pure_comp]\n\n/-- `SatisfiesM` distributes over `>>=`, weakest precondition version. -/\nprotected theorem bind_pre [Monad m] [LawfulMonad m] {f : \u03b1 \u2192 m \u03b2}\n    (hx : SatisfiesM (fun a => SatisfiesM q (f a)) x) :\n    SatisfiesM q (x >>= f) := hx.bind fun _ h => h\n\nend SatisfiesM\n\n@[simp] theorem SatisfiesM_Id_eq : SatisfiesM (m := Id) p x \u2194 p x :=\n  \u27e8fun \u27e8y, eq\u27e9 => eq \u25b8 y.2, fun h => \u27e8\u27e8_, h\u27e9, rfl\u27e9\u27e9\n\n@[simp] theorem SatisfiesM_Option_eq : SatisfiesM (m := Option) p x \u2194 \u2200 a, x = some a \u2192 p a :=\n  \u27e8by revert x; intro | some _, \u27e8some \u27e8_, h\u27e9, rfl\u27e9, _, rfl => exact h,\n   fun h => match x with | some a => \u27e8some \u27e8a, h _ rfl\u27e9, rfl\u27e9 | none => \u27e8none, rfl\u27e9\u27e9\n\n@[simp] theorem SatisfiesM_Except_eq : SatisfiesM (m := Except \u03b5) p x \u2194 \u2200 a, x = .ok a \u2192 p a :=\n  \u27e8by revert x; intro | .ok _, \u27e8.ok \u27e8_, h\u27e9, rfl\u27e9, _, rfl => exact h,\n   fun h => match x with | .ok a => \u27e8.ok \u27e8a, h _ rfl\u27e9, rfl\u27e9 | .error e => \u27e8.error e, rfl\u27e9\u27e9\n\n@[simp] theorem SatisfiesM_ReaderT_eq [Monad m] :\n    SatisfiesM (m := ReaderT \u03c1 m) p x \u2194 \u2200 s, SatisfiesM p (x s) :=\n  (exists_congr fun a => by exact \u27e8fun eq _ => eq \u25b8 rfl, funext\u27e9).trans Classical.skolem.symm\n\ntheorem SatisfiesM_StateRefT_eq [Monad m] :\n    SatisfiesM (m := StateRefT' \u03c9 \u03c3 m) p x \u2194 \u2200 s, SatisfiesM p (x s) := by simp\n\n@[simp] theorem SatisfiesM_StateT_eq [Monad m] [LawfulMonad m] :\n    SatisfiesM (m := StateT \u03c1 m) (\u03b1 := \u03b1) p x \u2194 \u2200 s, SatisfiesM (m := m) (p \u00b7.1) (x s) := by\n  refine .trans \u27e8fun \u27e8f, eq\u27e9 => eq \u25b8 ?_, fun \u27e8f, h\u27e9 => ?_\u27e9 Classical.skolem.symm\n  \u00b7 refine \u27e8fun s => (fun \u27e8\u27e8a, h\u27e9, s'\u27e9 => \u27e8\u27e8a, s'\u27e9, h\u27e9) <$> f s, fun s => ?_\u27e9\n    rw [\u2190 comp_map, map_eq_pure_bind]; rfl\n  \u00b7 refine \u27e8fun s => (fun \u27e8\u27e8a, s'\u27e9, h\u27e9 => \u27e8\u27e8a, h\u27e9, s'\u27e9) <$> f s, funext fun s => ?_\u27e9\n    show _ >>= _ = _; simp [map_eq_pure_bind, \u2190 h]\n\n@[simp] theorem SatisfiesM_ExceptT_eq [Monad m] [LawfulMonad m] :\n    SatisfiesM (m := ExceptT \u03c1 m) (\u03b1 := \u03b1) p x \u2194 SatisfiesM (m := m) (\u2200 a, \u00b7 = .ok a \u2192 p a) x := by\n  refine \u27e8fun \u27e8f, eq\u27e9 => eq \u25b8 ?_, fun \u27e8f, eq\u27e9 => eq \u25b8 ?_\u27e9\n  \u00b7 exists (fun | .ok \u27e8a, h\u27e9 => \u27e8.ok a, fun | _, rfl => h\u27e9 | .error e => \u27e8.error e, fun.\u27e9) <$> f\n    show _ = _ >>= _; rw [\u2190 comp_map, map_eq_pure_bind]; congr; funext a; cases a <;> rfl\n  \u00b7 exists ((fun | \u27e8.ok a, h\u27e9 => .ok \u27e8a, h _ rfl\u27e9 | \u27e8.error e, _\u27e9 => .error e) <$> f : m _)\n    show _ >>= _ = _; simp [\u2190 comp_map, map_eq_pure_bind]; congr; funext \u27e8a, h\u27e9; cases a <;> rfl\n"}
{"text": "(****************************************************************************)\n(* Copyright 2020 The Project Oak Authors                                   *)\n(*                                                                          *)\n(* Licensed under the Apache License, Version 2.0 (the \"License\")           *)\n(* you may not use this file except in compliance with the License.         *)\n(* You may obtain a copy of the License at                                  *)\n(*                                                                          *)\n(*     http://www.apache.org/licenses/LICENSE-2.0                           *)\n(*                                                                          *)\n(* Unless required by applicable law or agreed to in writing, software      *)\n(* distributed under the License is distributed on an \"AS IS\" BASIS,        *)\n(* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. *)\n(* See the License for the specific language governing permissions and      *)\n(* limitations under the License.                                           *)\n(****************************************************************************)\n\nRequire Import Coq.Arith.Arith Coq.Logic.Eqdep_dec Coq.Vectors.Vector Coq.micromega.Lia\n     Coq.NArith.NArith Coq.Strings.String Coq.NArith.Ndigits.\nRequire Import Cava.Arrow.ArrowExport\n     Cava.BitArithmetic Cava.VectorUtils.\nRequire Import Cava.Tactics.\n\nRequire Import Aes.Pkg Aes.SboxCanrightPkg.\n\nImport VectorNotations.\nImport KappaNotation.\nOpen Scope kind_scope.\n\n(* function automatic logic [3:0] aes_inverse_gf2p4(logic [3:0] gamma);\n  logic [3:0] delta;\n  logic [1:0] a, b, c, d;\n  a          = gamma[3:2] ^ gamma[1:0];\n  b          = aes_mul_gf2p2(gamma[3:2], gamma[1:0]);\n  c          = aes_scale_omega2_gf2p2(aes_square_gf2p2(a));\n  d          = aes_square_gf2p2(c ^ b);\n  delta[3:2] = aes_mul_gf2p2(d, gamma[1:0]);\n  delta[1:0] = aes_mul_gf2p2(d, gamma[3:2]);\n  return delta;\nendfunction *)\nProgram Definition aes_inverse_gf2p4\n  : <<Vector Bit 4, Unit>> ~> (Vector Bit 4) :=\n  <[\\ gamma =>\n      let a = (gamma[:3:2]) ^ (gamma[:1:0]) in\n      let b = !aes_mul_gf2p2 (gamma[:3:2]) (gamma[:1:0]) in\n      let c = !aes_scale_omega2_gf2p2 (!aes_square_gf2p2 a) in\n      let d = !aes_square_gf2p2 (c ^ b) in\n      concat\n        (!aes_mul_gf2p2 d (gamma[:3:2]))\n        (!aes_mul_gf2p2 d (gamma[:1:0]))\n  ]>.\n\n  (* // Inverse in GF(2^8), using normal basis [d^16, d]\n  // (see Figure 11 in the technical report)\n  function automatic logic [7:0] aes_inverse_gf2p8(logic [7:0] gamma);\n    logic [7:0] delta;\n    logic [3:0] a, b, c, d;\n    a          = gamma[7:4] ^ gamma[3:0];\n    b          = aes_mul_gf2p4(gamma[7:4], gamma[3:0]);\n    c          = aes_square_scale_gf2p4_gf2p2(a);\n    d          = aes_inverse_gf2p4(c ^ b);\n    delta[7:4] = aes_mul_gf2p4(d, gamma[3:0]);\n    delta[3:0] = aes_mul_gf2p4(d, gamma[7:4]);\n    return delta;\n  endfunction *)\nDefinition aes_inverse_gf2p8\n  :  <<Vector Bit 8, Unit>> ~> (Vector Bit 8) :=\n  <[\\ gamma =>\n      let a = (gamma[:7:4]) ^ (gamma[:3:0]) in\n      let b = !aes_mul_gf2p4 (gamma[:7:4]) (gamma[:3:0]) in\n      let c = !aes_square_scale_gf2p4_gf2p2 a in\n      let d = !aes_inverse_gf2p4 (c ^ b) in\n\n      concat\n        (!aes_mul_gf2p4 d (gamma[:7:4]))\n        (!aes_mul_gf2p4 d (gamma[:3:0]))\n  ]>.\n\n(* module aes_sbox_canright (\n  input  aes_pkg::ciph_op_e op_i,\n  input  logic [7:0]        data_i,\n  output logic [7:0]        data_o\n); *)\nDefinition aes_sbox_canright\n  :  << Bit, Vector Bit 8, Unit>> ~> (Vector Bit 8) :=\n  <[\\ op_i data_i =>\n      (* // Convert to normal basis X.\n      assign data_basis_x = (op_i == CIPH_FWD) ? aes_mvm(data_i, A2X) :\n                                                aes_mvm(data_i ^ 8'h63, S2X); *)\n      let data_basis_x = if op_i == !CIPH_FWD\n                        then !aes_mvm data_i !A2X\n                        else !aes_mvm (data_i ^ #99) !S2X in\n\n      (* // Do the inversion in normal basis X.\n      assign data_inverse = aes_inverse_gf2p8(data_basis_x); *)\n      let data_inverse = !aes_inverse_gf2p8 data_basis_x in\n\n      (* // Convert to basis S or A.\n      assign data_o       = (op_i == CIPH_FWD) ? aes_mvm(data_inverse, X2S) ^ 8'h63 :\n                                                aes_mvm(data_inverse, X2A);  *)\n      let data_o = if op_i == !CIPH_FWD\n                  then (!aes_mvm data_inverse !X2S) ^ #99\n                  else !aes_mvm data_inverse !X2A in\n\n      data_o\n  ]>.\n\nDefinition canright_composed\n  :  << Vector Bit 8, Unit>> ~> (Vector Bit 8) :=\n  <[\\input =>\n  let encoded = !aes_sbox_canright !CIPH_FWD input in\n  let decoded = !aes_sbox_canright !CIPH_INV encoded in\n  decoded ]>.\n\nLemma canright_composed_combinational: is_combinational (closure_conversion aes_sbox_canright).\nProof. time simply_combinational. Qed.\n\nLocal Notation \"# x\" := (nat_to_bitvec_sized 8 x) (at level 99).\n\nGoal kinterp canright_composed (# 0, tt) = (# 0).\nProof. time (vm_compute; auto). Qed.\n\n(* TODO(blaxill): reduced bound for CI time *)\nGoal forall x, x < 100 ->\nkinterp canright_composed (#x, tt) = (#x).\nProof. time (repeat (lia || destruct x); now vm_compute). Qed.\n"}
{"text": "/-\nCopyright (c) 2021 OpenAI. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kunhao Zheng, Stanislas Polu, David Renshaw, OpenAI GPT-f\n-/\nimport mathzoo.imports.miniF2F\n\nopen_locale nat rat real big_operators topological_space\n\ntheorem mathd_algebra_455\n  (x : \u211d)\n  (h\u2080 : 2 * (2 * (2 * (2 * x))) = 48) :\n  x = 3 :=\nbegin\n  linarith,\nend"}
{"text": "lemma contour_integral_subpath_refl [simp]: \"contour_integral (subpath u u g) f = 0\""}
{"text": "If $f$ is a real-valued function, then $\\int f(x) dx = c \\int f(t + cx) dx$ for any constant $c \\neq 0$."}
{"text": "[STATEMENT]\nlemma uint64_of_uint32_code [code]:\n  \"uint64_of_uint32 x = Abs_uint64' (ucast (Rep_uint32' x))\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. uint64_of_uint32 x = Abs_uint64' (ucast (Rep_uint32' x))\n[PROOF STEP]\nby transfer simp"}
{"text": "import data.equiv.algebra\nimport group_theory.quotient_group\n\n-- Some stuff is now in mathlib\n\nnamespace quotient_group\n\ntheorem map_id {G : Type*} [group G] (K : set G) [normal_subgroup K] (g : quotient K) :\nmap K K id (\u03bb x h, h) g = g := by induction g; refl\n\ntheorem map_comp\n  {G : Type*} {H : Type*} {J : Type*}\n  [group G] [group H] [group J]\n  (a : G \u2192 H) [is_group_hom a] (b : H \u2192 J) [is_group_hom b]\n  {G1 : set G} {H1 : set H} {J1 : set J}\n  [normal_subgroup G1] [normal_subgroup H1] [normal_subgroup J1]\n  (h1 : G1 \u2286 a \u207b\u00b9' H1) (h2 : H1 \u2286 b \u207b\u00b9' J1)\n  (g : quotient G1) :\nmap H1 J1 b h2 (map G1 H1 a h1 g) = map G1 J1 (b \u2218 a) (\u03bb _ hx, h2 $ h1 hx) g :=\nby induction g; refl\n\nend quotient_group\n\nopen quotient_group\n\n-- This version is better (than a previous, deleted version),\n-- but Mario points out that really I shuold be using a\n-- relation rather than h2 : he.to_equiv \u207b\u00b9' K = J.\ndef mul_equiv.quotient {G : Type*} {H : Type*} [group G] [group H]\n  (he : G \u2243* H) (J : set G) [normal_subgroup J] (K : set H) [normal_subgroup K]\n  (h2 : he.to_equiv \u207b\u00b9' K = J) :\nmul_equiv (quotient_group.quotient J) (quotient_group.quotient K) :=\n{ to_fun := quotient_group.lift J (mk \u2218 he) begin\n    unfold set.preimage at h2,\n    intros g hg,\n    rw \u2190h2 at hg,\n    rw \u2190is_group_hom.mem_ker (quotient_group.mk : H \u2192 quotient_group.quotient K),\n    rwa quotient_group.ker_mk,\n  end,\n  inv_fun := quotient_group.lift K (mk \u2218 he.symm) begin\n    intros h hh,\n    rw \u2190is_group_hom.mem_ker (quotient_group.mk : G \u2192 quotient_group.quotient J),\n    rw quotient_group.ker_mk,\n    show he.to_equiv.symm h \u2208 J,\n    rw \u2190h2,\n    show he.to_equiv (he.to_equiv.symm h) \u2208 K,\n    convert hh,\n    exact he.to_equiv.right_inv h\n  end,\n  left_inv := \u03bb g, begin\n    induction g,\n    conv begin\n      to_rhs,\n      rw \u2190he.to_equiv.left_inv g,\n    end,\n    refl, refl,\n    end,\n  right_inv := \u03bb h, begin\n    induction h,\n    conv begin\n      to_rhs,\n      rw \u2190he.to_equiv.right_inv h,\n    end,\n    refl, refl,\n  end,\n  map_mul' := (quotient_group.is_group_hom_quotient_lift J _ _).map_mul }\n"}
{"text": "From Perennial.program_proof.mvcc Require Import\n     txn_prelude txn_repr\n     wrbuf_repr wrbuf_open_tuples.\n\nSection program.\nContext `{!heapGS \u03a3, !mvcc_ghostG \u03a3}.\n\n(*****************************************************************)\n(* func (txn *Txn) acquire() bool                                *)\n(*****************************************************************)\nTheorem wp_txn__acquire txn tid view \u03b3 \u03c4 :\n  {{{ own_txn txn tid view \u03b3 \u03c4 }}}\n    Txn__acquire #txn\n  {{{ (ok : bool), RET #ok;\n      if ok then own_txn_ready txn tid view \u03b3 \u03c4 else own_txn txn tid view \u03b3 \u03c4\n  }}}.\nProof.\n  iIntros (\u03a6) \"Htxn H\u03a6\".\n  wp_call.\n\n  (***********************************************************)\n  (* ok := txn.wrbuf.OpenTuples(txn.tid, txn.idx)            *)\n  (* return ok                                               *)\n  (***********************************************************)\n  iNamed \"Htxn\".\n  iNamed \"Himpl\".\n  do 3 wp_loadField.\n  wp_apply (wp_wrbuf__OpenTuples with \"HidxRI [$HwrbufRP $Hactive]\").\n  iIntros (ok) \"[Hactive HwrbufRP]\".\n  wp_pures.\n  iApply \"H\u03a6\".\n  destruct ok.\n  { (* Case success. *)\n    iDestruct \"HwrbufRP\" as (tpls) \"[HwrbufRP Htpls]\".\n    do 3 iExists _.\n    rewrite Etid.\n    iFrame \"Htxnmap Htpls HwrbufRP Hltuples\".\n    eauto 20 with iFrame.\n  }\n  { (* Case failure. *)\n    do 2 iExists _.\n    iFrame \"Htxnmap HwrbufRP Hltuples\".\n    eauto 20 with iFrame.\n  }\nQed.\n\nEnd program.\n"}
{"text": "lemmas continuous_on_Re [continuous_intros] = bounded_linear.continuous_on[OF bounded_linear_Re]"}
{"text": "/-\nCopyright (c) 2020 S\u00e9bastien Gou\u00ebzel. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: S\u00e9bastien Gou\u00ebzel, Floris van Doorn\n\n! This file was ported from Lean 3 source module geometry.manifold.cont_mdiff_mfderiv\n! leanprover-community/mathlib commit 0187644979f2d3e10a06e916a869c994facd9a87\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathbin.Geometry.Manifold.Mfderiv\n\n/-!\n### Interactions between differentiability, smoothness and manifold derivatives\n\nWe give the relation between `mdifferentiable`, `cont_mdiff`, `mfderiv`, `tangent_map`\nand related notions.\n\n## Main statements\n\n* `cont_mdiff_on.cont_mdiff_on_tangent_map_within` states that the bundled derivative\n  of a `C\u207f` function in a domain is `C\u1d50` when `m + 1 \u2264 n`.\n* `cont_mdiff.cont_mdiff_tangent_map` states that the bundled derivative\n  of a `C\u207f` function is `C\u1d50` when `m + 1 \u2264 n`.\n-/\n\n\nopen Set Function Filter ChartedSpace SmoothManifoldWithCorners Bundle\n\nopen Topology Manifold Bundle\n\n/-! ### Definition of smooth functions between manifolds -/\n\n\nvariable {\ud835\udd5c : Type _} [NontriviallyNormedField \ud835\udd5c]\n  -- declare a smooth manifold `M` over the pair `(E, H)`.\n  {E : Type _}\n  [NormedAddCommGroup E] [NormedSpace \ud835\udd5c E] {H : Type _} [TopologicalSpace H]\n  {I : ModelWithCorners \ud835\udd5c E H} {M : Type _} [TopologicalSpace M] [ChartedSpace H M]\n  [Is : SmoothManifoldWithCorners I M]\n  -- declare a smooth manifold `M'` over the pair `(E', H')`.\n  {E' : Type _}\n  [NormedAddCommGroup E'] [NormedSpace \ud835\udd5c E'] {H' : Type _} [TopologicalSpace H']\n  {I' : ModelWithCorners \ud835\udd5c E' H'} {M' : Type _} [TopologicalSpace M'] [ChartedSpace H' M']\n  [I's : SmoothManifoldWithCorners I' M']\n  -- declare a smooth manifold `N` over the pair `(F, G)`.\n  {F : Type _}\n  [NormedAddCommGroup F] [NormedSpace \ud835\udd5c F] {G : Type _} [TopologicalSpace G]\n  {J : ModelWithCorners \ud835\udd5c F G} {N : Type _} [TopologicalSpace N] [ChartedSpace G N]\n  [Js : SmoothManifoldWithCorners J N]\n  -- declare a smooth manifold `N'` over the pair `(F', G')`.\n  {F' : Type _}\n  [NormedAddCommGroup F'] [NormedSpace \ud835\udd5c F'] {G' : Type _} [TopologicalSpace G']\n  {J' : ModelWithCorners \ud835\udd5c F' G'} {N' : Type _} [TopologicalSpace N'] [ChartedSpace G' N']\n  [J's : SmoothManifoldWithCorners J' N']\n  -- declare some additional normed spaces, used for fibers of vector bundles\n  {F\u2081 : Type _}\n  [NormedAddCommGroup F\u2081] [NormedSpace \ud835\udd5c F\u2081] {F\u2082 : Type _} [NormedAddCommGroup F\u2082]\n  [NormedSpace \ud835\udd5c F\u2082]\n  -- declare functions, sets, points and smoothness indices\n  {f f\u2081 : M \u2192 M'}\n  {s s\u2081 t : Set M} {x : M} {m n : \u2115\u221e}\n\n/-! ### Deducing differentiability from smoothness -/\n\n\ntheorem ContMdiffWithinAt.mdifferentiableWithinAt (hf : ContMdiffWithinAt I I' n f s x)\n    (hn : 1 \u2264 n) : MdifferentiableWithinAt I I' f s x :=\n  by\n  suffices h : MdifferentiableWithinAt I I' f (s \u2229 f \u207b\u00b9' (extChartAt I' (f x)).source) x\n  \u00b7 rwa [mdifferentiableWithinAt_inter'] at h\n    apply hf.1.preimage_mem_nhdsWithin\n    exact extChartAt_source_mem_nhds I' (f x)\n  rw [mdifferentiableWithinAt_iff]\n  exact \u27e8hf.1.mono (inter_subset_left _ _), (hf.2.DifferentiableWithinAt hn).mono (by mfld_set_tac)\u27e9\n#align cont_mdiff_within_at.mdifferentiable_within_at ContMdiffWithinAt.mdifferentiableWithinAt\n\ntheorem ContMdiffAt.mdifferentiableAt (hf : ContMdiffAt I I' n f x) (hn : 1 \u2264 n) :\n    MdifferentiableAt I I' f x :=\n  mdifferentiableWithinAt_univ.1 <| ContMdiffWithinAt.mdifferentiableWithinAt hf hn\n#align cont_mdiff_at.mdifferentiable_at ContMdiffAt.mdifferentiableAt\n\ntheorem ContMdiffOn.mdifferentiableOn (hf : ContMdiffOn I I' n f s) (hn : 1 \u2264 n) :\n    MdifferentiableOn I I' f s := fun x hx => (hf x hx).MdifferentiableWithinAt hn\n#align cont_mdiff_on.mdifferentiable_on ContMdiffOn.mdifferentiableOn\n\ntheorem ContMdiff.mdifferentiable (hf : ContMdiff I I' n f) (hn : 1 \u2264 n) : Mdifferentiable I I' f :=\n  fun x => (hf x).MdifferentiableAt hn\n#align cont_mdiff.mdifferentiable ContMdiff.mdifferentiable\n\ntheorem SmoothWithinAt.mdifferentiableWithinAt (hf : SmoothWithinAt I I' f s x) :\n    MdifferentiableWithinAt I I' f s x :=\n  hf.MdifferentiableWithinAt le_top\n#align smooth_within_at.mdifferentiable_within_at SmoothWithinAt.mdifferentiableWithinAt\n\ntheorem SmoothAt.mdifferentiableAt (hf : SmoothAt I I' f x) : MdifferentiableAt I I' f x :=\n  hf.MdifferentiableAt le_top\n#align smooth_at.mdifferentiable_at SmoothAt.mdifferentiableAt\n\ntheorem SmoothOn.mdifferentiableOn (hf : SmoothOn I I' f s) : MdifferentiableOn I I' f s :=\n  hf.MdifferentiableOn le_top\n#align smooth_on.mdifferentiable_on SmoothOn.mdifferentiableOn\n\ntheorem Smooth.mdifferentiable (hf : Smooth I I' f) : Mdifferentiable I I' f :=\n  ContMdiff.mdifferentiable hf le_top\n#align smooth.mdifferentiable Smooth.mdifferentiable\n\ntheorem Smooth.mdifferentiableAt (hf : Smooth I I' f) : MdifferentiableAt I I' f x :=\n  hf.Mdifferentiable x\n#align smooth.mdifferentiable_at Smooth.mdifferentiableAt\n\ntheorem Smooth.mdifferentiableWithinAt (hf : Smooth I I' f) : MdifferentiableWithinAt I I' f s x :=\n  hf.MdifferentiableAt.MdifferentiableWithinAt\n#align smooth.mdifferentiable_within_at Smooth.mdifferentiableWithinAt\n\n/-! ### The tangent map of a smooth function is smooth -/\n\n\nsection tangentMap\n\n/-- If a function is `C^n` with `1 \u2264 n` on a domain with unique derivatives, then its bundled\nderivative is continuous. In this auxiliary lemma, we prove this fact when the source and target\nspace are model spaces in models with corners. The general fact is proved in\n`cont_mdiff_on.continuous_on_tangent_map_within`-/\ntheorem ContMdiffOn.continuousOn_tangentMapWithin_aux {f : H \u2192 H'} {s : Set H}\n    (hf : ContMdiffOn I I' n f s) (hn : 1 \u2264 n) (hs : UniqueMdiffOn I s) :\n    ContinuousOn (tangentMapWithin I I' f s) (\u03c0 (TangentSpace I) \u207b\u00b9' s) :=\n  by\n  suffices h :\n    ContinuousOn\n      (fun p : H \u00d7 E =>\n        (f p.fst,\n          (fderivWithin \ud835\udd5c (writtenInExtChartAt I I' p.fst f) (I.symm \u207b\u00b9' s \u2229 range I)\n                ((extChartAt I p.fst) p.fst) :\n              E \u2192L[\ud835\udd5c] E')\n            p.snd))\n      (Prod.fst \u207b\u00b9' s)\n  \u00b7 have A := (tangentBundleModelSpaceHomeomorph H I).Continuous\n    rw [continuous_iff_continuousOn_univ] at A\n    have B :=\n      ((tangentBundleModelSpaceHomeomorph H' I').symm.Continuous.comp_continuousOn h).comp' A\n    have :\n      univ \u2229 \u21d1(tangentBundleModelSpaceHomeomorph H I) \u207b\u00b9' (Prod.fst \u207b\u00b9' s) =\n        \u03c0 (TangentSpace I) \u207b\u00b9' s :=\n      by\n      ext \u27e8x, v\u27e9\n      simp only [mfld_simps]\n    rw [this] at B\n    apply B.congr\n    rintro \u27e8x, v\u27e9 hx\n    dsimp [tangentMapWithin]\n    ext\n    \u00b7 rfl\n    simp only [mfld_simps]\n    apply congr_fun\n    apply congr_arg\n    rw [MdifferentiableWithinAt.mfderivWithin (hf.mdifferentiable_on hn x hx)]\n    rfl\n  suffices h :\n    ContinuousOn\n      (fun p : H \u00d7 E =>\n        (fderivWithin \ud835\udd5c (I' \u2218 f \u2218 I.symm) (I.symm \u207b\u00b9' s \u2229 range I) (I p.fst) : E \u2192L[\ud835\udd5c] E') p.snd)\n      (Prod.fst \u207b\u00b9' s)\n  \u00b7 dsimp [writtenInExtChartAt, extChartAt]\n    apply\n      ContinuousOn.prod\n        (ContinuousOn.comp hf.continuous_on continuous_fst.continuous_on (subset.refl _))\n    apply h.congr\n    intro p hp\n    rfl\n  suffices h : ContinuousOn (fderivWithin \ud835\udd5c (I' \u2218 f \u2218 I.symm) (I.symm \u207b\u00b9' s \u2229 range I)) (I '' s)\n  \u00b7 have C := ContinuousOn.comp h I.continuous_to_fun.continuous_on (subset.refl _)\n    have A : Continuous fun q : (E \u2192L[\ud835\udd5c] E') \u00d7 E => q.1 q.2 :=\n      is_bounded_bilinear_map_apply.continuous\n    have B :\n      ContinuousOn\n        (fun p : H \u00d7 E => (fderivWithin \ud835\udd5c (I' \u2218 f \u2218 I.symm) (I.symm \u207b\u00b9' s \u2229 range I) (I p.1), p.2))\n        (Prod.fst \u207b\u00b9' s) :=\n      by\n      apply ContinuousOn.prod _ continuous_snd.continuous_on\n      refine' (ContinuousOn.comp C continuous_fst.continuous_on _ : _)\n      exact preimage_mono (subset_preimage_image _ _)\n    exact A.comp_continuous_on B\n  rw [contMdiffOn_iff] at hf\n  let x : H := I.symm (0 : E)\n  let y : H' := I'.symm (0 : E')\n  have A := hf.2 x y\n  simp only [I.image_eq, inter_comm, mfld_simps] at A\u22a2\n  apply A.continuous_on_fderiv_within _ hn\n  convert hs.unique_diff_on_target_inter x using 1\n  simp only [inter_comm, mfld_simps]\n#align cont_mdiff_on.continuous_on_tangent_map_within_aux ContMdiffOn.continuousOn_tangentMapWithin_aux\n\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/- ./././Mathport/Syntax/Translate/Expr.lean:177:8: unsupported: ambiguous notation -/\n/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative is\n`C^m` when `m+1 \u2264 n`. In this auxiliary lemma, we prove this fact when the source and target space\nare model spaces in models with corners. The general fact is proved in\n`cont_mdiff_on.cont_mdiff_on_tangent_map_within` -/\ntheorem ContMdiffOn.contMdiffOn_tangentMapWithin_aux {f : H \u2192 H'} {s : Set H}\n    (hf : ContMdiffOn I I' n f s) (hmn : m + 1 \u2264 n) (hs : UniqueMdiffOn I s) :\n    ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (\u03c0 (TangentSpace I) \u207b\u00b9' s) :=\n  by\n  have m_le_n : m \u2264 n := by\n    apply le_trans _ hmn\n    have : m + 0 \u2264 m + 1 := add_le_add_left (zero_le _) _\n    simpa only [add_zero] using this\n  have one_le_n : 1 \u2264 n := by\n    apply le_trans _ hmn\n    change 0 + 1 \u2264 m + 1\n    exact add_le_add_right (zero_le _) _\n  have U' : UniqueDiffOn \ud835\udd5c (range I \u2229 I.symm \u207b\u00b9' s) :=\n    by\n    intro y hy\n    simpa only [UniqueMdiffOn, UniqueMdiffWithinAt, hy.1, inter_comm, mfld_simps] using\n      hs (I.symm y) hy.2\n  rw [contMdiffOn_iff]\n  refine' \u27e8hf.continuous_on_tangent_map_within_aux one_le_n hs, fun p q => _\u27e9\n  have A :\n    range I \u00d7\u02e2 univ \u2229\n        ((Equiv.sigmaEquivProd H E).symm \u2218 fun p : E \u00d7 E => (I.symm p.fst, p.snd)) \u207b\u00b9'\n          (\u03c0 (TangentSpace I) \u207b\u00b9' s) =\n      (range I \u2229 I.symm \u207b\u00b9' s) \u00d7\u02e2 univ :=\n    by\n    ext \u27e8x, v\u27e9\n    simp only [mfld_simps]\n  suffices h :\n    ContDiffOn \ud835\udd5c m\n      (((fun p : H' \u00d7 E' => (I' p.fst, p.snd)) \u2218 Equiv.sigmaEquivProd H' E') \u2218\n        tangentMapWithin I I' f s \u2218\n          (Equiv.sigmaEquivProd H E).symm \u2218 fun p : E \u00d7 E => (I.symm p.fst, p.snd))\n      ((range \u21d1I \u2229 \u21d1I.symm \u207b\u00b9' s) \u00d7\u02e2 univ)\n  \u00b7 simpa [A] using h\n  change\n    ContDiffOn \ud835\udd5c m\n      (fun p : E \u00d7 E =>\n        ((I' (f (I.symm p.fst)), (mfderivWithin I I' f s (I.symm p.fst) : E \u2192 E') p.snd) : E' \u00d7 E'))\n      ((range I \u2229 I.symm \u207b\u00b9' s) \u00d7\u02e2 univ)\n  -- check that all bits in this formula are `C^n`\n  have hf' := contMdiffOn_iff.1 hf\n  have A : ContDiffOn \ud835\udd5c m (I' \u2218 f \u2218 I.symm) (range I \u2229 I.symm \u207b\u00b9' s) := by\n    simpa only [mfld_simps] using (hf'.2 (I.symm 0) (I'.symm 0)).of_le m_le_n\n  have B : ContDiffOn \ud835\udd5c m ((I' \u2218 f \u2218 I.symm) \u2218 Prod.fst) ((range I \u2229 I.symm \u207b\u00b9' s) \u00d7\u02e2 univ) :=\n    A.comp cont_diff_fst.cont_diff_on (prod_subset_preimage_fst _ _)\n  suffices C :\n    ContDiffOn \ud835\udd5c m\n      (fun p : E \u00d7 E => (fderivWithin \ud835\udd5c (I' \u2218 f \u2218 I.symm) (I.symm \u207b\u00b9' s \u2229 range I) p.1 : _) p.2)\n      ((range I \u2229 I.symm \u207b\u00b9' s) \u00d7\u02e2 univ)\n  \u00b7 apply ContDiffOn.prod B _\n    apply C.congr fun p hp => _\n    simp only [mfld_simps] at hp\n    simp only [mfderivWithin, hf.mdifferentiable_on one_le_n _ hp.2, hp.1, if_pos, mfld_simps]\n  have D :\n    ContDiffOn \ud835\udd5c m (fun x => fderivWithin \ud835\udd5c (I' \u2218 f \u2218 I.symm) (I.symm \u207b\u00b9' s \u2229 range I) x)\n      (range I \u2229 I.symm \u207b\u00b9' s) :=\n    by\n    have : ContDiffOn \ud835\udd5c n (I' \u2218 f \u2218 I.symm) (range I \u2229 I.symm \u207b\u00b9' s) := by\n      simpa only [mfld_simps] using hf'.2 (I.symm 0) (I'.symm 0)\n    simpa only [inter_comm] using this.fderiv_within U' hmn\n  have := D.comp cont_diff_fst.cont_diff_on (prod_subset_preimage_fst _ _)\n  have := ContDiffOn.prod this cont_diff_snd.cont_diff_on\n  exact is_bounded_bilinear_map_apply.cont_diff.comp_cont_diff_on this\n#align cont_mdiff_on.cont_mdiff_on_tangent_map_within_aux ContMdiffOn.contMdiffOn_tangentMapWithin_aux\n\ninclude Is I's\n\n/-- If a function is `C^n` on a domain with unique derivatives, then its bundled derivative\nis `C^m` when `m+1 \u2264 n`. -/\ntheorem ContMdiffOn.contMdiffOn_tangentMapWithin (hf : ContMdiffOn I I' n f s) (hmn : m + 1 \u2264 n)\n    (hs : UniqueMdiffOn I s) :\n    ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) (\u03c0 (TangentSpace I) \u207b\u00b9' s) :=\n  by\n  /- The strategy of the proof is to avoid unfolding the definitions, and reduce by functoriality\n    to the case of functions on the model spaces, where we have already proved the result.\n    Let `l` and `r` be the charts to the left and to the right, so that we have\n    ```\n       l^{-1}      f       r\n    H --------> M ---> M' ---> H'\n    ```\n    Then the tangent map `T(r \u2218 f \u2218 l)` is smooth by a previous result. Consider the composition\n    ```\n        Tl        T(r \u2218 f \u2218 l^{-1})         Tr^{-1}\n    TM -----> TH -------------------> TH' ---------> TM'\n    ```\n    where `Tr^{-1}` and `Tl` are the tangent maps of `r^{-1}` and `l`. Writing `Tl` and `Tr^{-1}` as\n    composition of charts (called `Dl` and `il` for `l` and `Dr` and `ir` in the proof below), it\n    follows that they are smooth. The composition of all these maps is `Tf`, and is therefore smooth\n    as a composition of smooth maps.\n    -/\n  have m_le_n : m \u2264 n := by\n    apply le_trans _ hmn\n    have : m + 0 \u2264 m + 1 := add_le_add_left (zero_le _) _\n    simpa only [add_zero]\n  have one_le_n : 1 \u2264 n := by\n    apply le_trans _ hmn\n    change 0 + 1 \u2264 m + 1\n    exact add_le_add_right (zero_le _) _\n  -- First step: local reduction on the space, to a set `s'` which is contained in chart domains.\n  refine' contMdiffOn_of_locally_contMdiffOn fun p hp => _\n  have hf' := contMdiffOn_iff.1 hf\n  simp only [mfld_simps] at hp\n  let l := chart_at H p.proj\n  set Dl := chart_at (ModelProd H E) p with hDl\n  let r := chart_at H' (f p.proj)\n  let Dr := chart_at (ModelProd H' E') (tangentMapWithin I I' f s p)\n  let il := chart_at (ModelProd H E) (tangentMap I I l p)\n  let ir := chart_at (ModelProd H' E') (tangentMap I I' (r \u2218 f) p)\n  let s' := f \u207b\u00b9' r.source \u2229 s \u2229 l.source\n  let s'_lift := \u03c0 (TangentSpace I) \u207b\u00b9' s'\n  let s'l := l.target \u2229 l.symm \u207b\u00b9' s'\n  let s'l_lift := \u03c0 (TangentSpace I) \u207b\u00b9' s'l\n  rcases continuousOn_iff'.1 hf'.1 r.source r.open_source with \u27e8o, o_open, ho\u27e9\n  suffices h : ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' f s) s'_lift\n  \u00b7 refine' \u27e8\u03c0 (TangentSpace I) \u207b\u00b9' (o \u2229 l.source), _, _, _\u27e9\n    show IsOpen (\u03c0 (TangentSpace I) \u207b\u00b9' (o \u2229 l.source))\n    exact (IsOpen.inter o_open l.open_source).Preimage (continuous_proj E _)\n    show p \u2208 \u03c0 (TangentSpace I) \u207b\u00b9' (o \u2229 l.source)\n    \u00b7 simp\n      have : p.proj \u2208 f \u207b\u00b9' r.source \u2229 s := by simp [hp]\n      rw [ho] at this\n      exact this.1\n    \u00b7 have : \u03c0 (TangentSpace I) \u207b\u00b9' s \u2229 \u03c0 (TangentSpace I) \u207b\u00b9' (o \u2229 l.source) = s'_lift :=\n        by\n        dsimp only [s'_lift, s']\n        rw [ho]\n        mfld_set_tac\n      rw [this]\n      exact h\n  /- Second step: check that all functions are smooth, and use the chain rule to write the bundled\n    derivative as a composition of a function between model spaces and of charts.\n    Convention: statements about the differentiability of `a \u2218 b \u2218 c` are named `diff_abc`. Statements\n    about differentiability in the bundle have a `_lift` suffix. -/\n  have U' : UniqueMdiffOn I s' :=\n    by\n    apply UniqueMdiffOn.inter _ l.open_source\n    rw [ho, inter_comm]\n    exact hs.inter o_open\n  have U'l : UniqueMdiffOn I s'l := U'.unique_mdiff_on_preimage (mdifferentiable_chart _ _)\n  have diff_f : ContMdiffOn I I' n f s' := hf.mono (by mfld_set_tac)\n  have diff_r : ContMdiffOn I' I' n r r.source := contMdiffOn_chart\n  have diff_rf : ContMdiffOn I I' n (r \u2218 f) s' :=\n    by\n    apply ContMdiffOn.comp diff_r diff_f fun x hx => _\n    simp only [s', mfld_simps] at hx\n    simp only [hx, mfld_simps]\n  have diff_l : ContMdiffOn I I n l.symm s'l :=\n    haveI A : ContMdiffOn I I n l.symm l.target := contMdiffOn_chart_symm\n    A.mono (by mfld_set_tac)\n  have diff_rfl : ContMdiffOn I I' n (r \u2218 f \u2218 l.symm) s'l :=\n    by\n    apply ContMdiffOn.comp diff_rf diff_l\n    mfld_set_tac\n  have diff_rfl_lift :\n    ContMdiffOn I.tangent I'.tangent m (tangentMapWithin I I' (r \u2218 f \u2218 l.symm) s'l) s'l_lift :=\n    diff_rfl.cont_mdiff_on_tangent_map_within_aux hmn U'l\n  have diff_irrfl_lift :\n    ContMdiffOn I.tangent I'.tangent m (ir \u2218 tangentMapWithin I I' (r \u2218 f \u2218 l.symm) s'l) s'l_lift :=\n    haveI A : ContMdiffOn I'.tangent I'.tangent m ir ir.source := contMdiffOn_chart\n    ContMdiffOn.comp A diff_rfl_lift fun p hp => by simp only [ir, mfld_simps]\n  have diff_Drirrfl_lift :\n    ContMdiffOn I.tangent I'.tangent m (Dr.symm \u2218 ir \u2218 tangentMapWithin I I' (r \u2218 f \u2218 l.symm) s'l)\n      s'l_lift :=\n    by\n    have A : ContMdiffOn I'.tangent I'.tangent m Dr.symm Dr.target := contMdiffOn_chart_symm\n    apply ContMdiffOn.comp A diff_irrfl_lift fun p hp => _\n    simp only [s'l_lift, mfld_simps] at hp\n    simp only [ir, hp, mfld_simps]\n  -- conclusion of this step: the composition of all the maps above is smooth\n  have diff_DrirrflilDl :\n    ContMdiffOn I.tangent I'.tangent m\n      (Dr.symm \u2218 (ir \u2218 tangentMapWithin I I' (r \u2218 f \u2218 l.symm) s'l) \u2218 il.symm \u2218 Dl) s'_lift :=\n    by\n    have A : ContMdiffOn I.tangent I.tangent m Dl Dl.source := contMdiffOn_chart\n    have A' : ContMdiffOn I.tangent I.tangent m Dl s'_lift :=\n      by\n      apply A.mono fun p hp => _\n      simp only [s'_lift, mfld_simps] at hp\n      simp only [Dl, hp, mfld_simps]\n    have B : ContMdiffOn I.tangent I.tangent m il.symm il.target := contMdiffOn_chart_symm\n    have C : ContMdiffOn I.tangent I.tangent m (il.symm \u2218 Dl) s'_lift :=\n      ContMdiffOn.comp B A' fun p hp => by simp only [il, mfld_simps]\n    apply ContMdiffOn.comp diff_Drirrfl_lift C fun p hp => _\n    simp only [s'_lift, mfld_simps] at hp\n    simp only [il, s'l_lift, hp, total_space.proj, mfld_simps]\n  /- Third step: check that the composition of all the maps indeed coincides with the derivative we\n    are looking for -/\n  have eq_comp :\n    \u2200 q \u2208 s'_lift,\n      tangentMapWithin I I' f s q =\n        (Dr.symm \u2218 ir \u2218 tangentMapWithin I I' (r \u2218 f \u2218 l.symm) s'l \u2218 il.symm \u2218 Dl) q :=\n    by\n    intro q hq\n    simp only [s'_lift, mfld_simps] at hq\n    have U'q : UniqueMdiffWithinAt I s' q.1 := by\n      apply U'\n      simp only [hq, s', mfld_simps]\n    have U'lq : UniqueMdiffWithinAt I s'l (Dl q).1 :=\n      by\n      apply U'l\n      simp only [hq, s'l, mfld_simps]\n    have A :\n      tangentMapWithin I I' ((r \u2218 f) \u2218 l.symm) s'l (il.symm (Dl q)) =\n        tangentMapWithin I I' (r \u2218 f) s' (tangentMapWithin I I l.symm s'l (il.symm (Dl q))) :=\n      by\n      refine' tangentMapWithin_comp_at (il.symm (Dl q)) _ _ (fun p hp => _) U'lq\n      \u00b7 apply diff_rf.mdifferentiable_on one_le_n\n        simp only [hq, mfld_simps]\n      \u00b7 apply diff_l.mdifferentiable_on one_le_n\n        simp only [s'l, hq, mfld_simps]\n      \u00b7 simp only [mfld_simps] at hp\n        simp only [hp, mfld_simps]\n    have B : tangentMapWithin I I l.symm s'l (il.symm (Dl q)) = q :=\n      by\n      have :\n        tangentMapWithin I I l.symm s'l (il.symm (Dl q)) = tangentMap I I l.symm (il.symm (Dl q)) :=\n        by\n        refine' tangentMapWithin_eq_tangentMap U'lq _\n        refine' mdifferentiableAt_atlas_symm _ (chart_mem_atlas _ _) _\n        simp only [hq, mfld_simps]\n      rw [this, tangentMap_chart_symm, hDl]\n      \u00b7 simp only [hq, mfld_simps]\n        have : q \u2208 (chart_at (ModelProd H E) p).source := by simp only [hq, mfld_simps]\n        exact (chart_at (ModelProd H E) p).left_inv this\n      \u00b7 simp only [hq, mfld_simps]\n    have C :\n      tangentMapWithin I I' (r \u2218 f) s' q =\n        tangentMapWithin I' I' r r.source (tangentMapWithin I I' f s' q) :=\n      by\n      refine' tangentMapWithin_comp_at q _ _ (fun r hr => _) U'q\n      \u00b7 apply diff_r.mdifferentiable_on one_le_n\n        simp only [hq, mfld_simps]\n      \u00b7 apply diff_f.mdifferentiable_on one_le_n\n        simp only [hq, mfld_simps]\n      \u00b7 simp only [s', mfld_simps] at hr\n        simp only [hr, mfld_simps]\n    have D :\n      Dr.symm (ir (tangentMapWithin I' I' r r.source (tangentMapWithin I I' f s' q))) =\n        tangentMapWithin I I' f s' q :=\n      by\n      have A :\n        tangentMapWithin I' I' r r.source (tangentMapWithin I I' f s' q) =\n          tangentMap I' I' r (tangentMapWithin I I' f s' q) :=\n        by\n        apply tangentMapWithin_eq_tangentMap\n        \u00b7 apply IsOpen.uniqueMdiffWithinAt _ r.open_source\n          simp [hq]\n        \u00b7 refine' mdifferentiableAt_atlas _ (chart_mem_atlas _ _) _\n          simp only [hq, mfld_simps]\n      have : f p.proj = (tangentMapWithin I I' f s p).1 := rfl\n      rw [A]\n      dsimp [r, Dr]\n      rw [this, tangentMap_chart]\n      \u00b7 simp only [hq, mfld_simps]\n        have :\n          tangentMapWithin I I' f s' q \u2208\n            (chart_at (ModelProd H' E') (tangentMapWithin I I' f s p)).source :=\n          by simp only [hq, mfld_simps]\n        exact (chart_at (ModelProd H' E') (tangentMapWithin I I' f s p)).left_inv this\n      \u00b7 simp only [hq, mfld_simps]\n    have E : tangentMapWithin I I' f s' q = tangentMapWithin I I' f s q :=\n      by\n      refine' tangentMapWithin_subset (by mfld_set_tac) U'q _\n      apply hf.mdifferentiable_on one_le_n\n      simp only [hq, mfld_simps]\n    simp only [(\u00b7 \u2218 \u00b7), A, B, C, D, E.symm]\n  exact diff_DrirrflilDl.congr eq_comp\n#align cont_mdiff_on.cont_mdiff_on_tangent_map_within ContMdiffOn.contMdiffOn_tangentMapWithin\n\n/-- If a function is `C^n` on a domain with unique derivatives, with `1 \u2264 n`, then its bundled\nderivative is continuous there. -/\ntheorem ContMdiffOn.continuousOn_tangentMapWithin (hf : ContMdiffOn I I' n f s) (hmn : 1 \u2264 n)\n    (hs : UniqueMdiffOn I s) :\n    ContinuousOn (tangentMapWithin I I' f s) (\u03c0 (TangentSpace I) \u207b\u00b9' s) :=\n  haveI :\n    ContMdiffOn I.tangent I'.tangent 0 (tangentMapWithin I I' f s) (\u03c0 (TangentSpace I) \u207b\u00b9' s) :=\n    hf.cont_mdiff_on_tangent_map_within hmn hs\n  this.continuous_on\n#align cont_mdiff_on.continuous_on_tangent_map_within ContMdiffOn.continuousOn_tangentMapWithin\n\n/-- If a function is `C^n`, then its bundled derivative is `C^m` when `m+1 \u2264 n`. -/\ntheorem ContMdiff.contMdiff_tangentMap (hf : ContMdiff I I' n f) (hmn : m + 1 \u2264 n) :\n    ContMdiff I.tangent I'.tangent m (tangentMap I I' f) :=\n  by\n  rw [\u2190 contMdiffOn_univ] at hf\u22a2\n  convert hf.cont_mdiff_on_tangent_map_within hmn uniqueMdiffOn_univ\n  rw [tangentMapWithin_univ]\n#align cont_mdiff.cont_mdiff_tangent_map ContMdiff.contMdiff_tangentMap\n\n/-- If a function is `C^n`, with `1 \u2264 n`, then its bundled derivative is continuous. -/\ntheorem ContMdiff.continuous_tangentMap (hf : ContMdiff I I' n f) (hmn : 1 \u2264 n) :\n    Continuous (tangentMap I I' f) :=\n  by\n  rw [\u2190 contMdiffOn_univ] at hf\n  rw [continuous_iff_continuousOn_univ]\n  convert hf.continuous_on_tangent_map_within hmn uniqueMdiffOn_univ\n  rw [tangentMapWithin_univ]\n#align cont_mdiff.continuous_tangent_map ContMdiff.continuous_tangentMap\n\nend tangentMap\n\nnamespace TangentBundle\n\ninclude Is\n\nvariable (I M)\n\nopen Bundle\n\n/-- The derivative of the zero section of the tangent bundle maps `\u27e8x, v\u27e9` to `\u27e8\u27e8x, 0\u27e9, \u27e8v, 0\u27e9\u27e9`.\n\nNote that, as currently framed, this is a statement in coordinates, thus reliant on the choice\nof the coordinate system we use on the tangent bundle.\n\nHowever, the result itself is coordinate-dependent only to the extent that the coordinates\ndetermine a splitting of the tangent bundle.  Moreover, there is a canonical splitting at each\npoint of the zero section (since there is a canonical horizontal space there, the tangent space\nto the zero section, in addition to the canonical vertical space which is the kernel of the\nderivative of the projection), and this canonical splitting is also the one that comes from the\ncoordinates on the tangent bundle in our definitions. So this statement is not as crazy as it\nmay seem.\n\nTODO define splittings of vector bundles; state this result invariantly. -/\ntheorem tangentMap_tangentBundle_pure (p : TangentBundle I M) :\n    tangentMap I I.tangent (zeroSection (TangentSpace I)) p = \u27e8\u27e8p.proj, 0\u27e9, \u27e8p.2, 0\u27e9\u27e9 :=\n  by\n  rcases p with \u27e8x, v\u27e9\n  have N : I.symm \u207b\u00b9' (chart_at H x).target \u2208 \ud835\udcdd (I ((chart_at H x) x)) :=\n    by\n    apply IsOpen.mem_nhds\n    apply (LocalHomeomorph.open_target _).Preimage I.continuous_inv_fun\n    simp only [mfld_simps]\n  have A : MdifferentiableAt I I.tangent (fun x => @total_space_mk M (TangentSpace I) x 0) x :=\n    haveI : Smooth I (I.prod \ud835\udcd8(\ud835\udd5c, E)) (zero_section (TangentSpace I : M \u2192 Type _)) :=\n      Bundle.smooth_zeroSection \ud835\udd5c (TangentSpace I : M \u2192 Type _)\n    this.mdifferentiable_at\n  have B :\n    fderivWithin \ud835\udd5c (fun x' : E => (x', (0 : E))) (Set.range \u21d1I) (I ((chart_at H x) x)) v = (v, 0) :=\n    by\n    rw [fderivWithin_eq_fderiv, DifferentiableAt.fderiv_prod]\n    \u00b7 simp\n    \u00b7 exact differentiableAt_id'\n    \u00b7 exact differentiableAt_const _\n    \u00b7 exact ModelWithCorners.unique_diff_at_image I\n    \u00b7 exact differentiable_at_id'.prod (differentiableAt_const _)\n  simp only [Bundle.zeroSection, tangentMap, mfderiv, total_space.proj_mk, A, if_pos, chart_at,\n    FiberBundle.chartedSpace_chartAt, TangentBundle.trivializationAt_apply, tangentBundleCore,\n    Function.comp, ContinuousLinearMap.map_zero, mfld_simps]\n  rw [\u2190 fderivWithin_inter N (I.unique_diff (I ((chart_at H x) x)) (Set.mem_range_self _))] at B\n  rw [\u2190 fderivWithin_inter N (I.unique_diff (I ((chart_at H x) x)) (Set.mem_range_self _)), \u2190 B]\n  congr 2\n  apply fderivWithin_congr _ fun y hy => _\n  \u00b7 simp only [Prod.mk.inj_iff, mfld_simps]\n  \u00b7 apply UniqueDiffWithinAt.inter (I.unique_diff _ _) N\n    simp only [mfld_simps]\n  \u00b7 simp only [mfld_simps] at hy\n    simp only [hy, Prod.mk.inj_iff, mfld_simps]\n#align tangent_bundle.tangent_map_tangent_bundle_pure TangentBundle.tangentMap_tangentBundle_pure\n\nend TangentBundle\n\n"}
{"text": "\n#include(\"testS2Cell.jl\")\ninclude(\"testS1Angle.jl\")\ninclude(\"testS1ChordAngle.jl\")\ninclude(\"testS2Point.jl\")\n\n"}
{"text": "[STATEMENT]\nlemma af\\<^sub>G_eval\\<^sub>G:\n  \"Only_G \\<G> \\<Longrightarrow> \\<G> \\<Turnstile>\\<^sub>P af\\<^sub>G (eval\\<^sub>G \\<G> \\<phi>) w \\<longleftrightarrow> \\<G> \\<Turnstile>\\<^sub>P eval\\<^sub>G \\<G> (af\\<^sub>G \\<phi> w)\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. Only_G \\<G> \\<Longrightarrow> \\<G> \\<Turnstile>\\<^sub>P af\\<^sub>G (eval\\<^sub>G \\<G> \\<phi>) w = \\<G> \\<Turnstile>\\<^sub>P eval\\<^sub>G \\<G> (af\\<^sub>G \\<phi> w)\n[PROOF STEP]\nby (induction \\<phi>) (simp_all add: eval\\<^sub>G_prop_entailment af\\<^sub>G_decompose)"}
{"text": "open classical\n\nvariable p: Prop \n#check em p \n\ntheorem dne {p: Prop} (h: \u00ac \u00ac p) : p :=\n  (em p).elim \n    (assume hp: p, hp)\n    (assume hnp: \u00ac p, absurd hnp h)\n  \n#check by_cases\n"}
{"text": "abbrev M := ExceptT String $ StateT Nat Id\n\ndef add (n : Nat) : M Unit :=\n  modify (\u00b7 + 0)\n\n@[simp] theorem addZero : add (natLit! 0) = pure () :=\n  rfl\n\nsyntax \"bigAdd0Seq! \" num : term\n\nmacro_rules\n  | `(bigAdd0Seq! $n) =>\n    let n := n.toNat\n    if n == 0 then\n      `(pure ())\n    else\n      `(add (natLit! 0) >>= fun _ => bigAdd0Seq! $(Lean.quote (n - 1)))\n\nset_option maxRecDepth 10000\n\ntheorem ex : bigAdd0Seq! 10 = pure () := by\n  simp\n\n-- set_option pp.explicit true\n-- set_option pp.notation false\n-- #print ex\n"}
{"text": "import topology.basic\nimport algebra.module.basic\nimport algebra.module.submodule\n\nimport analysis.normed_space.basic\n\n-- Montrer que si un sous-espace vectoriel F d'un espace norm\u00e9 E est ouvert alors F = E .\n\ntheorem exo {R E: Type*} [normed_field R] [normed_group E] [normed_space R E] (F: subspace R E):\n  is_open F.carrier -> forall x: E, set.mem x F\n:= sorry\n"}
{"text": "module Test.Extra.ListTest\n\nimport IdrTest.Test\nimport IdrTest.Expectation\n\nimport Extra.List\n\nexport\nsuite : Test\nsuite =\n  describe \"List Extra Tests\" [\n    describe \"Length\" [\n      test \"Populated List\" (\\_ => assertEq\n        (length [1,2,3])\n        3\n      ),\n      test \"Empty\" (\\_ => assertEq\n        (length (the (List Int) []))\n        0\n      )\n    ],\n    describe \"Range\" [\n      test \"Simple Range\" (\\_ => assertEq\n        (range 5)\n        [0,1,2,3,4]\n      ),\n      test \"Empty Range\" (\\_ => assertEq\n        (range 0)\n        []\n      )\n    ],\n    describe \"Zip with Index\" [\n      test \"Simple List\" (\\_ => assertEq\n        (zipWithIndex ['a', 'b', 'c', 'd'])\n        [('a', 0), ('b', 1), ('c', 2), ('d', 3)]\n      ),\n      test \"Empty List\" (\\_ => assertEq\n        (zipWithIndex (the (List Int) []))\n        []\n      )\n    ],\n    describe \"Find all\" [\n      test \"Find all simple\" (\\_ => assertEq\n        (findAll (unpack \"abcbcd\") (unpack \"bc\"))\n        ([1, 3])\n      )\n    ],\n    describe \"Replace\" [\n      test \"Replace simple\" (\\_ => assertEq\n        (replace (unpack \"abcbcd\") (unpack \"bc\") (unpack \"zzz\"))\n        (unpack \"azzzzzzd\")\n      )\n    ]\n  ]\n"}
{"text": "\nimport data.finsupp.basic\n\nsection\n\n\n/-- An inductive type from which to index the variables of the multi-variable polynomials the proof manages -/\n@[derive decidable_eq]\ninductive vars : Type\n| r_v : vars\n| r_w : vars\n| \u03b1_v : vars\n| \u03b1_w : vars\n| \u03b1_y : vars\n| \u03b2 : vars\n| \u03b3 : vars\n\nlemma finsupp_vars_eq_ext (f g : vars \u2192\u2080 \u2115) : f = g \u2194 \n  f vars.r_v = g vars.r_v \n  \u2227 f vars.r_w = g vars.r_w\n  \u2227 f vars.\u03b1_v = g vars.\u03b1_v\n  \u2227 f vars.\u03b1_w = g vars.\u03b1_w\n  \u2227 f vars.\u03b1_y = g vars.\u03b1_y\n  \u2227 f vars.\u03b2 = g vars.\u03b2\n  \u2227 f vars.\u03b3 = g vars.\u03b3 :=\nbegin\n  rw finsupp.ext_iff,\n  split,\n    {\n      intro h,\n      split, exact h vars.r_v,\n      split, exact h vars.r_w,\n      split, exact h vars.\u03b1_v,\n      split, exact h vars.\u03b1_w,\n      split, exact h vars.\u03b1_y,\n      split, exact h vars.\u03b2,\n      exact h vars.\u03b3,\n    },\n    {\n      intro h,\n      intro a,\n      induction a,\n      finish,\n      finish,\n      finish,\n      finish,\n      finish,\n      finish,\n      finish,\n    },\n  -- induction,\nend\n\nend"}
{"text": "import data.finset\n\n-- Formula for the Number of Combinations\n\nopen finset\n\ntheorem t058 {\u03b1} : \u03a0 (n : \u2115) (s : finset \u03b1),\n  card (powerset_len n s) = nat.choose (card s) n\n:= finset.card_powerset_len\n"}
{"text": "using Dates\n\nout_dir() = mkpath(normpath(joinpath(@__FILE__, \"..\", \"..\", \"..\", \"out\")))\n\nsnapshot_name(time::DateTime, step::Int) = \"bert-abs-$(Dates.format(time, \"yyyy-mm-dd-HH:MM\"))-step-$(string(step, pad=6))\"\n\nsnapshot_file(time::DateTime, step::Int, name::String) = joinpath(out_dir(), \"$(snapshot_name(time, step))-$name\")\n\nfunction snapshot_files(time::DateTime, inc_steps::Int, name::String)::Tuple{Vector{String}, Int}\n    step = inc_steps\n    files = []\n    push!(files, snapshot_file(time, step, name))\n    while isfile(files[end])\n        step += inc_steps\n        push!(files, snapshot_file(time, step, name))\n    end\n    return files[1:end-1], step - inc_steps\nend\n"}
{"text": "! RUN: %f18 -fopenacc -funparse %s | FileCheck %s\n\n! Test unparse does not crash with OpenACC directives.\n\n! Test bug 47659\nprogram bug47659\n  integer :: i, j\n  label1: do i = 1, 10\n    !$acc parallel loop\n    do j = 1, 10\n      if (j == 2) then\n        exit label1\n      end if\n    end do\n  end do label1\nend program\n\n!CHECK-LABEL: PROGRAM bug47659\n!CHECK: !$ACC PARALLEL LOOP\n"}
{"text": "\ndata Nat : Set where\n  zero : Nat\n  suc  : Nat \u2192 Nat\n\ndata Id (A : Set) : Set where\n  mkId : A \u2192 Id A\n\ndata Monad (M : Set \u2192 Set) : Set where\n\npostulate\n  return : \u2200 {M} {{Mon : Monad M}} {A} \u2192 A \u2192 M A\n  _>>=_  : \u2200 {M} {{Mon : Monad M}} {A B} \u2192 M A \u2192 (A \u2192 M B) \u2192 M B\n  State : (S A : Set) \u2192 Set\n\n  instance\n    MonadState : \u2200 {S} \u2192 Monad (State S)\n    MonadId : Monad Id\n\n-- Yields\n--   _M Nat == State Nat Nat,\n-- which inert improvement solves by\n--   _M x := State (_S x) (_A x)\n--     with _S Nat == Nat\n--          _A Nat == Nat\n-- This allows instance search to pick the right instance.\nrz : State Nat Nat\nrz = return zero\n\npostulate\n  StateT : (S : Set) (M : Set \u2192 Set) (A : Set) \u2192 Set\n\n  instance\n    MonadStateT : \u2200 {S M} \u2192 Monad M \u2192 Monad (StateT S M)\n\nstateT\u2081 : \u2200 {M} {{Mon : Monad M}} \u2192 StateT Nat M Nat\nstateT\u2081 = return zero\n\nstateT\u2082 : \u2200 {M} {{Mon : Monad M}} \u2192 StateT Nat M Nat\nstateT\u2082 = return zero >>= \u03bb n \u2192 return (suc n)\n\npostulate\n  _<$_ : \u2200 {A B M} {{Mon : Monad M}} \u2192 A \u2192 M B \u2192 M A\n\nrecord \u22a4 : Set where\n  constructor tt\n\nfoo : Id \u22a4\nfoo = _ <$ return zero\n"}
{"text": "Formal statement is: lemma closed_empty [continuous_intros, intro, simp]: \"closed {}\" Informal statement is: The empty set is closed."}
{"text": "Formal statement is: lemma closure_closure [simp]: \"closure (closure S) = closure S\" Informal statement is: The closure of the closure of a set is the closure of the set."}
{"text": " Note \n"}
{"text": "Require Export P02.\n\n(** **** Problem #3 : 2 stars (mult_S_1) *)\nTheorem mult_S_1 : forall n m : nat,\n  m = S n -> \n  m * (1 + n) = m * m.\nProof.\n  intros n m.\n  intros K.\n  rewrite -> K.\n  reflexivity.\nQed.\n\n(*-- Check --*)\n\nCheck mult_S_1 : forall n m : nat,\n  m = S n -> \n  m * (1 + n) = m * m.\n"}
{"text": "/-\nCopyright (c) 2023 Mar\u00eda In\u00e9s de Frutos-Fern\u00e1ndez. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthor : Mar\u00eda In\u00e9s de Frutos-Fern\u00e1ndez\n-/\n\nimport order.filter.basic\n\n/-!\n# Filtros\nLa definici\u00f3n de `filtro` en Lean es la siguiente:\n\nstructure filter (\u03b1 : Type*) :=\n(sets                   : set (set \u03b1))\n(univ_sets              : set.univ \u2208 sets)\n(sets_of_superset {x y} : x \u2208 sets \u2192 x \u2286 y \u2192 y \u2208 sets)\n(inter_sets {x y}       : x \u2208 sets \u2192 y \u2208 sets \u2192 x \u2229 y \u2208 sets)\n\n\n## Notaci\u00f3n y resultados \u00fatiles.\n\nFijamos `\u03b1 : Type`, `F : filter \u03b1` y `S : set \u03b1`.\n\nPor definici\u00f3n, la notaci\u00f3n `S \u2208 F` significa `S \u2208 F.sets`. \n(La intuici\u00f3n es `F \u2286 S`, aunque por supuesto esto no tiene\nsentido porque `F` es un filtro, no un subconjunto).\n\nDos filtros `F` y `G` son iguales si y s\u00f3lo si \n`\u2200 S, S \u2208 F \u2194 S \u2208 G`. \n\nLos lemas correspondientes a las condiciones que\naparecen en la definici\u00f3n de filtro son:\n\n`univ_mem : univ \u2208 F`\n`mem_of_superset : S \u2208 F \u2192 S \u2286 T \u2192 T \u2208 F`\n`inter_mem : S \u2208 F \u2192 T \u2208 F \u2192 S \u2229 T \u2208 F`\n\nEstos lemas est\u00e1n en el espacio de nombres `filter`.\n-/\n\n-- Abrimos los espacios de nombres `filter` y `set`.\nopen filter set \n\n--  Sea `\u03b1` un tipo, `F` un filtro sobre `\u03b1`, y `S` y `T` dos subconjuntos de `\u03b1`.\nvariables (\u03b1 : Type) (F : filter \u03b1) (S T : set \u03b1)\n\n/-\nDos subconjuntos `S` y `T` est\u00e1n en un filtro `F` si y s\u00f3lo\nsi su intersecci\u00f3n est\u00e1 en `F`.\n\nLos lemas `inter_subset_left S T : S \u2229 T \u2286 S` e `inter_subset_right S T : S \u2229 T \u2286 S`\nson \u00fatiles para esta demostraci\u00f3n.\n-/\nexample : S \u2229 T \u2208 F \u2194 S \u2208 F \u2227 T \u2208 F :=\nbegin\n  split,\n  { intro hST,\n    exact \u27e8mem_of_superset hST (inter_subset_left S T), \n      mem_of_superset hST (inter_subset_right S T) \u27e9, },\n  { rintro \u27e8hS, hT\u27e9,\n    exact inter_mem hS hT }\nend\n\n/-! ## Ejemplos de filtros -/\n\n/- ### Filtros principales\nDado un subconjunto `X` de `\u03b1`, el filtro principal de `X` es la \ncolecci\u00f3n de subconjuntos de `\u03b1` que contienen `X`.\nEst\u00e1 definido en mathlib, y denotado mediante `\ud835\udcdf X`, pero en \neste ejemplo vamos a demostrar nosotros mismos que es un filtro.\n\nLemas \u00fatiles:\n`mem_univ s : s \u2208 univ`\n`subset.trans : A \u2286 B \u2192 B \u2286 C \u2192 A \u2286 C`\n`subset_inter : X \u2286 S \u2192 X \u2286 T \u2192 X \u2286 S \u2229 T`\n`mem_set_of_eq : x \u2208 {a : \u03b1 | p a} = p x`\n-/\n\n-- El filtro principal de `X`.\nexample (X : set \u03b1) : filter \u03b1 :=\n{ sets := {S : set \u03b1 | X \u2286 S},\n  univ_sets := begin\n    exact subset_univ _,\n  end,\n  sets_of_superset := begin\n    intros S T hS hST,\n    exact subset.trans hS hST,\n  end,\n  inter_sets := begin\n    intros S T hS hT,\n    exact subset_inter hS hT,\n  end }\n\n/-- ### EL filtro `at_top` en un conjunto totalmente ordenado\n\nSea `L` un conjunto linearmente ordenado no vac\u00edo.\nVamos a construir un filtro `at_top` que representa un\n\"entorno infinitesimal\" de `\u221e`. En concreto, los conjuntos \npertenecientes a este filtro ser\u00e1n aquellos `X : set L`\npara los que existe un `x : L` tal que para todo `y \u2265 x`, `y \u2208 X`.\n-/\ndef at_top (L : Type) [linear_order L] (e : L) : filter L :=\n{ sets := {X : set L | \u2203 x : L, \u2200 y, x \u2264 y \u2192 y \u2208 X},\n  univ_sets := begin\n    use e,\n    rintros y -,\n    exact mem_univ _,\n  end,\n  sets_of_superset := begin\n    intros S T hS hST,\n    simp only [mem_set_of_eq] at hS \u22a2,\n    obtain \u27e8s, hs\u27e9 := hS,\n    use s,\n    intros x hx,\n    exact hST (hs x hx),\n  end,\n  inter_sets := begin\n    rintros S T \u27e8s, hs\u27e9 \u27e8t, ht\u27e9,\n    use max s t,\n    intros x hx,\n    exact \u27e8hs _ (le_trans (le_max_left s t) hx), ht _ (le_trans (le_max_right s t) hx)\u27e9,\n  end }\n\n/-! ### El filtro cofinito\nEl filtro cofinito en un tipo `\u03b1` es la colecci\u00f3n de subconjuntos `S : set \u03b1`\ncon la propiedad de que el complemento `S\u1d9c`de `S` es finito.\n\nLemas \u00fatiles:\n`compl_univ : univ\u1d9c = \u2205`\n`finite_empty : finite \u2205`\n`compl_subset_compl : X\u1d9c \u2286 Y\u1d9c \u2194 Y \u2286 X`\n`finite.subset : S.finite \u2192 \u2200 {T : set \u03b1}, T \u2286 S \u2192 T.finite`\n`compl_inter S T : (S \u2229 T)\u1d9c = S\u1d9c \u222a T\u1d9c`\n`finite.union : S.finite \u2192 T.finite \u2192 (S \u222a T).finite`.\n-/\ndef cofinite (\u03b1 : Type) : filter \u03b1 :=\n{ sets := { S : set \u03b1 | (S\u1d9c).finite },\n  univ_sets := begin\n    simp only [mem_set_of_eq, compl_univ, finite_empty],\n  end,\n  sets_of_superset := begin\n    intros S T hS hST,\n    rw \u2190 compl_subset_compl at hST, \n    exact finite.subset hS hST,\n  end,\n  inter_sets := begin\n    intros S T hS hT,\n    rw [mem_set_of_eq, compl_inter],\n    exact finite.union hS hT,\n  end }\n\n-- Esta instrucci\u00f3n nos permite acceder a la notaci\u00f3n `\ud835\udcdf X` para el filtro principal\nopen_locale filter\n\n/-!\n## El orden (\u2264) sobre los filtros de `\u03b1`\nLos filtros est\u00e1n parcialmente ordenados, mediante la relaci\u00f3n `\u2264`\ndefinida mediante `F \u2264 G` si y s\u00f3lo si `G.sets \u2286 F.sets`. \n(Cuanto m\u00e1s peque\u00f1o es el filtro `F`, m\u00e1s grande es la colecci\u00f3n\n`F.sets`, ya que el \"conjunto generalizado\" `F` est\u00e1 \"contenido\"\nen m\u00e1s conjuntos).\n\nEn este ejemplo vamos a demostrar que `\ud835\udcdf S \u2264 \ud835\udcdf T \u2194 S \u2286 T`.\nEsto es lo que dice el lema `principal_mono` de mathlib,\npero vamos a demostrarlo utilizando los lemas:\n`mem_principal : T \u2208 \ud835\udcdf S \u2194 S \u2286 T`\n`mem_principal_self S : S \u2208 \ud835\udcdf S`\n`le_def : F \u2264 G \u2194 \u2200 (S : set \u03b1), S \u2208 G \u2192 S \u2208 F`\n-/\n\nexample (S T : set \u03b1) : \ud835\udcdf S \u2264 \ud835\udcdf T \u2194 S \u2286 T :=\nbegin\n  split; -- La siguiente instrucci\u00f3n se aplica a todas las metas abiertas (por el ;).\n  intro hST,\n  { rw \u2190 mem_principal, -- Puedes comentarla y la prueba sigue funcionando\n    rw le_def at hST,\n    exact hST T (mem_principal_self T), },\n  { intros X hX,\n    rw mem_principal at hX \u22a2, -- Puedes comentarla y la prueba sigue funcionando\n    exact subset.trans hST hX, },\nend\n\n/- Este ejemplo se llama `le_principal_iff` en mathlib, pero podemos demostrarlo a\n  partir de las definiciones y lemas anteriores. -/\nexample (F : filter \u03b1) (S : set \u03b1) : F \u2264 \ud835\udcdf S \u2194 S \u2208 F :=\nbegin\n  rw le_def,\n  exact \u27e8\u03bb h, h S (mem_principal_self S), \u03bb h T hT, mem_of_superset h hT\u27e9,\nend\n"}
{"text": "{-# LANGUAGE ConstraintKinds, PolyKinds, TypeFamilies #-}\n{-# LANGUAGE FlexibleInstances, UndecidableInstances #-}\n\nmodule CFunctor where\n\nimport Generics.SOP.Constraint\nimport Numeric.LinearAlgebra hiding (C)\n\nclass CFunctor f where\n  type C f :: * -> Constraint\n  cfmap :: (C f a, C f b) => (a -> b) -> f a -> f b\n\n{-\ninstance {-# OVERLAPPABLE #-} Functor f => CFunctor f where\n  type C f = Top\n  cfmap = fmap\n-}\n\ninstance CFunctor Vector where\n  type C Vector = And Element (Container Vector)\n  cfmap = cmap\n\n"}
{"text": "Require Import Coq.Lists.List.\nRequire Import Coq.Arith.Compare_dec.\nImport ListNotations.\nSet Implicit Arguments.\n\n\nInductive Regex (n : Set) :=\n | Elem  : n -> Regex n\n | Empty :      Regex n\n | Seq   :      Regex n -> Regex n -> Regex n\n | Alt   :      Regex n -> Regex n -> Regex n\n | Star  :      Regex n -> Regex n\n .\n\nInductive Match (n : Set) : Regex n -> list n -> Prop :=\n | MElem  : forall e:n, Match (Elem e)  [e]\n | MEmpty :             Match (Empty _) []\n\n | MSeq   : forall r1 r2 l1 l2,\n            Match r1 l1\n         -> Match r2 l2\n         -> Match (Seq r1 r2) (l1 ++ l2)\n\n | MAlt_L : forall r1 r2 l,\n            Match r1 l\n         -> Match (Alt r1 r2) l\n | MAlt_R : forall r1 r2 l,\n            Match r2 l\n         -> Match (Alt r1 r2) l\n\n | MStar_0: forall r,\n            Match (Star r) []\n | MStar_1: forall r l l',\n            Match r l\n         -> Match (Star r) l'\n         -> Match (Star r) (l ++ l')\n .\n\nDefinition RegexEq (n : Set) (r1 r2 : Regex n) :=\n  forall l, Match r1 l -> Match r2 l\n   /\\       Match r2 l -> Match r1 l.\n\n(* I promise! *)\nAxiom RegexEq_dec : forall (n : Set) (r1 r2 : Regex n), RegexEq r1 r2 \\/ ~ RegexEq r1 r2.\n\n\nCheck filter.\n\nFixpoint filterRx (A : Set) (f : A -> bool) (rx : Regex A) :=\n match rx with\n | Empty => Empty _\n | Elem n => if f n then Elem n else Empty _\n | Seq p q => Seq (filterRx f p) (filterRx f q)\n | Alt p q => Alt (filterRx f p) (filterRx f q)\n | Star p  => Star (filterRx f p)\n end.\n\nTheorem filter_app_dist (A : Set) (f : A -> bool) (a b : list A) :\n   filter f (a ++ b) = filter f a ++ filter f b.\nProof.\n induction a; simpl;\n   try destruct (f a);\n   try rewrite IHa;\n   eauto.\nQed.\n\nTheorem filter_same (A : Set) (f : A -> bool) (rx : Regex A) (w : list A) :\n Match rx w -> Match (filterRx f rx) (filter f w).\nProof.\n intros.\n induction H; eauto; simpl;\n  try rewrite filter_app_dist;\n  try (destruct (f e));\n  try solve [constructor; eauto];\n  eauto.\n\n apply MAlt_R; eauto.\nQed.\n\n"}
{"text": "import ProofWidgets.Component.HtmlDisplay\n\nopen scoped ProofWidgets.Jsx -- \u27f5 remember this!\n\ndef x := <b>You can use HTML in lean! {.text <| toString <| 4 + 5} <hr/> </b>\n\n#html x\n\ntheorem ghjk : True := by\n  html! <b>What, HTML in Lean?! </b>\n  html! <i>And another!</i>\n  html! <img src=\"https://upload.wikimedia.org/wikipedia/commons/a/a5/Parrot_montage.jpg\"/>\n  trivial\n"}
{"text": "/-\nCopyright (c) 2020 Kevin Lacker. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kevin Lacker\n-/\n\nimport data.nat.digits\n\n/-!\n# IMO 1960 Q1\n\nDetermine all three-digit numbers $N$ having the property that $N$ is divisible by 11, and\n$\\dfrac{N}{11}$ is equal to the sum of the squares of the digits of $N$.\n\nSince Lean doesn't have a way to directly express problem statements of the form\n\"Determine all X satisfying Y\", we express two predicates where proving that one implies the\nother is equivalent to solving the problem. A human solver also has to discover the\nsecond predicate.\n\nThe strategy here is roughly brute force, checking the possible multiples of 11.\n-/\n\nopen nat\n\nnamespace imo1960_q1\n\ndef sum_of_squares (L : list \u2115) : \u2115 := (L.map (\u03bb x, x * x)).sum\n\ndef problem_predicate (n : \u2115) : Prop :=\n(nat.digits 10 n).length = 3 \u2227 11 \u2223 n \u2227 n / 11 = sum_of_squares (nat.digits 10 n)\n\ndef solution_predicate (n : \u2115) : Prop := n = 550 \u2228 n = 803\n\n/-\nProving that three digit numbers are the ones in [100, 1000).\n-/\n\nlemma not_zero {n : \u2115} (h1 : problem_predicate n) : n \u2260 0 :=\nhave h2 : nat.digits 10 n \u2260 list.nil, from list.ne_nil_of_length_eq_succ h1.left,\ndigits_ne_nil_iff_ne_zero.mp h2\n\nlemma ge_100 {n : \u2115} (h1 : problem_predicate n) : 100 \u2264 n :=\nhave h2 : 10^3 \u2264 10 * n, begin\n  rw \u2190 h1.left,\n  refine nat.base_pow_length_digits_le 10 n _ (not_zero h1),\n  simp,\nend,\nby linarith\n\nlemma lt_1000 {n : \u2115} (h1 : problem_predicate n) : n < 1000 :=\nhave h2 : n < 10^3, begin\n  rw \u2190 h1.left,\n  refine nat.lt_base_pow_length_digits _,\n  simp,\nend,\nby linarith\n\n/-\nWe do an exhaustive search to show that all results are covered by `solution_predicate`.\n-/\n\ndef search_up_to (c n : \u2115) : Prop :=\nn = c * 11 \u2227 \u2200 m : \u2115, m < n \u2192 problem_predicate m \u2192 solution_predicate m\n\nlemma search_up_to_start : search_up_to 9 99 := \u27e8rfl, \u03bb n h p, by linarith [ge_100 p]\u27e9\n\nlemma search_up_to_step {c n} (H : search_up_to c n)\n  {c' n'} (ec : c + 1 = c') (en : n + 11 = n')\n  {l} (el : nat.digits 10 n = l)\n  (H' : c = sum_of_squares l \u2192 c = 50 \u2228 c = 73) :\n  search_up_to c' n' :=\nbegin\n  subst ec, subst en, subst el,\n  obtain \u27e8rfl, H\u27e9 := H,\n  refine \u27e8by ring, \u03bb m l p, _\u27e9,\n  obtain \u27e8h\u2081, \u27e8m, rfl\u27e9, h\u2082\u27e9 := id p,\n  by_cases h : 11 * m < c * 11, { exact H _ h p },\n  obtain rfl : m = c := by linarith,\n  rw [nat.mul_div_cancel_left _ (by norm_num : 11 > 0), mul_comm] at h\u2082,\n  refine (H' h\u2082).imp _ _; {rintro rfl, norm_num}\nend\n\nlemma search_up_to_end {c} (H : search_up_to c 1001)\n  {n : \u2115} (ppn : problem_predicate n) : solution_predicate n :=\nH.2 _ (by linarith [lt_1000 ppn]) ppn\n\nlemma right_direction {n : \u2115} : problem_predicate n \u2192 solution_predicate n :=\nbegin\n  have := search_up_to_start,\n  iterate 82\n  { replace := search_up_to_step this (by norm_num1; refl) (by norm_num1; refl)\n      (by norm_num1; refl) dec_trivial },\n  exact search_up_to_end this\nend\n\n/-\nNow we just need to prove the equivalence, for the precise problem statement.\n-/\n\nlemma left_direction (n : \u2115) (spn : solution_predicate n) : problem_predicate n :=\nby rcases spn with (rfl | rfl); norm_num [problem_predicate, sum_of_squares]\n\nend imo1960_q1\n\nopen imo1960_q1\n\ntheorem imo1960_q1 (n : \u2115) : problem_predicate n \u2194 solution_predicate n :=\n\u27e8right_direction, left_direction n\u27e9\n"}
{"text": "import Data.Nat\ndata FizzBuzzReturn =\n  Fizz\n  | Buzz\n  | FizzBuzz\n  | Normal Nat\n\nShow FizzBuzzReturn where\n  show Fizz = \"fizz\"\n  show Buzz = \"buzz\"\n  show FizzBuzz = \"fizzbuzz\"\n  show (Normal x) = show x\n\n\npartial fizzBuzzReturn: (x: Nat) -> FizzBuzzReturn\nfizzBuzzReturn x with (modNat x (the Nat 3), modNat x (the Nat 5))\n  fizzBuzzReturn x | (Z, Z) = FizzBuzz\n  fizzBuzzReturn x | (Z, _) = Fizz\n  fizzBuzzReturn x | (_, Z) = Buzz\n  fizzBuzzReturn x | _ = Normal x\n\npartial fizzBuzzReturnString: (x: Nat) -> String\nfizzBuzzReturnString x = show(fizzBuzzReturn x)\n"}
{"text": "# PROPOSAL TO CALCULATE WINDOW MEAN\n# =================================\n# =================================\n\n# Idea: Get Data From all words in timespan, calculate, write back\n\n# Steps\n#   Connect to DB\n#   Get all data from DB\n#   Reshape 1: make big table\n#   Calculation\n#   Plot Example Word \"Flugzeug\"\n#   Reshape II: make tall table (date, w_id, window_value)\n#   Write back into DB\n\n\n\n\n# GET DATA FROM DB\n# ================\n#get all data in timespan\nsql_all_words_in_daterange = \"\nSELECT w_id, date, freq\nFROM daily_words\nWHERE date>'2015-03-5 00:00:00' AND date<'2015-03-31 00:00:00'\"\nrs = dbSendQuery(mydb, sql_all_words_in_daterange)\nmarchData = fetch(rs, n=-1) #fetch n number of results to get (-1 all)\nmarchData$date <- as.Date(marchData$date[]) # format date in class Date\n#check Datespan if necessary\nmin(marchData$date)\nmax(marchData$date)\n\n"}
{"text": "[STATEMENT]\nlemma get_distinguishing_sequence_from_ofsm_tables_with_provided_tables_simp :\n  \"get_distinguishing_sequence_from_ofsm_tables_with_provided_tables (compute_ofsm_tables M (size M - 1)) M = get_distinguishing_sequence_from_ofsm_tables_refined M\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. get_distinguishing_sequence_from_ofsm_tables_with_provided_tables (compute_ofsm_tables M (FSM.size M - 1)) M = get_distinguishing_sequence_from_ofsm_tables_refined M\n[PROOF STEP]\nunfolding get_distinguishing_sequence_from_ofsm_tables_with_provided_tables.simps\n            get_distinguishing_sequence_from_ofsm_tables_refined_code\n            Let_def\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. (\\<lambda>q1 q2. assemble_distinguishing_sequence_from_ofsm_table_with_provided_tables (compute_ofsm_tables M (FSM.size M - 1)) M q1 q2 (if q1 \\<in> FSM.states M \\<and> q2 \\<in> FSM.states M \\<and> ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) (FSM.size M - 1))) q1 \\<noteq> ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) (FSM.size M - 1))) q2 then the (find_index (\\<lambda>i. ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) i)) q1 \\<noteq> ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) i)) q2) [0..<FSM.size M]) else 0)) = (\\<lambda>q1 q2. assemble_distinguishing_sequence_from_ofsm_table_with_provided_tables (compute_ofsm_tables M (FSM.size M - 1)) M q1 q2 (if q1 \\<in> FSM.states M \\<and> q2 \\<in> FSM.states M \\<and> ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) (FSM.size M - 1))) q1 \\<noteq> ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) (FSM.size M - 1))) q2 then the (find_index (\\<lambda>i. ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) i)) q1 \\<noteq> ofsm_lookup (the (Mapping.lookup (compute_ofsm_tables M (FSM.size M - 1)) i)) q2) [0..<FSM.size M]) else 0))\n[PROOF STEP]\nby meson"}
{"text": "lemma bounded_linear_zero[simp]: \"bounded_linear (\\<lambda>x. 0)\""}
{"text": "lemma map_poly_id [simp]: \"map_poly id p = p\""}
{"text": "import ring_theory.algebraic\nimport topology.algebra.polynomial\nimport analysis.calculus.mean_value\nimport ring_theory.integral_closure\nimport data.polynomial.field_division\nimport field_theory.minimal_polynomial\nimport data.real.irrational\n-- import small_things\n\n\nnoncomputable theory\nopen_locale classical\n\nnotation \u03b1`[X]` := polynomial \u03b1\nnotation `transcendental` x := \u00ac(is_algebraic \u2124 x)\n\n\ntheorem liouville (\u03b1 : \u211d) (ha : is_integral \u2124 \u03b1) (hb : irrational \u03b1) : \u2203 c : \u211d, c > 0 \u2227 \u2200 p q : \u2124, q > 0 \u2192 abs(\u03b1 - p / q) > (c / q^(minimal_polynomial ha).nat_degree) :=\nbegin\nsorry,\nend"}
{"text": "lemma i_squared [simp]: \"\\<i> * \\<i> = -1\""}
{"text": "\ndata Nat : Set where\n  zero : Nat\n  suc  : Nat \u2192 Nat\n\n{-# BUILTIN NATURAL Nat #-}\n\ndata _\u2261_ {A : Set} (x : A) : A \u2192 Set where\n  refl : x \u2261 x\n\npred : Nat \u2192 Nat\npred zero = zero\npred (suc n) = n\n\n{-# NON_TERMINATING #-}\nloop : Nat \u2192 Nat\nloop zero = zero\nloop n = loop (pred n)\n\n-- Non-terminating functions reduce when evaluated at top-level,\n-- but not in a hole.\nhole : Set\nhole = {!!}\n"}
{"text": "import tactic\nimport data.nat.basic\nimport data.real.basic\n \nopen_locale classical\nnoncomputable theory\n\n\nopen_locale big_operators\nopen finset\n\ntheorem cauchy_induction {P : \u2115 \u2192 Prop} (h1 : \u03a0 (n : \u2115), P (n + 1) \u2192 P n) (h2 : \u03a0 (n : \u2115), P n \u2192 P (2 * n)) \n{m : \u2115} (hm : 0 < m) (hp : P m) : \n\u2200 (n : \u2115), P n :=\n\nbegin\n  intro n,\n  have lt_pow_two := nat.lt_two_pow n,\n  have le_m_pow_two : n <= 2 ^ n * m,\n  {\n    have le_pow_two := nat.le_of_lt lt_pow_two,\n    have hm' := nat.succ_le_of_lt hm,\n    have target_times_one := nat.mul_le_mul le_pow_two hm',\n    rw mul_one at target_times_one,\n    refine target_times_one,\n  },\n  have two_pow_k_times_m : (\u2200 k : \u2115, P (2 ^ k * m)),\n  {\n    intro k,\n    induction k with i hi,\n    {\n      rw [pow_zero, one_mul],\n      refine hp,\n    },\n    {\n      rw [pow_succ, mul_assoc],\n      refine h2 (2 ^ i * m) hi,\n    },\n  },\n  have two_pow_n_times_m := two_pow_k_times_m n,\n  refine nat.decreasing_induction h1 le_m_pow_two two_pow_n_times_m,\nend"}
{"text": "module Parity\n\n\n\n{- conversion\n\nplus 3 4\n\\k => plus k 0\n\\k => plus Z k\n\\k,m => plus (S k) m\n\\k:Nat => 0+k\n\\k:Nat => k+0\n\\k => Z + k\n \n-}\n\n\n\n\n\ndata Parity : Nat -> Type where\n   Even : Parity (n + n)\n   Odd  : Parity (S (n + n))\n\n{-\nl1: Parity (S (plus j (S j))) -> Parity (S (S (plus j j)))\n....\n-}\n\nparity : (n:Nat) -> Parity n\nparity Z     = Even {n = Z}\nparity (S Z) = Odd {n = Z}\nparity (S (S k)) with (parity k)\n    parity (S (S (j + j)))     | Even  = ?l1 (Even {n=S j})\n    parity (S (S (S (j + j)))) | Odd  ?= (Odd {n=S j})\n\n\n{-\n---------- Proofs ----------\nParity.l1 = proof\n  compute\n  intros\n  rewrite sym (plusSuccRightSucc j j)\n  trivial\n\n\n\nParity.parity_lemma_1 = proof\n  compute\n  intros\n  rewrite sym (plusSuccRightSucc j j)\n  trivial\n-}\n\n\n\n{-\n\nparity2 : (n:Nat) -> Parity n\nparity2 Z     = Even {n = Z}\nparity2 (S k) with (parity2 k)\n    parity2 (S (j + j))     | Even ?= Odd {n=j}\n    parity2 (S (S (j + j))) | Odd  ?= Even {n=S j}\n\n-}\n"}
{"text": "\nmodule Issue249-2 where\n\npostulate\n  A B : Set\n\nmodule A where\n  X = A\n  Y = B\n\n-- open A renaming (X to C; Y to C)\n\nopen A using (X) renaming (Y to X)\n"}
{"text": "theory Check\n  imports Submission\nbegin\n\ntheorem denotational_is_big_step: \"(s,t) \\<in> D(c)  =  ((c,s) \\<Rightarrow> t)\"\n  by (rule Submission.denotational_is_big_step)\n\nend"}
{"text": "import basic\nopen emulators\n--(1,4), (4,1), (2,3), (3,2), (2,5), (5,2), (4,5), (5,4), (2,2), (3,3)\ndef ex: finset (vector \u211a 2 )\n  := {\n    vector.cons 1 (vector.cons 4 vector.nil),\n    vector.cons 4 (vector.cons 1 vector.nil),\n    vector.cons 2 (vector.cons 3 vector.nil),\n    vector.cons 3 (vector.cons 2 vector.nil),\n    vector.cons 2 (vector.cons 5 vector.nil),\n    vector.cons 5 (vector.cons 2 vector.nil),\n    vector.cons 4 (vector.cons 5 vector.nil),\n    vector.cons 5 (vector.cons 4 vector.nil),\n    vector.cons 2 (vector.cons 2 vector.nil),\n    vector.cons 3 (vector.cons 3 vector.nil)\n    }\n\nlemma excard: (ex.card = 10) := begin\nsorry,\nend\n\n-- Maybe a new file for this\n-- OPEN PROBLEM B. What is the smallest cardinality m of such an E in 11? What is the relationship between the n in Open Problem A and this m here? \ntheorem open_problem_B: \n\u2203 (S : finset (vector \u211a 2 )) ,\n S.card = 10 \u2227 \n \u2200 (E:set (vector \u211a 2 )), \n (@is_emulator 2 (E) (\u2191S)) := begin\nuse ex,\nsplit,\n{\n  exact excard,\n},\nintros E,\n-- simp,\nsorry,\nend\n"}
{"text": "# define constants whose name changed with different versions\nmf = Pkg.Operations.Context().env.manifest\nver = mf[findfirst(v -> v.name == \"GLPK\", mf)].version\nif ver >= v\"1\"\n    const GLPK_ON = GLPK.GLP_ON\nelse\n    const GLPK_ON = GLPK.ON\nend\n"}
{"text": "Require Coq.extraction.Extraction.\n\nRequire Import Arith.\nRequire Import ExtrHaskellNatNum.\nRequire Import Ascii.\nRequire Import String.\n\nRequire Import FormatList.\n\nExtraction Language Haskell.\n\nExtract Inductive nat => \"Prelude.Int\" [ \"0\" \"Prelude.succ\" ]\n  \"(\\fO fS n -> if n Prelude.== 0 then fO () else fS (n Prelude.- 1))\".\n\nExtract Inductive ascii => \"Prelude.Char\"\n  [ \"(\\b0 b1 b2 b3 b4 b5 b6 b7 -> Data.Char.chr ( (if b0 then Data.Bits.shiftL 1 0 else 0) Prelude.+ (if b1 then Data.Bits.shiftL 1 1 else 0) Prelude.+ (if b2 then Data.Bits.shiftL 1 2 else 0) Prelude.+ (if b3 then Data.Bits.shiftL 1 3 else 0) Prelude.+ (if b4 then Data.Bits.shiftL 1 4 else 0) Prelude.+ (if b5 then Data.Bits.shiftL 1 5 else 0) Prelude.+ (if b6 then Data.Bits.shiftL 1 6 else 0) Prelude.+ (if b7 then Data.Bits.shiftL 1 7 else 0)))\" ]\n  \"(\\f a -> f (Data.Bits.testBit (Data.Char.ord a) 0) (Data.Bits.testBit (Data.Char.ord a) 1) (Data.Bits.testBit (Data.Char.ord a) 2) (Data.Bits.testBit (Data.Char.ord a) 3) (Data.Bits.testBit (Data.Char.ord a) 4) (Data.Bits.testBit (Data.Char.ord a) 5) (Data.Bits.testBit (Data.Char.ord a) 6) (Data.Bits.testBit (Data.Char.ord a) 7))\".\nExtract Inlined Constant Ascii.ascii_dec => \"(Prelude.==)\".\nExtract Inlined Constant Ascii.eqb => \"(Prelude.==)\".\n\nExtract Inductive string => \"Prelude.String\" [ \"([])\" \"(:)\" ].\nExtract Inlined Constant String.string_dec => \"(Prelude.==)\".\nExtract Inlined Constant String.eqb => \"(Prelude.==)\".\n\nExtract Inductive bool => \"Prelude.Bool\" [ \"Prelude.True\" \"Prelude.False\" ].\nExtract Inductive option => \"Prelude.Maybe\" [ \"Prelude.Just\" \"Prelude.Nothing\" ].\nExtract Inductive unit => \"()\" [ \"()\" ].\nExtract Inductive list => \"([])\" [ \"([])\" \"(:)\" ].\nExtract Inductive prod => \"(,)\" [ \"(,)\" ].\n\nExtract Inductive sumbool => \"Prelude.Bool\" [ \"Prelude.True\" \"Prelude.False\" ].\nExtract Inductive sumor => \"Prelude.Maybe\" [ \"Prelude.Just\" \"Prelude.Nothing\" ].\nExtract Inductive sum => \"Prelude.Either\" [ \"Prelude.Left\" \"Prelude.Right\" ].\n\nExtract Inlined Constant andb => \"(Prelude.&&)\".\nExtract Inlined Constant orb => \"(Prelude.||)\".\nExtract Inlined Constant negb => \"Prelude.not\".\n\nExtraction \"result\" evaluatorList.\n\n"}
{"text": "section\n  variable A : Type\n  variable f : A \u2192 A\n  variable P : A \u2192 Prop\n  variable h : \u2200 x, P x \u2192 P (f x)\n\n  -- Show the following:\n  example : \u2200 y, P y \u2192 P (f (f y)) :=\n  assume y,\n  have h1 : P y \u2192 P (f y), from h y,\n  have h2 : P (f y) \u2192 P (f (f y)), from h (f y),\n  show P y \u2192 P (f (f y)), from \n    assume h4 : P y,\n    have h5 : P (f y), from h1 h4,\n    show P (f (f y)), from h2 h5\nend\n\nsection\n  variable U : Type\n  variables A B : U \u2192 Prop\n\n  example : (\u2200 x, A x \u2227 B x) \u2192 \u2200 x, A x :=\n  assume h1 : \u2200 x, A x \u2227 B x,\n  assume y,\n  have h2 : A y \u2227 B y, from h1 y,\n  show A y, from h2.left\nend\n\nsection\n  variable U : Type\n  variables A B C : U \u2192 Prop\n\n  variable h1 : \u2200 x, A x \u2228 B x\n  variable h2 : \u2200 x, A x \u2192 C x\n  variable h3 : \u2200 x, B x \u2192 C x\n\n  example : \u2200 x, C x :=\n  assume y,\n  show C y, from\n    have h4 : A y \u2228 B y, from h1 y,\n    or.elim h4\n      (assume h5 : A y,\n      have h6 : A y \u2192 C y, from h2 y,\n      show C y, from h6 h5)\n      (assume h5 : B y,\n      have h6 : B y \u2192 C y, from h3 y,\n      show C y, from h6 h5)\nend\n\nopen classical   -- not needed, but you can use it\n\n-- This is an exercise from Chapter 4. Use it as an axiom here.\naxiom not_iff_not_self (P : Prop) : \u00ac (P \u2194 \u00ac P)\n\nexample (Q : Prop) : \u00ac (Q \u2194 \u00ac Q) :=\nnot_iff_not_self Q\n\nsection\n  variable Person : Type\n  variable shaves : Person \u2192 Person \u2192 Prop\n  variable barber : Person\n  variable h : \u2200 x, shaves barber x \u2194 \u00ac shaves x x\n\n  -- Show the following:\n  example : false :=\n  have h3 : shaves barber barber \u2194 \u00ac shaves barber barber, from h barber,\n  have h2 : \u00ac shaves barber barber, from\n    assume h4 : shaves barber barber,\n    have h5 : \u00ac shaves barber barber, from iff.elim_left h3 h4,\n    show false, from h5 h4,\n  have h1 : shaves barber barber, from iff.elim_right h3 h2,\n  show false, from h2 h1\nend\n\nsection\n  variable U : Type\n  variables A B : U \u2192 Prop\n\n  example : (\u2203 x, A x) \u2192 \u2203 x, A x \u2228 B x :=\n  assume h1 : \u2203 x, A x,\n  show \u2203 x, A x \u2228 B x, from exists.elim h1\n    (assume y (h2 : A y),\n    have h3 : A y \u2228 B y, from or.inl h2,\n    show \u2203 x, A x \u2228 B x, from exists.intro y h3)\nend\n\nsection\n  variable U : Type\n  variables A B : U \u2192 Prop\n\n  variable h1 : \u2200 x, A x \u2192 B x\n  variable h2 : \u2203 x, A x\n\n  example : \u2203 x, B x :=  \n  show \u2203 x, B x, from exists.elim h2\n    (assume y (h3 : A y),\n    have h4 : A y \u2192 B y, from h1 y,\n    have h5 : B y, from h4 h3,\n    show \u2203 x, B x, from exists.intro y h5)\nend\n\nsection\n  variable  U : Type\n  variables A B C : U \u2192 Prop\n\n  example (h1 : \u2203 x, A x \u2227 B x) (h2 : \u2200 x, B x \u2192 C x) :\n  \u2203 x, A x \u2227 C x :=\n    exists.elim h1\n      (assume y (h3 : A y \u2227 B y),\n      have h4 : A y, from h3.left,\n      have h5 : B y, from h3.right,\n      have h6 : B y \u2192 C y, from h2 y,\n      have h7 : C y, from h6 h5,\n      have h8 : A y \u2227 C y, from and.intro h4 h7,\n      exists.intro y h8)\nend\n"}
{"text": "{-# OPTIONS --exact-split              #-}\n{-# OPTIONS --no-universe-polymorphism #-}\n{-# OPTIONS --without-K                #-}\n\nmodule Test where\n\ndata _\u2228_ (A B : Set) : Set where\n  inj\u2081 : A \u2192 A \u2228 B\n  inj\u2082 : B \u2192 A \u2228 B\n\npostulate\n  A B    : Set\n  \u2228-comm : A \u2228 B \u2192 B \u2228 A\n{-# ATP prove \u2228-comm #-}\n"}
{"text": "#\n# types.jl -\n#\n# Types used in Fourier optics.\n#\n\nabstract type AbstractLens end\n\nstruct Lens <: AbstractLens\n    f::Float64   # focal length of lens\n    D::Float64   # diameter of lens\n    x0::Float64  # abscissa of center of lens\n    y0::Float64  # ordinate of center of lens\nend\n\nstruct IndexBox\n    I::UnitRange{Int64}            # range of first index\n    J::UnitRange{Int64}            # range of second index\nend\n\nstruct LensOperator{Tl<:AbstractLens,\n                    Tf<:Base.DFT.Plan{Complex{Float64}}} <: LinearMapping\n    lens::Tl                       # lens parameters\n    lambda::Float64                # wavelength\n    Rinp::Region                   # pupil plane\n    Qinp::Matrix{Complex{Cdouble}} # complex transmission in pupil plane\n    Binp::IndexBox                 # part to consider the input region\n    Rout::Region                   # focal plane\n    Qout::Matrix{Complex{Cdouble}} # complex modulation in focal plane\n    FFT::Tf                        # FFT plan\n    ws::Matrix{Complex{Cdouble}}   # workspace for the FFT\nend\n"}
{"text": "module Phi.Window\n  ( Window, mkWindow\n  , length\n  , push\n  , phi\n  ) where\n\nimport           Data.Vector.Unboxed            (Vector)\nimport qualified Data.Vector.Unboxed            as V\nimport           Prelude                        hiding (length)\nimport           Statistics.Distribution        (complCumulative)\nimport           Statistics.Distribution.Normal (normalFromSample)\n\ndata Window =\n  Window\n  { sample :: !(Vector Double)\n  , size   :: !Int\n  }\n\nmkWindow :: Int -> Window\nmkWindow = Window V.empty\n\npush :: Double -> Window -> Window\npush d window = window {sample = sample'}\n  where sample' =\n          V.take (size window)\n                 (V.cons d (sample window))\n\nphi :: Window -> Double -> Double\nphi w = negate . logBase 10 . pLater w\n  where pLater :: Window -> Double -> Double\n        pLater = complCumulative . normalFromSample . sample\n\nlength :: Window -> Int\nlength = V.length . sample\n"}
{"text": "/-\nCopyright (c) 2020 Kyle Miller. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kyle Miller\n\n! This file was ported from Lean 3 source module data.zmod.parity\n! leanprover-community/mathlib commit 048240e809f04e2bde02482ab44bc230744cc6c9\n! Please do not edit these lines, except to modify the commit id\n! if you have ported upstream changes.\n-/\nimport Mathlib.Data.Nat.Parity\nimport Mathlib.Data.ZMod.Basic\n\n/-!\n# Relating parity to natural numbers mod 2\n\nThis module provides lemmas relating `ZMod 2` to `Even` and `Odd`.\n\n## Tags\n\nparity, zmod, even, odd\n-/\n\n\nnamespace ZMod\n\ntheorem eq_zero_iff_even {n : \u2115} : (n : ZMod 2) = 0 \u2194 Even n :=\n  (CharP.cast_eq_zero_iff (ZMod 2) 2 n).trans even_iff_two_dvd.symm\n#align zmod.eq_zero_iff_even ZMod.eq_zero_iff_even\n\ntheorem eq_one_iff_odd {n : \u2115} : (n : ZMod 2) = 1 \u2194 Odd n := by\n  rw [\u2190 @Nat.cast_one (ZMod 2), ZMod.eq_iff_modEq_nat, Nat.odd_iff, Nat.ModEq]\n  norm_num\n#align zmod.eq_one_iff_odd ZMod.eq_one_iff_odd\n\ntheorem ne_zero_iff_odd {n : \u2115} : (n : ZMod 2) \u2260 0 \u2194 Odd n := by\n  constructor <;>\n    \u00b7 contrapose\n      simp [eq_zero_iff_even]\n#align zmod.ne_zero_iff_odd ZMod.ne_zero_iff_odd\n\nend ZMod\n\n"}
{"text": "import Mathlib.Tactic.Basic\n/-!\n## Reasoning about Equality\n\nEquality (`=`) is also a basic logical constant. It is characterized by the following\nintroduction and elimination rules:\n\n```lean\nEq.refl : \u2200a, a = a\nEq.symm : ?a = ?b \u2192 ?b = ?a\nEq.trans : ?a = ?b \u2192 ?b = ?c \u2192 ?a = ?c\nEq.subst : ?a = ?b \u2192 ?p ?a \u2192 ?p ?b\n```\n\nThe first three lemmas are introduction rules specifying that `=` is an equivalence\nrelation. The fourth lemma is an elimination rule that allows us to replace equals\nfor equals in an arbitrary context, represented by the higher-order variable `?p`.\n\nAn example will show how this works. Below, we apply `Eq.subst` to rewrite\n`f a b` to `f a' b`, using the hypothesis `a = a'`:\n-/\n\ntheorem cong_fst_arg {\u03b1 : Type} (a a' b : \u03b1)\n(f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (ha : a = a') : f a b = f a' b := by\n  apply Eq.subst ha (motive := \u03bb x => f a b = f x b)\n  apply Eq.refl\n\n-- BUGBUG why does lean4 require this motive, lean3 did not\n-- See https://leanprover.zulipchat.com/#narrow/stream/270676-lean4/topic/debugging.20'apply'.20failed.20to.20unify\n\n/-!\nThe `Eq.subst` instance we use has `?a := a`, `?b := a'`, and `?p := (\u03bb x => f a b = f x b)`:\n```lean\na = a' \u2192 (\u03bbx => f a b = f x b) a \u2192 (\u03bbx => f a b = f x b) a'\n```\nIn \u03b2-reduced form:\n```lean\na = a' \u2192 f a b = f a b \u2192 f a b = f a' b\n```\nThe lemma's first assumption matches the hypothesis `ha : a = a'`, which is passed as an argument in the\nfirst apply invocation. The lemma's second assumption is a trivial equality that can be proved by\napply `Eq.refl` or `rfl`. The lemma's conclusion matches the goal\u2019s target. Notice how a higher-order\nvariable (e.g., `?p`) can represent an arbitrary context (e.g., `f . . . b`) around a term (e.g.,\n`a` or `a'`). This works because `apply` unifies up to computation, including \u03b2-conversion.\n\nThe `Eq.subst` lemma can be applied several times in sequence, as follows:\n\n(\u03bbx => f x n\u2081 ... n\u2096) a = f a` n\u2081 ... n\u2096\n\n-/\n\nlemma cong_two_args {\u03b1 : Type} (a a' b b' : \u03b1)\n  (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (ha : a = a') (hb : b = b') :\nf a b = f a' b' := by\n  apply Eq.subst ha (motive := \u03bb x => f a b = f x b')\n  apply Eq.subst hb (motive := \u03bb x => f a b = f a x)\n  apply Eq.refl\n  -- rw [ha, hb]\n\n\n-- BUGBUG lean3 did not require these explicit motives...\n\n/-!\nSince rewriting in this way is such a common operation, Lean provides a `rw` tactic\nto achieve the same result. The tactic will also notice if `rfl` is applicable:\n-/\nlemma cong_two_args\u2082 {\u03b1 : Type} (a a' b b' : \u03b1)\n  (f : \u03b1 \u2192 \u03b1 \u2192 \u03b1) (ha : a = a') (hb : b = b') :\nf a b = f a' b' := by\n  rw [ha]\n  rw [hb]\n\n/-!\nA note on parsing: Equality binds more tightly than the logical connectives.\nThus, `a = a' \u2227 b = b'` should be read as (a = a') \u2227 (b = b').\n\n-/"}
{"text": "Require Import\n  MathClasses.interfaces.abstract_algebra MathClasses.interfaces.universal_algebra MathClasses.theory.ua_homomorphisms\n  MathClasses.interfaces.canonical_names MathClasses.theory.categories MathClasses.theory.ua_mapped_operations.\n\nRequire MathClasses.categories.varieties.\n\nSection contents.\n\n  Context (et: EquationalTheory) `{InVariety et A} `{InVariety et B}\n    `{!HomoMorphism et A B ab} `{!HomoMorphism et B A ba}\n    (i: iso_arrows (varieties.arrow et ab) (varieties.arrow et ba)).\n\n  Arguments ab {a} _.\n  Arguments ba {a} _.\n\n  Let ab_proper a: Proper ((=) ==> (=)) (@ab a).\n  Proof. apply _. Qed.\n\n  Let ba_proper a: Proper ((=) ==> (=)) (@ba a).\n  Proof. apply _. Qed.\n\n  Let epA: \u2200 V n, Proper ((=) ==> eq ==> (=)) (@eval _ A _ V n) := _.\n  Let epB: \u2200 V n, Proper ((=) ==> eq ==> (=)) (@eval _ B _ V n) := _.\n    (* hints. shouldn't be necessary *)\n\n  Let ab_ba: \u2200 b (a: B b), ab (ba a) = a := proj1 i.\n  Let ba_ab: \u2200 b (a: A b), ba (ab a) = a := proj2 i.\n\n  Program Lemma transfer_eval n (t: Term et nat n) (v: Vars et B nat):\n    eval et (A:=A) (\u03bb _ i, ba (v _ i)) t = map_op _ (@ba) (@ab) (eval et v t).\n  Proof with auto; try reflexivity.\n   induction t; simpl in *; intros...\n    set (eval et (\u03bb (a: sorts et) (i : nat), ba (v a i)) t2).\n    eapply transitivity.\n     apply (@epA nat (ne_list.cons y t1) (\u03bb a i, ba (v a i))\n         (\u03bb a i, ba (v a i)) (reflexivity _) t2 t2 (reflexivity _)\n         : Proper ((=) ==> op_type_equiv (sorts et) A t1)%signature o).\n     now apply IHt2.\n    subst o.\n    rewrite (IHt1 (ba (eval et v t3)) (ba (eval et v t3)))...\n    apply (@map_op_proper (sorts et) B A _ _ _ _ _ _).\n    unfold compose in *.\n    rapply (epB _ _ v v (reflexivity _) t2 t2 (reflexivity _)).\n    apply ab_ba.\n   generalize\n     (@algebra_propers _ A _ _ _ o)\n     (@algebra_propers _ B _ _ _ o).\n   generalize (@preserves et A B _ _ _ _ (@ab) _ o).\n   fold (@algebra_op et A _ o) (@algebra_op et B _ o).\n   generalize (@algebra_op et A _ o), (@algebra_op et B _ o).\n   induction (et o); simpl; repeat intro.\n    rewrite <- ba_ab, H1...\n   apply IHo0.\n     eapply Preservation_proper''; eauto; intros; try apply _.\n     symmetry. apply H3, ab_proper, H4.\n    apply H2...\n   apply H3...\n  Qed. (* todo: make [reflexivity] work as a hint. further cleanup. *)\n\n  Program Lemma transfer_eval' n (t: Term et nat n) (v: Vars et B nat):\n    map_op _ (@ab) (@ba) (eval et (A:=A) (\u03bb _ i, ba (v _ i)) t) = eval et v t.\n  Proof with auto.\n   intros.\n   pose proof (@map_op_proper (sorts et) A B _ _ _ _ _ _).\n   rewrite transfer_eval.\n   apply (@map_iso _ A B _ _ (@ab) (@ba) ab_ba).\n   apply _.\n  Qed.\n\n  Program Lemma transfer_statement_and_vars (s: Statement et) (v: Vars et B nat):\n    eval_stmt et v s \u2194 eval_stmt et (A:=A) (\u03bb _ i, ba (v _ i)) s.\n  Proof with auto; reflexivity.\n   intros.\n   induction s; simpl; intuition.\n    rewrite transfer_eval. symmetry.\n    rewrite transfer_eval. symmetry.\n    apply (map_op_proper _ _ _)...\n   rewrite <- transfer_eval'. symmetry.\n   rewrite <- transfer_eval'. symmetry.\n   apply (map_op_proper _ _ _)...\n  Qed.\n\n  Theorem transfer_statement (s: Statement et): (\u2200 v, eval_stmt et (A:=A) v s) \u2192 (\u2200 v, eval_stmt et (A:=B) v s).\n  Proof with intuition auto.\n   intros ? v.\n   assert (v = (\u03bb _ i, ab (ba (v _ i)))) as P.\n    destruct i. intros a a0. symmetry...\n   rewrite P, transfer_statement_and_vars...\n  Qed.\n\nEnd contents.\n"}
{"text": "-- Andreas, 2012-05-04\n-- Occurs check when unifying indices in patterns\n{-# OPTIONS --allow-unsolved-metas #-}\n-- The option is supplied to force a real error to pass the regression test.\nmodule OccursCheck1 where\n\ndata Nat : Set where\n  zero : Nat\n  suc  : Nat -> Nat\n\ndata _==_ {A : Set}(x : A) : A -> Set where\n  refl : x == x\n\ntest :\n  let X : Nat\n      X = _\n  in  X == suc X\ntest = refl\n-- should fail with error message indicating no solution possible\n"}
{"text": "theory Sieve_of_Eratosthenes\n  imports Main \"HOL-Imperative_HOL.Array\"\nbegin\n(* Prvi deo Seminarskog *)\n(* Zadatak:\n  Neka je n prirodan broj. Ako su a i b prirodni brojevi veci\u000fi od 1 takvi\n  da je a*b= 2*n-1, dokazati da je broj ab-(a-b)-1 oblika k*2^(2m), gde\n  je k neparan prirodan, a m prirodan broj. \n*)\n\nlemma balkanska_matematicka_olimpijada_2001_prvi_zadatak_a_ge_b:\n  fixes n :: nat\n  fixes a b :: int\n  assumes \"a > 1 \\<and> b > 1 \\<and> a*b = 2^n-1\"\n  shows \"\\<exists> k m ::nat . (odd k) \\<and> (a*b-(a-b)-1 = k*2^m)\"\n  using assms\n  sorry\n\n(* Drugi Deo Seminarskog *)\ndefinition prime :: \"nat \u21d2 bool\"  where \n  \"prime p \u2261 1 < p \u2227 (\u2200m. m dvd p \u27f6  m = 1 \u2228 m = p)\"\n\n(* \n  Pomocna lema za dokaz sledece leme  \n*)\nlemma greater_hence_not_dvd:\n  fixes a b :: nat\n  assumes \"a > 0 \u2227 b > 0\"\n  assumes \"a > b\"\n  shows \"\u00ac a dvd b\"\n  using assms\n  using nat_dvd_not_less\n  by auto\n\n(*\n  Nije moguce racunski odrediti da li je broj prost na osnovu prethodne definicije.\n  Sledeca lema omogucava izracunavanje\n*)\ntheorem prime_code[code, simp]:\n  \"prime p \u27f7 1 < p \u2227 (\u2200m\u2208{1..p}. m dvd p \u27f6  m = 1 \u2228 m = p)\"\nproof\n  assume \"prime p\"\n  show \"1 < p \u2227 (\u2200m\u2208{1..p}. m dvd p \u27f6  m = 1 \u2228 m = p)\"\n    apply (rule conjI)\n  proof-\n    show \"1 < p\"\n      using \u2039prime p\u203a prime_def by simp\n    show \"\u2200m\u2208{1..p}. m dvd p \u27f6  m = 1 \u2228 m = p\"\n      using \u2039prime p\u203a prime_def by simp\n  qed\nnext\n  assume *: \"1 < p \u2227 (\u2200m\u2208{1..p}. m dvd p \u27f6  m = 1 \u2228 m = p)\"\n  show \"prime p\"\n    unfolding prime_def\n    apply (rule conjI)\n  proof-\n    show \"1 < p\"\n      using * by simp\n    show \"\u2200m. m dvd p \u27f6 m = 1 \u2228 m = p\"\n    proof\n      fix m\n      show \"m dvd p \u27f6 m = 1 \u2228 m = p\"\n      proof (cases \"m > p\")\n        case True\n        then show ?thesis \n        proof-\n          from \u2039m > p\u203a have **: \"m > 0\"\n            by auto\n          have \"p > 0\"\n            using \u20391 < p\u203a by simp\n          from this ** and \u2039m > p\u203a have \"\u00ac m dvd p\"\n            using greater_hence_not_dvd\n            by auto\n          thus ?thesis\n            by auto\n        qed\n      next\n        case False\n        hence ***: \"m \u2264 p\"\n          by simp\n        then show ?thesis \n        proof (cases \"m = 0\")\n          case True\n          then show ?thesis \n            by auto\n        next\n          case False\n          then show ?thesis\n            using \"*\" \"***\" by auto\n        qed\n      qed\n    qed\n  qed\nqed\n\nvalue \"prime 4\"\nvalue \"prime 5\"\n\ndefinition true_factor :: \"nat \u21d2 nat \u21d2 bool\" where\n  \"true_factor x y \u2261 x > 1 \u2227 x < y \u2227 x dvd y\"\n\n(* Svaki prost broj je veci ili jednak od 2 *)\nlemma prime_greater_than_2[simp]:\n  \"prime x \u27f6 x \u2265 2\"\n  by (simp add: prime_def)\n\n(* \n  Ako broj p nije prost, onda postoji z tako da vazi: 1 < z < p\n  (pravi delilac) i z deli p \n*)\nlemma not_prime_hence_has_true_factor:\n  assumes \"p > 1\"\n  assumes \"\u00ac prime p\"\n  shows \"\u2203z. true_factor z p\"\n  using assms\nproof-\n  from \u2039\u00ac prime p\u203a have \"p \u2264 1 \u2228 (\u2203m\u2208{1..p}. m dvd p \u2227 \u00ac (m = 1 \u2228 m = p))\"\n    using assms(1) assms(2) prime_code by blast\n  hence \"\u2203m\u2208{1..p}. m dvd p \u2227 \u00ac (m = 1 \u2228 m = p)\"\n    using \u2039p > 1\u203a\n    by auto\n  hence \"\u2203m\u2208{1..p}. m dvd p \u2227 m \u2260 1 \u2227 m \u2260 p\"\n    by auto\n  hence \"\u2203m\u2208{1..p}. m dvd p \u2227 m > 1 \u2227 m < p\"\n    by auto\n  hence \"\u2203m\u2208{1..p}. true_factor m p\"\n    unfolding true_factor_def\n    by auto\n  thus ?thesis\n    by auto\nqed\n\n(* \n  Ako broj nije prost, onda ima prost delilac.\n  Dokaz indukcijom, gde se pretpostavlja da vazi\n  za sve brojeve manje od n\n*)\nlemma not_prime_hence_has_prime_true_factor:\n  \"\u2200p. (p \u2265 2 \u2227 p \u2264 n \u2227 \u00ac prime p) \u27f6 (\u2203z. prime z \u2227 true_factor z p)\"\nproof (induction n)\n  case 0\n  then show ?case \n    by simp\nnext\n  case (Suc n)\n  show ?case \n    apply (rule allI)\n    apply (rule impI)\n  proof-\n    fix p \n    assume \"2 \u2264 p \u2227 p \u2264 Suc n \u2227 \u00ac prime p\"\n    hence \"2 \u2264 p\" \"p \u2264 Suc n\" \"\u00ac prime p\"\n      by auto\n    then show \"\u2203z. prime z \u2227 true_factor z p\"\n    proof-\n      have \"\u00ac prime p\"\n        using \u2039\u00ac prime p\u203a by blast\n      hence \"\u2203a. true_factor a p\"\n        using \u20392 \u2264 p\u203a not_prime_hence_has_true_factor by auto\n      then obtain a where \"true_factor a p\"\n        by auto\n      then show ?thesis\n      proof (cases \"prime a\")\n        case True\n        then show ?thesis \n          using \u2039true_factor a p\u203a by blast\n      next\n        case False\n        hence \"a \u2264 n\" \n          using \u2039p \u2264 Suc n\u203a \u2039true_factor a p\u203a true_factor_def by auto\n        hence \"\u2203b. prime b \u2227 true_factor b a\"\n          using False Suc.IH \u2039true_factor a p\u203a true_factor_def by auto\n        then obtain b where \"prime b \u2227 true_factor b a\"\n          by auto\n        hence \"true_factor b p\"\n          using \u2039true_factor a p\u203a less_trans true_factor_def by auto\n        then show ?thesis \n          using \u2039prime b \u2227 true_factor b a\u203a by blast\n      qed\n    qed\n  qed\nqed\n\n(* \n   funkcija koja \n   izbacuje sve mnozioce broja x \n   koji su veci od broja x \n   iz liste L\n*)\nprimrec remove_multipliers :: \"nat list \u21d2 nat \u21d2 nat list\" where\n  \"remove_multipliers [] n = []\"\n| \"remove_multipliers (x # xs) n = (if n dvd x \u2227 x > n\n                                    then remove_multipliers xs n\n                                    else x # (remove_multipliers xs n))\"\n\n(* \n  Lista prirodnih brojeva do n bez jedinice.\n  Lista je opadajuca, kako bi dokazi indukcijom bili jednostavniji\n*)\ndefinition nlist :: \"nat \u21d2 nat list\" where\n  \"nlist n = rev [2..<n+1]\"\n\nvalue \"remove_multipliers (nlist 100) 2\"\nvalue \"remove_multipliers (nlist 1) 2\"\nvalue \"remove_multipliers (nlist 2) 2\"\n\n(*\n  Sledi par jednostanih i neophodnih lema za\n  koje se kasnije koriste\n*)\nlemma nlist_suc[simp]:\n  assumes \"n > 0\"\n  shows \"nlist (Suc n) = (Suc n) # (nlist n)\"\n  unfolding nlist_def\n  using assms\n  by auto\n\nlemma nlist_suc_subset[simp]:\n \"set (nlist n) \u2286 set (nlist (Suc n))\"\n  unfolding nlist_def\n  by auto \n\nlemma remove_multipliers_remove_y_stays:\n  assumes \"y \u2208 set ys\"\n  shows \"y \u2208 set (remove_multipliers ys y)\"\n  using assms\n  by (induction ys) auto\n\nlemma remove_multipliers_subset[simp]:\n  \"set (remove_multipliers xs y) \u2286 set xs\"\n  by (induction xs) auto\n\nlemma remove_multipliers_nlist_subset[simp]:\n  \"set (remove_multipliers (nlist n) y) \u2286 set (nlist n)\"\n  by auto\n\nlemma remove_multipliers_greater_y:\n  assumes \"y > n\"\n  shows \"remove_multipliers (nlist n) y = nlist n\"\n  using assms\nproof (induction n)\n  case 0\n  then show ?case\n    unfolding nlist_def\n    by auto\nnext\n  case (Suc n)\n  then show ?case\n  proof (cases \"n = 0\")\n    case True\n    then show ?thesis\n      unfolding nlist_def\n      by auto\n  next\n    case False\n    then show ?thesis\n    proof-\n      have \"remove_multipliers (nlist (Suc n)) y\n        = remove_multipliers ((Suc n) # (nlist n)) y\"\n        using \u2039n \u2260 0\u203a\n        by auto\n      also have \"...  = (Suc n) # (remove_multipliers (nlist n) y)\"\n        using assms(1)\n        by (simp add: Suc.prems nat_dvd_not_less)\n      also have \"... = (Suc n) # (nlist n)\"\n        by (simp add: Suc.IH Suc.prems Suc_lessD)\n      also have \"... = nlist (Suc n)\"\n        using False \n        by auto\n      finally show ?thesis\n        by simp\n    qed\n  qed  \nqed\n\nlemma remove_multipliers_nlist_suc_subset[simp]:\n  \"set (remove_multipliers (nlist n) y) \n    \u2286 set (remove_multipliers (nlist (Suc n)) y)\"\nproof (cases \"n > 0\")\n  case True\n  hence *: \"remove_multipliers (nlist (Suc n)) y\n        = remove_multipliers ((Suc n) # (nlist n)) y\"\n    by simp \n\n  case True\n  then show ?thesis\n  proof (cases \"(Suc n) \u2264 y\")\n    case True\n    hence **: \u2039\u00ac(y dvd (Suc n) \u2227 (Suc n) > y)\u203a\n      by auto\n    case True\n    then show ?thesis\n    proof-\n      from * have \"remove_multipliers (nlist (Suc n)) y \n            = remove_multipliers ((Suc n) # (nlist n)) y\"\n        by simp\n      also have \"... = (Suc n) # remove_multipliers (nlist n) y\"\n        using \u2039\u00ac(y dvd (Suc n) \u2227 (Suc n) > y)\u203a\n        by auto\n      also have \"set ((Suc n) # remove_multipliers (nlist n) y)\n            = {Suc n} \u222a set (remove_multipliers (nlist n) y)\"\n        by auto\n      finally have \"set (remove_multipliers (nlist n) y)\n                     \u2286 set (remove_multipliers (nlist (Suc n)) y)\"\n        by auto\n      thus ?thesis\n        by simp\n    qed\n  next\n    case False\n    then show ?thesis\n    proof (cases \"y dvd (Suc n)\")\n      case True\n      hence ***: \u2039y dvd (Suc n) \u2227 (Suc n) > y\u203a\n        using \u2039\u00ac (Suc n \u2264 y)\u203a\n        by auto\n        case True\n      then show ?thesis\n      proof-\n        from * have \"remove_multipliers (nlist (Suc n)) y \n              = remove_multipliers ((Suc n) # (nlist n)) y\"\n          by simp\n        also have \"... = remove_multipliers (nlist n) y\"\n          using \u2039y dvd (Suc n) \u2227 (Suc n) > y\u203a\n          by simp\n        finally have \"set (remove_multipliers (nlist n) y)\n                     \u2286 set (remove_multipliers (nlist (Suc n)) y)\"\n        by simp\n      thus  ?thesis\n          by simp\n      qed\n    next\n      case False\n      hence **: \u2039\u00ac(y dvd (Suc n) \u2227 (Suc n) > y)\u203a\n        by auto\n      case False\n      then show ?thesis\n      proof-\n      from * have \"remove_multipliers (nlist (Suc n)) y \n            = remove_multipliers ((Suc n) # (nlist n)) y\"\n        by simp\n      also have \"... = (Suc n) # remove_multipliers (nlist n) y\"\n        using \u2039\u00ac(y dvd (Suc n) \u2227 (Suc n) > y)\u203a\n        by auto\n      also have \"set ((Suc n) # remove_multipliers (nlist n) y)\n            = {Suc n} \u222a set (remove_multipliers (nlist n) y)\"\n        by auto\n      finally have \"set (remove_multipliers (nlist n) y)\n                     \u2286 set (remove_multipliers (nlist (Suc n)) y)\"\n        by auto\n      thus ?thesis\n        by simp\n      qed\n    qed\n  qed\nnext\n  case False \n  then show ?thesis\n    unfolding nlist_def\n    by auto\nqed\n\nlemma remove_multipliers_suc_subset[simp]:\n  \"set (remove_multipliers (nlist (Suc n)) y)\n   \u2286 {Suc n} \u222a (set (remove_multipliers (nlist n) y))\"\n  unfolding nlist_def\n  by auto\n\n(*\n  Izbacivanje svih mnozioca broja y je ekvivaletno izbacivanju\n  svakog broja x > y za koji vazi da y deli x\n*)\ntheorem remove_multipliers_theorem1:\n  fixes x y n :: nat\n  assumes \"y \u2265 2\"\n  assumes \"x \u2264 n \u2227 x > y\"\n  shows \"x \u2208 set (remove_multipliers (nlist n) y) \u27f7 \u00ac (y dvd x)\"\n  using assms\nproof (induction n)\n  case 0\n  then show ?case\n    by auto\nnext\n  case (Suc n) \n  then show ?case \n  proof (cases \"x = Suc n\")\n    case True\n    then show ?thesis\n    proof (cases \"y dvd Suc n\")\n      case True\n      then show ?thesis \n      proof-\n        have \"remove_multipliers (nlist (Suc n)) y\n          = remove_multipliers ((Suc n) # (nlist n)) y\"\n          by (metis One_nat_def True assms(1) dvd_imp_le neq0_conv nlist_suc not_less_eq_eq one_add_one plus_1_eq_Suc zero_less_Suc)\n        hence \"... = remove_multipliers (nlist n) y\"\n          using Suc.prems(2) True by auto\n        have \"(Suc n) \u2209 set (remove_multipliers (nlist n) y)\"\n          by (metis Groups.add_ac(2) Suc_n_not_le_n atLeastAtMost_iff atLeastLessThanSuc_atLeastAtMost in_mono nlist_def one_add_one plus_1_eq_Suc remove_multipliers_subset set_rev set_upt)\n        hence \"x \u2209 set (remove_multipliers (nlist n) y)\"\n          using \u2039x = Suc n\u203a\n          by blast\n        hence \"x \u2209 set (remove_multipliers (nlist (Suc n)) y)\"\n          using \u2039remove_multipliers (Suc n # nlist n) y = remove_multipliers (nlist n) y\u203a \u2039remove_multipliers (nlist (Suc n)) y = remove_multipliers (Suc n # nlist n) y\u203a \n          by auto\n        show ?thesis\n          using Suc.IH Suc.prems(2) True \u2039x \u2209 set (remove_multipliers (nlist (Suc n)) y)\u203a \u2039x \u2209 set (remove_multipliers (nlist n) y)\u203a assms(1) le_Suc_eq by blast\n    qed\n    next\n      case False\n      then show ?thesis \n      proof-\n        have \"remove_multipliers (nlist (Suc n)) y\n          = remove_multipliers ((Suc n) # (nlist n)) y\"\n          using Suc.prems(2) assms(1) by auto\n        hence \"... = (Suc n) # remove_multipliers (nlist n) y\"\n          by (simp add: False)\n        have \"(Suc n) \u2208 set ((Suc n) # remove_multipliers (nlist n) y)\"\n          by simp\n        hence \"x \u2208 set ((Suc n) # remove_multipliers (nlist n) y)\"\n          using True \n          by blast\n        hence \"x \u2208 set (remove_multipliers (nlist (Suc n)) y)\"\n          using \u2039remove_multipliers (Suc n # nlist n) y = Suc n # remove_multipliers (nlist n) y\u203a \u2039remove_multipliers (nlist (Suc n)) y = remove_multipliers (Suc n # nlist n) y\u203a \n          by auto\n        thus ?thesis\n          using False True by blast\n      qed\n    qed\n  next\n    case False\n    hence *: \"x \u2208 set (remove_multipliers (nlist n) y) \u27f7 \u00ac (y dvd x)\"\n      using Suc.IH Suc.prems(2) assms(1) le_SucE by blast\n    have \"set (remove_multipliers (nlist (Suc n)) y)\n        \u2286 {Suc n} \u222a (set (remove_multipliers (nlist n) y))\"\n      using remove_multipliers_suc_subset by simp\n    hence \"x \u2208 set (remove_multipliers (nlist (Suc n)) y)\n        \u27f6 x = (Suc n) \u2228 x \u2208 set (remove_multipliers (nlist n) y)\"\n      by auto\n    from this and \u2039x \u2260 Suc n\u203a have **: \n       \"x \u2208 set (remove_multipliers (nlist (Suc n)) y)\n        \u27f6 x \u2208 set (remove_multipliers (nlist n) y)\"\n      by auto\n    case False\n    then show ?thesis\n      using \u2039x \u2260 Suc n\u203a\n      using * and **\n      using remove_multipliers_nlist_suc_subset \n      by blast\n  qed\nqed\n\n(*\n  Direktna posledica prethodne teoreme:\n  f-ja \"remove_multipliers\" ne brise proste brojeve\n*)\ntheorem remove_multipliers_theorem1_cons:\n  fixes x y n :: nat\n  assumes \"prime x\"\n  assumes \"y \u2265 2\"\n  assumes \"x \u2264 n \u2227 x > y\"\n  shows \"x \u2208 set (remove_multipliers (nlist n) y)\"\n  using assms\n  using prime_def remove_multipliers_theorem1 by auto\n\n(*\n  Jaca verzija prethodne teoreme\n*)\ntheorem remove_multipliers_theorem2:\n  assumes \"prime x\"\n  assumes \"x \u2208 set xs\"\n  assumes \"x \u2260 y\"\n  assumes \"y \u2265 2\"\n  shows \"x \u2208 set (remove_multipliers xs y)\"\n  using assms\nproof (induction xs)\n  case Nil\n  then show ?case \n    by simp\nnext\n  case (Cons a xs)\n  then show ?case\n  proof (cases \"a > y\")\n    case True\n    then show ?thesis\n    proof (cases \"y dvd a\")\n      case True\n      then show ?thesis\n      proof-\n        from \u2039a > y\u203a and \u2039y dvd a\u203a have \"y dvd a \u2227 a > y\"\n          by simp\n        hence \"remove_multipliers (a # xs) y = remove_multipliers xs y\"\n          by auto\n        also have \u2039x \u2208 set (remove_multipliers xs y)\u203a \n          by (metis Cons.IH Cons.prems(2) True \u2039y < a\u203a \u2039y dvd a \u2227 y < a\u203a assms(1) assms(3) assms(4) less_imp_triv not_less remove_multipliers_theorem1 remove_multipliers_theorem1_cons set_ConsD)\n        finally show ?thesis\n          by simp\n      qed\n    next\n      case False\n      then show ?thesis \n        using Cons.IH Cons.prems(2) assms(1) assms(3) assms(4) by auto\n    qed\n  next\n    case False\n    then show ?thesis \n      using Cons.IH Cons.prems(2) assms(1) assms(3) assms(4) by auto\n  qed\nqed\n\n(*\n  Ako u listi xs postoji broj y koji je pravi delilac broja z,\n  onda broj nakon uklanjanja svih mnozioca broja y, \n  u listi xs se ne nalazi broj z\n*)\nlemma remove_multipliers_true_factor:\n  assumes \"true_factor z y\"\n  shows \"y \u2209 set (remove_multipliers xs z)\"\n  using assms\nproof (induction xs)\n  case Nil\n  then show ?case\n    by auto\nnext\n  case (Cons a xs)\n  then show ?case\n  proof (cases \"a = y\")\n    case True\n    then show ?thesis\n      using Cons.IH assms true_factor_def by auto\n  next\n    case False\n    then show ?thesis \n      using Cons.IH assms by auto\n  qed\nqed\n\n(* Erastostenovo Sito *)\n(*\n  erast' je pomocna f-ja preko\n  koje se definise f-ja za Erastostenovo sito\n*)\nprimrec erast' :: \"nat list \u21d2 nat list \u21d2 nat list\" where\n  \"erast' [] ys = ys\"\n| \"erast' (x # xs) ys = (let es = erast' xs ys\n                         in (if x \u2208 set es\n                             then remove_multipliers es x\n                             else es))\"\n(*\n  Posto je (nlist n) opadajuca f-ja,\n  rezultat se rotira kako bi bio rastuci\n*)\ndefinition erast :: \"nat \u21d2 nat list\" where\n  \"erast n = rev (erast' (nlist n) (nlist n))\"\n\nvalue \"erast 100\"\n\nlemma erast_0:\n  \"erast 0 = []\"\n  unfolding erast_def nlist_def\n  by auto\n\n(*\n  Vazi sledece:\n  set (erast' [a1, a2, ..., an] bs)\n  \u2286 set (erast' [a2, ..., an] bs)\n  ...\n  \u2286 set (erast' [an] bs)\n  \u2286 set (erast' [] bs)\n  = bs\n*)\nlemma erast'_next_sub:\n  \"set (erast' (x # xs) ys) \u2286 set (erast' xs ys)\"\nproof (cases \"x \u2208 set (erast' xs ys)\")\n  case True\n  then show ?thesis\n  proof-\n    have \"erast' (x # xs) ys = remove_multipliers (erast' xs ys) x\"\n      using True\n      by auto\n    hence \"set (erast' (x # xs) ys) \u2286 set (remove_multipliers (erast' xs ys) x)\"\n      by auto\n    thus \"set (erast' (x # xs) ys) \u2286 set (erast' xs ys)\"\n      using remove_multipliers_subset\n      by blast\n  qed\nnext\n  case False\n  then show ?thesis\n    by auto\nqed\n\n(*\n  Direktna posledica prethodne leme\n*)\nlemma erast'_nlist_sub:\n  \"set (erast' xs ys) \u2286 set ys\"\nproof (induction xs)\n  case Nil\n  then show ?case\n    by auto\nnext\n  case (Cons a xs)\n  then show ?case\n    by (meson dual_order.trans erast'_next_sub)\nqed\n\n(*\n  Specijalan slucaj prethodne leme koji se cesce koristi\n*)\nlemma erast_nlist_sub:\n  \"set (erast n) \u2286 set (nlist n)\"\n  unfolding erast_def\n  by (simp add: erast'_nlist_sub)\n\n(*\n  F-ja erast (tj. erast') ne brise proste brojeve iz list\n  tj. oni uvek opstaju\n\n  Ovo predstavlja jednu od kljucnih lema u dokazu korektnosti\n  Erastostenovog sita\n*)\nlemma erast'_prime_stays:\n  assumes \"prime y\"\n  assumes \"y \u2208 set ys\"\n  shows \"y \u2208 set (erast' (nlist n) ys)\"\nproof (induction n)\n  case 0\n  then show ?case\n    unfolding nlist_def\n    by (simp add: assms(2))\nnext\n  case (Suc n)\n  then show ?case\n  proof (cases \"n = 0\")\n    case True\n    then show ?thesis\n      unfolding nlist_def\n      by (simp add: assms(2))\n  next\n    case False\n    hence *: \"erast' (nlist (Suc n)) ys = erast' ((Suc n) # (nlist n)) ys\"\n      by simp\n    case False\n    then show ?thesis \n    proof (cases \"(Suc n) \u2208 set (erast' (nlist n) ys)\")\n      case True\n      from this and * have **: \"erast' (nlist (Suc n)) ys = \n        remove_multipliers (erast' (nlist n) ys) (Suc n)\"\n        by simp\n      case True\n      then show ?thesis\n      proof (cases \"y = Suc n\")\n        case True\n        then show ?thesis\n        proof-\n          from \u2039y = Suc n\u203a and \u2039y \u2208 set (erast' (nlist n) ys)\u203a have \n            \"y \u2208 set (remove_multipliers (erast' (nlist n) ys) (Suc n))\"\n            using remove_multipliers_remove_y_stays \n            by simp\n          from this and ** show ?thesis\n            by simp\n        qed\n      next\n        case False\n        then show ?thesis\n          using \"**\" Suc.IH assms(1) nlist_def remove_multipliers_theorem2 by fastforce\n      qed\n    next\n      case False\n      hence \"erast' (nlist (Suc n)) ys = erast' (nlist n) ys\"\n        by (simp add: \"*\")\n      case False\n      then show ?thesis \n        by (simp add: Suc.IH \u2039erast' (nlist (Suc n)) ys = erast' (nlist n) ys\u203a)\n    qed\n  qed\nqed\n\n(*\n  Posledica prethodne leme\n  Predstavlja jedan kljucni smer u dokazu korektnosti Erastostenovog sita\n*)\ntheorem erast_prime_stays:\n  assumes \"prime y\"\n  assumes \"y \u2264 n\"\n  shows \"y \u2208 set (erast n)\" \n  using assms\nproof (induction n)\ncase 0\n  then show ?case \n    using prime_def by blast\nnext\n  case (Suc n)\n  then show ?case\n  proof-\n    have \"y \u2208 set (nlist (Suc n))\"\n      by (metis (full_types) One_nat_def Suc.IH Suc.prems(2) assms(1) erast_nlist_sub le_SucE list.set_intros(1) nat_less_le nlist_suc nlist_suc_subset prime_def subset_eq zero_less_Suc)\n    hence \"y \u2208 set (erast' (nlist (Suc n)) (nlist (Suc n)))\"\n      using assms(1) erast'_prime_stays by blast\n    thus \"y \u2208 set (erast (Suc n))\"\n      by (simp add: erast_def)\n  qed\nqed\n\nlemma erast'_less_than_n:\n  assumes \"y \u2208 set (erast' (nlist n) (nlist n))\"\n  shows \"y \u2264 n\"\n  using assms erast'_nlist_sub nlist_def by fastforce\n\n(*\n  Svi brojevi u Erastostenovom situ su\n  izmedju 2 i n, gde je n zadati parametar f-je\n*)\nlemma erast_y_less_than_n:\n  assumes \"y \u2208 set (erast' (nlist n) (nlist n))\"\n  shows \"y > 1 \u2227 y \u2264 n\"\nproof-\n  from assms have \"y \u2208 set (nlist n)\"\n    using erast'_nlist_sub by blast\n  thus \"y > 1 \u2227 y \u2264 n\"\n    using nlist_def\n    by auto\nqed\n\n(*\n  Direktna posledica lema: erast'_next_sub\n*)\nlemma erast'_less_removals_sub:\n  shows \"set (erast' (cs @ as) ys) \u2286 set (erast' as ys)\"\nproof (induction cs)\n  case Nil\n  then show ?case\n    by simp\nnext\n  case (Cons c cs)\n  then show ?case \n  proof (cases \"c \u2208 set(erast' (cs @ as) ys)\")\n    case True\n    then show ?thesis\n      by (metis Cons.IH append_Cons dual_order.trans erast'_next_sub)\n  next\n    case False\n    then show ?thesis \n      using Cons.IH by auto\n  qed\n\nqed\n\n(*\n  Ako broj ima prost delilac, onda on ce on\n  biti izbrisan u Erastostenovom situ \n*)\nlemma erast_prime_true_factor_deletes:\n  assumes \"prime z\"\n  assumes \"true_factor z y\"\n  assumes \"y \u2264 n\"\n  shows \"y \u2209 set (erast n)\"\n  using assms\nproof-\n  have \"z \u2208 set (nlist n)\"\n    by (meson assms(1) assms(2) assms(3) erast_nlist_sub erast_prime_stays less_imp_le_nat less_le_trans subset_iff true_factor_def)\n  hence \"z \u2208 set (erast n)\"\n    using assms(1) assms(2) assms(3) erast_prime_stays true_factor_def by auto\n  from \u2039z \u2208 set (nlist n)\u203a have \"\u2203as bs. (nlist n) = as @ [z] @ bs\"\n    by (simp add: split_list)\n  then obtain as bs where \"(nlist n) = as @ [z] @ bs\"\n    by auto\n  hence \"set ([z] @ bs) \u2286 set (as @ [z] @ bs)\"\n    by (simp add: subset_iff)\n  have \"set (erast' (nlist n) (nlist n)) = set(erast' (as @ [z] @ bs) (nlist n))\"\n    using \u2039nlist n = as @ [z] @ bs\u203a by auto\n  hence \"... \u2286 set(erast' ([z] @ bs) (nlist n))\"\n    using erast'_less_removals_sub by blast\n  have \"z \u2208 set(erast' bs (nlist n))\"\n    by (metis Cons_eq_appendI \u2039nlist n = as @ [z] @ bs\u203a \u2039set (erast' (as @ [z] @ bs) (nlist n)) \u2286 set (erast' ([z] @ bs) (nlist n))\u203a \u2039z \u2208 set (nlist n)\u203a append_self_conv2 assms(1) erast'_next_sub erast'_prime_stays in_mono)\n  hence \"erast' ([z] @ bs) (nlist n)\n     = remove_multipliers (erast' bs (nlist n)) z\"\n    by auto\n  hence \"y \u2209 set (remove_multipliers (erast' bs (nlist n)) z)\"\n    using assms(2) remove_multipliers_true_factor by blast\n  hence \"y \u2209 set (erast' ([z] @ bs) (nlist n))\"\n    using \u2039erast' ([z] @ bs) (nlist n) = remove_multipliers (erast' bs (nlist n)) z\u203a by auto\n  thus \"y \u2209 set (erast n)\"\n    using \u2039nlist n = as @ [z] @ bs\u203a \u2039set (erast' (as @ [z] @ bs) (nlist n)) \u2286 set (erast' ([z] @ bs) (nlist n))\u203a erast_def by auto\nqed\n\n(*\n  Opstiji slucaj prethodne leme (z ne mora da bude prost broj)\n*)\nlemma erast_true_factor_deletes:\n  assumes \"true_factor z y\"\n  assumes \"y \u2264 n\"\n  shows \"y \u2209 set (erast n)\"\n  using assms\nproof (cases \"prime z\")\n  case True\n  then show ?thesis \n    using assms(1) assms(2) erast_prime_true_factor_deletes by blast\nnext\n  case False\n  hence \"\u2203s. true_factor s z \u2227 prime s\"\n    by (metis (full_types) One_nat_def Suc_1 Suc_leI assms(1) le_refl not_prime_hence_has_prime_true_factor true_factor_def)\n then obtain s where \"true_factor s z \u2227 prime s\"\n    by auto\n  hence \"true_factor s y\"\n    using assms(1) less_trans true_factor_def by auto\n  then show ?thesis\n    using \u2039true_factor s z \u2227 prime s\u203a assms(2) erast_prime_true_factor_deletes by blast\nqed\n\n(*\n  Prosti brojevi ostaju u Erastostenovom situ\n*)\nlemma erast'_keeps_prime:\n  assumes \"y \u2264 n\"\n  assumes \"y \u2208 set (erast' (nlist n) (nlist n))\"\n  shows \"prime y\"\n  apply (rule ccontr)\nproof-\n  assume \"\u00ac prime y\"\n  then show False\n  proof-\n    from \u2039\u00ac prime y\u203a have \"\u2203z. true_factor z y\"\n      unfolding true_factor_def\n      by (metis assms(2) atLeastAtMost_iff erast_y_less_than_n le_neq_implies_less prime_code)\n    then obtain z where \"true_factor z y\"\n      by auto\n    hence \"z \u2208 set (nlist n)\"\n      unfolding true_factor_def\n      using assms(1) nlist_def by auto\n    hence \"y \u2209 set (erast' (nlist n) (nlist n))\"\n      using true_factor_def\n      using \u2039true_factor z y\u203a assms(1) erast_def erast_true_factor_deletes by auto\n    from this and assms show \"False\"\n      by auto\n  qed\nqed\n\n(*\n  Ekvivaletno prethodnoj lemi (posledica)\n  Predstavlja drugi kljucni smer u dokazivanju korektnosti\n  Erastostenovog sita\n*)\ntheorem erast_keeps_prime:\n  assumes \"y \u2208 set (erast n)\"\n  shows \"prime y\"\n  using assms erast'_keeps_prime erast_def erast_y_less_than_n by auto\n\n(*\n  Broj x se nalazi u Erastostenovom situ\n    akko\n  broj x je prost broj\n*)\ntheorem erast_prime:\n  fixes x n :: nat\n  assumes \"x \u2264 n\"\n  shows \"x \u2208 set (erast n) \u27f7 prime x\"\n  using assms\n  using erast_keeps_prime erast_prime_stays by blast\n\nexport_code erast in Haskell\n\nend\n"}
{"text": "lemmas continuous_on_mult [continuous_intros] = bounded_bilinear.continuous_on [OF bounded_bilinear_mult]"}
{"text": "lemmas swap_apply2 = swap_apply(2)"}
{"text": "lemma and_symm (P Q : Prop) : P \u2227 Q \u2192 Q \u2227 P :=\nbegin\n    intro h,\n    cases h with p q,\n    split,\n    exact q,\n    exact p,\nend"}
{"text": "-- 2014-09-19\n-- Reported by Mateusz Kowalczyk.\n\ngood : Set\u2081\ngood = let -- F : _  -- worked if you added the type signature\n           F X = X\n       in F Set\n\n-- Now works without the type signature."}
{"text": "/-\nCopyright (c) 2019 Kenny Lau. All rights reserved.\nReleased under Apache 2.0 license as described in the file LICENSE.\nAuthors: Kenny Lau\n-/\nimport ring_theory.adjoin\nimport ring_theory.algebra_tower\nimport ring_theory.polynomial.scale_roots\n\n/-!\n# Integral closure of a subring.\n\nIf A is an R-algebra then `a : A` is integral over R if it is a root of a monic polynomial\nwith coefficients in R. Enough theory is developed to prove that integral elements\nform a sub-R-algebra of A.\n\n## Main definitions\n\nLet `R` be a `comm_ring` and let `A` be an R-algebra.\n\n* `ring_hom.is_integral_elem (f : R \u2192+* A) (x : A)` : `x` is integral with respect to the map `f`,\n\n* `is_integral (x : A)`  : `x` is integral over `R`, i.e., is a root of a monic polynomial with\n                           coefficients in `R`.\n* `integral_closure R A` : the integral closure of `R` in `A`, regarded as a sub-`R`-algebra of `A`.\n-/\n\nopen_locale classical\nopen_locale big_operators\nopen polynomial submodule\n\nsection ring\nvariables {R S A : Type*}\nvariables [comm_ring R] [ring A] [ring S] (f : R \u2192+* S)\n\n/-- An element `x` of `A` is said to be integral over `R` with respect to `f`\nif it is a root of a monic polynomial `p : polynomial R` evaluated under `f` -/\ndef ring_hom.is_integral_elem (f : R \u2192+* A) (x : A) :=\n\u2203 p : polynomial R, monic p \u2227 eval\u2082 f x p = 0\n\n/-- A ring homomorphism `f : R \u2192+* A` is said to be integral\nif every element `A` is integral with respect to the map `f` -/\ndef ring_hom.is_integral (f : R \u2192+* A) :=\n\u2200 x : A, f.is_integral_elem x\n\nvariables [algebra R A] (R)\n\n/-- An element `x` of an algebra `A` over a commutative ring `R` is said to be *integral*,\nif it is a root of some monic polynomial `p : polynomial R`.\nEquivalently, the element is integral over `R` with respect to the induced `algebra_map` -/\ndef is_integral (x : A) : Prop :=\n(algebra_map R A).is_integral_elem x\n\nvariable (A)\n\n/-- An algebra is integral if every element of the extension is integral over the base ring -/\ndef algebra.is_integral : Prop :=\n(algebra_map R A).is_integral\n\nvariables {R A}\n\nlemma ring_hom.is_integral_map {x : R} : f.is_integral_elem (f x) :=\n\u27e8X - C x, monic_X_sub_C _, by simp\u27e9\n\ntheorem is_integral_algebra_map {x : R} : is_integral R (algebra_map R A x) :=\n(algebra_map R A).is_integral_map\n\ntheorem is_integral_of_noetherian (H : is_noetherian R A) (x : A) :\n  is_integral R x :=\nbegin\n  let leval : @linear_map R (polynomial R) A _ _ _ _ _ := (aeval x).to_linear_map,\n  let D : \u2115 \u2192 submodule R A := \u03bb n, (degree_le R n).map leval,\n  let M := well_founded.min (is_noetherian_iff_well_founded.1 H)\n    (set.range D) \u27e8_, \u27e80, rfl\u27e9\u27e9,\n  have HM : M \u2208 set.range D := well_founded.min_mem _ _ _,\n  cases HM with N HN,\n  have HM : \u00acM < D (N+1) := well_founded.not_lt_min\n    (is_noetherian_iff_well_founded.1 H) (set.range D) _ \u27e8N+1, rfl\u27e9,\n  rw \u2190 HN at HM,\n  have HN2 : D (N+1) \u2264 D N := classical.by_contradiction (\u03bb H, HM\n    (lt_of_le_not_le (map_mono (degree_le_mono\n      (with_bot.coe_le_coe.2 (nat.le_succ N)))) H)),\n  have HN3 : leval (X^(N+1)) \u2208 D N,\n  { exact HN2 (mem_map_of_mem (mem_degree_le.2 (degree_X_pow_le _))) },\n  rcases HN3 with \u27e8p, hdp, hpe\u27e9,\n  refine \u27e8X^(N+1) - p, monic_X_pow_sub (mem_degree_le.1 hdp), _\u27e9,\n  show leval (X ^ (N + 1) - p) = 0,\n  rw [linear_map.map_sub, hpe, sub_self]\nend\n\ntheorem is_integral_of_submodule_noetherian (S : subalgebra R A)\n  (H : is_noetherian R (S : submodule R A)) (x : A) (hx : x \u2208 S) :\n  is_integral R x :=\nbegin\n  letI : algebra R S := S.algebra,\n  letI : ring S := S.ring R A,\n  suffices : is_integral R (\u27e8x, hx\u27e9 : S),\n  { rcases this with \u27e8p, hpm, hpx\u27e9,\n    replace hpx := congr_arg subtype.val hpx,\n    refine \u27e8p, hpm, eq.trans _ hpx\u27e9,\n    simp only [aeval_def, eval\u2082, finsupp.sum],\n    rw \u2190 p.support.sum_hom subtype.val,\n    { refine finset.sum_congr rfl (\u03bb n hn, _),\n      change _ = _ * _,\n      rw is_monoid_hom.map_pow coe, refl,\n      split; intros; refl },\n    refine { map_add := _, map_zero := _ }; intros; refl },\n  refine is_integral_of_noetherian H \u27e8x, hx\u27e9\nend\n\nend ring\n\nsection\nvariables {R A B S : Type*}\nvariables [comm_ring R] [comm_ring A] [comm_ring B] [comm_ring S]\nvariables [algebra R A] [algebra R B] (f : R \u2192+* S)\n\ntheorem is_integral_alg_hom (f : A \u2192\u2090[R] B) {x : A} (hx : is_integral R x) : is_integral R (f x) :=\nlet \u27e8p, hp, hpx\u27e9 := hx in \u27e8p, hp, by rw [\u2190 aeval_def, aeval_alg_hom_apply, aeval_def, hpx, f.map_zero]\u27e9\n\ntheorem is_integral_of_is_scalar_tower [algebra A B] [is_scalar_tower R A B]\n  (x : B) (hx : is_integral R x) : is_integral A x :=\nlet \u27e8p, hp, hpx\u27e9 := hx in\n\u27e8p.map $ algebra_map R A, monic_map _ hp, by rw [\u2190 aeval_def, \u2190 is_scalar_tower.aeval_apply, aeval_def, hpx]\u27e9\n\nsection\nlocal attribute [instance] subset.comm_ring algebra.of_is_subring\n\ntheorem is_integral_of_subring {x : A} (T : set R) [is_subring T]\n  (hx : is_integral T x) : is_integral R x :=\nis_integral_of_is_scalar_tower x hx\n\nlemma is_integral_algebra_map_iff [algebra A B] [is_scalar_tower R A B]\n  {x : A} (hAB : function.injective (algebra_map A B)) :\n  is_integral R (algebra_map A B x) \u2194 is_integral R x :=\nbegin\n  split; rintros \u27e8f, hf, hx\u27e9; use [f, hf],\n  { exact is_scalar_tower.aeval_eq_zero_of_aeval_algebra_map_eq_zero R A B hAB hx },\n  { rw [is_scalar_tower.algebra_map_eq R A B, \u2190 hom_eval\u2082, hx, ring_hom.map_zero] }\nend\n\ntheorem is_integral_iff_is_integral_closure_finite {r : A} :\n  is_integral R r \u2194 \u2203 s : set R, s.finite \u2227 is_integral (ring.closure s) r :=\nbegin\n  split; intro hr,\n  { rcases hr with \u27e8p, hmp, hpr\u27e9,\n    refine \u27e8_, set.finite_mem_finset _, p.restriction, subtype.eq hmp, _\u27e9,\n    erw [\u2190 aeval_def, is_scalar_tower.aeval_apply _ R, map_restriction, aeval_def, hpr] },\n  rcases hr with \u27e8s, hs, hsr\u27e9,\n  exact is_integral_of_subring _ hsr\nend\n\nend\n\ntheorem fg_adjoin_singleton_of_integral (x : A) (hx : is_integral R x) :\n  (algebra.adjoin R ({x} : set A) : submodule R A).fg :=\nbegin\n  rcases hx with \u27e8f, hfm, hfx\u27e9,\n  existsi finset.image ((^) x) (finset.range (nat_degree f + 1)),\n  apply le_antisymm,\n  { rw span_le, intros s hs, rw finset.mem_coe at hs,\n    rcases finset.mem_image.1 hs with \u27e8k, hk, rfl\u27e9, clear hk,\n    exact is_submonoid.pow_mem (algebra.subset_adjoin (set.mem_singleton _)) },\n  intros r hr, change r \u2208 algebra.adjoin R ({x} : set A) at hr,\n  rw algebra.adjoin_singleton_eq_range at hr,\n  rcases (aeval x).mem_range.mp hr with \u27e8p, rfl\u27e9,\n  rw \u2190 mod_by_monic_add_div p hfm,\n  rw \u2190 aeval_def at hfx,\n  rw [alg_hom.map_add, alg_hom.map_mul, hfx, zero_mul, add_zero],\n  have : degree (p %\u2098 f) \u2264 degree f := degree_mod_by_monic_le p hfm,\n  generalize_hyp : p %\u2098 f = q at this \u22a2,\n  rw [\u2190 sum_C_mul_X_eq q, aeval_def, eval\u2082_sum, finsupp.sum],\n  refine sum_mem _ (\u03bb k hkq, _),\n  rw [eval\u2082_mul, eval\u2082_C, eval\u2082_pow, eval\u2082_X, \u2190 algebra.smul_def],\n  refine smul_mem _ _ (subset_span _),\n  rw finset.mem_coe, refine finset.mem_image.2 \u27e8_, _, rfl\u27e9,\n  rw [finset.mem_range, nat.lt_succ_iff], refine le_of_not_lt (\u03bb hk, _),\n  rw [degree_le_iff_coeff_zero] at this,\n  rw [finsupp.mem_support_iff] at hkq, apply hkq, apply this,\n  exact lt_of_le_of_lt degree_le_nat_degree (with_bot.coe_lt_coe.2 hk)\nend\n\ntheorem fg_adjoin_of_finite {s : set A} (hfs : s.finite)\n  (his : \u2200 x \u2208 s, is_integral R x) : (algebra.adjoin R s : submodule R A).fg :=\nset.finite.induction_on hfs (\u03bb _, \u27e8{1}, submodule.ext $ \u03bb x,\n  by { erw [algebra.adjoin_empty, finset.coe_singleton, \u2190 one_eq_span, one_eq_map_top,\n      map_top, linear_map.mem_range, algebra.mem_bot], refl }\u27e9)\n(\u03bb a s has hs ih his, by rw [\u2190 set.union_singleton, algebra.adjoin_union_coe_submodule]; exact\n  fg_mul _ _ (ih $ \u03bb i hi, his i $ set.mem_insert_of_mem a hi)\n    (fg_adjoin_singleton_of_integral _ $ his a $ set.mem_insert a s)) his\n\ntheorem is_integral_of_mem_of_fg (S : subalgebra R A)\n  (HS : (S : submodule R A).fg) (x : A) (hx : x \u2208 S) : is_integral R x :=\nbegin\n  cases HS with y hy,\n  obtain \u27e8lx, hlx1, hlx2\u27e9 :\n    \u2203 (l : A \u2192\u2080 R) (H : l \u2208 finsupp.supported R R \u2191y), (finsupp.total A A R id) l = x,\n  { rwa [\u2190(@finsupp.mem_span_iff_total A A R _ _ _ id \u2191y x), set.image_id \u2191y, hy] },\n  have hyS : \u2200 {p}, p \u2208 y \u2192 p \u2208 S := \u03bb p hp, show p \u2208 (S : submodule R A),\n    by { rw \u2190 hy, exact subset_span hp },\n  have : \u2200 (jk : (\u2191(y.product y) : set (A \u00d7 A))), jk.1.1 * jk.1.2 \u2208 (S : submodule R A) :=\n    \u03bb jk, S.mul_mem (hyS (finset.mem_product.1 jk.2).1) (hyS (finset.mem_product.1 jk.2).2),\n  rw [\u2190 hy, \u2190 set.image_id \u2191y] at this, simp only [finsupp.mem_span_iff_total] at this,\n  choose ly hly1 hly2,\n  let S\u2080 : set R := ring.closure \u2191(lx.frange \u222a finset.bUnion finset.univ (finsupp.frange \u2218 ly)),\n  refine is_integral_of_subring S\u2080 _,\n  letI : comm_ring S\u2080 := @subtype.comm_ring _ _ _ ring.closure.is_subring,\n  letI : algebra S\u2080 A := algebra.of_is_subring _,\n  have : span S\u2080 (insert 1 \u2191y : set A) * span S\u2080 (insert 1 \u2191y : set A) \u2264 span S\u2080 (insert 1 \u2191y : set A),\n  { rw span_mul_span, refine span_le.2 (\u03bb z hz, _),\n    rcases set.mem_mul.1 hz with \u27e8p, q, rfl | hp, hq, rfl\u27e9,\n    { rw one_mul, exact subset_span hq },\n    rcases hq with rfl | hq,\n    { rw mul_one, exact subset_span (or.inr hp) },\n    erw \u2190 hly2 \u27e8(p, q), finset.mem_product.2 \u27e8hp, hq\u27e9\u27e9,\n    rw [finsupp.total_apply, finsupp.sum],\n    refine (span S\u2080 (insert 1 \u2191y : set A)).sum_mem (\u03bb t ht, _),\n    have : ly \u27e8(p, q), finset.mem_product.2 \u27e8hp, hq\u27e9\u27e9 t \u2208 S\u2080 :=\n    ring.subset_closure (finset.mem_union_right _ $ finset.mem_bUnion.2\n      \u27e8\u27e8(p, q), finset.mem_product.2 \u27e8hp, hq\u27e9\u27e9, finset.mem_univ _,\n        finsupp.mem_frange.2 \u27e8finsupp.mem_support_iff.1 ht, _, rfl\u27e9\u27e9),\n    change (\u27e8_, this\u27e9 : S\u2080) \u2022 t \u2208 _, exact smul_mem _ _ (subset_span $ or.inr $ hly1 _ ht) },\n  haveI : is_subring (span S\u2080 (insert 1 \u2191y : set A) : set A) :=\n  { one_mem := subset_span $ or.inl rfl,\n    mul_mem := \u03bb p q hp hq, this $ mul_mem_mul hp hq,\n    zero_mem := (span S\u2080 (insert 1 \u2191y : set A)).zero_mem,\n    add_mem := \u03bb _ _, (span S\u2080 (insert 1 \u2191y : set A)).add_mem,\n    neg_mem := \u03bb _, (span S\u2080 (insert 1 \u2191y : set A)).neg_mem },\n  have : span S\u2080 (insert 1 \u2191y : set A) = algebra.adjoin S\u2080 (\u2191y : set A),\n  { refine le_antisymm (span_le.2 $ set.insert_subset.2\n        \u27e8(algebra.adjoin S\u2080 \u2191y).one_mem, algebra.subset_adjoin\u27e9) (\u03bb z hz, _),\n    rw [subalgebra.mem_to_submodule, algebra.mem_adjoin_iff] at hz, rw \u2190 submodule.mem_coe,\n    refine ring.closure_subset (set.union_subset (set.range_subset_iff.2 $ \u03bb t, _)\n      (\u03bb t ht, subset_span $ or.inr ht)) hz,\n    rw algebra.algebra_map_eq_smul_one,\n    exact smul_mem (span S\u2080 (insert 1 \u2191y : set A)) _ (subset_span $ or.inl rfl) },\n  haveI : is_noetherian_ring \u21a5S\u2080 := is_noetherian_ring_closure _ (finset.finite_to_set _),\n  refine is_integral_of_submodule_noetherian (algebra.adjoin S\u2080 \u2191y)\n    (is_noetherian_of_fg_of_noetherian _ \u27e8insert 1 y, by rw [finset.coe_insert, this]\u27e9) _ _,\n  rw [\u2190 hlx2, finsupp.total_apply, finsupp.sum], refine subalgebra.sum_mem _ (\u03bb r hr, _),\n  have : lx r \u2208 S\u2080 := ring.subset_closure (finset.mem_union_left _ (finset.mem_image_of_mem _ hr)),\n  change (\u27e8_, this\u27e9 : S\u2080) \u2022 r \u2208 _,\n  rw finsupp.mem_supported at hlx1,\n  exact subalgebra.smul_mem _ (algebra.subset_adjoin $ hlx1 hr) _\nend\n\nlemma ring_hom.is_integral_of_mem_closure {x y z : S}\n  (hx : f.is_integral_elem x) (hy : f.is_integral_elem y)\n  (hz : z \u2208 ring.closure ({x, y} : set S)) :\n  f.is_integral_elem z :=\nbegin\n  letI : algebra R S := f.to_algebra,\n  have := fg_mul _ _ (fg_adjoin_singleton_of_integral x hx) (fg_adjoin_singleton_of_integral y hy),\n  rw [\u2190 algebra.adjoin_union_coe_submodule, set.singleton_union] at this,\n  exact is_integral_of_mem_of_fg (algebra.adjoin R {x, y}) this z\n    (algebra.mem_adjoin_iff.2  $ ring.closure_mono (set.subset_union_right _ _) hz),\nend\n\ntheorem is_integral_of_mem_closure {x y z : A}\n  (hx : is_integral R x) (hy : is_integral R y)\n  (hz : z \u2208 ring.closure ({x, y} : set A)) :\n  is_integral R z :=\n(algebra_map R A).is_integral_of_mem_closure hx hy hz\n\nlemma ring_hom.is_integral_zero : f.is_integral_elem 0 :=\nf.map_zero \u25b8 f.is_integral_map\n\ntheorem is_integral_zero : is_integral R (0:A) :=\n(algebra_map R A).is_integral_zero\n\nlemma ring_hom.is_integral_one : f.is_integral_elem 1 :=\nf.map_one \u25b8 f.is_integral_map\n\ntheorem is_integral_one : is_integral R (1:A) :=\n(algebra_map R A).is_integral_one\n\nlemma ring_hom.is_integral_add {x y : S}\n  (hx : f.is_integral_elem x) (hy : f.is_integral_elem y) :\n  f.is_integral_elem (x + y) :=\nf.is_integral_of_mem_closure hx hy (is_add_submonoid.add_mem\n  (ring.subset_closure (or.inl rfl)) (ring.subset_closure (or.inr rfl)))\n\ntheorem is_integral_add {x y : A}\n  (hx : is_integral R x) (hy : is_integral R y) :\n  is_integral R (x + y) :=\n(algebra_map R A).is_integral_add hx hy\n\nlemma ring_hom.is_integral_neg {x : S}\n  (hx : f.is_integral_elem x) : f.is_integral_elem (-x) :=\nf.is_integral_of_mem_closure hx hx (is_add_subgroup.neg_mem\n  (ring.subset_closure (or.inl rfl)))\n\ntheorem is_integral_neg {x : A}\n  (hx : is_integral R x) : is_integral R (-x) :=\n(algebra_map R A).is_integral_neg hx\n\nlemma ring_hom.is_integral_sub {x y : S}\n  (hx : f.is_integral_elem x) (hy : f.is_integral_elem y) : f.is_integral_elem (x - y) :=\nby simpa only [sub_eq_add_neg] using f.is_integral_add hx (f.is_integral_neg hy)\n\ntheorem is_integral_sub {x y : A}\n  (hx : is_integral R x) (hy : is_integral R y) : is_integral R (x - y) :=\n(algebra_map R A).is_integral_sub hx hy\n\nlemma ring_hom.is_integral_mul {x y : S}\n  (hx : f.is_integral_elem x) (hy : f.is_integral_elem y) : f.is_integral_elem (x * y) :=\nf.is_integral_of_mem_closure hx hy (is_submonoid.mul_mem\n  (ring.subset_closure (or.inl rfl)) (ring.subset_closure (or.inr rfl)))\n\ntheorem is_integral_mul {x y : A}\n  (hx : is_integral R x) (hy : is_integral R y) : is_integral R (x * y) :=\n(algebra_map R A).is_integral_mul hx hy\n\ntheorem ring_hom.is_integral_pow {x : S} :\n  \u03a0 (n : \u2115) (hx : f.is_integral_elem x), f.is_integral_elem (x ^ n)\n| 0 hx := by simpa using f.is_integral_one\n| (n + 1) hx := by simpa using f.is_integral_mul hx (ring_hom.is_integral_pow n hx)\n\ntheorem is_integral_pow {x : A} (n : \u2115) (hx : is_integral R x) : is_integral R (x ^ n) :=\n(algebra_map R A).is_integral_pow n hx\n\nvariables (R A)\n\n/-- The integral closure of R in an R-algebra A. -/\ndef integral_closure : subalgebra R A :=\n{ carrier := { r | is_integral R r },\n  zero_mem' := is_integral_zero,\n  one_mem' := is_integral_one,\n  add_mem' := \u03bb _ _, is_integral_add,\n  mul_mem' := \u03bb _ _, is_integral_mul,\n  algebra_map_mem' := \u03bb x, is_integral_algebra_map }\n\ntheorem mem_integral_closure_iff_mem_fg {r : A} :\n  r \u2208 integral_closure R A \u2194 \u2203 M : subalgebra R A, (M : submodule R A).fg \u2227 r \u2208 M :=\n\u27e8\u03bb hr, \u27e8algebra.adjoin R {r}, fg_adjoin_singleton_of_integral _ hr, algebra.subset_adjoin rfl\u27e9,\n\u03bb \u27e8M, Hf, hrM\u27e9, is_integral_of_mem_of_fg M Hf _ hrM\u27e9\n\nvariables {R} {A}\n\n/-- Mapping an integral closure along an `alg_equiv` gives the integral closure. -/\nlemma integral_closure_map_alg_equiv (f : A \u2243\u2090[R] B) :\n  (integral_closure R A).map (f : A \u2192\u2090[R] B) = integral_closure R B :=\nbegin\n  ext y,\n  rw subalgebra.mem_map,\n  split,\n  { rintros \u27e8x, hx, rfl\u27e9,\n    exact is_integral_alg_hom f hx },\n  { intro hy,\n    use [f.symm y, is_integral_alg_hom (f.symm : B \u2192\u2090[R] A) hy],\n    simp }\nend\n\nlemma integral_closure.is_integral (x : integral_closure R A) : is_integral R x :=\nlet \u27e8p, hpm, hpx\u27e9 := x.2 in \u27e8p, hpm, subtype.eq $\nby rwa [\u2190 aeval_def, subtype.val_eq_coe, \u2190 subalgebra.val_apply, aeval_alg_hom_apply] at hpx\u27e9\n\nlemma ring_hom.is_integral_of_is_integral_mul_unit (x y : S) (r : R) (hr : f r * y = 1)\n  (hx : f.is_integral_elem (x * y)) : f.is_integral_elem x :=\nbegin\n  obtain \u27e8p, \u27e8p_monic, hp\u27e9\u27e9 := hx,\n  refine \u27e8scale_roots p r, \u27e8(monic_scale_roots_iff r).2 p_monic, _\u27e9\u27e9,\n  convert scale_roots_eval\u2082_eq_zero f hp,\n  rw [mul_comm x y, \u2190 mul_assoc, hr, one_mul],\nend\n\ntheorem is_integral_of_is_integral_mul_unit {x y : A} {r : R} (hr : algebra_map R A r * y = 1)\n  (hx : is_integral R (x * y)) : is_integral R x :=\n(algebra_map R A).is_integral_of_is_integral_mul_unit x y r hr hx\n\n/-- Generalization of `is_integral_of_mem_closure` bootstrapped up from that lemma -/\nlemma is_integral_of_mem_closure' (G : set A) (hG : \u2200 x \u2208 G, is_integral R x) :\n  \u2200 x \u2208 (subring.closure G), is_integral R x :=\n\u03bb x hx, subring.closure_induction hx hG is_integral_zero is_integral_one\n  (\u03bb _ _, is_integral_add) (\u03bb _, is_integral_neg) (\u03bb _ _, is_integral_mul)\n\nlemma is_integral_of_mem_closure'' {S : Type*} [comm_ring S] {f : R \u2192+* S} (G : set S)\n  (hG : \u2200 x \u2208 G, f.is_integral_elem x) : \u2200 x \u2208 (subring.closure G), f.is_integral_elem x :=\n\u03bb x hx, @is_integral_of_mem_closure' R S _ _ f.to_algebra G hG x hx\n\nlemma algebra_map_injective (h : function.injective (algebra_map R A)) :\n  function.injective (algebra_map R (integral_closure R A)) :=\n\u03bb x y hxy, h $\n  show algebra_map (integral_closure R A) A (algebra_map R _ x) = _,\n  from congr_arg (algebra_map (integral_closure R A) A) hxy\n\nend\n\nsection algebra\nopen algebra\nvariables {R A B S T : Type*}\nvariables [comm_ring R] [comm_ring A] [comm_ring B] [comm_ring S] [comm_ring T]\nvariables [algebra A B] [algebra R B] (f : R \u2192+* S) (g : S \u2192+* T)\n\nlemma is_integral_trans_aux (x : B) {p : polynomial A} (pmonic : monic p) (hp : aeval x p = 0) :\n  is_integral (adjoin R (\u2191(p.map $ algebra_map A B).frange : set B)) x :=\nbegin\n  generalize hS : (\u2191(p.map $ algebra_map A B).frange : set B) = S,\n  have coeffs_mem : \u2200 i, (p.map $ algebra_map A B).coeff i \u2208 adjoin R S,\n  { intro i, by_cases hi : (p.map $ algebra_map A B).coeff i = 0,\n    { rw hi, exact subalgebra.zero_mem _ },\n    rw \u2190 hS, exact subset_adjoin (finsupp.mem_frange.2 \u27e8hi, i, rfl\u27e9) },\n  obtain \u27e8q, hq\u27e9 : \u2203 q : polynomial (adjoin R S), q.map (algebra_map (adjoin R S) B) =\n      (p.map $ algebra_map A B),\n  { rw \u2190 set.mem_range, exact (polynomial.mem_map_range _).2 (\u03bb i, \u27e8\u27e8_, coeffs_mem i\u27e9, rfl\u27e9) },\n  use q,\n  split,\n  { suffices h : (q.map (algebra_map (adjoin R S) B)).monic,\n    { refine monic_of_injective _ h,\n      exact subtype.val_injective },\n    { rw hq, exact monic_map _ pmonic } },\n  { convert hp using 1,\n    replace hq := congr_arg (eval x) hq,\n    convert hq using 1; symmetry; apply eval_map },\nend\n\nvariables [algebra R A] [is_scalar_tower R A B]\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand x is an element of an A-algebra that is integral over A, then x is integral over R.-/\nlemma is_integral_trans (A_int : is_integral R A) (x : B) (hx : is_integral A x) :\n  is_integral R x :=\nbegin\n  rcases hx with \u27e8p, pmonic, hp\u27e9,\n  let S : set B := \u2191(p.map $ algebra_map A B).frange,\n  refine is_integral_of_mem_of_fg (adjoin R (S \u222a {x})) _ _ (subset_adjoin $ or.inr rfl),\n  refine fg_trans (fg_adjoin_of_finite (finset.finite_to_set _) (\u03bb x hx, _)) _,\n  { rw [finset.mem_coe, finsupp.mem_frange] at hx, rcases hx with \u27e8_, i, rfl\u27e9,\n    show is_integral R ((p.map $ algebra_map A B).coeff i), rw coeff_map,\n    convert is_integral_alg_hom (is_scalar_tower.to_alg_hom R A B) (A_int _) },\n  { apply fg_adjoin_singleton_of_integral,\n    exact is_integral_trans_aux _ pmonic hp }\nend\n\n/-- If A is an R-algebra all of whose elements are integral over R,\nand B is an A-algebra all of whose elements are integral over A,\nthen all elements of B are integral over R.-/\nlemma algebra.is_integral_trans (hA : is_integral R A) (hB : is_integral A B) : is_integral R B :=\n\u03bb x, is_integral_trans hA x (hB x)\n\nlemma ring_hom.is_integral_trans (hf : f.is_integral) (hg : g.is_integral) :\n  (g.comp f).is_integral :=\n@algebra.is_integral_trans R S T _ _ _ g.to_algebra (g.comp f).to_algebra f.to_algebra\n  (@is_scalar_tower.of_algebra_map_eq R S T _ _ _ f.to_algebra g.to_algebra (g.comp f).to_algebra\n  (ring_hom.comp_apply g f)) hf hg\n\nlemma ring_hom.is_integral_of_surjective (hf : function.surjective f) : f.is_integral :=\n\u03bb x, (hf x).rec_on (\u03bb y hy, (hy \u25b8 f.is_integral_map : f.is_integral_elem x))\n\nlemma is_integral_of_surjective (h : function.surjective (algebra_map R A)) : is_integral R A :=\n(algebra_map R A).is_integral_of_surjective h\n\n/-- If `R \u2192 A \u2192 B` is an algebra tower with `A \u2192 B` injective,\nthen if the entire tower is an integral extension so is `R \u2192 A` -/\nlemma is_integral_tower_bot_of_is_integral (H : function.injective (algebra_map A B))\n  {x : A} (h : is_integral R (algebra_map A B x)) : is_integral R x :=\nbegin\n  rcases h with \u27e8p, \u27e8hp, hp'\u27e9\u27e9,\n  refine \u27e8p, \u27e8hp, _\u27e9\u27e9,\n  rw [is_scalar_tower.algebra_map_eq R A B, \u2190 eval\u2082_map,\n      eval\u2082_hom, \u2190 ring_hom.map_zero (algebra_map A B)] at hp',\n  rw [eval\u2082_eq_eval_map],\n  exact H hp',\nend\n\nlemma ring_hom.is_integral_tower_bot_of_is_integral (hg : function.injective g)\n  (hfg : (g.comp f).is_integral) : f.is_integral :=\n\u03bb x, @is_integral_tower_bot_of_is_integral R S T _ _ _ g.to_algebra (g.comp f).to_algebra f.to_algebra\n  (@is_scalar_tower.of_algebra_map_eq R S T _ _ _ f.to_algebra g.to_algebra (g.comp f).to_algebra\n  (ring_hom.comp_apply g f))  hg x (hfg (g x))\n\nlemma is_integral_tower_bot_of_is_integral_field {R A B : Type*} [comm_ring R] [field A]\n  [comm_ring B] [nontrivial B] [algebra R A] [algebra A B] [algebra R B] [is_scalar_tower R A B]\n  {x : A} (h : is_integral R (algebra_map A B x)) : is_integral R x :=\nis_integral_tower_bot_of_is_integral (algebra_map A B).injective h\n\nlemma ring_hom.is_integral_elem_of_is_integral_elem_comp {x : T}\n  (h : (g.comp f).is_integral_elem x) : g.is_integral_elem x :=\nlet \u27e8p, \u27e8hp, hp'\u27e9\u27e9 := h in \u27e8p.map f, monic_map f hp, by rwa \u2190 eval\u2082_map at hp'\u27e9\n\nlemma ring_hom.is_integral_tower_top_of_is_integral (h : (g.comp f).is_integral) : g.is_integral :=\n\u03bb x, ring_hom.is_integral_elem_of_is_integral_elem_comp f g (h x)\n\n/-- If `R \u2192 A \u2192 B` is an algebra tower,\nthen if the entire tower is an integral extension so is `A \u2192 B`. -/\nlemma is_integral_tower_top_of_is_integral {x : B} (h : is_integral R x) : is_integral A x :=\nbegin\n  rcases h with \u27e8p, \u27e8hp, hp'\u27e9\u27e9,\n  refine \u27e8p.map (algebra_map R A), \u27e8monic_map (algebra_map R A) hp, _\u27e9\u27e9,\n  rw [is_scalar_tower.algebra_map_eq R A B, \u2190 eval\u2082_map] at hp',\n  exact hp',\nend\n\nlemma ring_hom.is_integral_quotient_of_is_integral {I : ideal S} (hf : f.is_integral) :\n  (ideal.quotient_map I f le_rfl).is_integral :=\nbegin\n  rintros \u27e8x\u27e9,\n  obtain \u27e8p, \u27e8p_monic, hpx\u27e9\u27e9 := hf x,\n  refine \u27e8p.map (ideal.quotient.mk _), \u27e8monic_map _ p_monic, _\u27e9\u27e9,\n  simpa only [hom_eval\u2082, eval\u2082_map] using congr_arg (ideal.quotient.mk I) hpx\nend\n\nlemma is_integral_quotient_of_is_integral {I : ideal A} (hRA : is_integral R A) :\n  is_integral (I.comap (algebra_map R A)).quotient I.quotient :=\n(algebra_map R A).is_integral_quotient_of_is_integral hRA\n\nlemma is_integral_quotient_map_iff {I : ideal S} :\n  (ideal.quotient_map I f le_rfl).is_integral \u2194\n    ((ideal.quotient.mk I).comp f : R \u2192+* I.quotient).is_integral :=\nbegin\n  let g := ideal.quotient.mk (I.comap f),\n  have := ideal.quotient_map_comp_mk le_rfl,\n  refine \u27e8\u03bb h, _, \u03bb h, ring_hom.is_integral_tower_top_of_is_integral g _ (this \u25b8 h)\u27e9,\n  refine this \u25b8 ring_hom.is_integral_trans g (ideal.quotient_map I f le_rfl) _ h,\n  exact ring_hom.is_integral_of_surjective g ideal.quotient.mk_surjective,\nend\n\n/-- If the integral extension `R \u2192 S` is injective, and `S` is a field, then `R` is also a field. -/\nlemma is_field_of_is_integral_of_is_field {R S : Type*} [integral_domain R] [integral_domain S]\n  [algebra R S] (H : is_integral R S) (hRS : function.injective (algebra_map R S))\n  (hS : is_field S) : is_field R :=\nbegin\n  refine \u27e8\u27e80, 1, zero_ne_one\u27e9, mul_comm, \u03bb a ha, _\u27e9,\n  -- Let `a_inv` be the inverse of `algebra_map R S a`,\n  -- then we need to show that `a_inv` is of the form `algebra_map R S b`.\n  obtain \u27e8a_inv, ha_inv\u27e9 := hS.mul_inv_cancel (\u03bb h, ha (hRS (trans h (ring_hom.map_zero _).symm))),\n\n  -- Let `p : polynomial R` be monic with root `a_inv`,\n  -- and `q` be `p` with coefficients reversed (so `q(a) = q'(a) * a + 1`).\n  -- We claim that `q(a) = 0`, so `-q'(a)` is the inverse of `a`.\n  obtain \u27e8p, p_monic, hp\u27e9 := H a_inv,\n  use -\u2211 (i : \u2115) in finset.range p.nat_degree, (p.coeff i) * a ^ (p.nat_degree - i - 1),\n\n  -- `q(a) = 0`, because multiplying everything with `a_inv^n` gives `p(a_inv) = 0`.\n  -- TODO: this could be a lemma for `polynomial.reverse`.\n  have hq : \u2211 (i : \u2115) in finset.range (p.nat_degree + 1), (p.coeff i) * a ^ (p.nat_degree - i) = 0,\n  { apply (algebra_map R S).injective_iff.mp hRS,\n    have a_inv_ne_zero : a_inv \u2260 0 := right_ne_zero_of_mul (mt ha_inv.symm.trans one_ne_zero),\n    refine (mul_eq_zero.mp _).resolve_right (pow_ne_zero p.nat_degree a_inv_ne_zero),\n    rw [eval\u2082_eq_sum_range] at hp,\n    rw [ring_hom.map_sum, finset.sum_mul],\n    refine (finset.sum_congr rfl (\u03bb i hi, _)).trans hp,\n    rw [ring_hom.map_mul, mul_assoc],\n    congr,\n    have : a_inv ^ p.nat_degree = a_inv ^ (p.nat_degree - i) * a_inv ^ i,\n    { rw [\u2190 pow_add a_inv, nat.sub_add_cancel (nat.le_of_lt_succ (finset.mem_range.mp hi))] },\n    rw [ring_hom.map_pow, this, \u2190 mul_assoc, \u2190 mul_pow, ha_inv, one_pow, one_mul] },\n\n  -- Since `q(a) = 0` and `q(a) = q'(a) * a + 1`, we have `a * -q'(a) = 1`.\n  -- TODO: we could use a lemma for `polynomial.div_X` here.\n  rw [finset.sum_range_succ, p_monic.coeff_nat_degree, one_mul, nat.sub_self, pow_zero,\n      add_eq_zero_iff_eq_neg, eq_comm] at hq,\n  rw [mul_comm, \u2190 neg_mul_eq_neg_mul, finset.sum_mul],\n  convert hq using 2,\n  refine finset.sum_congr rfl (\u03bb i hi, _),\n  have : 1 \u2264 p.nat_degree - i := nat.le_sub_left_of_add_le (finset.mem_range.mp hi),\n  rw [mul_assoc, \u2190 pow_succ', nat.sub_add_cancel this]\nend\n\nend algebra\n\nsection\nlocal attribute [instance] subset.comm_ring algebra.of_is_subring\ntheorem integral_closure_idem {R : Type*} {A : Type*} [comm_ring R] [comm_ring A] [algebra R A] :\n  integral_closure (integral_closure R A : set A) A = \u22a5 :=\neq_bot_iff.2 $ \u03bb x hx, algebra.mem_bot.2\n\u27e8\u27e8x, @is_integral_trans _ _ _ _ _ _ _ _ (integral_closure R A).algebra\n     _ integral_closure.is_integral x hx\u27e9, rfl\u27e9\nend\n\nsection integral_domain\nvariables {R S : Type*} [comm_ring R] [integral_domain S] [algebra R S]\n\ninstance : integral_domain (integral_closure R S) :=\n{ exists_pair_ne := \u27e80, 1, mt subtype.ext_iff_val.mp zero_ne_one\u27e9,\n  eq_zero_or_eq_zero_of_mul_eq_zero := \u03bb \u27e8a, ha\u27e9 \u27e8b, hb\u27e9 h,\n    or.imp subtype.ext_iff_val.mpr subtype.ext_iff_val.mpr (eq_zero_or_eq_zero_of_mul_eq_zero (subtype.ext_iff_val.mp h)),\n  ..(integral_closure R S).comm_ring R S }\n\nend integral_domain\n"}
{"text": "opaque f : Nat \u2192 Nat\nopaque q : Nat \u2192 (Nat \u2192 Prop) \u2192 Nat\n\n@[simp]\ntheorem ex {x : Nat} {p : Nat \u2192 Prop} (h\u2081 : p x) (h\u2082 : q x p = x) : f x = x :=\n  sorry\n\nset_option trace.Meta.Tactic.simp.discharge true\ntheorem foo : f (f x) = x := by\n  simp\n  sorry\n"}
{"text": "Require Import Coq.Program.Equality.\nFrom Coq.Logic Require Import JMeq EqdepFacts.\nFrom mathcomp Require Import ssreflect.\nFrom Category.Base Require Import Logic Category.\n\nOpen Scope equiv_scope.\n\nSet Universe Polymorphism.\n\nStructure Functor (C D : Category) : Type :=\n  {\n    FApp : Obj C -> Obj D;\n    FAppH : forall {X Y : Obj C}, Hom X Y -> Hom (FApp X) (FApp Y);\n\n    (* Conditions *)\n    FAppH_comp_eq : forall {X Y Z : Obj C} (f : Hom Y Z) (g : Hom X Y), FAppH (f \\o g) = (FAppH f) \\o (FAppH g);\n    Functor_id_eq : forall {X : Obj C}, FAppH (\\Id X) = \\Id (FApp X)\n  }.\n\nGlobal Arguments FApp {C D}.\nGlobal Arguments FAppH {C D} f {X Y}.\nGlobal Arguments FAppH_comp_eq {C D} f {X Y Z}.\n\nLemma ToFunctorEq :\n  forall {C D : Category} (F G : Functor C D),\n    (forall {X Y : Obj C} (f : Hom X Y), Hom_eq' (FAppH F f) (FAppH G f)) ->\n    F = G.\nProof.\n  move => C D.\n  case => AppF AppHF compeqF ideqF.\n  case => AppG AppHG compeqG ideqG.\n  rewrite /=.\n  move => cond.\n  have: AppF = AppG.\n  {\n    apply: functional_extensionality.\n    move => X.\n    move: (cond X X (\\Id X)).\n    case.\n    by [].\n  }\n  move => eqApp.\n  subst.\n  have: AppHF = AppHG.\n  {\n    apply: functional_extensionality_dep => X.\n    apply: functional_extensionality_dep => Y.\n    apply: functional_extensionality => f.\n    case: (cond _ _ f).\n    move => eqX.\n    case.\n    move => eqY.\n    repeat rewrite HomId'_id.\n    rewrite Hom_IdL.\n    rewrite Hom_IdR.\n    by [].\n  }\n  move => eqApp.\n  subst.\n  have: (compeqF = compeqG /\\ ideqF = ideqG).\n  {\n    split; exact: p_proof_irrelevance.\n  }\n  case.\n  move =>-> =>->.\n  by [].\nQed.  \n\n\n      "}
{"text": "(*********************************************************************** \n* HiVe theory files\n* \n* Copyright (C) 2015 Commonwealth of Australia as represented by Defence Science and Technology \n* Group (DST Group)\n* \n* All rights reserved.\n*\n* The HiVe theory files are free software: released for redistribution and use, and/or modification,\n* under the BSD License, details of which can be found in the LICENSE file included in the \n* distribution. \n************************************************************************)\n\ntheory Equipotence \n  \nimports \n  Z_Fun\n  Orders\n  Ordinal\nbegin\n\ntext {*\n\nWe follow Dugundji~\\cite{Dugundji:Top}.\n\nWhile ordinals are aimed at counting through sets, cardinals are aimed\nat comparing their sizes. \nTwo sets have the ``same size'', or formally speaking are {\\em equipotent},\nif there is bijection between them.\nOne set is {\\em sub-equipotent} to another if there is a total injection \nbetween them.\n\n*}\n\ndefinition\n  subequipotent :: \"['a set, 'b set] \\<rightarrow> \\<bool>\"\nwhere\n  subequipotent_def: \"subequipotent A B \\<defs> (\\<exists> f \\<bullet> f \\<in> A \\<zinj> B)\" \n\ndefinition\n  equipotent :: \"['a set, 'b set] \\<rightarrow> \\<bool>\"\nwhere\n  equipotent_def: \"equipotent A B \\<defs> (\\<exists> f \\<bullet> f \\<in> A \\<zbij> B)\"\n\nnotation (xsymbols output)\n  subequipotent (\"card _ \\<le> card _\" [1000,1000] 1000)\n\nnotation (xsymbols)\n  subequipotent  (\"op \\<preceq>\") and\n  subequipotent  (\"(_/ \\<preceq> _)\"  [51, 51] 50) and\n  equipotent (infixl \"\\<asymp>\" 50)\n\nnotation (zed)\n  subequipotent (\"\\<^sEP>{:_:}{:_:}\") and\n  equipotent (\"\\<^EP>{:_:}{:_:}\")\n\nabbreviation\n  nequipotent  :: \"['a set, 'b set] \\<rightarrow> \\<bool>\"\nwhere\n  \"nequipotent X Y \\<equiv> \\<not>(\\<^EP>{:X:}{:Y:})\"\n\nnotation (xsymbols)\n  nequipotent (infixl \"\\<notasymp>\" 50)\n\nnotation (zed)\n  nequipotent (\"\\<^nEP>{:_:}{:_:}\")\n\nabbreviation\n  subequipotent_ne  :: \"['a set, 'b set] \\<rightarrow> \\<bool>\"\nwhere\n  \"subequipotent_ne X Y \\<equiv> \\<^sEP>{:X:}{:Y:} \\<and> \\<^nEP>{:X:}{:Y:}\"\n\nnotation (xsymbols)\n  subequipotent_ne  (\"op \\<prec>\") and\n  subequipotent_ne (\"(_/ \\<prec> _)\"  [51, 51] 50)\n\nnotation (zed)\n  subequipotent_ne (\"\\<^sEPne>{:_:}{:_:}\")\n\nlemma subequipotentI:\n  assumes \n    a1: \"f \\<in> A \\<zinj> B\"\n  shows \n    \"\\<^sEP>{:A:}{:B:}\"\n  using a1\n  by (auto simp add: subequipotent_def)\n\nlemma subequipotentE:\n  assumes \n    a1: \"\\<^sEP>{:A:}{:B:}\"\n        \"\\<And> f \\<bullet> f \\<in> A \\<zinj> B \\<turnstile> R\"\n  shows \"R\"\n  using a1\n  by (auto simp add: subequipotent_def)\n\nlemma subequipotent_eq_inj_on:\n  \"\\<^sEP>{:A:}{:B:} \\<Leftrightarrow> (\\<exists> f \\<bullet> inj_on f A \\<and> f\\<lparr>A\\<rparr> \\<subseteq> B)\"\nproof (msafe_no_assms(inference))\n  assume\n    b1: \"\\<^sEP>{:A:}{:B:}\"\n  then obtain f where\n    b2: \"f \\<in> A \\<zinj> B\"\n    by (auto simp add: subequipotent_def)\n  have\n    b3: \"inj_on (\\<opof> f) A\" and\n    b4: \"(\\<opof> f)\\<lparr>A\\<rparr> \\<subseteq> B\"\n    by (auto intro!: inj_onI tinj_inj [OF b2] tinj_range [OF b2])\n  then show\n    \"(\\<exists> f \\<bullet> inj_on f A \\<and> f\\<lparr>A\\<rparr> \\<subseteq> B)\"\n    by (auto)\nnext\n  fix\n    f\n  assume\n    b1: \"inj_on f A\" and \n    b2: \"f\\<lparr>A\\<rparr> \\<subseteq> B\"\n  from b1 [THEN graph_of_dresf_inj_on] b2 have \n    \"A \\<zdres> (\\<graphof> f) \\<in> A \\<zinj> B\"\n    apply (mauto(fspace))\n    apply (auto simp add: Image_def image_def dres_graph_of eind_def)\n    done\n  then show \n    \"\\<^sEP>{:A:}{:B:}\"\n    by (rule subequipotentI)\nqed\n\nlemma subepIinj_on:\n  assumes \n    a1: \"inj_on f A\" and \n    a2: \"f\\<lparr>A\\<rparr> \\<subseteq> B\"\n  shows \n    \"\\<^sEP>{:A:}{:B:}\"\n  using a1 a2\n  by (auto simp add: subequipotent_eq_inj_on)\n\nlemma subepEinj_on:\n  assumes \n    a1: \"\\<^sEP>{:A:}{:B:}\" and\n    a2: \"\\<And> f \\<bullet> \\<lbrakk> inj_on f A; f\\<lparr>A\\<rparr> \\<subseteq> B \\<rbrakk> \\<turnstile> R\"\n  shows\n    \"R\"\n  using a1\n  by (auto intro: a2 simp add: subequipotent_eq_inj_on)  \n\nlemma subepIsurj:\n  assumes a1: \"A \\<subseteq> f\\<lparr>B\\<rparr>\"\n  shows \"\\<^sEP>{:A:}{:B:}\"\nproof (rule subepIinj_on)\n  let ?finv = \"(\\<olambda> x \\<bullet> (\\<some> y | y \\<in> B \\<and> f y = x))\"\n{ fix y \n  have \"y \\<in> f\\<lparr>B\\<rparr> ==> f(?finv y) = y\"\n    apply (rule conjunct2)\n    apply (rule someI_ex)\n    apply (auto)\n   done\n} note f_finv = this\n{ fix x y\n  assume eq: \"?finv x = ?finv y\"\n      and x: \"x \\<in> f\\<lparr>B\\<rparr>\"\n      and y: \"y \\<in> f\\<lparr>B\\<rparr>\"\n  have \"x = y\"\n  proof -\n    have \"f (?finv x) = f (?finv y)\" using eq by simp\n    thus ?thesis by (simp add: f_finv x y)\n  qed                                                                           \n} note finv_injective = this\n  from a1 show \"inj_on ?finv A\"\n    by (fast intro: inj_onI elim: finv_injective injD)\n  from a1 show \"(?finv)\\<lparr>A\\<rparr> \\<subseteq> B\"\n    apply (auto simp add: image_def subset_def)\n    apply (rule conjunct1)\n    apply (rule someI_ex)\n    apply (fast)\n    done\nqed\n\nlemma univ_top:\n  \"\\<^sEP>{:(A::'a set):}{:\\<univ>-['a]:}\"\nproof -\n  from Z_id_bij have \"rel_id A \\<in> A \\<zinj> \\<univ>-['a]\"\n    apply (mauto(fspace))\n    apply (auto simp add: rel_id_def)\n    done\n  then show \"\\<^sEP>{:A:}{:\\<univ>-['a]:}\"\n    by (rule subequipotentI)\nqed\n\nlemma empty_bot:\n  \"\\<^sEP>{:\\<emptyset>-['b]:}{:(A::'a set):}\"\nproof -\n  have \"\\<emptyset> \\<in> \\<emptyset>-['b] \\<zinj> A\"\n    by (mauto(fspace) mintro: fin_pfunI msimp add: fin_pfun_simp vacuous_inv empty_functional)\n  then show \n    \"\\<^sEP>{:\\<emptyset>-['b]:}{:A:}\"\n    by (rule subequipotentI)\nqed\n\nlemma empty_glb:\n  \"\\<^sEP>{:(A::'a set):}{:\\<emptyset>-['b]:} \\<Leftrightarrow> A = \\<emptyset>-['a]\"\nproof (auto simp add: empty_bot)\n  fix \n    x :: \"'a\"\n  assume\n    b1: \"\\<^sEP>{:A:}{:\\<emptyset>-['b]:}\" and\n    b2: \"x \\<in> A\"\n  from b1 obtain f where\n    b3: \"f \\<in> A \\<zinj> \\<emptyset>-['b]\" \n    by (auto simp add: subequipotent_def)\n  from tinj_range [OF b3 b2] show\n    \"\\<False>\"\n    by (auto)\nqed\n\nlemma equipotentI:\n  assumes \n    a1: \"f \\<in> A \\<zbij> B\"\n  shows \n    \"\\<^EP>{:A:}{:B:}\"\n  using a1\n  by (auto simp add: equipotent_def)\n\nlemma equipotentE:\n  assumes \n    a1: \"\\<^EP>{:A:}{:B:}\"\n        \"\\<And> f \\<bullet> f \\<in> A \\<zbij> B \\<turnstile> R\"\n  shows \n    \"R\"\n  using a1\n  by (auto simp add: equipotent_def)\n\nlemma equipotentD1:\n  assumes \n    a1: \"\\<^EP>{:A:}{:B:}\"\n  shows  \n    \"\\<^sEP>{:A:}{:B:}\"\n  using a1\n  by (auto intro!: subequipotentI elim!: equipotentE)\n\nlemma equipotentD2:\n  assumes \n    a1: \"\\<^EP>{:A:}{:B:}\"\n  shows  \n    \"\\<^sEP>{:B:}{:A:}\"\n  using a1\n  by (auto intro!: subequipotentI elim!: equipotentE)\n\nlemma equipotentIinj_on:\n  assumes \n    a1: \"inj_on f A\" and \n    a2: \"f\\<lparr>A\\<rparr> = B\"\n  shows \n    \"\\<^EP>{:A:}{:B:}\"\nproof -\n  from a1 [THEN graph_of_dresf_inj_on] a2\n  have \"A \\<zdres> (\\<graphof> f) \\<in> A \\<zbij> B\"\n    apply (mauto(fspace))\n    apply (auto simp add: Image_def image_def dres_graph_of)\n    done\n  then show ?thesis\n    by (rule equipotentI)\nqed\n\nlemma equipotentIinj_on':\n  assumes \n    a1: \"inj_on f A\"\n  shows \n    \"\\<^EP>{:A:}{:f\\<lparr>A\\<rparr>:}\"\n  apply (rule equipotentIinj_on [OF a1])\n  apply (auto)\n  done\n\nlemma subep_subsetE:\n  assumes \n    a1: \"\\<^sEP>{:A:}{:B:}\" and\n    a2: \"\\<And> B' \\<bullet> \\<lbrakk> \\<^EP>{:A:}{:B':}; B' \\<subseteq> B \\<rbrakk> \\<turnstile> R\"\n  shows\n    \"R\"\nproof (rule subepEinj_on [OF a1])\n  fix \n    f\n  assume\n    b1: \"inj_on f A\" and\n    b2: \"f\\<lparr>A\\<rparr> \\<subseteq> B\"\n  from equipotentIinj_on' [OF b1] b2 show\n    \"R\"\n    by (rule a2)\nqed\n\nlemma equipotentEinj_on:\n  assumes \n    a1: \"\\<^EP>{:A:}{:B:}\" and\n    a2: \"\\<And> f \\<bullet> \\<lbrakk> inj_on f A; f\\<lparr>A\\<rparr> = B \\<rbrakk> \\<turnstile> R\"\n  shows\n    \"R\"\nproof -\n  from a1 obtain f where\n    b1: \"f \\<in> A \\<zbij> B\"\n    by (auto simp add: equipotent_def)\n  have\n    b2: \"inj_on (\\<opof> f) A\" and\n    b3: \"(\\<opof> f)\\<lparr>A\\<rparr> = B\"\n    apply (auto intro!: inj_onI bij_inj [OF b1] bij_range [OF b1] simp add: image_conv)\n    apply (auto intro: bij_beta [OF b1, symmetric] simp add: bij_ran [OF b1, symmetric] bij_dom [OF b1, symmetric])\n    done\n  then show\n    \"R\"\n    by (rule a2)\nqed\n\nlemma equipotent_eq_inj_on:\n  \"\\<^EP>{:A:}{:B:} \\<Leftrightarrow> (\\<exists> f \\<bullet> inj_on f A \\<and> f\\<lparr>A\\<rparr> = B)\"\n  by (auto elim: equipotentEinj_on intro: equipotentIinj_on)\n\nlemma subset_subequipotent:\n  assumes \n    a1: \"A \\<subseteq> B\"\n  shows \n    \"\\<^sEP>{:A:}{:B:}\"\n  apply (rule subequipotentI [of \"\\<zid> A\"])\n  apply (mauto(fspace))\n  using a1\n  apply (auto simp add: rel_id_def)\n  done\n\ntext {*\n\nThe equipotence relation is a generalised form of equivalence relation.\n\n*}\n\nlemma \n  equipotent_refl: \"\\<^EP>{:A:}{:A:}\"\nproof -\n  have \"\\<zid> A \\<in> A \\<zbij> A\"\n    by (auto simp add: rel_id_def fun_space_defs)\n  then show ?thesis\n    by (auto simp add: equipotent_def)\nqed\n\nlemma \n  equipotent_sym [sym]: \"\\<^EP>{:A:}{:B:} \\<turnstile> \\<^EP>{:B:}{:A:}\"\n  by (auto simp add: equipotent_def)\n\nlemma equipotent_trans [trans]: \n  assumes \n    a1: \"\\<^EP>{:A:}{:B:}\" and \n    a2: \"\\<^EP>{:B:}{:C:}\"\n  shows\n    \"\\<^EP>{:A:}{:C:}\"\nproof -\n  from a1 [unfolded equipotent_def] a2 [unfolded equipotent_def]\n  show ?thesis\n  proof (auto)\n    fix f g\n    assume \n      b1: \"f \\<in> A \\<zbij> B\" and \n      b2: \"g \\<in> B \\<zbij> C\"\n    then have \n      \"(f \\<zfcomp> g) \\<in> A \\<zbij> C\"\n      by (auto)\n    then show \n      ?thesis\n      by (auto simp add: equipotent_def)\n  qed\nqed\n\nlemma equipotent_substL:\n  assumes\n    a1: \"\\<^EP>{:A:}{:B:}\"\n  shows \n    \"\\<^EP>{:A:}{:C:} \\<Leftrightarrow> \\<^EP>{:B:}{:C:}\"\n  by (auto intro: equipotent_trans a1 a1 [THEN equipotent_sym])\n\nlemma equipotent_substR:\n  assumes\n    a1: \"\\<^EP>{:A:}{:B:}\"\n  shows \n    \"\\<^EP>{:C:}{:A:} \\<Leftrightarrow> \\<^EP>{:C:}{:A:}\"\n  by (auto intro: equipotent_trans a1 a1 [THEN equipotent_sym])\n\nlemma equipotent_cong: \n  assumes\n    a1: \"\\<^EP>{:A:}{:A':}\" and\n    a2: \"\\<^EP>{:B:}{:B':}\"\n  shows \n    \"\\<^EP>{:A:}{:B:} \\<Leftrightarrow> \\<^EP>{:A':}{:B':}\"\n  by (auto intro: equipotent_trans [THEN equipotent_trans] a1 a1 [THEN equipotent_sym] a2 a2 [THEN equipotent_sym])\n\nlemma equipotent_equiv:\n  \"equivalence \\<univ>-['a set] equipotent\"\n  apply (simp_all add: equivalence_def')\n  apply (auto simp add: op2rel_def rel_def)\n  apply (rule equipotent_refl)\n  apply (rule equipotent_sym, assumption)\n  apply (rule equipotent_trans, assumption+)\n  done\n\ninterpretation equi_equiv: equivalence \"\\<univ>-['a set]\" \"equipotent\"\n  by (rule equipotent_equiv)\n \ntext {*\n\nWe introduce some congruence style rules for breaking down equipotence goals involving image and cross product operators..\n\n*}\n\nlemma equipotent_prodL:\n  assumes\n    a1: \"\\<^EP>{:A:}{:B:}\"\n  shows\n    \"\\<^EP>{:A \\<times> C:}{:B \\<times> C:}\"\nproof -\n  from a1 obtain f where\n    b1: \"f \\<in> A \\<zbij> B\"\n    by (auto elim!: equipotentE)\n  show\n    \"?thesis\"\n    apply (rule equipotentI [of \"(\\<glambda> (a, c) | (a, c) \\<in> A \\<times> C \\<bullet> (f\\<cdot>a, c))\"])\n    apply (mauto(fspace) msimp add: glambda_dom glambda_ran split_def)\n    apply (msafe_no_assms(inference))\n    using b1\n    apply (auto elim!: bij_surjE [OF b1] simp add: bij_inj bij_range)\n    done\nqed\n  \nlemma equipotent_prod_com:\n  \"\\<^EP>{:C \\<times> A:}{:A \\<times> C:}\"\n  apply (rule equipotentI [of \"(\\<glambda> (c, a) | (c, a) \\<in> C \\<times> A \\<bullet> (a, c))\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran split_def)\n  apply (auto)\n  done\n  \nlemma equipotent_prod_assoc:\n  \"\\<^EP>{:(A \\<times> B) \\<times> C:}{:A \\<times> (B \\<times> C):}\"\n  apply (rule equipotentI [of \"(\\<glambda> ((a, b), c) | ((a, b), c) \\<in> (A \\<times> B) \\<times> C \\<bullet> (a, (b, c)))\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran split_def)\n  apply (auto)\n  done\n\nlemma equipotent_prodR:\n  assumes\n    a1: \"\\<^EP>{:A:}{:B:}\"\n  shows\n    \"\\<^EP>{:C \\<times> A:}{:C \\<times> B:}\"\n  apply (rule equipotent_trans)\n  apply (rule equipotent_trans)\n  apply (rule equipotent_prod_com)\n  apply (rule equipotent_prodL [OF a1])\n  apply (rule equipotent_prod_com)\n  done\n\nlemma equipotent_prod_cong:\n  assumes\n    a1: \"\\<^EP>{:A:}{:A':}\" and\n    a2: \"\\<^EP>{:B:}{:B':}\"\n  shows\n    \"\\<^EP>{:A \\<times> B:}{:A' \\<times> B':}\"\n  apply (rule equipotent_trans)\n  apply (rule equipotent_prodL [OF a1])\n  apply (rule equipotent_prodR [OF a2])\n  done\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^EP>{:A:}{:A':}\"\n  shows\n    \"\\<^EP>{:A \\<times> B:}{:A' \\<times> B:}\"\n  by (rule equipotent_prod_cong [OF a1 equipotent_refl])\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^EP>{:B:}{:B':}\"\n  shows\n    \"\\<^EP>{:A \\<times> B:}{:A \\<times> B':}\"\n  by (rule equipotent_prod_cong [OF equipotent_refl a1])\n\n\nlemma equipotent_prod_singletonL:\n  assumes\n    a1: \"\\<^EP>{:B:}{:B':}\"\n  shows\n  \"\\<^EP>{:{x} \\<times> B:}{:B':}\"\n  apply (rule equipotent_trans [OF _ a1])\n  apply (rule equipotentI [of \"(\\<glambda> (a, b) | a = x \\<and> b \\<in> B \\<bullet> b)\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran split_def)\n  apply (auto)\n  done\n\nlemma equipotent_prod_singletonR:\n  assumes\n    a1: \"\\<^EP>{:A:}{:A':}\"\n  shows\n  \"\\<^EP>{:A \\<times> {x}:}{:A':}\"\n  apply (rule equipotent_trans [OF _ a1])\n  apply (rule equipotentI [of \"(\\<glambda> (a, b) | a \\<in> A \\<and> b = x \\<bullet> a)\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran split_def)\n  apply (auto)\n  done\n\nlemma equipotent_prod_singleton_congL:\n  assumes\n    a1: \"\\<^EP>{:A:}{:{True}:}\"\n  shows\n  \"\\<^EP>{:A \\<times> B:}{:B:}\"\n  apply (rule equipotent_trans)\n  apply (rule equipotent_prod_cong [OF a1 equipotent_refl])\n  apply (rule equipotent_prod_singletonL [OF equipotent_refl])\n  done\n\nlemma equipotent_prod_singleton_congR:\n  assumes\n    a1: \"\\<^EP>{:A:}{:{True}:}\"\n  shows\n  \"\\<^EP>{:B \\<times> A:}{:B:}\"\n  apply (rule equipotent_trans)\n  apply (rule equipotent_prod_cong [OF equipotent_refl a1])\n  apply (rule equipotent_prod_singletonR [OF equipotent_refl])\n  done\n\ntext {*\n\nThe sub-equipotence relation is a generalised form of partial ordering.\n\n*}\n\nlemma subequipotent_refl: \"\\<^sEP>{:A:}{:A:}\"\nproof -\n  have \"\\<zid> A \\<in> A \\<zinj> A\"\n    by (auto simp add: rel_id_def fun_space_defs)\n  then show ?thesis\n    by (auto simp add: subequipotent_def)\nqed\n\nlemma subequipotent_trans [trans]: \n  assumes a1: \"\\<^sEP>{:A:}{:B:}\" and a2: \"\\<^sEP>{:B:}{:C:}\"\n  shows \"\\<^sEP>{:A:}{:C:}\"\nproof -\n  from a1 [unfolded subequipotent_def] a2 [unfolded subequipotent_def]\n  show ?thesis\n  proof (auto)\n    fix f g\n    assume b1: \"f \\<in> A \\<zinj> B\" and b2: \"g \\<in> B \\<zinj> C\"\n    then have \"(f \\<zfcomp> g) \\<in> A \\<zinj> C\"\n      by (auto)\n    then show ?thesis\n      by (auto simp add: subequipotent_def)\n  qed\nqed\n\nlemma subeq_eq_trans [trans]:\n  assumes a1: \"\\<^sEP>{:A:}{:B:}\" and a2: \"\\<^EP>{:B:}{:C:}\"\n  shows \"\\<^sEP>{:A:}{:C:}\"\n  apply (rule subequipotent_trans)\n  apply (rule a1)\n  apply (rule equipotentD1)\n  apply (rule a2)\n  done\n\nlemma eq_subeq_trans [trans]:\n  assumes a1: \"\\<^EP>{:A:}{:B:}\" and a2: \"\\<^sEP>{:B:}{:C:}\"\n  shows \"\\<^sEP>{:A:}{:C:}\"\n  apply (rule subequipotent_trans)\n  apply (rule equipotentD1)\n  apply (rule a1)\n  apply (rule a2)\n  done\n\n\ninterpretation cardpre: preorder \"\\<univ>-['a set]\" \"subequipotent\"\n  apply (rule preorder_intros)\n  apply (simp)\n  apply (simp add: op2rel_def rel_def)\n  apply (rule subequipotent_refl)\n  apply (rule subequipotent_trans)\n  apply (assumption+)\n  done\n\nlemma subeq_prodL:\n  assumes \n    a1: \"\\<^sEP>{:A:}{:A':}\"\n  shows\n    \"\\<^sEP>{:A \\<times> B:}{:A' \\<times> B:}\"\nproof - \n  from a1 obtain f where\n    b1: \"f \\<in> A \\<zinj> A'\"\n    by (auto simp add: subequipotent_def)\n  let ?g = \"(\\<glambda> (a, b) | a \\<in> A \\<and> b \\<in> B \\<bullet> (f\\<cdot>a, b))\"\n  have\n    \"?g \\<in> (A \\<times> B) \\<zinj> (A' \\<times> B)\"\n    apply (mauto(fspace) msimp add: split_def)\n    apply (auto intro: tinj_inj [OF b1] tinj_range [OF b1] tinj_dom [OF b1] simp add: glambda_dom glambda_ran)\n    done\n  then show\n    \"?thesis\"\n    by (rule subequipotentI)\nqed\n\nlemma subeq_prod_com:\n  \"\\<^sEP>{:A \\<times> B:}{:B \\<times> A:}\"\n  apply (rule subequipotentI [of \"(\\<glambda> (a, b) | a \\<in> A \\<and> b \\<in> B \\<bullet> (b, a))\"])\n  apply (mauto(fspace) msimp add: split_def)\n  apply (auto simp add: glambda_dom glambda_ran)\n  done\n\nlemma subeq_prod_cong:\n  assumes \n    a1: \"\\<^sEP>{:A:}{:A':}\" and\n    a2: \"\\<^sEP>{:B:}{:B':}\"\n  shows\n    \"\\<^sEP>{:A \\<times> B:}{:A' \\<times> B':}\"\n  apply (rule subequipotent_trans)\n  apply (rule subeq_prodL [OF a1])\n  apply (rule subequipotent_trans)\n  apply (rule subeq_prod_com)\n  apply (rule subequipotent_trans)\n  apply (rule subeq_prodL [OF a2])\n  apply (rule subeq_prod_com)\n  done\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^sEP>{:A:}{:A':}\"\n  shows\n    \"\\<^sEP>{:A \\<times> B:}{:A' \\<times> B:}\"\n  by (rule subeq_prod_cong [OF a1 subequipotent_refl])\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^sEP>{:B:}{:B':}\"\n  shows\n    \"\\<^sEP>{:A \\<times> B:}{:A \\<times> B':}\"\n  by (rule subeq_prod_cong [OF subequipotent_refl a1])\n\ntext {*\n\nThe Schroeder-Bernstein Theorem, following a proof outline due to Joe Hurd.\n\n*}\n\nlemma subequipotent_antisym [trans]: \n  assumes a1: \"\\<^sEP>{:A:}{:B:}\" and a2: \"\\<^sEP>{:B:}{:A:}\"\n  shows \"\\<^EP>{:A:}{:B:}\"\nproof -\ntxt {* \nFirst we reduce the result to the case of @{text \"B\"} a subset of \n@{text A}, showing this to be enough to establish the general result.\n*}\n  { \n  presume b1:\n    \"\\<forall> Y | Y \\<subseteq> A \\<and> \\<^sEP>{:A:}{:Y:} \\<bullet> \\<^EP>{:A:}{:Y:}\"\n  from a1 a2 show ?thesis\n  proof (elim subequipotentE)\n    fix f g\n    assume c1: \"f \\<in> A \\<zinj> B\" and c2: \"g \\<in> B \\<zinj> A\"\n    from c2 have c3: \"g\\<zlImg>B\\<zrImg> \\<subseteq> A\"\n      by (mauto(fspace))\n    from c1 c2 c3 have c4: \"f \\<zfcomp> g \\<in> A \\<zinj> g\\<zlImg>B\\<zrImg>\"\n      apply (intro fcomp_in_tinjI2)\n      apply (mauto(fspace))\n      done\n    from c3 c4 [THEN subequipotentI]\n    have c5: \"\\<^EP>{:A:}{:g\\<zlImg>B\\<zrImg>:}\"\n      by (rule b1 [rule_format])\n    then obtain h where c6: \"h \\<in> A \\<zbij> g\\<zlImg>B\\<zrImg>\"\n      by (auto elim!: equipotentE)\n    from c2 have c7: \"g \\<in> B \\<zbij> g\\<zlImg>B\\<zrImg>\"\n      apply (intro in_bijI)\n      apply (mauto(fspace))\n      done\n    from c6 c7 have c8: \"h \\<zfcomp> g\\<^sup>\\<sim> \\<in> A \\<zbij> B\"\n      by (auto)\n    then show ?thesis\n      by (rule equipotentI)\n  qed\n  }\ntxt {*\nNow we must prove the special case.\n*}\n  show\n    \"\\<forall> Y | Y \\<subseteq> A \\<and> \\<^sEP>{:A:}{:Y:} \\<bullet> \\<^EP>{:A:}{:Y:}\"\n  proof (msafe_no_assms(inference))\n    fix Y \n    assume c1: \"Y \\<subseteq> A\" and c2: \"\\<^sEP>{:A:}{:Y:}\"\n    from c2 obtain f where c3: \"f \\<in> A \\<zinj> Y\"\n      by (auto elim!: subequipotentE)\ntxt {*\nThe key insight is to distinguish between elements of @{text Y}\nthat are not related\nthrough @{text \"f\"} back to @{text \"A - Y\"}, for which the identity relation\nis a suitable bijection, and those that are related back to @{text \"A - Y\"},\nfor which @{text f} is a suitable bijection. The two bijections are then pasted \ntogether to give the complete bijection.\n*}\n    let ?X = \"(f^*)\\<zlImg>A - Y\\<zrImg>\"\n    let ?h = \"(\\<glambda> x | x \\<in> A \\<bullet> \\<if> x \\<in> ?X \\<then> f\\<cdot>x \\<else> x \\<fi>)\"\n    from c3 [THEN dr_tinjD3] subset_trans [OF c3 [THEN dr_tinjD5] c1]\n    have c4: \"?X \\<subseteq> A\"\n      apply (auto simp add: subset_def)\n      apply (cases set: rtrancl)\n      apply (assumption)\n      apply (auto)\n      done\n    from c4 have c5: \"\\<forall> x | x \\<in> ?X \\<bullet> ?h\\<cdot>x = f\\<cdot>x\"\n      by (auto simp add: subset_def glambda_beta)\n    have c6: \"\\<forall> x | x \\<in> A - ?X \\<bullet> ?h\\<cdot>x = x\"\n      by (auto simp add: glambda_beta)\n    have c7: \"f\\<zlImg>?X\\<zrImg> \\<subseteq> ?X\"\n      by (auto simp add: Image_def)\n    have \"?h \\<in> A \\<zbij> Y\"\n      apply (rule in_bijIa)\n      apply (rule in_pinjI)\n      apply (mauto(fspace))\n      apply (simp_all add: glambda_dom)\n    proof -\n      show d1: \"\\<zran> ?h \\<subseteq> Y\"\n      proof (auto simp add: glambda_mem)\n        fix x \n        assume e1: \"x \\<in> A\"\n        with c3 show \"f\\<cdot>x \\<in> Y\"\n          by (auto intro!: tfun_range)\n      next\n        fix x \n        assume e1: \"x \\<in> A\" and e2: \"x \\<notin> ?X\"\n        from e2 have \"x \\<notin> A - Y\"\n          by (auto)\n        with e1 show \"x \\<in> Y\"\n          by (auto)\n      qed\n      {\n      fix x_d_1 x_d_2 y \n      assume e1: \"(x_d_1 \\<mapsto> y) \\<in> ?h\" and e2: \"(x_d_2 \\<mapsto> y) \\<in> ?h\"\n      from e1 have e3: \"?h\\<cdot>x_d_1 = y\"\n        by (rule functional_beta [OF glambda_functional])\n      from e2 have e4: \"?h\\<cdot>x_d_2 = y\"\n        by (rule functional_beta [OF glambda_functional]) \n      show \"x_d_1 = x_d_2\"\n         apply (cases \"x_d_1 \\<in> ?X\")\n         apply (cases \"x_d_2 \\<in> ?X\")\n      proof -\n        assume f1: \"x_d_1 \\<in> ?X\" and f2: \"x_d_2 \\<in> ?X\"\n        show \"x_d_1 = x_d_2\"\n        proof (rule pinj_inj)\n          from c3 show \"f \\<in> A \\<zpinj> Y\"\n            by (rule tinj_pinj)\n          from f1 c3 [THEN dr_tinjD3] subset_trans [OF c3 [THEN dr_tinjD5] c1]\n          show g1: \"x_d_1 \\<in> \\<zdom> f\"\n            apply (simp add: Image_def)\n            apply (msafe_no_assms(inference))\n            apply (cases set: rtrancl)\n            apply (assumption)\n            apply (auto)\n            done\n          from f2 c3 [THEN dr_tinjD3] subset_trans [OF c3 [THEN dr_tinjD5] c1]\n          show g2: \"x_d_2 \\<in> \\<zdom> f\"\n            apply (simp add: Image_def)\n            apply (msafe_no_assms(inference))\n            apply (cases set: rtrancl)\n            apply (assumption)\n            apply (auto)\n            done\n          from g1 f1 c3 [THEN dr_tinjD3] have \"f\\<cdot>x_d_1 = ?h\\<cdot>x_d_1\"\n            by (simp add: glambda_beta)\n          also from e3 have \"\\<dots> = y\"\n            by (simp)\n          also from e4 have \"\\<dots> = ?h\\<cdot>x_d_2\"\n            by (simp)\n          also from g2 f2 c3 [THEN dr_tinjD3] have \"\\<dots> = f\\<cdot>x_d_2\"\n            by (simp add: glambda_beta)\n          finally show \"f\\<cdot>x_d_1 = f\\<cdot>x_d_2\"\n            by (this)\n        qed\n      next\n        assume f1: \"x_d_1 \\<notin> ?X\"\n        from e1 [THEN DomainI] have f2: \"x_d_1 \\<in> A\"\n          by (simp add: glambda_dom)       \n        with f1 e3 have \"x_d_1 = y\"\n           by (simp add: glambda_beta)\n        with e2 have f3: \"(x_d_2 \\<mapsto> x_d_1) \\<in> ?h\"\n           by (simp)\n        from f1 c7 have f4: \"x_d_1 \\<notin> f\\<zlImg>?X\\<zrImg>\"\n           by (auto)\n        from f3 f4\n        show \"x_d_1 = x_d_2\"\n          apply (simp add: glambda_mem)\n          apply (msafe_no_assms(inference))\n          apply (simp)\n          apply (elim notE)\n          apply (rule ImageI)\n          apply (rule functional_appl)\n          apply (rule c3 [THEN dr_tinjD1])\n          apply (simp add: c3 [THEN dr_tinjD3])\n          apply (assumption)\n          done\n      next\n        assume f1: \"x_d_2 \\<notin> ?X\"\n        from e2 [THEN DomainI] have f2: \"x_d_2 \\<in> A\"\n          by (simp add: glambda_dom)       \n        with f1 e4 have \"x_d_2 = y\"\n           by (simp add: glambda_beta)\n        with e1 have f3: \"(x_d_1 \\<mapsto> x_d_2) \\<in> ?h\"\n           by (simp)\n        from f1 c7 have f4: \"x_d_2 \\<notin> f\\<zlImg>?X\\<zrImg>\"\n           by (auto)\n        from f3 f4\n        show \"x_d_1 = x_d_2\"\n          apply (simp add: glambda_mem)\n          apply (msafe_no_assms(inference))\n          apply (simp)\n          apply (elim notE)\n          apply (rule ImageI)\n          apply (rule functional_appl)\n          apply (rule c3 [THEN dr_tinjD1])\n          apply (simp add: c3 [THEN dr_tinjD3])\n          apply (assumption)\n          done\n      qed\n      }\n      from d1 show \"\\<zran> ?h = Y\"\n      proof (auto)\n        fix x assume e1: \"x \\<in> Y\"\n        show \"x \\<in> \\<zran> ?h\"\n        proof (cases \"x \\<in> ?X\")\n          assume f1: \"x \\<in> ?X\"\n          then show \"x \\<in> \\<zran> ?h\"\n            apply (auto)\n            apply (cases set: rtrancl)\n            apply (assumption)\n            apply (simp add: e1)\n          proof -\n            fix y z \n            assume g1: \"y \\<in> A\" \"y \\<notin> Y\" \"(y \\<mapsto> z) \\<in> f\\<^sup>*\" and g2: \"(z \\<mapsto> x) \\<in> f\"\n            from g1 have g3: \"z \\<in> ?X\"\n              by (auto simp add: Image_def)\n            with c4 have \"(z \\<mapsto> x) \\<in> ?h\"\n              apply (auto simp add: glambda_mem)\n              apply (rule functional_beta [THEN sym])\n              apply (rule c3 [THEN dr_tinjD1])\n              apply (rule g2)\n              done\n            then show \"x \\<in> \\<zran> ?h\" \n              by (auto)\n          qed\n        next\n          assume f1: \"x \\<notin> ?X\"\n          with c1 e1 have \"(x \\<mapsto> x) \\<in> ?h\"\n            by (auto simp add: glambda_mem)\n          then show \"x \\<in> \\<zran> ?h\" \n            by (auto)\n        qed\n      qed\n    qed\n    then show \"\\<^EP>{:A:}{:Y:}\"  \n      by (rule equipotentI)\n  qed\nqed\n\nlemma equipotent_iff:\n  \"\\<^EP>{:A:}{:B:} \\<Leftrightarrow> \\<^sEP>{:A:}{:B:} \\<and> \\<^sEP>{:B:}{:A:}\"\n  by (blast intro: subequipotent_antisym equipotentD1 equipotentD2)\n\nlemma epI_inj_surj:\n  assumes a1: \"inj_on f A\" \"f\\<lparr>A\\<rparr> \\<subseteq> B\"\n    and a2: \"B \\<subseteq> g\\<lparr>A\\<rparr>\"\n  shows \"\\<^EP>{:A:}{:B:}\"\n  apply (rule subequipotent_antisym)\n  apply (rule subepIinj_on)\n  apply (rule a1)\n  apply (rule a1)\n  apply (rule subepIsurj)\n  apply (rule a2)\n  done\n\nlemma inj_on_equipotent_image_inject:\n  assumes \n    a1: \"inj_on f A\" and\n    a2: \"inj_on g B\"\n  shows\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:} \\<Leftrightarrow> \\<^EP>{:A:}{:B:}\"\nproof (rule iffI)\n  assume\n    b1: \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:}\"\n  have \n    \"\\<^EP>{:A:}{:f\\<lparr>A\\<rparr>:}\"\n    by (rule equipotentIinj_on' [OF a1])\n  also have \n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:}\"\n    by (rule b1)\n  also have \n    \"\\<^EP>{:g\\<lparr>B\\<rparr>:}{:B:}\"\n    apply (rule equipotent_sym)\n    apply (rule equipotentIinj_on' [OF a2])\n    done\n  finally show\n    \"\\<^EP>{:A:}{:B:}\"\n    by (this)\nnext\n  assume \n    b1: \"\\<^EP>{:A:}{:B:}\"\n  have\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:A:}\"\n    apply (rule equipotent_sym)\n    apply (rule equipotentIinj_on' [OF a1])\n    done\n  also have \n    \"\\<^EP>{:A:}{:B:}\"\n    by (rule b1)\n  also have\n    \"\\<^EP>{:B:}{:g\\<lparr>B\\<rparr>:}\"\n    by (rule equipotentIinj_on' [OF a2])\n  finally show\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:}\"\n    by (this)\nqed\n\nlemmas inj_on_equipotent_image_cong = inj_on_equipotent_image_inject [THEN iffD2]\n\nlemma inj_on_equipotent_image:\n  assumes\n    a1: \"inj_on f A\" and\n    a2: \"\\<^EP>{:A:}{:A':}\"\n  shows\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:A':}\"\n  apply (rule equipotent_trans [OF _ a2])\n  apply (rule equipotent_sym)\n  apply (rule equipotentIinj_on' [OF a1])\n  done\n\nlemma inj_equipotent_image:\n  assumes\n    a1: \"inj f\" and\n    a2: \"\\<^EP>{:A:}{:A':}\"\n  shows\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:A':}\"\n  apply (rule inj_on_equipotent_image [OF a1 [THEN subset_inj_on] a2])\n  apply (auto)\n  done\n\nlemma inj_inj_equipotent_image_inject:\n  assumes \n    a1: \"inj f\" and\n    a2: \"inj g\" \n  shows\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:} \\<Leftrightarrow> \\<^EP>{:A:}{:B:}\"\n  apply (rule inj_on_equipotent_image_inject)\n  using a1 a2\n  apply (auto intro: subset_inj_on)\n  done\n\nlemmas inj_inj_equipotent_image_cong = inj_inj_equipotent_image_inject [THEN iffD2]\n\nlemma inj_equipotent_image_inject:\n  assumes \n    a1: \"inj f\" \n  shows\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:f\\<lparr>B\\<rparr>:} \\<Leftrightarrow> \\<^EP>{:A:}{:B:}\"\n  apply (rule inj_on_equipotent_image_inject)\n  using a1\n  apply (auto intro: subset_inj_on)\n  done\n\nlemmas inj_equipotent_image_cong = inj_equipotent_image_inject [THEN iffD2]\n\nlemma inj_on_subequipotent_image_inject:\n  assumes \n    a1: \"inj_on f A\" and\n    a2: \"inj_on g B\"\n  shows\n    \"\\<^sEP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:} \\<Leftrightarrow> \\<^sEP>{:A:}{:B:}\"\nproof (rule iffI)\n  assume\n    b1: \"\\<^sEP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:}\"\n  have \n    \"\\<^EP>{:A:}{:f\\<lparr>A\\<rparr>:}\"\n    apply (rule equipotentIinj_on [OF a1])\n    apply (simp)\n    done\n  also have \n    \"\\<^sEP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:}\"\n    by (rule b1)\n  also have \n    \"\\<^EP>{:g\\<lparr>B\\<rparr>:}{:B:}\"\n    apply (rule equipotent_sym)\n    apply (rule equipotentIinj_on [OF a2])\n    apply (simp)\n    done\n  finally show\n    \"\\<^sEP>{:A:}{:B:}\"\n    by (this)\nnext\n  assume \n    b1: \"\\<^sEP>{:A:}{:B:}\"\n  have\n    \"\\<^EP>{:f\\<lparr>A\\<rparr>:}{:A:}\"\n    apply (rule equipotent_sym)\n    apply (rule equipotentIinj_on [OF a1])\n    apply (simp)\n    done\n  also have \n    \"\\<^sEP>{:A:}{:B:}\"\n    by (rule b1)\n  also have\n    \"\\<^EP>{:B:}{:g\\<lparr>B\\<rparr>:}\"\n    apply (rule equipotentIinj_on [OF a2])\n    apply (simp)\n    done\n  finally show\n    \"\\<^sEP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:}\"\n    by (this)\nqed\n\nlemmas inj_on_subequipotent_image_cong = inj_on_subequipotent_image_inject [THEN iffD2]\n\nlemma inj_inj_subequipotent_image_inject:\n  assumes \n    a1: \"inj f\" and\n    a2: \"inj g\" \n  shows\n    \"\\<^sEP>{:f\\<lparr>A\\<rparr>:}{:g\\<lparr>B\\<rparr>:} \\<Leftrightarrow> \\<^sEP>{:A:}{:B:}\"\n  apply (rule inj_on_subequipotent_image_inject)\n  using a1 a2\n  apply (auto intro: subset_inj_on)\n  done\n\nlemmas inj_inj_subequipotent_image_cong = inj_inj_subequipotent_image_inject [THEN iffD2]\n\nlemma inj_subequipotent_image_inject:\n  assumes \n    a1: \"inj f\" \n  shows\n    \"\\<^sEP>{:f\\<lparr>A\\<rparr>:}{:f\\<lparr>B\\<rparr>:} \\<Leftrightarrow> \\<^sEP>{:A:}{:B:}\"\n  apply (rule inj_on_subequipotent_image_inject)\n  using a1\n  apply (auto intro: subset_inj_on)\n  done\n\nlemmas inj_subequipotent_image_cong = inj_subequipotent_image_inject [THEN iffD2]\n\nlemma subequipotent_iUnion:\n  assumes\n    a1: \"Disjoint { i | i \\<in> I \\<bullet> \\<P> i }\" and\n    a2: \"Disjoint { i | i \\<in> I \\<bullet> \\<Q> i }\" and\n    a3: \"inj_on \\<P> I\" and\n    a4: \"inj_on \\<Q> I\" and\n    a5: \"(\\<forall> i | i \\<in> I \\<bullet> \\<^sEP>{:\\<P> i:}{:\\<Q> i:})\"\n  shows\n    \"\\<^sEP>{:(\\<Union> i | i \\<in> I \\<bullet> \\<P> i):}{:(\\<Union> i | i \\<in> I \\<bullet> \\<Q> i):}\"\nproof -\n  from a5 obtain F where\n    b1 [rule_format]: \"(\\<forall> i | i \\<in> I \\<bullet> F i \\<in> \\<P> i \\<zinj> \\<Q> i)\"\n    by (auto simp add: subequipotent_def qual_ax_choice_eq)\n  have\n    b2: \"(\\<Union> i | i \\<in> I \\<bullet> F i) \\<in> (\\<Union> i | i \\<in> I \\<bullet> \\<P> i) \\<zinj> (\\<Union> i | i \\<in> I \\<bullet> \\<Q> i)\"\n  proof (mauto(fspace))\n    show\n      \"functional (\\<Union> i | i \\<in> I \\<bullet> F i)\"\n      apply (rule disj_rel_Union_functional')\n      using b1 [THEN tinj_functional] b1 [THEN tinj_dom]\n      apply (simp)\n      apply (simp add: b1 [THEN tinj_dom])\n      apply (rule a1 [THEN DisjointD1])\n      apply (auto simp add: inj_on_iff [OF a3])\n      done\n  next\n    show\n      \"functional ((\\<Union> i | i \\<in> I \\<bullet> F i)\\<^sup>\\<sim>)\"\n      apply (simp add: converse_Union eind_def eind_comp)\n      apply (simp add: eind_norm [of \"(\\<olambda> x \\<bullet> Union (Collect x))\"])\n      apply (rule disj_rel_Union_functional')\n      using b1 [THEN tinj_inv_functional] Z_inverse_dom b1 [THEN tinj_ran]\n      apply (simp)\n      apply (simp add: Z_inverse_dom)\n      apply (rule \n        disjoint_left_mono \n          [OF b1 [THEN tinj_ran], \n           OF _ disjoint_right_mono [OF b1 [THEN tinj_ran]],\n           OF _ _ DisjointD1 [OF a2]])\n      apply (auto simp add: inj_on_iff [OF a4])\n      done\n  next\n    show\n      \"\\<zdom> (\\<Union> i | i \\<in> I \\<bullet> F i) = (\\<Union> i | i \\<in> I \\<bullet> \\<P> i)\"\n      using b1 [THEN tinj_dom]\n      by (auto simp add: rel_Union_dom eind_def eind_comp)\n  next\n    show\n      \"\\<zran> (\\<Union> i | i \\<in> I \\<bullet> F i) \\<subseteq> (\\<Union> i | i \\<in> I \\<bullet> \\<Q> i)\"\n      using b1 [THEN tinj_ran]\n      by (auto simp add: eind_def)        \n  qed\n  then show\n    \"?thesis\"\n    by (rule subequipotentI)\nqed\n\nlemma subequipotent_iUnion':\n  assumes\n    a1: \"Disjoint \\<P>\" and\n    a2: \"Disjoint { P | P \\<in> \\<P> \\<bullet> \\<Q> P }\" and\n    a3: \"inj_on \\<Q> \\<P>\" and\n    a4: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> \\<^sEP>{:P:}{:\\<Q> P:})\"\n  shows\n    \"\\<^sEP>{:(\\<Union>\\<P>):}{:(\\<Union> P | P \\<in> \\<P> \\<bullet> \\<Q> P):}\"\n  using subequipotent_iUnion [OF _ a2 inj_on_id [of \"\\<P>\"] a3] a1 a4\n  by (simp add: eind_def)  \n\nlemma subequipotent_iUnion'':\n  assumes\n    a1: \"Disjoint \\<P>\" and\n    a2: \"Disjoint { P | P \\<in> \\<P> \\<bullet> \\<Q> P }\" and\n    a3: \"inj_on \\<Q> \\<P>\" and\n    a4: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> \\<^sEP>{:\\<Q> P:}{:P:})\"\n  shows\n    \"\\<^sEP>{:(\\<Union> P | P \\<in> \\<P> \\<bullet> \\<Q> P):}{:(\\<Union>\\<P>):}\"\n  using subequipotent_iUnion [OF a2 _ a3 inj_on_id [of \"\\<P>\"]] a1 a4\n  by (simp add: eind_def)\n\nlemma equipotent_iUnion:\n  assumes\n    a1: \"Disjoint { i | i \\<in> I \\<bullet> \\<P> i }\" and\n    a2: \"Disjoint { i | i \\<in> I \\<bullet> \\<Q> i }\" and\n    a3: \"inj_on \\<P> I\" and\n    a4: \"inj_on \\<Q> I\" and\n    a5: \"(\\<forall> i | i \\<in> I \\<bullet> \\<^EP>{:\\<P> i:}{:\\<Q> i:})\"\n  shows\n    \"\\<^EP>{:(\\<Union> i | i \\<in> I \\<bullet> \\<P> i):}{:(\\<Union> i | i \\<in> I \\<bullet> \\<Q> i):}\"\n  apply (rule subequipotent_antisym)\n  apply (rule subequipotent_iUnion [OF a1 a2 a3 a4])\n  apply (simp add: a5 [rule_format, THEN equipotentD1])\n  apply (rule subequipotent_iUnion [OF a2 a1 a4 a3])\n  apply (simp add: a5 [rule_format, THEN equipotent_sym, THEN equipotentD1])\n  done\n\nlemma equipotent_iUnion':\n  assumes\n    a1: \"Disjoint \\<P>\" and\n    a2: \"Disjoint { P | P \\<in> \\<P> \\<bullet> \\<Q> P }\" and\n    a3: \"inj_on \\<Q> \\<P>\" and\n    a4: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> \\<^EP>{:P:}{:\\<Q> P:})\"\n  shows\n    \"\\<^EP>{:(\\<Union>\\<P>):}{:(\\<Union> P | P \\<in> \\<P> \\<bullet> \\<Q> P):}\"\n  using equipotent_iUnion [OF _ a2 inj_on_id [of \"\\<P>\"] a3] a1 a4\n  by (simp add: eind_def)\n\nlemma equipotent_Plus_union:\n  assumes\n    a1: \"disjoint A B\"\n  shows\n    \"\\<^EP>{:A <+> B:}{:A \\<union> B:}\"\n  apply (rule equipotentI \n                [of \"(\\<glambda> ab | ab \\<in> A <+> B \\<bullet> \\<case> ab \\<of> Inl a \\<longrightarrow> a | Inr b \\<longrightarrow> b \\<esac>)\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran)\n  using a1\n  apply (auto simp add: glambda_dom glambda_ran Plus_def image_def disjoint_def)\n  apply (intro exI conjI disjI1)\n  apply (auto)\n  apply (intro exI conjI disjI2)\n  apply (auto)\n  done\n\nlemma equipotent_Plus_cong:\n  assumes\n    a1: \"\\<^EP>{:A:}{:A':}\" and\n    a2: \"\\<^EP>{:B:}{:B':}\"\n  shows\n    \"\\<^EP>{:A <+> B:}{:A' <+> B':}\"\nproof -\n  from a1 obtain f where\n    b1: \"f \\<in> A \\<zbij> A'\"\n    by (auto elim!: equipotentE)\n  from a2 obtain g where\n    b2: \"g \\<in> B \\<zbij> B'\"\n    by (auto elim!: equipotentE)\n  have \n    \"(\\<glambda> ab \n     | ab \\<in> A <+> B \n     \\<bullet> \\<case> ab \\<of> \n         Inl a \\<longrightarrow> Inl (f\\<cdot>a) \n         | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \n       \\<esac>) \\<in> (A <+> B) \\<zbij> (A' <+> B')\"\n    apply (mauto(fspace) msimp add: Collect_mem_eq glambda_dom glambda_ran)\n    apply (intro allI impI)\n    apply (elim conjE)\n  proof - \n    fix \n      \"ab\" and \"cd\"\n    assume\n      c1: \"ab \\<in> (A <+> B)\" and\n      c2: \"cd \\<in> (A <+> B)\"\n    with b1 b2 show\n      \"\\<case> ab \\<of> \n         Inl a \\<longrightarrow> Inl (f\\<cdot>a) \n         | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \n       \\<esac> \n       = \\<case> cd \\<of> \n           Inl a \\<longrightarrow> Inl (f\\<cdot>a) \n           | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \n         \\<esac>\n      \\<Leftrightarrow> ab = cd\"\n        by (auto simp add: tinj_inj tinj_range)\n  next\n    show \n      \"{ ab | ab \\<in> (A <+> B) \\<bullet> \\<case> ab \\<of> Inl a \\<longrightarrow> Inl (f\\<cdot>a) | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \\<esac> }\n      = A' <+> B'\"\n      apply (simp split: sum.split add: set_eq_def)\n      apply (msafe_no_assms(inference))\n    proof -\n      fix \n        \"ab\" and \n        \"ab'\"\n      assume\n        c1: \"(\\<forall> a | ab = Inl a \\<bullet> ab' = Inl (f\\<cdot>a) \\<and> Inl a \\<in> A <+> B)\" and\n        c2: \"(\\<forall> b | ab = Inr b \\<bullet> ab' = Inr (g\\<cdot>b) \\<and> Inr b \\<in> A <+> B)\"\n      with b1 b2 show \n        \"ab' \\<in> A' <+> B'\"\n        apply (cases \"ab\")\n        apply (auto simp add: tinj_range)\n        done\n    next\n      fix \n        \"ab'\"\n      assume\n        c1: \"ab' \\<in> A' <+> B'\"\n      show\n        \"(\\<exists> ab \\<bullet> \n          (\\<forall> a | ab = Inl a \\<bullet> ab' = Inl (f\\<cdot>a) \\<and> Inl a \\<in> A <+> B) \\<and> \n          (\\<forall> b | ab = Inr b \\<bullet> ab' = Inr (g\\<cdot>b) \\<and> Inr b \\<in> A <+> B))\"\n      proof (cases ab')\n        fix \n          \"a'\"\n        assume\n          d1: \"ab' = Inl a'\"\n        with b1 b2 c1 show\n          \"?thesis\"\n          apply (witness \"Inl-['a,'c] ((f\\<^sup>\\<sim>)\\<cdot>a')\")\n          apply (auto)\n          done\n      next\n        fix \n          \"b'\"\n        assume\n          d1: \"ab' = Inr b'\"\n        with b1 b2 c1 show\n          \"?thesis\"\n          apply (witness \"Inr-['c,'a] ((g\\<^sup>\\<sim>)\\<cdot>b')\")\n          apply (auto)\n          done\n      qed\n    qed\n  qed\n  then show\n    \"?thesis\"\n    by (rule equipotentI)\nqed\n\nlemma equipotent_Plus_unionIl:\n  assumes\n    a2: \"\\<^EP>{:A:}{:A':}\" and\n    a1: \"disjoint A' B\"\n  shows\n    \"\\<^EP>{:A <+> B:}{:A' \\<union> B:}\"\n  apply (rule equipotent_trans)\n  apply (rule equipotent_Plus_cong [OF a2 equipotent_refl [of \"B\"]])\n  apply (rule equipotent_Plus_union [OF a1])\n  done\n\nlemma equipotent_Plus_unionIr:\n  assumes\n    a2: \"\\<^EP>{:B:}{:B':}\" and\n    a1: \"disjoint A B'\"\n  shows\n    \"\\<^EP>{:A <+> B:}{:A \\<union> B':}\"\n  apply (rule equipotent_trans)\n  apply (rule equipotent_Plus_cong [OF equipotent_refl [of \"A\"] a2])\n  apply (rule equipotent_Plus_union [OF a1])\n  done\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^EP>{:A:}{:A':}\"\n  shows\n    \"\\<^EP>{:A <+> B:}{:A' <+> B:}\"\n  by (rule equipotent_Plus_cong [OF a1 equipotent_refl])\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^EP>{:B:}{:B':}\"\n  shows\n    \"\\<^EP>{:A <+> B:}{:A <+> B':}\"\n  by (rule equipotent_Plus_cong [OF equipotent_refl a1])\n\n\nlemma equipotent_Plus_com:\n  \"\\<^EP>{:A <+> B:}{:B <+> A:}\"\n  apply (rule equipotentI [of \"(\\<glambda> ab | ab \\<in> A <+> B \\<bullet> \\<case> ab \\<of> Inl a \\<longrightarrow> Inr a | Inr a \\<longrightarrow> Inl a \\<esac>)\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran)\n  apply (auto)\n  apply (auto split: sum.splits)\n  done\n\nlemma equipotent_Plus_assoc:\n  \"\\<^EP>{:(A <+> B) <+> C:}{:A <+> (B <+> C):}\"\n  apply (rule equipotentI [of \"(\\<glambda> abc | abc \\<in> (A <+> B) <+> C \\<bullet> \\<case> abc \\<of> Inl ab \\<longrightarrow> \\<case> ab \\<of> Inl a \\<longrightarrow> Inl a | Inr b \\<longrightarrow> Inr (Inl b) \\<esac> | Inr c \\<longrightarrow> Inr (Inr c) \\<esac>)\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran)\n  apply (auto)\n  apply (intro exI conjI)\n  defer\n  apply (rule InlI [THEN InlI, of _ \"A\" \"B\" \"C\"])\n  apply (assumption)\n  apply (intro exI conjI)\n  defer\n  apply (rule InrI [THEN InlI, of _ \"B\" \"A\" \"C\"])\n  apply (assumption)\n  apply (intro exI conjI)\n  defer\n  apply (rule InrI)\n  apply (assumption)\n  apply (auto split: sum.splits)\n  done\n\nlemma equipotent_Plus_emptyL:\n  \"\\<^EP>{:\\<emptyset> <+> B:}{:B:}\"\n  apply (rule equipotentI [of \"{ b | b \\<in> B \\<bullet> (Inr b \\<mapsto> b) }\"])\n  apply (mauto(fspace))\n  apply (auto intro!: functionalI)\n  done\n\nlemma equipotent_Plus_empty_congL:\n  assumes\n    a1: \"\\<^EP>{:B:}{:B':}\"\n  shows\n    \"\\<^EP>{:\\<emptyset> <+> B:}{:B':}\"\n  by (rule equipotent_trans [OF equipotent_Plus_emptyL a1])\n\nlemma equipotent_Plus_emptyR:\n  \"\\<^EP>{:B <+> \\<emptyset>:}{:B:}\"\n  apply (rule equipotentI [of \"{ b | b \\<in> B \\<bullet> (Inl b \\<mapsto> b) }\"])\n  apply (mauto(fspace))\n  apply (auto intro!: functionalI)\n  done\n\nlemma equipotent_Plus_empty_congR:\n  assumes\n    a1: \"\\<^EP>{:B:}{:B':}\"\n  shows\n    \"\\<^EP>{:B <+> \\<emptyset>:}{:B':}\"\n  by (rule equipotent_trans [OF equipotent_Plus_emptyR a1])\n\nlemma subequipotent_Plus_union:\n  \"\\<^sEP>{:A \\<union> B:}{:A <+> B:}\"\n  apply (rule subequipotentI [of \"(\\<glambda> a | a \\<in> A \\<union> B \\<bullet> \\<if> a \\<in> A \\<then> Inl a \\<else> Inr a \\<fi>)\"])\n  apply (mauto(fspace) msimp add: glambda_dom glambda_ran)\n  apply (auto)\n  done\n\nlemma subequipotent_Plus_cong:\n  assumes\n    a1: \"\\<^sEP>{:A:}{:A':}\" and\n    a2: \"\\<^sEP>{:B:}{:B':}\"\n  shows\n    \"\\<^sEP>{:A <+> B:}{:A' <+> B':}\"\nproof -\n  from a1 obtain f where\n    b1: \"f \\<in> A \\<zinj> A'\"\n    by (auto elim!: subequipotentE)\n  from a2 obtain g where\n    b2: \"g \\<in> B \\<zinj> B'\"\n    by (auto elim!: subequipotentE)\n  have \n    \"(\\<glambda> ab | ab \\<in> A <+> B \\<bullet> \n      \\<case> ab \\<of> Inl a \\<longrightarrow> Inl (f\\<cdot>a) | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \\<esac>) \\<in> (A <+> B) \\<zinj> (A' <+> B')\"\n    apply (mauto(fspace) msimp add: glambda_dom glambda_ran Collect_mem_eq)\n    apply (intro allI impI)\n    apply (elim conjE)\n  proof -\n    fix \n      \"ab\" and \"cd\"\n    assume\n      c1: \"ab \\<in> (A <+> B)\" and\n      c2: \"cd \\<in> (A <+> B)\"\n    with b1 b2 show\n      \"\\<case> ab \\<of> \n        Inl a \\<longrightarrow> Inl (f\\<cdot>a) \n      | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \n      \\<esac> \n      = \\<case> cd \\<of> \n          Inl a \\<longrightarrow> Inl (f\\<cdot>a) \n        | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \n        \\<esac>\n      \\<Leftrightarrow> ab = cd\"\n        by (auto simp add: tinj_inj tinj_range)\n  next\n    from b1 b2 show \n      \"{ ab | ab \\<in> (A <+> B) \\<bullet> \\<case> ab \\<of> Inl a \\<longrightarrow> Inl (f\\<cdot>a) | Inr b \\<longrightarrow> Inr (g\\<cdot>b) \\<esac> }\n      \\<subseteq> A' <+> B'\"\n      by (auto  split: sum.split simp add: subset_def)\n  qed\n  then show\n    \"?thesis\"\n    by (rule subequipotentI)\nqed\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^sEP>{:A:}{:A':}\"\n  shows\n    \"\\<^sEP>{:A <+> B:}{:A' <+> B:}\"\n  by (rule subequipotent_Plus_cong [OF a1 subequipotent_refl])\n\nlemma [mintro!(wind)]:\n  assumes\n    a1: \"\\<^sEP>{:B:}{:B':}\"\n  shows\n    \"\\<^sEP>{:A <+> B:}{:A <+> B':}\"\n  by (rule subequipotent_Plus_cong [OF subequipotent_refl a1])\n\nlemmas cartesian_equipotent_intros = \n  equipotent_refl subequipotent_refl\n  inj_on_equipotent_image inj_on_equipotent_image_cong inj_on_subequipotent_image_cong\n  equipotent_prod_cong equipotent_prod_singletonL equipotent_prod_singletonR subeq_prod_cong\n  equipotent_Plus_union equipotent_Plus_cong equipotent_Plus_empty_congL equipotent_Plus_empty_congR\n  subequipotent_Plus_union subequipotent_Plus_cong\n\ntext {*\n\nIn fact equipotentence is exactly the default equivalence generated by \nsubequipotence.\n\n*}\n\nlemma equipotent_default:\n  \"equipotent = default_equiv subequipotent\"\n  apply (intro ext)\n  apply (simp add: default_equiv_def)\n  apply (msafe_no_assms(inference))\nproof -\n  fix X Y \n{ assume \"\\<^EP>{:X:}{:Y:}\"\n  then show \"\\<^sEP>{:X:}{:Y:}\"\n    by (auto intro!: subequipotentI elim!: equipotentE)\nnext\n  assume \"\\<^EP>{:X:}{:Y:}\"\n  then show \"\\<^sEP>{:Y:}{:X:}\"\n    by (auto intro!: subequipotentI elim!: equipotentE)\nnext\n  assume \"\\<^sEP>{:X:}{:Y:}\" \"\\<^sEP>{:Y:}{:X:}\"\n  then show \"\\<^EP>{:X:}{:Y:}\"\n    by (rule subequipotent_antisym)\n}\nqed\n\ninterpretation cardqpo: partial_order \"\\<^qspace>{:\\<univ>-['a set]:}{:equipotent:}\" \"\\<^quotord>{:subequipotent:}{:equipotent:}\"\n  apply (simp_all add: equipotent_default)\n  apply (rule cardpre.default_order_congI [THEN order_cong.quotpoI])\n  done\n\nlemma equipotent_congruent:\n  \"r_congruent equipotent subequipotent\"\n  apply (simp add: r_congruent_def)\n  apply (msafe_no_assms(inference))\nproof -\n  fix y_d_1 y_d_2 z_d_1 z_d_2\n  assume \n    b1: \"\\<^EP>{:y_d_1:}{:z_d_1:}\" and\n    b2: \"\\<^EP>{:y_d_2:}{:z_d_2:}\"\n  {\n  assume b3: \"\\<^sEP>{:y_d_1:}{:y_d_2:}\"\n  from b1 have \"\\<^sEP>{:z_d_1:}{:y_d_1:}\"\n    by (rule equipotentD2)\n  also have \"\\<^sEP>{:y_d_1:}{:y_d_2:}\"\n    by (rule b3)\n  also from b2 have \"\\<^sEP>{:y_d_2:}{:z_d_2:}\"\n    by (rule equipotentD1)\n  finally show \"\\<^sEP>{:z_d_1:}{:z_d_2:}\"\n    by (this)\n  }\n  {\n  assume b3: \"\\<^sEP>{:z_d_1:}{:z_d_2:}\"\n  from b1 have \"\\<^sEP>{:y_d_1:}{:z_d_1:}\"\n    by (rule equipotentD1)\n  also have \"\\<^sEP>{:z_d_1:}{:z_d_2:}\"\n    by (rule b3)\n  also from b2 have \"\\<^sEP>{:z_d_2:}{:y_d_2:}\"\n    by (rule equipotentD2)\n  finally show \"\\<^sEP>{:y_d_1:}{:y_d_2:}\"\n    by (this)\n  }\nqed\n\nsection {* Finite sets *}\n\nlemma subequipotent_nat_interval_nat:\n  \"\\<^sEP>{:\\<lclose>0\\<dots>N::\\<nat>\\<ropen>:}{:\\<univ>-[\\<nat>]:}\"\n  apply (rule subequipotentI [of \"(\\<glambda> n | n \\<in> \\<lclose>0\\<dots>N\\<ropen> \\<bullet> n)\"])\n  apply (mauto(fspace))\n  apply (auto simp add: glambda_dom)\n  done\n\nlemma finite_card: \n  fixes F::\"'a set\"\n  shows \"finite F \\<Leftrightarrow> (\\<exists> N::\\<nat> \\<bullet> \\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:})\"\nproof (msafe_no_assms(inference))\n  assume a1: \"finite F\"\n  then show \"\\<exists> N::\\<nat> \\<bullet> \\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n  proof (induct F rule: finite_induct)\n    have \"\\<emptyset>-['a \\<times> \\<nat>] \\<in> \\<emptyset>-['a] \\<zbij> \\<lclose>0\\<dots>0\\<ropen>\"\n      by (mauto(fspace), auto simp add: functional_def interval_defs)\n    then have \"\\<^EP>{:\\<emptyset>-['a]:}{:\\<lclose>0\\<dots>(0::\\<nat>)\\<ropen>:}\"\n      by (auto simp add: equipotent_def)\n    then show \"\\<exists> N::\\<nat> \\<bullet> \\<^EP>{:\\<emptyset>-['a]:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n      apply (witness \"0::\\<nat>\")\n      apply (auto)\n      done\n  next\n    fix F::\"'a set\" and x::'a\n    assume a1: \"finite F\" and a2: \"x \\<notin> F\" and\n      a3: \"\\<exists> N::\\<nat> \\<bullet> \\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n    from a3 have \"\\<exists> (N::\\<nat>) f \\<bullet> f \\<in> F \\<zbij> \\<lclose>0\\<dots>N\\<ropen>\"\n      by (auto simp add: equipotent_def)\n    then have \"\\<exists> (M::\\<nat>) g \\<bullet> g \\<in> \\<^ins>{:x:}{:F:} \\<zbij> \\<lclose>0\\<dots>M\\<ropen>\"\n    proof (msafe_no_assms(inference))\n      fix N::\"\\<nat>\" and f::\"('a \\<times> \\<nat>)set\"\n      assume b1: \"f \\<in> F \\<zbij> \\<lclose>0\\<dots>N\\<ropen>\"\n      from b1 have b2: \"N \\<notin> \\<zran> f\"\n        by (mauto(fspace), simp)\n      from b1 b2 a2 have \"\\<^ins>{:(x \\<mapsto> N):}{:f:} \\<in> \\<^ins>{:x:}{:F:} \\<zbij> \\<lclose>0\\<dots>N+1\\<ropen>\"\n      proof (mauto(fspace))\n(*\n        show \"\\<zdom> (\\<^ins>{:(x \\<mapsto> N):}{:f:}) = \\<^ins>{:x:}{:(\\<zdom> f):}\"\n          by (simp only: fin_pfun_simp)\n      next\n*)\n        assume c1: \"\\<zran> f = \\<lclose>0\\<dots>N\\<ropen>\"\n        then show \"\\<zran> (\\<^ins>{:(x \\<mapsto> N):}{:f:}) = \\<lclose>0\\<dots>N+1\\<ropen>\"\n        proof (simp add: fin_pfun_simp)\n          show \"\\<^ins>{:N:}{:\\<lclose>0\\<dots>N\\<ropen>:} = \\<lclose>0\\<dots>Suc N\\<ropen>\"\n            by (auto simp add: interval_defs less_Suc_eq)\n        qed\n      qed\n      then show \"?thesis\" by (auto)\n    qed\n    then show \"\\<exists> N::\\<nat> \\<bullet> \\<^EP>{:\\<^ins>{:x:}{:F:}:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n      by (simp add: equipotent_def)\n  qed\nnext\n  fix N::\"\\<nat>\"\n  assume a1: \"\\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n  have a2: \"\\<forall> F::'a set \\<bullet> \\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:} \\<Rightarrow> finite F\"\n  proof (induct N type: nat, msafe_no_assms(inference))\n    fix F::\"'a set\"\n    assume b1: \"\\<^EP>{:F:}{:\\<lclose>0\\<dots>(0::\\<nat>)\\<ropen>:}\"\n    then have \"F = \\<emptyset>\"\n    proof (simp add: equipotent_def interval_defs, msafe_no_assms(inference))\n      fix f x\n      assume c1: \"f \\<in> F \\<zbij> \\<emptyset>-[\\<nat>]\"\n      then have \"f = \\<emptyset>\"\n        by (mauto(fspace), auto)\n      then have \"\\<zdom> f = \\<emptyset>\" by (auto)\n      with c1 show \"F = \\<emptyset>\"\n        by (mauto(fspace))\n    qed\n    then show \"finite F\" by (auto)\n  next\n    fix N::\"\\<nat>\" and F::\"'a set\"\n    assume b1: \"\\<forall> F::'a set \\<bullet> \\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:} \\<Rightarrow> finite F\" and\n      b2: \"\\<^EP>{:F:}{:\\<lclose>0\\<dots>Suc N\\<ropen>:}\"\n    from b2 show \"finite F\"\n    proof (simp add: equipotent_def, msafe_no_assms(inference))\n      fix f assume c1: \"f \\<in> F \\<zbij> \\<lclose>0\\<dots>Suc N\\<ropen>\"\n      then have \"\\<exists> x \\<bullet> (x \\<mapsto> N) \\<in> f\"\n        by (mauto(fspace), auto simp add: Range_def Domain_def interval_defs)\n      then have \"\\<exists> x | x \\<in> \\<zdom> f \\<bullet> (x \\<mapsto> N) \\<in> f\"\n        by (auto)\n      also from c1 have \"\\<zdom> f = F\" by (mauto(fspace))\n      finally have \"\\<exists> x | x \\<in> F \\<bullet> (x \\<mapsto> N) \\<in> f\" by (auto)\n      then show \"finite F\"\n      proof (msafe_no_assms(inference))\n        fix x assume d1: \"x \\<in> F\" and d2: \"(x \\<mapsto> N) \\<in> f\"\n        have d3: \"f - {(x \\<mapsto> N)} = ({x} \\<zdsub> f)\"\n        proof (auto simp add: dsub_def)\n          fix M \n          assume e1: \"(x \\<mapsto> M) \\<in> f\"\n          with c1 d2 show \"M = N\"\n            by (mauto(fspace), auto elim!: functionalE)\n        qed\n        have d4: \"f - {(x \\<mapsto> N)} = (f \\<zrsub> {N})\"\n        proof (auto simp add: rsub_def)\n          fix y \n          assume e1: \"(y \\<mapsto> N) \\<in> f\"\n          with c1 d2 show \"y = x\"\n            apply (mauto(fspace))\n            apply (auto elim!: functionalE)\n            done\n        qed\n        from c1 have d5: \"(f - {(x \\<mapsto> N)}) \\<in> (F - {x}) \\<zbij> \\<lclose>0\\<dots>N\\<ropen>\"\n        proof (simp only: d3, mauto(fspace))\n          show \"\\<zdom> ({x} \\<zdsub> f) = (\\<zdom> f) - {x}\"\n           by (auto simp add: dsub_def)\n        next\n          assume e1: \"\\<zran> f = \\<lclose>0\\<dots>Suc N\\<ropen>\"\n          have \"\\<zran> (f - {(x \\<mapsto> N)}) = (\\<zran> f) - {N}\"\n            by (auto simp add: d4 rsub_def)\n          also from e1 have \"\\<dots> = \\<lclose>0\\<dots>N\\<ropen>\"\n            by (auto simp add: interval_defs less_Suc_eq)\n          finally show \"\\<zran> ({x} \\<zdsub> f) = \\<lclose>0\\<dots>N\\<ropen>\"\n            by (simp add: d3)\n        qed\n        then have \"\\<^EP>{:(F - {x}):}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n          by (auto simp add: equipotent_def)\n        with b1 have \"finite (F - {x})\" by (auto)\n        then show \"finite F\" by (auto)\n      qed\n    qed\n  qed\n  with a1 show \"finite F\" by (auto)\nqed\n\nlemma finite_interval:\n  \"finite \\<lclose>0-[\\<nat>]\\<dots>N\\<ropen>\"\n  apply (simp add: finite_card)\n  apply (witness \"N\")\n  apply (rule equipotentI [of \"(\\<glambda> n | n \\<in> \\<lclose>0-[\\<nat>]\\<dots>N\\<ropen> \\<bullet> n)\"])\n  apply (mauto(fspace))\n  apply (auto simp add: glambda_dom glambda_ran)\n  done\n\nlemma finite_card': \n  fixes F::\"'a set\"\n  shows \"finite F \\<Leftrightarrow> (\\<exists> N::\\<nat> \\<bullet> \\<^sEP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:})\"\nproof (auto intro: equipotentD1 simp add: finite_card)\n  fix\n    n :: \"\\<nat>\"\n  assume\n    b1: \"\\<^sEP>{:F:}{:\\<lclose>0\\<dots>n\\<ropen>:}\"\n  then obtain f where\n    b2: \"f \\<in> F \\<zinj> \\<lclose>0\\<dots>n\\<ropen>\"\n    by (auto simp add: subequipotent_def)\n  from b2 [THEN tinj_ran] have\n    b3: \"finite (\\<zran> f)\"\n    apply (rule finite_subset)\n    apply (simp add: finite_interval)\n    done\n  have\n    b4: \"finite (f\\<^sup>\\<sim>)\"\n    apply (rule dom_finite_fun)\n    using b2 [THEN tinj_inv_pfun] b3\n    apply (mauto(fspace) msimp add: Z_inverse_dom)\n    done\n  from fun_finite_ran [OF b4] have\n    b5: \"finite F\"\n    by (simp add: Z_inverse_ran tinj_dom [OF b2])\n  then show\n    \"(\\<exists> N::\\<nat> \\<bullet> \\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:})\"\n    by (simp add: finite_card)\nqed\n\n(* Move to somewhere in Z Toolkit \n\nlemma Z_fin_pow_def:  \n  \"\\<fset> X \\<defs> { S::'b set | S \\<in> \\<pset> X \\<and> (\\<exists> n::'a::znumbers | n \\<in> zNats \\<bullet> (\\<exists> f \\<bullet> f \\<in> zint_range 1 n \\<zbij> S)) }\"\nproof (rule eq_reflection)\n  let \"?g n\" = \"(\\<glambda> k | k \\<in> \\<lclose>0\\<dots>n\\<ropen> \\<bullet> (of_nat k) + (1::'a))\"\n  have b1 [rule_format]: \"(\\<forall> n \\<bullet> ?g n \\<in> \\<lclose>0\\<dots>n\\<ropen> \\<zbij> zint_range 1 (of_nat n))\" \n  proof (msafe_no_assms(inference), mauto(fspace), simp_all)\n    fix n\n    show \"\\<zdom> (\\<glambda> k | k < n \\<bullet> (of_nat k) + (1::'a)) = \\<lclose>0\\<dots>n\\<ropen>\"\n      by (simp add: glambda_dom interval_defs)\n    show \"\\<zran> (\\<glambda> k | k < n \\<bullet> (of_nat k) + (1::'a)) = zint_range 1 (of_nat n)\"\n    proof (auto simp add: glambda_ran interval_defs nat_of_norm zNats.Rep_inverse)\n      fix k::'a\n      assume d1: \"k \\<in> zInts\" and d2: \"1 \\<le> k\" and d3: \"k \\<le> of_nat n\"\n      from d1 d2 have d4: \"k \\<in> zNats\"\n        by (auto simp add: Z_zNats_zInts_conv)\n      from d4 d2 have d5: \"0 < k\"\n        by (auto)\n      with d2 d3 d4 show \"(\\<exists> a \\<bullet> k = of_nat a + 1 \\<and> a < n)\"\n        apply (witness \"nat_of k - 1\")\n        apply (simp add: nat_of_norm zNats.Rep_inverse)\n        done\n    qed\n  qed\n  show \"\\<fset> X = { S::'b set | S \\<in> \\<pset> X \\<and> (\\<exists> n::'a::znumbers | n \\<in> zNats \\<bullet> (\\<exists> f \\<bullet> f \\<in> zint_range 1 n \\<zbij> S)) }\"\n  proof (auto simp add: fin_pow_def finite_card equipotent_def)\n    fix S::\"'b set\" and n::\\<nat> and f::\"'b \\<leftrightarrow> \\<nat>\"\n    assume c1: \"S \\<subseteq> X\" and c2: \"f \\<in> S \\<zbij> \\<lclose>0\\<dots>n\\<ropen>\"\n    show \"(\\<exists> n::'a | n \\<in> zNats \\<bullet> (\\<exists> f \\<bullet> f \\<in> zint_range 1 n \\<zbij> S))\"\n      apply (witness \"(of_nat n)::'a\")\n      apply (simp)\n      apply (witness \"((?g n)\\<^sup>\\<sim>)\\<zfcomp> (f\\<^sup>\\<sim>)\")\n      apply (rule fcomp_in_bijI)\n      apply (rule bij_inv_bij [OF b1])\n      apply (rule bij_inv_bij [OF c2])\n      done\n  next\n    fix S::\"'b set\" and n::'a and f::\"'a \\<leftrightarrow> 'b\"\n    assume c1: \"S \\<subseteq> X\" and c2: \"f \\<in> zint_range 1 n \\<zbij> S\" and c3: \"n \\<in> zNats\"\n    from bij_inv_bij [OF b1 [of \"nat_of n\"]]\n    show \"(\\<exists> (n::\\<nat>) f \\<bullet> f \\<in> S \\<zbij> \\<lclose>0\\<dots>n\\<ropen>)\"\n      apply (witness \"nat_of n\")\n      apply (witness \"(f\\<^sup>\\<sim>)\\<zfcomp> ((?g (nat_of n))\\<^sup>\\<sim>)\")\n      apply (rule fcomp_in_bijI)\n      apply (rule bij_inv_bij [OF c2])\n      apply (simp add: zNats.Abs_inverse [OF c3])\n      done\n  qed\nqed\n\nlemma Z_zcard_def:  \n  assumes a1: \"S \\<in> \\<fset> (X::'b set)\"\n  shows \"zcard S \\<defs> (\\<mu> (n::'a::znumbers) | n \\<in> zNats \\<and> (\\<exists> f \\<bullet> f \\<in> zint_range 1 n \\<zbij> S))\"\nproof (rule eq_reflection)\n  from a1\n  obtain n::'a and f where b1: \"n \\<in> zNats\" and b2: \"f \\<in> zint_range 1 n \\<zbij> S\"\n    by (auto simp add: Z_fin_pow_def [where ?'a = 'a])\n  from b2 have b3: \"((zcard S)::'a) = zcard (zint_range (1::'a) n)\"\n    by (rule zcard_Image)\n  also from b1 have \"zcard (zint_range (1::'a) n) = n\"\n    by (simp add: zint_range_zcard_from_1)\n  finally have b5: \"zcard S = n\"\n    by (simp)\n  with b2 have b6: \"f \\<in> zint_range 1 ((zcard S)::'a) \\<zbij> S\"\n    by (simp)\n  show \"zcard S = (\\<mu> (n::'a::znumbers) | n \\<in> zNats \\<and> (\\<exists> f \\<bullet> f \\<in> zint_range 1 n \\<zbij> S))\"\n    apply (rule collect_the_equality [symmetric])\n    apply (simp add: zNats_zcard)\n    apply (rule exI)\n    apply (rule b6)\n    apply (auto)\n  proof -\n    fix m::'a and f\n    assume c1: \"m \\<in> zNats\" and c2: \"f \\<in> zint_range 1 m \\<zbij> S\"\n    have \"((zcard S)::'a) = zcard (zint_range (1::'a) m)\"\n      by (rule zcard_Image [OF c2])\n    then show \"m = zcard S\"\n      by (simp add: zint_range_zcard_from_1 [OF c1])\n  qed\nqed\n*)\nlemma equipotent_empty:\n  \"\\<^EP>{:\\<emptyset>-['a]:}{:\\<emptyset>-['b]:}\"\n  apply (rule equipotentI [of \"\\<emptyset>-['a \\<times> 'b]\"])\n  apply (mauto(fspace) mintro: fin_pfunI msimp add: fin_pfun_simp vacuous_inv empty_functional)\n  done\n\nlemma equipotent_empty_iff:\n  \"\\<^EP>{:X:}{:\\<emptyset>-['b]:} \\<Leftrightarrow> X = \\<emptyset>-['a]\" \n  \"\\<^EP>{:\\<emptyset>-['b]:}{:X:} \\<Leftrightarrow> X = \\<emptyset>-['a]\" \n  apply (auto simp add: equipotent_empty)\n  apply (auto simp add: equipotent_def)\n  apply (mauto(fspace))\n  done\n\nlemma subequipotent_insert_cong:\n  assumes\n    a1: \"\\<^sEP>{:X - {x}:}{:Y - {y}:}\"\n  shows\n    \"\\<^sEP>{:insert x X:}{:insert y Y:}\"\nproof -\n  from a1 obtain f where \n    b1: \"f \\<in> (X - {x}) \\<zinj> (Y - {y})\"\n    by (auto simp add: subequipotent_def)\n  show\n    \"?thesis\"\n    apply (rule subequipotentI [of \"insert (x \\<mapsto> y) f\"])\n    using b1\n    apply (mauto_full(fspace) mintro!: insert_functionalI msimp add: insert_rinv)\n    apply (auto)\n    done\nqed\n(* J: this above is no good... have to fix up fin_fspace andeven fspace to extend the simpset!\n DONE! ! \n*)\n\nlemma equipotent_insert_cong:\n  assumes\n    a1: \"\\<^EP>{:X - {x}:}{:Y - {y}:}\"\n  shows\n    \"\\<^EP>{:insert x X:}{:insert y Y:}\"\n  using a1\n  by (simp add: equipotent_iff subequipotent_insert_cong)\n\nlemma subequipotent_insert_iff:\n  \"\\<^sEP>{:insert x X:}{:insert y Y:} \\<Leftrightarrow> \\<^sEP>{:X - {x}:}{:Y - {y}:}\"\nproof (rule iffI [OF _ subequipotent_insert_cong])\n  assume\n    b1: \"\\<^sEP>{:insert x X:}{:insert y Y:}\"\n  then obtain f where\n    b2: \"f \\<in> (insert x X) \\<zinj> (insert y Y)\"\n    by (auto simp add: subequipotent_def)\n  show\n    \"\\<^sEP>{:X - {x}:}{:Y - {y}:}\"\n  proof (cases \"y \\<in> \\<zran> f\")\n    assume\n      c1: \"y \\<in> \\<zran> f\"\n    then obtain x' where\n      c2: \"(x' \\<mapsto> y) \\<in> f\"\n      by (auto)\n    from c2 b2 have\n      c3: \"f\\<cdot>x' = y\"\n      by (mauto(fspace) mintro!: functional_beta)\n    from c2 b2 have\n      c4: \"x' \\<in> insert x X\"\n      by (mauto(fspace))\n    let \n      ?g = \"({x, x'} \\<zdsub> f)\"\n    from c4 have\n      c5: \"?g = f \\<zrsub> { f\\<cdot>x, f\\<cdot>x' }\"\n      by (auto simp add: dsub_def rsub_def tinj_unique [OF b2] tinj_inj_iff [OF b2])\n    from b2 have\n      c6: \"?g \\<in> (X \\<setminus> {x, x'}) \\<zinj> (Y \\<setminus> {f\\<cdot>x, f\\<cdot>x'})\"\n      apply (\n        mauto(fspace) \n          mintro!: dsub_functional rsub_functional \n          msimp add: dsub_rinv rsub_rinv)\n      apply (simp add: dsub_dom)\n      apply (simp add: c5 rsub_ran c3 [symmetric])\n      apply (auto)\n      done\n    show \n      \"?thesis\"\n    proof (cases \"x' = x\")\n      assume\n        d1: \"x' = x\"\n      show\n        \"?thesis\"\n        apply (rule subequipotentI [of \"?g\"])\n        using c6 c3\n        apply (simp add: d1)\n        done\n    next\n      assume\n        d1: \"x' \\<noteq> x\"\n      with c4 have \n        d2: \"x' \\<in> X\"\n        by (auto)\n      from d1 d2 c3 [symmetric] have\n        d3: \"f\\<cdot>x \\<noteq> y\"\n        by (simp add: tinj_inj_iff [OF b2])\n      from tinj_range [OF b2, of \"x\"] d3 have \n        d4: \"f\\<cdot>x \\<in> Y\"\n        by (auto)\n      show\n        \"?thesis\"\n        apply (rule subequipotentI [of \"insert (x' \\<mapsto> f\\<cdot>x) ?g\"])\n        using c6 d1\n        apply\n          (mauto(fspace)\n            mintro!: insert_functionalI \n            msimp add: dsub_rinv rsub_rinv insert_rinv Z_rel_insert_dom Z_rel_insert_ran)\n        apply (simp add: Z_dom_def rsub_def)\n        apply (mauto(inference) mintro!: disjCI')\n        apply (simp add: tinj_unique [OF b2])\n        apply (mauto(inference))\n        apply (simp add: tinj_inj_iff [OF b2])\n        defer 1\n        using d2 c3 d3 d1 d4\n        apply (simp add: dsub_def Z_ran_def subset_def)\n        apply (rule set_eqI)\n        using d2\n        apply (auto)\n        done\n    qed\n  next\n    assume\n      c1: \"y \\<notin> \\<zran> f\"\n    from tinj_ran [OF b2] c1 have\n      c2: \"\\<zran> f \\<subseteq> Y \\<setminus> {y}\"\n      by (auto)\n    let \n      ?g = \"({x} \\<zdsub> f)\"\n    show\n      \"?thesis\"\n      apply (rule subequipotentI [of \"?g\"])\n      using b2 c1 c2\n      apply\n        (mauto(fspace)\n          mintro!: insert_functionalI \n          msimp add: dsub_rinv rsub_rinv insert_rinv Z_rel_insert_dom Z_rel_insert_ran)\n      apply (simp add: dsub_dom)\n      apply (auto simp add: Z_ran_def dsub_def eind_def)\n      done\n  qed\nqed (simp)\n\nlemma equipotent_insert_iff:\n  \"\\<^EP>{:insert x X:}{:insert y Y:} \\<Leftrightarrow> \\<^EP>{:X - {x}:}{:Y - {y}:}\"\n  by (simp add: equipotent_iff subequipotent_insert_iff)\n\nlemma finite_subequipotent_card:\n  assumes\n    a1: \"finite (A::'a set)\" and\n    a2: \"finite (B::'b set)\"\n  shows\n    \"\\<^sEP>{:A:}{:B:} \\<Leftrightarrow> card A \\<le> card B\"\nproof -\n  have\n    b1 [rule_format]: \n      \"\\<forall> A::'a set | finite A \\<bullet> \\<^sEP>{:A:}{:B:} \\<Leftrightarrow> card A \\<le> card B\"\n      (is \"?P B\")\n  using a2\n  proof (induct \"B\" set: finite)\n    show\n      \"?P \\<emptyset>\"\n      by (simp add: empty_glb)\n  next\n    fix\n      B x\n    assume\n      b1: \"finite B\" and\n      b2: \"x \\<notin> B\" and\n      b3: \"?P B\"\n    from b1 show\n      \"?P (insert x B)\"\n    proof (mauto(inference) mdel: iffI)\n      fix \n        A::\"'a set\"\n      assume\n        c1: \"finite A\"\n      then show\n        \"\\<^sEP>{:A:}{:insert x B:} \\<Leftrightarrow> card A \\<le> card (insert x B)\" (is \"?Q A\")\n      proof (induct \"A\" set: finite)\n        show\n          \"?Q \\<emptyset>\"\n          by (simp add: empty_bot)\n      next\n        fix \n          A :: \"'a set\" and\n          a :: \"'a\"\n        assume\n          d1: \"finite A\" and\n          d2: \"a \\<notin> A\"\n        with b2 have\n          \"\\<^sEP>{:insert a A:}{:insert x B:}\n          \\<Leftrightarrow> \\<^sEP>{:A:}{:B:}\"\n          by (simp add: subequipotent_insert_iff)\n        also from b3 [rule_format, OF d1] have \"\\<dots>\n          \\<Leftrightarrow> card A \\<le> card B\"\n          by (this)\n        also from d1 d2 b1 b2 have \"\\<dots>\n          \\<Leftrightarrow> card (insert a A) \\<le> card (insert x B)\"\n          by (auto)     \n        finally show\n          \"?Q (insert a A)\"\n          by (this)\n      qed\n    qed\n  qed\n  with a1 show\n    \"?thesis\"\n    by (auto)\nqed\n\nlemma finite_equipotent_card:\n  assumes\n    a1: \"finite (A::'a set)\" and\n    a2: \"finite (B::'b set)\"\n  shows\n    \"\\<^EP>{:A:}{:B:} \\<Leftrightarrow> card A = card B\"\n  using a1 a2\n  by (auto simp add: equipotent_iff finite_subequipotent_card)\n\nlemma equipotent_singleton:\n  \"\\<^EP>{:{x}:}{:{y}:}\"\n  apply (subst finite_equipotent_card)\n  apply (auto)\n  done\n\nlemma equipotent_singleton_iff:\n  \"\\<^EP>{:X:}{:{y}:} \\<Leftrightarrow> (\\<exists> x \\<bullet> X = {x})\"\nproof (auto simp add: equipotent_singleton)\n  assume\n    b1: \"\\<^EP>{:X:}{:{y}:}\"\n  from b1 obtain f where\n    b2: \"f \\<in> X \\<zbij> {y}\"\n    by (auto simp add: equipotent_def)\n  then show\n    \"(\\<exists> x \\<bullet> X = {x})\"\n    apply (witness \"(f\\<^sup>\\<sim>)\\<cdot>y\")\n    apply (mauto(fspace))\n    apply (auto intro: functional_beta [symmetric] functional_ran [of \"f\\<^sup>\\<sim>\", simplified])\n    done\nqed\n\nlemma subequipotent_nat_interval_lemma:\n  fixes\n    n :: \"\\<nat>\" and \n    n' :: \"\\<nat>\"\n  shows\n   \"\\<^sEP>{:{0..<n}:}{:{0..<n'}:} \\<Leftrightarrow> \\<zid> {0..<n} \\<in> {0..<n} \\<zinj> {0..<n'}\"\nproof -\n  have \n    b1: \"(\\<forall> n \\<bullet> \\<^sEP>{:{0..<n}:}{:{0..<n'}:} \\<Rightarrow> \\<zid> {0..<n} \\<in> {0..<n} \\<zinj> {0..<n'})\" (is \"?P n'\")\n  proof (induct \"n'\" type: nat)\n    show\n      \"?P 0\" \n      apply (auto elim!: subequipotentE)\n      apply (mauto(fspace))\n      apply (auto simp add: Z_rel_id_mem Z_dom_def Z_ran_def)\n      done\n  next\n    fix\n      n' :: \"\\<nat>\"\n    assume\n      ihyp: \"?P n'\"\n    show\n      \"?P (Suc n')\"\n    proof (msafe_no_assms(inference))\n      fix \n        n :: \"\\<nat>\"\n      assume\n        d1: \"\\<^sEP>{:{0..<n}:}{:{0..<Suc n'}:}\"\n      show\n        \"\\<zid> {0..<n} \\<in> {0..<n} \\<zinj> {0..<Suc n'}\"\n      proof (cases \"n\" type: nat)\n        assume\n          e1: \"n = 0\"\n        with d1 id_in_relI [of \"{0..<0-[\\<nat>]}\"]  show\n          \"?thesis\"\n          by (mauto_full(fspace) msimp add: empty_bot)\n      next\n        fix \n          n0 :: \"\\<nat>\"\n        assume\n          e1: \"n = Suc n0\"\n        from d1 obtain f where\n          e2: \"f \\<in> {0..<n} \\<zinj> {0..<Suc n'}\" \n          by (auto simp add: subequipotent_def)\n        have\n          e3: \"\\<^sEP>{:{0..<n0}:}{:{0..<n'}:}\"\n        proof (cases \"n' \\<in> \\<zran> f\")\n          assume\n            f1: \"n' \\<notin> \\<zran> f\"\n          then have\n            \"(\\<forall> a | a \\<in> \\<zran> f \\<bullet> a \\<noteq> n')\"\n            by (auto)\n          with e2 have\n            f2: \"f \\<in> {0..<n} \\<zinj> {0..<n'}\"\n            by (mauto_full(fspace) msimp add: subset_def less_Suc_eq mdel: RangeE)\n         show\n            \"\\<^sEP>{:{0..<n0}:}{:{0..<n'}:}\"\n            apply (rule subequipotentI [of \"\\<zid> {0..<n0}\\<zfcomp> f\"])\n            apply (rule fcomp_in_tinjI2 [OF _ f2])\n            apply (mauto_full(fspace) msimp add: id_dom id_ran e1)\n            done\n        next\n          assume\n            f1: \"n' \\<in> \\<zran> f\"\n          then have\n            f2: \"((f\\<^sup>\\<sim>)\\<cdot>n' \\<mapsto> n') \\<in> f\"\n            by (rule pfun_appl [OF tinj_inv_pfun [OF e2], simplified Z_inverse_mem Z_inverse_dom])\n          have\n            f3: \"(n0 \\<mapsto> f\\<cdot>n0) \\<in> f\"\n            apply (rule tinj_appl [OF e2])\n            apply (auto simp add: e1)\n            done\n          from f2 f3 have \n            f4 [rule_format]: \n              \"f\\<cdot>n0 = n' \\<Rightarrow> (f\\<^sup>\\<sim>)\\<cdot>n' = n0\"\n              \"f\\<cdot>n0 \\<noteq> n' \\<Rightarrow> (f\\<^sup>\\<sim>)\\<cdot>n' \\<noteq> n0\"\n            apply (auto elim!: contrapos_nn)\n            apply (mauto(inference) mintro: tinj_inv_beta [OF e2] tinj_beta [OF e2])\n            done\n          show\n            \"?thesis\"\n          proof (cases \"f\\<cdot>n0 = n'\")\n            assume\n              g1: \"f\\<cdot>n0 = n'\"\n            show\n              \"?thesis\"\n              apply (rule subequipotentI [of \"{n0} \\<zdsub> f\"])\n              using Z_subset_in_pinj [rule_format, OF tinj_pinj [OF e2], of \"{n0} \\<zdsub> f\", OF Z_dsub_sub_self] e2\n              apply (mauto_full(fspace) msimp add: e1 g1 f4)\n              apply (auto simp add: dsub_mem g1 f4 tinj_unique [OF e2] e1)\n            proof -\n              fix\n                x :: \"\\<nat>\"\n              assume\n                h1: \"x \\<noteq> n0\" and\n                h2: \"x < Suc n0\"\n              from tinj_range [OF e2, of \"x\"] h2 have\n                h3: \"f\\<cdot>x < Suc n'\"\n                by (auto simp add: less_Suc_eq e1)\n              from h1 have\n                h4: \"f\\<cdot>x \\<noteq> f\\<cdot>n0\"\n                apply (rule contrapos_nn)\n                apply (rule tinj_inj [OF e2])\n                apply (auto simp add: e1 h2)\n                done\n              from h3 h4 show\n                \"f\\<cdot>x < n'\"\n                by (simp add: g1)\n            qed\n          next\n            assume\n              g1: \"f\\<cdot>n0 \\<noteq> n'\"\n            have \n              g2: \n                \"(f \\<oplus> {((f\\<^sup>\\<sim>)\\<cdot>n' \\<mapsto> f\\<cdot>n0), (n0 \\<mapsto> n')})\\<^sup>\\<sim> \n                = (f\\<^sup>\\<sim>) \\<oplus> {(f\\<cdot>n0 \\<mapsto> (f\\<^sup>\\<sim>)\\<cdot>n'), (n' \\<mapsto> n0)}\"\n              apply (auto simp add: rel_oride_mem Z_inverse_mem fin_pfun_simp tinj_beta [OF e2] tinj_inv_beta [OF e2] tinj_f_inv_f_beta [OF e2] tinj_f_f_inv_beta [OF e2 f1] e1 f4 split: if_splits)\n              apply (auto elim:  notE [OF _ tinj_inj [OF e2]] simp add: tinj_unique [OF e2] tinj_f_f_inv_beta [OF e2 f1] e1)\n              done\n(*J: bad below need fin_fspace method! ! *)\n            from  e2 f2 f3 g1 g2 have \n              g3: \"f \\<oplus> {((f\\<^sup>\\<sim>)\\<cdot>n' \\<mapsto> f\\<cdot>n0), (n0 \\<mapsto> n')} \\<in>  {0..<Suc n0} \\<zinj> {0..<Suc n'}\"\n              apply (mauto_full(fspace) msimp add: Z_rel_oride_dom_dist rel_oride_ran_dist fin_pfun_simp f4 e1)\n              apply (mauto_no_assms(fspace) mintro: fin_pfunI msimp add: fin_pfun_simp vacuous_inv empty_functional  Z_rel_oride_dom_dist rel_oride_ran_dist e1 f4)\n              apply (mstep(fspace) mintro: fin_pfunI | simp)+\n              apply (mauto(fspace) mintro: fin_pfunI msimp add: fin_pfun_simp vacuous_inv empty_functional  Z_rel_oride_dom_dist rel_oride_ran_dist e1 f4)\n              apply ((mstep(fspace) mintro: fin_pfunI)+ | simp)\n              apply ((mstep(fspace) mintro: fin_pfunI)+ | simp)\n              apply ((mstep(fspace) mintro: fin_pfunI)+ | simp)\n              apply ((mstep(fspace) mintro: fin_pfunI)+ | simp)\n              apply ((mstep(fspace) mintro: fin_pfunI) | simp)\n              using tinj_range [OF e2]\n              apply (auto simp add: e1 rel_oride_mem tinj_unique [OF e2] e1 f4 g1 fin_pfun_simp split: if_splits)\n              done\n            have\n              g4: \"{n0} \\<zdsub> (f \\<oplus> {((f\\<^sup>\\<sim>)\\<cdot>n' \\<mapsto> f\\<cdot>n0), (n0 \\<mapsto> n')}) \\<subseteq> f \\<oplus> {((f\\<^sup>\\<sim>)\\<cdot>n' \\<mapsto> f\\<cdot>n0), (n0 \\<mapsto> n')}\"\n              by (rule Z_dsub_sub_self)\n            from Z_subset_in_pinj [rule_format, OF tinj_pinj [OF g3], OF g4] have \n              \"{n0} \\<zdsub> (f \\<oplus> {((f\\<^sup>\\<sim>)\\<cdot>n' \\<mapsto> f\\<cdot>n0), (n0 \\<mapsto> n')}) \\<in> {0..<n0} \\<zinj> {0..<n'}\"\n              apply (mauto(fspace))\n              apply (auto simp add: dsub_mem rel_oride_mem fin_pfun_simp split: if_splits)\n              apply (simp add: dsub_dom Z_rel_oride_dom_dist fin_pfun_simp tinj_dom [OF e2] e1)\n              using tinj_range [OF e2, of \"n0\"] g1\n              apply (simp add: e1)\n              apply (auto simp add: tinj_unique [OF e2] e1 less_Suc_eq)\n            proof -\n              fix\n                x :: \"\\<nat>\"\n              assume\n                h1: \"x \\<noteq> (f\\<^sup>\\<sim>)\\<cdot>n'\" and\n                h2: \"x < n0\"\n              from f2 have\n                h3: \"(f\\<^sup>\\<sim>)\\<cdot>n' \\<in> \\<zdom> f\"\n                by (auto)\n              from h1 have\n                h4: \"f\\<cdot>x \\<noteq> f\\<cdot>((f\\<^sup>\\<sim>)\\<cdot>n')\"\n                apply (rule contrapos_nn)\n                apply (rule tinj_inj [OF e2])\n                using h3\n                apply (auto simp add: e1 h2 less_Suc_eq g1 tinj_dom [OF e2])\n                done\n              have \n                h5: \"f\\<cdot>((f\\<^sup>\\<sim>)\\<cdot>n') = n'\"\n                apply (rule tinj_f_f_inv_beta [OF e2])\n                using f2\n                apply (auto)\n                done\n              from h4 h5 tinj_range [OF e2, of \"x\"] h2 show\n                \"f\\<cdot>x < n'\"\n                by (auto simp add: e1)\n            qed\n            then show\n              \"?thesis\"\n              by (rule subequipotentI)\n          qed\n        qed\n        from ihyp [rule_format, OF e3] show\n          \"\\<zid> {0..<n} \\<in> {0..<n} \\<zinj> {0..<Suc n'}\"\n          apply (mauto(fspace) msimp add: e1 id_dom id_ran)\n          apply (auto)\n          done\n      qed\n    qed\n  qed\n  show \n    \"?thesis\"\n    apply (mauto(inference) mintro: b1 [rule_format])\n    apply (mauto(inference) mintro: subequipotentI)\n    done \nqed\n\nlemma subequipotent_nat_interval_iff:\n  fixes\n    m :: \"\\<nat>\" and \n    n :: \"\\<nat>\" and \n    n' :: \"\\<nat>\"\n  assumes\n    a1: \"m \\<le> n\" and\n    a2: \"m \\<le> n'\"\n  shows\n    \"\\<^sEP>{:{m..<n}:}{:{m..<n'}:} \\<Leftrightarrow> n \\<le> n'\"\n  using a1 a2\n  by (auto simp add: finite_subequipotent_card)\n\nlemma subequipotent_nat_interval_iff_empty:\n  fixes\n    m :: \"\\<nat>\" and \n    n :: \"\\<nat>\" and \n    n' :: \"\\<nat>\"\n  shows\n    \"\\<^sEP>{:{m..<n}:}{:\\<emptyset>-[\\<nat>]:} \\<Leftrightarrow> n \\<le> m\"\n  by (auto simp add: finite_subequipotent_card)\n\nlemma equipotent_nat_interval_iff:\n  fixes\n    m :: \"\\<nat>\" and \n    n :: \"\\<nat>\" and \n    n' :: \"\\<nat>\"\n  assumes\n    a1: \"m \\<le> n\" and\n    a2: \"m \\<le> n'\"\n  shows\n   \"\\<^EP>{:{m..<n}:}{:{m..<n'}:} \\<Leftrightarrow> n = n'\"\n  using a1 a2\n  by (auto simp add: finite_equipotent_card)\n\nlemma equipotent_nat_interval_iff_empty:\n  fixes\n    m :: \"\\<nat>\" and \n    n :: \"\\<nat>\" and \n    n' :: \"\\<nat>\"\n  shows\n   \"\\<^EP>{:\\<emptyset>-[\\<nat>]:}{:{m..<n'}:} \\<Leftrightarrow> n' \\<le> m\"\n   \"\\<^EP>{:{m..<n}:}{:\\<emptyset>-[\\<nat>]:} \\<Leftrightarrow> n \\<le> m\"\n  by (auto simp add: finite_equipotent_card)\n\nlemma equipotent_nat_interval_iff_0:\n  fixes\n    n :: \"\\<nat>\" and \n    n' :: \"\\<nat>\"\n  shows\n    \"\\<^EP>{:{0..<n}:}{:{0..<n'}:} \\<Leftrightarrow> n = n'\"\n    \"\\<^EP>{:\\<emptyset>-[\\<nat>]:}{:{0..<n'}:} \\<Leftrightarrow> n' = 0\"\n    \"\\<^EP>{:{0..<n}:}{:\\<emptyset>-[\\<nat>]:} \\<Leftrightarrow> n = 0\"\n  by (auto simp add: finite_equipotent_card)\n\nlemma subequipotent_int_interval_iff:\n  fixes\n    m :: \"\\<int>\" and \n    n :: \"\\<int>\" and \n    n' :: \"\\<int>\"\n  assumes\n    a1: \"m \\<le> n\" and\n    a2: \"m \\<le> n'\"\n  shows\n    \"\\<^sEP>{:{m..<n}:}{:{m..<n'}:} \\<Leftrightarrow> n \\<le> n'\"\n  using a1 a2\n  by (auto simp add: finite_subequipotent_card)\n\nlemma subequipotent_int_interval_iff_empty:\n  fixes\n    n :: \"\\<int>\" and \n    n' :: \"\\<int>\"\n  shows\n    \"\\<^sEP>{:{m..<n}:}{:\\<emptyset>-[\\<int>]:} \\<Leftrightarrow> n \\<le> m\"\n  by (auto simp add: finite_subequipotent_card)\n\nlemma equipotent_int_interval_iff:\n  fixes\n    n :: \"\\<int>\" and \n    n' :: \"\\<int>\"\n  assumes\n    a1: \"m \\<le> n\" and\n    a2: \"m \\<le> n'\"\n  shows\n   \"\\<^EP>{:{m..<n}:}{:{m..<n'}:} \\<Leftrightarrow> n = n'\"\n  using a1 a2\n  by (auto simp add: finite_equipotent_card)\n\nlemma equipotent_int_interval_iff_empty:\n  fixes\n    n :: \"\\<int>\" and \n    n' :: \"\\<int>\"\n  shows\n   \"\\<^EP>{:\\<emptyset>-[\\<int>]:}{:{m..<n'}:} \\<Leftrightarrow> n' \\<le> m\"\n   \"\\<^EP>{:{m..<n}:}{:\\<emptyset>-[\\<int>]:} \\<Leftrightarrow> n \\<le> m\"\n  by (auto simp add: finite_equipotent_card)\n\nsection {* Ordinals and equipotence *}\n\ntext {*\n\nWe need some results about ordinals and equipotence.\n\nThe representation of every ordinal is equipotent to the set of \nlower ordinals.\n\n*}\n\nlemma ordinal_equipotent:\n  \"\\<^EP>{:Rep_ordinal b:}{:{a | a < b}:}\"\nproof -\n  have b1: \"oindex\\<lparr>Rep_ordinal b\\<rparr> = {a | a < b}\"\n  proof (auto simp add: image_def)\n    fix x \n    assume c1: \"x \\<in> Rep_ordinal b\"\n    from oindex_under [of x]\n    show \"oindex x < b\"\n      apply (rule contrapos_np)\n      apply (auto simp add: linorder_not_less ole_def c1)\n      done\n  next\n    fix a\n    assume c1: \"a < b\"\n    let ?x = \"(\\<some> x | x \\<notin> Rep_ordinal a)\"\n    from order_less_le_trans [OF c1 omax_ub [of b]]\n    have c2: \"?x \\<notin> Rep_ordinal a\"\n      apply (intro someI_ex [of \"\\<olambda> x \\<bullet> x \\<notin> Rep_ordinal a\"])\n      apply (auto simp add: olt_def Romax_conv)\n      done\n    then have c3: \"a \\<le> oindex ?x\"\n      apply (simp add: oindex_def)\n      apply (rule olim_char)\n      apply (auto)\n      done\n    have c4: \"?x \\<in> Rep_ordinal (\\<osuc> a)\"\n      by (simp add: Rosuc_conv osuc_Rep_def)\n    from oindex_under [of ?x] have c5: \"oindex ?x < osuc a\"\n      apply (rule contrapos_np)\n      apply (auto simp add: linorder_not_less ole_def c4)\n      done\n    from c3 c5 [THEN osuc_char2] have c6: \"a = oindex ?x\"\n      by (rule order_antisym)\n    from c1 [THEN osuc_char] c4 have c7: \"?x \\<in> Rep_ordinal b\"\n      by (auto simp add: ole_def)\n    from c6 c7 show \"\\<exists> x \\<bullet> x \\<in> Rep_ordinal b \\<and> a = oindex x\"\n      by (auto)\n  qed\n  from ord_inj have b2: \"inj_on oindex (Rep_ordinal b)\"\n    apply (rule subset_inj_on)\n    apply (auto)\n    done\n  from b2 b1 show ?thesis\n    by (rule equipotentIinj_on)\nqed\n\ndefinition\n  ord_of :: \"'a set \\<rightarrow> 'a ordinal\"\nwhere\n  ord_of_def: \"ord_of A \\<defs> (\\<LEAST> b | \\<^sEP>{:A:}{:Rep_ordinal b:})\"\n\nlemma ord_of_wdef1:\n  \"\\<^sEP>{:A:}{:Rep_ordinal (ord_of A):}\"\nproof -\n  from univ_top [of A]\n  have \"\\<^sEP>{:A:}{:Rep_ordinal (\\<omax>::'a ordinal):}\"\n    by (simp add: Romax_conv)\n  then show ?thesis\n    apply (simp add: ord_of_def)\n    apply (rule wellorder_Least_lemma)\n    apply (assumption)\n    done\nqed\n\nlemma ord_of_wdef2:\n  assumes \n    a1: \"\\<^sEP>{:A:}{:Rep_ordinal b:}\"\n  shows \n    \"ord_of A \\<le> b\"\n  apply (simp add: ord_of_def)\n  apply (rule Least_le)\n  apply (rule a1)\n  done\n\nlemma Rep_ord_of: \n  \"\\<^EP>{:A:}{:Rep_ordinal (ord_of A):}\"\n  apply (rule subequipotent_antisym)\n  apply (rule ord_of_wdef1)\nproof -\n\tshow \"\\<^sEP>{:Rep_ordinal (ord_of A):}{:A:}\"\n\tproof (cases \"A = \\<emptyset>\")\n\t  assume b1: \"A = \\<emptyset>\"\n\t  then have \"{b::'a ordinal | \\<^sEP>{:A:}{:Rep_ordinal b:}} = \\<univ>\"\n\t    by (auto simp add: empty_bot)\n\t  then have \"ord_of A = \\<ozero>\"\n\t    apply (simp add: ord_of_def set_eq_def)\n\t    apply (rule Least_equality)\n\t    apply (auto simp add: ozero_lb)\n\t    done\n\t  then have \"Rep_ordinal (ord_of A) = \\<emptyset>\"\n\t    by (simp add: Rozero_conv)\n\t  then show \"\\<^sEP>{:Rep_ordinal (ord_of A):}{:A:}\"\n\t    by (simp add: empty_bot)\n\tnext\n\t  assume b1: \"A \\<noteq> \\<emptyset>\"\n\t  obtain \"next\" where next_def: \"next = (\\<olambda> X \\<bullet> (\\<some> x | x \\<in> A \\<and> (A-X \\<noteq> \\<emptyset> \\<Rightarrow> x \\<notin> X)))\"\n\t    by (auto)\n\t  obtain char where char_def: \"char = orec (\\<olambda> X (b::'a ordinal) \\<bullet> insert (next X) X) (\\<olambda> CL_X (b::'a ordinal) \\<bullet> \\<Union>CL_X)\"\n\t    by (auto)\n\t  obtain ind where ind_def: \"ind = (\\<olambda> (b::'a ordinal) \\<bullet> next (char b))\"\n\t    by (auto)\n\t  have b2 [rule_format]: \"\\<forall> b::'a ordinal \\<bullet> char b \\<subseteq> A\"\n\t  proof (msafe_no_assms(inference))\n\t    fix b\n\t    show \"char b \\<subseteq> A\"\n\t    proof (induct b rule: ord_baseinduct)\n\t      fix b\n\t      assume d1: \"b \\<noteq> \\<omax>\" and d2: \"char b \\<subseteq> A\"\n\t      show \"char (\\<osuc> b) \\<subseteq> A\"\n\t      proof (cases \"A-(char b) = \\<emptyset>\")\n\t        assume e1: \"A-(char b) = \\<emptyset>\"\n\t        with b1 have e2: \"\\<exists> x \\<bullet> x \\<in> A \\<and> (A-(char b) \\<noteq> \\<emptyset> \\<Rightarrow> x \\<notin> (char b))\"\n\t          by (auto)\n\t        from someI_ex [OF e2] e1 have \"next (char b) \\<in> A\"\n\t          by (auto simp add: next_def)\n\t        with d2 show \"char (\\<osuc> b) \\<subseteq> A\"\n\t          by (simp add: osuc_unwind [OF d1] char_def)\n\t      next\n\t        assume e1: \"A-(char b) \\<noteq> \\<emptyset>\"\n\t        then have e2: \"\\<exists> x \\<bullet> x \\<in> A \\<and> (A-(char b) \\<noteq> \\<emptyset> \\<Rightarrow> x \\<notin> char b)\"\n\t          by (auto)\n\t        from someI_ex [OF e2] e1 have \"next (char b) \\<in> A\"\n\t          by (auto simp add: next_def)\n\t        with d2 show \"char (\\<osuc> b) \\<subseteq> A\"\n\t          by (simp add: osuc_unwind [OF d1] char_def)\n\t      qed\n\t    next\n\t      fix b::\"'a ordinal\"\n\t      assume \"is_limit b\" and \"\\<forall> a | a < b \\<bullet> char a \\<subseteq> A\"\n\t      then show \"char b \\<subseteq> A\" \n\t        by (auto simp add: olim_unwind char_def eind_def)\n\t    qed\n\t  qed\n\t  have b3 [rule_format]: \"\\<forall> b \\<bullet> char b = {a | a < b \\<bullet> ind a}\"\n\t  proof (rule allI)\n\t    fix b\n\t    show \"char b = {a | a < b \\<bullet> ind a}\"\n\t    proof (induct b rule: ord_baseinduct)\n\t      fix b\n\t      assume d1: \"b \\<noteq> \\<omax>\" and d2: \"char b = {a | a < b \\<bullet> ind a}\"\n\t      have d3 [rule_format]: \"\\<forall> a \\<bullet> a < \\<osuc> b \\<Leftrightarrow> a < b \\<or> a = b\"\n\t        by (auto intro: order_neq_le_trans osuc_char2 order_less_trans simp add: osuc_incr [OF d1])\n\t      have \"char (\\<osuc> b) = insert (next (char b)) (char b)\"\n\t        by (auto simp add: osuc_unwind [OF d1] char_def)\n\t      also have \"\\<dots> = insert (ind b) (char b)\"\n\t        by (simp add: ind_def)\n\t      also from d2 have \"\\<dots> = insert (ind b) {a | a < b \\<bullet> ind a}\"\n\t        by (simp add: d1)\n\t      also have \"\\<dots> = {a | a < \\<osuc> b \\<bullet> ind a}\"\n\t        by (auto simp add: d3)\n\t      finally show \"char (\\<osuc> b) = {a | a < \\<osuc> b \\<bullet> ind a}\"\n\t        by (simp)\n\t    next\n\t      fix b::\"'a ordinal\"\n\t      assume \n\t        d1: \"is_limit b\" and\n\t        d2: \"\\<forall> a | a < b \\<bullet> char a = {c | c < a \\<bullet> ind c}\"\n\t      have \"char b = \\<Union>{a | a < b \\<bullet> char a}\"\n\t        by (simp add: olim_unwind [OF d1] char_def)\n\t      also have \"\\<dots> = \\<Union>{a | a < b \\<bullet> {c | c < a \\<bullet> ind c}}\"\n\t        apply (mauto(wind))\n\t        apply (auto simp add: d2)\n\t        done\n\t      also have \"\\<dots> = {a | a < b \\<bullet> ind a}\"\n\t        apply (auto simp add: eind_def)\n\t        apply (intro exI conjI)\n\t      proof -\n\t        fix a\n\t        assume e1: \"a < b\"\n\t        show \"a < \\<osuc> a\"\n\t          apply (rule osuc_incr)\n\t          apply (simp add: nonmax_conv [THEN sym])\n\t          apply (rule order_less_le_trans [OF e1 omax_ub])\n\t          done\n\t        from d1 e1 show \"\\<osuc> a < b\"\n\t         by (rule le_is_limit_osuc_le)\n\t      qed (simp)\n\t      finally show \"char b = {a | a < b \\<bullet> ind a}\"\n\t        by (this)\n\t    qed\n\t  qed\n\t  have b3a [rule_format]: \"\\<forall> a b \\<bullet> a \\<le> b \\<Rightarrow> char a \\<le> char b\"\n\t    by (auto simp add: b3 eind_def)\n\t  from b1 have b3b [rule_format]: \"\\<forall> b \\<bullet> ind b \\<in> A\"\n\t    apply (simp add: ind_def next_def)\n\t    apply (rule allI)\n\t    apply (rule someI_ex [THEN conjunct1])\n\t    apply (auto)\n\t    done\n\t  have b4 [rule_format]: \"\\<forall> b | char b \\<subset> A \\<bullet> ind b \\<notin> char b\"\n\t    apply (simp add: ind_def subset_def)\n\t    apply (msafe_no_assms(inference))\n\t  proof -\n\t    fix b \n\t    assume c1: \"char b \\<subset> A\"\n\t    then obtain x where c2: \"x \\<in> A - char b\"\n\t      by (auto)\n\t    then have \"x \\<in> A \\<and> (A - char b \\<noteq> \\<emptyset> \\<Rightarrow> x \\<notin> char b)\"\n\t      by (auto)\n\t    then have \"next (char b) \\<in> A \\<and> (A - char b \\<noteq> \\<emptyset> \\<Rightarrow> next (char b) \\<notin> char b)\"\n\t      apply (simp only: next_def)\n\t      apply (rule someI)\n\t      apply (assumption)\n\t      done\n\t    with c1 show \"next (char b) \\<notin> char b\"\n\t      by (auto)\n\t  qed\n\t  have b5 [rule_format]: \"\\<forall> b | char b \\<subset> A \\<bullet> inj_on ind {c | c \\<le> b}\"\n\t  proof (rule allI)\n\t    fix b\n\t    show \"char b \\<subset> A \\<Rightarrow> inj_on ind {c | c \\<le> b}\" (is \"?P b\")\n\t    proof (induct b)\n\t      from b1 show \"?P \\<ozero>\"\n\t        by (auto simp add: b3 ozero_bot ozero_eq)\n\t    next\n\t      fix b \n\t      assume c1: \"b \\<noteq> \\<omax>\" and c2: \"?P b\"\n\t      show \"?P (\\<osuc> b)\"\n\t      proof (rule impI)\n\t        assume d1: \"char (\\<osuc> b) \\<subset> A\"\n\t        have d2: \"char b \\<subset> A\"\n\t          apply (rule order_le_less_trans [OF _ d1])\n\t          apply (auto simp add: b3 osuc_less_le [OF c1] eind_def)\n\t          done\n\t        with c2 have d3: \"inj_on ind {c | c \\<le> b}\"\n\t          by (simp)\n\t        have d4: \"{c | c \\<le> \\<osuc> b} = insert (\\<osuc> b) {c | c \\<le> b}\"\n\t          by (auto simp add: set_eq_def osuc_less_le [OF c1] order_le_less)\n\t        from c1 [THEN osuc_incr] have d5: \"{c | c \\<le> b} - {\\<osuc> b} = {c | c \\<le> b}\"\n\t          by (auto)\n\t        from b4 [OF d1]\n\t        show \"inj_on ind {c | c \\<le> \\<osuc> b}\"\n\t          apply (simp add: d4 d3 d5)\n\t          apply (simp only: b3 Collect_image)\n\t          apply (auto simp add: osuc_less_le [OF c1])\n\t          done\n\t      qed\n\t    next\n\t      fix b assume c1: \"\\<ozero> < b\" and c2: \"is_limit b\" and\n\t        c3: \"\\<forall> a | a < b \\<bullet> ?P a\"\n\t      show \"?P b\"\n\t      proof (rule impI)\n\t        assume d1: \"char b \\<subset> A\"\n\t        show \"inj_on ind {c | c \\<le> b}\"\n\t        proof (rule inj_onI, auto simp add: order_le_less)\n\t          fix x y\n\t          assume e1: \"ind x = ind y\" and e2: \"x < b\" and e3: \"y < b\"\n\t          from e2 e3 have \"char x \\<subseteq> char b\" \"char y \\<subseteq> char b\"\n\t            by (auto simp add: b3 subset_def)\n\t          with d1 have e4: \"char x \\<subset> A\" \"char y \\<subset> A\"\n\t            by (auto)\n\t          show \"x = y\"\n\t          proof (cases x y rule: linorder_cases, auto)\n\t            assume f1: \"x < y\"\n\t            from e1 e3 e4 f1 show \"x = y\"\n\t              by (auto intro!: c3 [rule_format, THEN inj_onD])\n\t          next\n\t            assume f1: \"y < x\"\n\t            from e1 e2 e4 f1 show \"x = y\"\n\t              by (auto intro!: c3 [rule_format, THEN inj_onD])\n\t          qed\n\t        next\n\t          apply_end (rule contrapos_pp)\n\t          apply_end (assumption)\n\t          fix x assume e1: \"x < b\"\n\t          show \"ind x \\<noteq> ind b\"\n                    apply (rule not_sym)\n\t            using b4 [OF d1] e1\n\t            by (auto simp add: b3)\n\t        next\n\t          apply_end (rule contrapos_pp)\n\t          apply_end (assumption)\n\t          fix y assume \"y < b\"\n\t          with b4 [OF d1]\n\t          show \"ind b \\<noteq> ind y\"\n\t            by (auto simp add: b3)         \n\t        qed\n\t      qed\n\t    qed\n\t  qed\n\t  have b6 [rule_format]: \"\\<forall> b | char b \\<subset> A \\<bullet> \\<^sEP>{:{c | c \\<le> b}:}{:A:}\"\n\t    apply (msafe_no_assms(inference))\n\t    apply (rule subepIinj_on)\n\t    apply (rule b5)\n\t    apply (auto simp add: b3b Collect_image subset_def)\n\t    done \n\t  show ?thesis\n\t  proof (cases \"char \\<omax> = A\")\n\t    assume \"char \\<omax> \\<noteq> A\"\n\t    with b2 [of \"\\<omax>\"] have c1: \"char \\<omax> \\<subset> A\"\n\t      by (auto)\n\t    have \"\\<^EP>{:Rep_ordinal (ord_of A):}{:{c::'a ordinal | c < ord_of A}:}\"\n\t      by (rule ordinal_equipotent)\n\t    also have \"\\<^sEP>{:\\<dots>:}{:{c::'a ordinal | c \\<le> ord_of A}:}\"\n\t      apply (rule subset_subequipotent)\n\t      apply (auto)\n\t      done\n\t    also have \"\\<^sEP>{:\\<dots>:}{:A:}\"\n\t    proof (rule b6)\n\t      show \"char (ord_of A) \\<subset> A\"\n\t        apply (rule order_le_less_trans [of _ \"char \\<omax>\"])\n\t        apply (rule b3a)\n\t        apply (rule omax_ub)\n\t        apply (rule c1)\n\t        done\n\t    qed\n\t    finally show ?thesis by (this)\n\t  next\n\t    assume c1: \"char \\<omax> = A\"\n\t    let ?b = \"\\<LEAST> b | char b = A\"\n\t    from c1 have c2: \"char ?b = A\"\n\t      by (rule LeastI)\n\t    have c3 [rule_format]: \"\\<forall> a | a < ?b \\<bullet> char a \\<subset> A\"\n\t    proof (msafe_no_assms(inference))\n\t      fix a assume \"a < ?b\"\n\t      then have \"char a \\<noteq> A\"\n\t        apply (rule contrapos_pp)\n\t        apply (simp add: linorder_not_less)\n\t        apply (rule Least_le)\n\t        apply (assumption)\n\t        done\n\t      with b2 [of a] show \"char a \\<subset> A\"\n\t        by (auto)\n\t    qed\n\t    then have c4 [rule_format]: \"\\<forall> a | a < ?b \\<bullet> \\<^sEP>{:{c | c \\<le> a}:}{:A:}\"\n\t      apply (msafe_no_assms(inference))\n\t      apply (rule b6)\n\t      apply (auto)\n\t      done\n\t    have c5: \"\\<^sEP>{:{c | c < ?b}:}{:A:}\"\n\t      apply (rule subepIinj_on [of ind])\n\t      defer 1\n\t      apply (simp add: b3b Collect_image subset_def)    \n\t    proof (cases \"?b\" rule: ord_basecases)\n\t      assume d1: \"is_limit ?b\"\n\t      show \"inj_on ind {c | c < ?b}\"\n\t      proof (rule inj_onI, simp)\n\t        fix x y \n\t        assume e1: \"x < ?b\" and e2: \"y < ?b\" and e3: \"ind x = ind y\"\n\t        show \"x = y\"\n\t        proof (rule inj_onD)\n\t          show \"inj_on ind {c | c \\<le> x \\<lsup> y}\"\n\t            apply (rule b5)\n\t            apply (rule c3)\n\t            apply (cases x y rule: xHOL_Lemmas.linorder_le_cases)\n\t            apply (auto simp add: Lattice_Class.sup_max sup_max' Lattice_Class.sup_idem e1 e2)\n\t            done\n\t          show \"ind x = ind y\" by (rule e3)\n\t          show \"x \\<in> {c | c \\<le> x \\<lsup> y}\"\n\t            by (simp add: sup_ub1)\n\t          show \"y \\<in> {c | c \\<le> x \\<lsup> y}\"\n\t            by (simp add: sup_ub2)\n\t        qed\n\t      qed\n\t    next\n\t      apply_end (msafe_no_assms(inference))  \n\t      fix b assume d1: \"b \\<noteq> \\<omax>\" and d2: \"?b = \\<osuc> b\"\n\t      from d1 have \"b < \\<osuc> b\"\n\t        by (rule osuc_incr)\n\t      then have \"b < ?b\"\n\t        by (simp add: d2)\n\t      then have d3: \"char b \\<subset> A\"\n\t        by (rule c3)\n\t      from d3 have d4: \"inj_on ind {c | c \\<le> b}\"\n\t        by (rule b5)\n\t      have d5: \"{c | c < ?b} = {c | c \\<le> b}\"\n\t        apply (auto simp add: d2 osuc_char2)\n\t        apply (rule order_le_less_trans)\n\t        apply (assumption)\n\t        apply (rule osuc_incr)\n\t        apply (rule d1)\n\t        done\n\t      from d4 d5 show \"inj_on ind {c | c < ?b}\"\n\t        by (simp)\n\t    qed\n\t    with ordinal_equipotent [THEN equipotentD1]\n\t    have c6: \"\\<^sEP>{:Rep_ordinal ?b:}{:A:}\"\n\t      by (rule subequipotent_trans)\n\t    from c2 have c7: \"\\<^sEP>{:A:}{:Rep_ordinal ?b:}\"\n\t      apply (intro subequipotent_trans [OF _ ordinal_equipotent [THEN equipotentD2]])\n\t      apply (rule subepIsurj [of _ ind])\n\t      apply (simp add: b3 Collect_image)\n\t      done\n\t    from ord_of_wdef2 [OF c7]\n\t    have c8 : \"\\<^sEP>{:Rep_ordinal (ord_of A):}{:Rep_ordinal ?b:}\"\n\t      by (auto intro: subset_subequipotent simp add: ole_def)\n\t    from c8 c6 show \"\\<^sEP>{:Rep_ordinal (ord_of A):}{:A:}\"\n\t      by (rule subequipotent_trans)\n\t  qed\n\tqed\nqed\n\nlemma ord_of_conv:\n  \"ord_of (A::'a set) = (\\<LEAST> b::'a ordinal | \\<^EP>{:A:}{:Rep_ordinal b:})\"\n  apply (rule sym)\n  apply (rule Least_equality)\nproof -\n  show \"\\<^EP>{:A:}{:Rep_ordinal (ord_of A):}\"\n    by (rule Rep_ord_of)\nnext\n  fix b::\"'a ordinal\"\n  assume b1: \"\\<^EP>{:A:}{:Rep_ordinal b:}\"\n  show \"ord_of A \\<le> b\"\n    apply (rule ord_of_wdef2)\n    apply (rule equipotentD1)\n    apply (rule b1)\n    done\nqed\n\nlemma ord_of_sEP:\n  \"ord_of A \\<le> ord_of B \\<Leftrightarrow> \\<^sEP>{:A:}{:B:}\"\nproof (msafe_no_assms(inference))\n  assume b1: \"ord_of A \\<le> ord_of B\"\n  have \"\\<^EP>{:A:}{:Rep_ordinal (ord_of A):}\"\n    by (simp add: Rep_ord_of)\n  also from b1 have \"\\<^sEP>{:\\<dots>:}{:Rep_ordinal (ord_of B):}\"\n    by (simp add: ole_def subset_subequipotent)\n  also have \"\\<^EP>{:\\<dots>:}{:B:}\"\n    by (rule equipotent_sym, simp add:  Rep_ord_of)\n  finally show \"\\<^sEP>{:A:}{:B:}\"\n    by (this)\nnext\n  assume a1: \"\\<^sEP>{:A:}{:B:}\"\n  show \"ord_of A \\<le> ord_of B\"\n    apply (rule ord_of_wdef2)\n    apply (rule subequipotent_trans)\n    apply (rule a1)\n    apply (rule ord_of_wdef1)\n    done\nqed\n\nlemma linear_sEP':\n  fixes\n    A :: \"'a set\" and\n    B :: \"'a set\"\n  shows\n    \"\\<^sEP>{:A:}{:B:} \\<or> \\<^sEP>{:B:}{:A:}\"\n  apply (simp add: ord_of_sEP [symmetric])\n  apply (rule linear)\n  done\n\n\nlemma linear_sEP:\n  \"\\<^sEP>{:A:}{:B:} \\<or> \\<^sEP>{:B:}{:A:}\"\n  apply (multi_cases \"A = \\<emptyset>\" \"B = \\<emptyset>\")\n  apply (simp_all add: empty_bot nempty_conv)\n  apply (mauto(inference))\nproof -\n  fix\n    a b\n  assume\n    b1: \"a \\<in> A\" and\n    b2: \"b \\<in> B\"\n  have\n    b3: \"\\<^EP>{:A:}{:A \\<times> {b}:}\"\n    apply (rule equipotent_sym)\n    apply (rule equipotent_prod_singletonR [OF equipotent_refl])\n    done\n   have\n    b4: \"\\<^EP>{:{a} \\<times> B:}{:B:}\"\n    by (rule equipotent_prod_singletonL [OF equipotent_refl])\n from linear_sEP' [of \"A \\<times> {b}\" \"{a} \\<times> B\"] show\n    \"?thesis\"\n    apply (mauto(inference))\n    apply (rule disjI1)\n    apply (rule eq_subeq_trans)\n    apply (rule b3)\n    apply (rule subeq_eq_trans)\n    apply (assumption)\n    apply (rule b4)\n    apply (rule disjI2)\n    apply (rule eq_subeq_trans)\n    apply (rule b4 [THEN equipotent_sym])\n    apply (rule subeq_eq_trans)\n    apply (assumption)\n    apply (rule b3 [THEN equipotent_sym])\n    done\nqed\n\n\nlemma ord_of_EP:\n  \"ord_of A = ord_of B \\<Leftrightarrow> \\<^EP>{:A:}{:B:}\"\n  by (simp add: order_eq_iff equipotent_iff ord_of_sEP)\n\ninterpretation \n  cardqord: \n    order \n      \"\\<^qspace>{:\\<univ>-['a set]:}{:equipotent:}\" \n      \"\\<^quotord>{:subequipotent:}{:equipotent:}\"\n  apply (rule cardqpo.orderIa)\n  apply (simp add: quot_set_def)\n  apply (msafe_no_assms(inference))\n  apply (simp)\nproof -\n  fix \n    A :: \"'a set\" and\n    B :: \"'a set\"\n  from linear_sEP [of A B] show\n    \"\\<^infopa>{:\\<^eclass>{:A:}{:equipotent:}:}{:\n      \\<^quotord>{:subequipotent:}{:equipotent:}:}{:\\<^eclass>{:B:}{:equipotent:}:} \n    \\<or> \\<^infopa>{:\\<^eclass>{:B:}{:equipotent:}:}{:\n      \\<^quotord>{:subequipotent:}{:equipotent:}:}{:\\<^eclass>{:A:}{:equipotent:}:}\"\n    by (auto simp add: quot_order_def rel2op_def)\nqed\n\n\nsection {* Infinite sets *}\n\nlemma infinite_card': \n  fixes F::\"'a set\"\n  shows \"infinite F \\<Leftrightarrow> (\\<forall> N::\\<nat> \\<bullet> \\<^sEP>{:\\<lclose>0\\<dots>N\\<ropen>:}{:F:})\"\n  apply (subst iff_conv_conj_imp)\n  apply (simp add: finite_card')\n  apply (rule conjI)\nproof -\n  show\n    \"(\\<forall> N::\\<nat> \\<bullet> \\<not>\\<^sEP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}) \\<Rightarrow> (\\<forall> N::\\<nat> \\<bullet> \\<^sEP>{:\\<lclose>0\\<dots>N\\<ropen>:}{:F:})\"\n    apply (mauto(wind))\n    apply (mauto(inference))\n  proof -\n    fix\n      N::\"\\<nat>\"\n    assume\n      c1: \"\\<not>\\<^sEP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n    with linear_sEP [of \"F\" \"\\<lclose>0\\<dots>N\\<ropen>\"] show\n      \"\\<^sEP>{:\\<lclose>0\\<dots>N\\<ropen>:}{:F:}\"\n      by (auto)\n  qed\nnext\n  apply_end (mauto(inference))\n  fix\n    N::\"\\<nat>\"\n  assume\n    b1: \"(\\<forall> N::\\<nat> \\<bullet> \\<^sEP>{:\\<lclose>0\\<dots>N\\<ropen>:}{:F:})\"\n  then show\n    \"\\<not>\\<^sEP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n    apply (rule contrapos_pn)\n    apply (auto)\n    apply (witness \"Suc N\")\n    apply (auto)\n  proof -\n    assume\n      c1: \"\\<^sEP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}\" and\n      c2: \"\\<^sEP>{:\\<lclose>0\\<dots>Suc N\\<ropen>:}{:F:}\"\n    from c2 c1 have\n      c3: \"\\<^sEP>{:\\<lclose>0\\<dots>Suc N\\<ropen>:}{:\\<lclose>0\\<dots>N\\<ropen>:}\"\n      by (rule subequipotent_trans)\n    with subequipotent_nat_interval_iff [of \"0\" \"Suc N\" \"N\"] show\n      \"\\<False>\"\n      by (auto simp add: interval_defs)\n  qed\nqed\n\nprimrec\n  nat_maps_to_chain :: \"'a set \\<rightarrow> \\<nat> \\<rightarrow> (\\<nat> \\<leftrightarrow> 'a)\"\nwhere\n  \"nat_maps_to_chain A 0 = \\<emptyset>\"\n| \"nat_maps_to_chain A (Suc n) \n   = (nat_maps_to_chain A n) \\<union> \n     { (n \\<mapsto> (\\<some> a | a \\<in> A \\<and> a \\<notin> \\<zran> (nat_maps_to_chain A n))) }\"\n\ndefinition\n  \"nat_index A = (\\<Union> N \\<bullet> nat_maps_to_chain A N)\"\n\nlemma infinite_nat_index:\n  assumes\n    a1: \"infinite F\"\n  shows\n    \"nat_index F \\<in> \\<univ>-[\\<nat>] \\<zinj> F\"\n  using a1\nproof (auto simp add: infinite_card')\n  assume\n    b1: \"(\\<forall> N::\\<nat> \\<bullet> \\<^sEP>{:\\<lclose>0\\<dots>N\\<ropen>:}{:F:})\"\n{\n  fix\n    N\n  have\n    \"nat_maps_to_chain F N \\<in> \\<lclose>0\\<dots>N\\<ropen> \\<zinj> F\"\n  proof (induct \"N\")\n    show\n      \"nat_maps_to_chain F 0 \\<in> \\<lclose>0\\<dots>0\\<ropen> \\<zinj> F\"\n      apply (simp add: interval_defs)\n      apply (mauto(fspace) msimp add: empty_functional converse_empty)\n      done\n  next\n    fix\n      N\n    assume\n      c1: \"nat_maps_to_chain F N \\<in> \\<lclose>0\\<dots>N\\<ropen> \\<zinj> F\"\n    have\n      c2: \"finite (nat_maps_to_chain F N)\"\n      apply (rule dom_finite_fun [OF c1 [THEN tinj_functional]])\n      apply (simp add: c1 [THEN tinj_dom] interval_defs)\n      done\n    then have\n      c3: \"finite (\\<zran> (nat_maps_to_chain F N))\"\n      by (rule fun_finite_ran)\n    from c1 [THEN tinj_ran] have\n      c4: \"\\<zran> (nat_maps_to_chain F N) \\<subset> F\"\n    proof (auto)\n      assume\n        d1: \"\\<zran> (nat_maps_to_chain F N) = F\"\n      from \n        fun_card_dom [OF tinj_functional [OF c1]] \n        fun_card_dom [OF tinj_inv_functional [OF c1], symmetric]\n      have\n        d2: \"card (\\<zran> (nat_maps_to_chain F N)) = N\"\n        by (auto simp add: \n              inverse_card [of \"nat_maps_to_chain F N\"]\n              tinj_dom [OF c1] cINTVLo_atLeastLessThan)\n      from b1 [rule_format, of \"Suc N\"] d2 card_infinite [of \"\\<zran> (nat_maps_to_chain F N)\"] have\n        d4: \"Suc N \\<le> N\"\n        apply (subst (asm) d1 [symmetric])\n        apply (subst (asm) finite_subequipotent_card)\n        apply (auto simp add: cINTVLo_atLeastLessThan c3)\n        done\n      then show\n        \"\\<False>\"\n        by (auto)\n    qed\n    then have\n      c5: \"(\\<exists> a \\<bullet> a \\<in> F \\<and> a \\<notin> \\<zran> (nat_maps_to_chain F N))\"\n      by (auto)\n    from someI_ex [OF c5] c1 show\n      \"nat_maps_to_chain F (Suc N) \\<in> \\<lclose>0\\<dots>Suc N\\<ropen> \\<zinj> F\"\n      apply (simp)\n      apply (mauto(fspace) msimp add: insert_functional)\n      apply (rule disjI1)\n      apply (simp add: interval_defs)\n      apply (auto simp add: interval_defs)\n      done\n  qed\n} note b2 = this\n{\n  fix\n    M::\\<nat> and N::\\<nat>\n  have\n    \"M \\<le> N \\<Rightarrow> nat_maps_to_chain F M \\<subseteq> nat_maps_to_chain F N\"\n    apply (induct \"N\")\n    apply (simp)\n    apply (simp add: less_Suc_eq_le le_less)\n    apply (auto)\n    done\n} note b3 = this\n  show\n    \"?thesis\"\n  proof (mauto(fspace) mintro!: functionalI msimp add: Z_inverse_mem)\n    fix\n      n a b\n    assume\n      c1: \"(n \\<mapsto> a) \\<in> nat_index F\" and\n      c2: \"(n \\<mapsto> b) \\<in> nat_index F\"\n    from c1 obtain N where\n      c3: \"(n \\<mapsto> a) \\<in> nat_maps_to_chain F N\"\n      by (auto simp add: nat_index_def)\n    from c2 obtain M where\n      c4: \"(n \\<mapsto> b) \\<in> nat_maps_to_chain F M\"\n      by (auto simp add: nat_index_def)\n    from c3 b3 [of \"N\" \"max N M\"] have\n      c5: \"(n \\<mapsto> a) \\<in> nat_maps_to_chain F (max N M)\"\n      by (auto)\n    from c4 b3 [of \"M\" \"max N M\"] have\n      c6: \"(n \\<mapsto> b) \\<in> nat_maps_to_chain F (max N M)\"\n      by (auto)\n    from c5 c6 show\n      \"a = b\"\n      by (simp add: b2 [of \"max N M\", THEN tinj_unique])\n  next\n    fix\n      n m a\n    assume\n      c1: \"(n \\<mapsto> a) \\<in> nat_index F\" and\n      c2: \"(m \\<mapsto> a) \\<in> nat_index F\"\n    from c1 obtain N where\n      c3: \"(n \\<mapsto> a) \\<in> nat_maps_to_chain F N\"\n      by (auto simp add: nat_index_def)\n    from c2 obtain M where\n      c4: \"(m \\<mapsto> a) \\<in> nat_maps_to_chain F M\"\n      by (auto simp add: nat_index_def)\n    from c3 b3 [of \"N\" \"max N M\"] have\n      c5: \"(n \\<mapsto> a) \\<in> nat_maps_to_chain F (max N M)\"\n      by (auto)\n    from c4 b3 [of \"M\" \"max N M\"] have\n      c6: \"(m \\<mapsto> a) \\<in> nat_maps_to_chain F (max N M)\"\n      by (auto)\n    from c5 c6 show\n      \"n = m\"\n      apply (simp add: b2 [of \"max N M\", THEN tinj_unique])\n      apply (rule tinj_inj [OF b2 [of \"max N M\"]])\n      apply (auto simp add: interval_defs)\n      done\n  next\n    show\n      \"\\<zdom> (nat_index F) = \\<univ>\"\n      apply (simp add: nat_index_def rel_Union_dom' tinj_dom  [OF b2])\n      apply (auto)\n      done\n  next\n    show\n      \"\\<zran> (nat_index F) \\<subseteq> F\"\n      apply (simp add: nat_index_def rel_Union_ran')\n      using tinj_ran [OF b2]\n      apply (auto simp add: eind_def)\n      done\n  qed\nqed\n\nlemma infinite_card: \n  fixes F::\"'a set\"\n  shows \"infinite F \\<Leftrightarrow> \\<^sEP>{:\\<univ>-[\\<nat>]:}{:F:}\"\n  using infinite_nat_index [THEN subequipotentI, of \"F\"]\nproof (auto simp add: infinite_card')\n  fix\n    N::\\<nat>\n  assume\n    b1: \"\\<^sEP>{:\\<univ>-[\\<nat>]:}{:F:}\"\n  then obtain f where\n    b2: \"f \\<in> \\<univ>-[\\<nat>] \\<zinj> F\"\n    by (auto simp add: subequipotent_def)\n  with dres_subset_in_tfunI [OF tinj_tfun [OF b2], of \"\\<lclose>0\\<dots>N\\<ropen>\"] have\n    b3: \"\\<lclose>0\\<dots>N\\<ropen> \\<zdres> f \\<in> \\<lclose>0\\<dots>N\\<ropen> \\<zinj> F\"\n    apply (simp)\n    apply (mauto(fspace))\n    done\n  then show\n    \"\\<^sEP>{:\\<lclose>0\\<dots>N\\<ropen>:}{:F:}\"\n    by (auto simp add: subequipotent_def)\nqed\n\nclass infinite =\n  assumes \n    nat_subep_UNIV: \"\\<^sEP>{:\\<univ>-[\\<nat>]:}{:\\<univ>-['a]:}\"\nbegin\n\nlemma infinite_UNIV:\n  \"infinite \\<univ>-['a]\"\n  apply (rule infinite_card [THEN iffD2])\n  apply (rule nat_subep_UNIV)\n  done\n\ndefinition\n  \"nat_index_op = \\<opof> (nat_index \\<univ>-['a])\"\n\nlemma nat_index_op_inj:\n  \"inj nat_index_op\"\n  apply (simp add: nat_index_op_def)\n  apply (rule fun_of_f_inj)\n  apply (rule infinite_nat_index)\n  apply (rule infinite_UNIV)\n  done\n\nend\n\nlemma infinite_ep_infinite:\n  assumes\n    a1: \"infinite A\" and\n    a2: \"A \\<asymp> B\"\n  shows\n    \"infinite B\"\n  using a1 subequipotent_trans [OF _ equipotentD1 [OF a2]]\n  by (auto simp add: infinite_card)\n\nlemma infinite_sep_infinite:\n  assumes\n    a1: \"infinite A\" and\n    a2: \"A \\<preceq> B\"\n  shows\n    \"infinite B\"\n  using a1 subequipotent_trans [OF _ a2]\n  by (auto simp add: infinite_card)\n\nlemma finite_sub_infinite:\n  assumes \n    a1: \"finite F\" and\n    a2: \"infinite A\"\n  shows\n    \"\\<^sEP>{:F:}{:A:}\"\n  using a1 a2\n  apply (subst (asm) finite_card)\n  apply (subst (asm) infinite_card)\n  apply (auto)\n  apply (rule \n           subequipotent_trans \n             [OF _ subequipotent_trans [OF subequipotent_nat_interval_nat]])\n  apply (auto intro: equipotentD1)\n  done\n\nlemma finite_neq_infinite:\n  assumes \n    a1: \"finite F\" and\n    a2: \"infinite A\"\n  shows\n    \"\\<^nEP>{:F:}{:A:}\"\n  using a1\nproof (auto simp add: finite_card)\n  fix\n    N :: \"\\<nat>\"\n  assume\n    b1: \"F \\<asymp> \\<lclose>0\\<dots>N\\<ropen>\" and\n    b2: \"F \\<asymp> A\"\n  from b2 [symmetric] b1 have\n    b3: \"A \\<asymp> \\<lclose>0\\<dots>N\\<ropen>\"\n    by (rule equipotent_trans)\n  moreover from a2 have\n    b4: \"A \\<notasymp> \\<lclose>0\\<dots>N\\<ropen>\"\n    by (auto simp add: finite_card)\n  ultimately show\n    \"\\<False>\"\n    by (contradiction)\nqed\n\nlemma seq_not_infinite_finite:\n  assumes \n    a1: \"A \\<preceq> B\"\n  shows\n    \"\\<not> (finite B \\<and> infinite A)\"\nproof (mauto(inference) mintro!: notI)\n  assume\n    b1: \"finite B\" and\n    b2: \"infinite A\"\n  from \n    subequipotent_antisym [OF a1 finite_sub_infinite [OF b1 b2], symmetric] \n    finite_neq_infinite [OF b1 b2]\n  show\n    \"\\<False>\"\n    by (contradiction)\nqed\n\nlemma countable_card: \n  fixes F::\"'a set\"\n  shows \"countable F \\<Leftrightarrow> \\<^sEP>{:F:}{:\\<univ>-[\\<nat>]:}\"\nproof (auto simp add: countable_def)\n  fix \n    f::\"'a \\<rightarrow> \\<nat>\"\n  assume\n    b1: \"inj_on f F\"\n  show\n    \"\\<^sEP>{:F:}{:\\<univ>-[\\<nat>]:}\"\n    apply (rule subequipotentI [of \"F \\<zdres> (\\<graphof> f)\"])\n    apply (mauto(fspace) mintro!: functionalI)\n    apply (auto simp add: dres_mem graph_of_def glambda_mem inj_onD [OF b1])\n    done\nnext\n  assume\n    b1: \"\\<^sEP>{:F:}{:\\<univ>-[\\<nat>]:}\"\n  then obtain f where\n    b2: \"f \\<in> F \\<zinj> \\<univ>-[\\<nat>]\"\n    by (auto simp add: subequipotent_def)\n  have\n    \"inj_on (\\<opof> f) F\"\n    apply (rule inj_onI)\n    apply (auto intro: tinj_inj [OF b2])\n    done\n  then show\n    \"(\\<exists> f::'a \\<rightarrow> \\<nat> \\<bullet> inj_on f F)\"\n    by (auto)\nqed\n\nabbreviation\n  \"countable_inf P\n  \\<defs> infinite P \\<and> countable P\"\n\nlemma countable_inf_card: \n  fixes F::\"'a set\"\n  shows \"countable_inf F \\<Leftrightarrow> \\<^EP>{:F:}{:\\<univ>-[\\<nat>]:}\"\n  apply (simp add: infinite_card countable_card)\n  apply (auto intro: subequipotent_antisym equipotentD1 equipotentD2)\n  done\n\nlemmas countable_infD = countable_inf_card [THEN iffD1]\nlemmas countable_infI = countable_inf_card [THEN iffD2]\n\nlemma finite_subeq_countable_inf:\n  assumes\n    a1: \"finite F\" and\n    a2: \"countable_inf A\"\n  shows\n    \"\\<^sEP>{:F:}{:A:}\"\n  using a1 a2\n  apply (subst (asm) countable_inf_card)\n  apply (auto simp add: finite_card)\nproof -\n  fix\n    N :: \"\\<nat>\"\n  assume\n    b1: \"\\<^EP>{:F:}{:\\<lclose>0\\<dots>N\\<ropen>:}\" and\n    b2: \"\\<^EP>{:A:}{:\\<univ>-[\\<nat>]:}\"\n  note b1\n  also have \"\\<^sEP>{:\\<lclose>0\\<dots>N\\<ropen>\n    :}{:\\<univ>-[\\<nat>]:}\"\n    by (rule subequipotent_nat_interval_nat)\n  also note b2 [symmetric]\n  finally show\n    \"\\<^sEP>{:F:}{:A:}\"\n    by (this)\nqed\n\nlemma infinite_card'': \n  fixes F::\"'a set\"\n  shows \"infinite F \\<Leftrightarrow> (\\<exists> F' \\<bullet> F' \\<subseteq> F \\<and> countable_inf F')\"\n  apply (subst infinite_card)\n  apply (subst countable_inf_card)\n  apply (mauto(inference))\nproof -\n  assume\n    b1: \"\\<^sEP>{:\\<univ>-[\\<nat>]:}{:F:}\"\n  have\n    b2: \"(\\<exists> F' \\<bullet> F' \\<subseteq> F \\<and> \\<^EP>{:F':}{:\\<univ>-[\\<nat>]:})\n    \\<Leftrightarrow> (\\<exists> F' \\<bullet> F' \\<subseteq> F \\<and> \\<^EP>{:\\<univ>-[\\<nat>]:}{:F':})\"\n    apply (mauto(wind))\n    apply (auto intro: equipotent_sym)\n    done\n   from b1 show\n    \"(\\<exists> F' \\<bullet> F' \\<subseteq> F \\<and> \\<^EP>{:F':}{:\\<univ>-[\\<nat>]:})\"\n    apply (simp add: b2)\n    apply (auto simp add: subequipotent_eq_inj_on equipotent_eq_inj_on)\n    done\nnext\n  fix \n    F'\n  assume\n    b1: \"F' \\<subseteq> F\" and\n    b2: \"\\<^EP>{:F':}{:\\<univ>-[\\<nat>]:}\"\n  from b2 [symmetric] subset_subequipotent [OF b1] show\n    \"\\<^sEP>{:\\<univ>-[\\<nat>]:}{:F:}\"\n    by (rule eq_subeq_trans)\nqed\n\nlemma finite_subeq_infinite:\n  assumes\n    a1: \"finite F\" and\n    a2: \"infinite A\"\n  shows\n    \"\\<^sEP>{:F:}{:A:}\"\n  using a2\n  apply (subst (asm) infinite_card'')\n  apply (elim exE conjE)\n  apply (rule subequipotent_trans)\n  apply (rule finite_subeq_countable_inf [OF a1])\n  apply (auto intro: subset_subequipotent)\n  done\n\nlemma infinite_partition:\n  assumes\n    a1: \"infinite A\"\n  shows\n    \"(\\<exists> \\<P> \\<bullet> \n      (\\<forall> P | P \\<in> \\<P> \\<bullet> countable_inf P) \\<and> \n      Disjoint \\<P> \\<and>\n      (\\<Union>\\<P>) = A)\"\nproof -\n  let\n    ?\\<A> \n    = \"{ \\<P> | \n        (\\<forall> P | P \\<in> \\<P> \\<bullet> countable_inf P) \\<and> \n        Disjoint \\<P> \\<and> \n        (\\<Union>\\<P>) \\<subseteq> A}\"\n{\n  fix\n    \\<P> P\n  assume\n    b1: \"\\<P> \\<in> ?\\<A>\" and\n    b2: \"P \\<in> \\<P>\"\n  then have\n    \"countable_inf P\"\n    by (auto)\n} note b2 = this\n{\n  fix\n    \\<P> P P'\n  assume\n    b1: \"\\<P> \\<in> ?\\<A>\" and\n    b2: \"P \\<in> \\<P>\" and\n    b3: \"P' \\<in> \\<P>\" and\n    b4: \"P \\<inter> P' \\<noteq> \\<emptyset>\"\n  then have\n    \"P = P'\"\n    apply (intro DisjointD1')\n    apply (auto simp add: disjoint_def)\n    done\n} note b3 = this\n{\n  fix\n    \\<P> P P'\n  assume\n    b1: \"\\<P> \\<in> ?\\<A>\" and\n    b2: \"P \\<in> \\<P>\" and\n    b3: \"P' \\<in> \\<P>\" and\n    b4: \"P = P'\"\n  then have\n    \"P \\<inter> P' \\<noteq> \\<emptyset>\"\n    by (auto)\n} note b3' = this\n{\n  fix\n    \\<P>\n  assume\n    b1: \"\\<P> \\<in> ?\\<A>\"\n  then have\n    \"(\\<Union>\\<P>) \\<subseteq> A\"\n    by (auto)\n} note b4 = this \n  have  \n    \"(\\<exists> \\<P> \\<bullet> \\<P> \\<in> ?\\<A> \\<and> (\\<forall> \\<P>' \\<bullet> \\<P>' \\<in> ?\\<A> \\<Rightarrow> \\<P> \\<subseteq> \\<P>' \\<Rightarrow> \\<P>' = \\<P>))\"\n  proof (rule subset_Zorn' [of \"?\\<A>\", simplified Ball_def Bex_def])\n    fix \n      C\n    assume\n      c1: \"subset.chain ?\\<A> C\"\n    then have\n      c2: \"C \\<subseteq> ?\\<A>\"\n      by (simp add: pred_on.chain_def)\n    show\n      \"\\<Union>C \\<in> ?\\<A>\"\n      apply (simp add: Disjoint_def' disjoint_def)\n      apply (mauto(inference))\n    proof -\n      fix\n        \\<P> P\n      assume\n        d1: \"\\<P> \\<in> C\" and\n        d2: \"P \\<in> \\<P>\"\n      from c2 [THEN subsetD, THEN b2, OF d1 d2] show\n        \"countable P\"\n        \"infinite P\"\n        by (auto)\n    next\n      fix\n        \\<P> P \\<P>' P'\n      assume\n        d1: \"\\<P> \\<in> C\" and\n        d2: \"P \\<in> \\<P>\" and\n        d3: \"\\<P>' \\<in> C\" and\n        d4: \"P' \\<in> \\<P>'\" and\n        d5: \"P \\<inter> P' \\<noteq> \\<emptyset>\"\n      from pred_on.chain_total [OF c1 d1 d3] have\n        d6: \"\\<P> \\<subseteq> \\<P>' \\<or> \\<P>' \\<subseteq> \\<P>\"\n        by (auto)\n      then show\n        \"P = P'\"\n      proof (mauto(inference))\n        assume\n          e1: \"\\<P> \\<subseteq> \\<P>'\"\n        from c2 [THEN subsetD, THEN b3, OF d3 subsetD [OF e1 d2] d4 d5] show\n          \"P = P'\"\n          by (this)\n      next\n        assume\n          e1: \"\\<P>' \\<subseteq> \\<P>\"      \n        from c2 [THEN subsetD, THEN b3, OF d1 d2 subsetD [OF e1 d4] d5] show\n          \"P = P'\"\n          by (this)\n      qed\n    next\n      fix\n        \\<P> P \\<P>'\n      assume\n        d1: \"\\<P> \\<in> C\" and\n        d2: \"P \\<in> \\<P>\" and\n        d3: \"\\<P>' \\<in> C\" and\n        d4: \"P \\<in> \\<P>'\"\n      from pred_on.chain_total [OF c1 d1 d3] have\n        \"\\<P> \\<subseteq> \\<P>' \\<or> \\<P>' \\<subseteq> \\<P>\"\n        by (auto)\n      then show\n        \"P \\<inter> P \\<noteq> \\<emptyset>\"\n      proof (mauto(inference))\n        assume\n          e1: \"\\<P> \\<subseteq> \\<P>'\"      \n        from c2 [THEN subsetD, THEN b3', OF d3 subsetD [OF e1 d2] d4] show\n          \"P \\<inter> P \\<noteq> \\<emptyset>\"\n          by (simp)\n      next\n        assume\n          e1: \"\\<P>' \\<subseteq> \\<P>\"      \n        from c2 [THEN subsetD, THEN b3', OF d1 d2 subsetD [OF e1 d4]] show\n          \"P \\<inter> P \\<noteq> \\<emptyset>\"\n          by (simp)\n      qed\n    next\n      show\n        \"\\<Union>\\<Union>C \\<subseteq> A\"\n      proof (auto)\n        fix\n          \\<P> P a\n        assume\n          d1: \"\\<P> \\<in> C\" and\n          d2: \"P \\<in> \\<P>\" and\n          d3: \"a \\<in> P\"      \n        from c2 [THEN subsetD, THEN b4, OF d1] d2 d3 show\n          \"a \\<in> A\"\n          by (auto)\n      qed\n    qed\n  qed\n  then obtain \\<P> where  \n    b5: \"\\<P> \\<in> ?\\<A>\" and \n    b6: \"(\\<forall> \\<P>' \\<bullet> \\<P>' \\<in> ?\\<A> \\<Rightarrow> \\<P> \\<subseteq> \\<P>' \\<Rightarrow> \\<P>' = \\<P>)\"\n    by (auto)\n  from b6 have\n    b7: \"finite (A \\<setminus> (\\<Union>\\<P>))\"\n  proof (rule contrapos_pp)\n    assume\n      c1: \"infinite (A \\<setminus> (\\<Union>\\<P>))\"\n    then obtain f where\n      c2: \"f \\<in> \\<univ>-[\\<nat>] \\<zinj> (A \\<setminus> (\\<Union>\\<P>))\"\n      by (auto simp add: infinite_card subequipotent_def)\n    then have\n      c3: \"f \\<in> \\<univ>-[\\<nat>] \\<zbij> (\\<zran> f)\"\n      by (mauto(fspace))\n    from equipotentI [OF c3] have\n      c4: \"countable (\\<zran> f) \\<and> infinite (\\<zran> f)\"\n      by (simp add: equipotentD1 equipotentD2 countable_card infinite_card)\n    from c3 have\n      c5: \"\\<zran> f \\<noteq> \\<emptyset>\"\n      apply (simp add: nempty_conv)\n      apply (witness \"f\\<cdot>0\")\n      apply (rule bij_range)\n      apply (auto)\n      done\n    from tinj_ran [OF c2] c4 c5 have\n      c6: \"insert (\\<zran> f) \\<P> \\<in> ?\\<A>\"\n      apply (simp add: Disjoint_def' disjoint_def)\n      apply (mauto(inference))\n      apply (simp add: b2 [OF b5])\n      apply (simp add: b2 [OF b5])\n      apply (rule b3 [OF b5])\n      apply (simp)\n      apply (simp)\n      apply (simp)\n      apply (rule b3' [OF b5])\n      apply (simp)+\n      apply (rule b4 [OF b5])\n      done\n    from tinj_ran [OF c2] have\n      c7: \"(\\<zran> f) \\<inter> (\\<Union>\\<P>) = \\<emptyset>\"\n      by (auto simp add: subset_def)\n    with c5 have\n      c8: \"(\\<zran> f) \\<notin> \\<P>\"\n      by (auto)\n    then have\n      c9: \"\\<P> \\<subseteq> insert (\\<zran> f) \\<P>\" and\n      c10: \"\\<P> \\<noteq> insert (\\<zran> f) \\<P>\"\n      by (auto)\n    from c4 c6 c9 c10 show\n      \"\\<not>(\\<forall> \\<P>' \\<bullet> \\<P>' \\<in> ?\\<A> \\<Rightarrow> \\<P> \\<subseteq> \\<P>' \\<Rightarrow> \\<P>' = \\<P>)\"\n      apply (simp)\n      apply (witness \"insert (\\<zran> f) \\<P>\")\n      apply (simp)\n      done\n  qed\n  from a1 have\n    b8: \"\\<Union>\\<P> \\<noteq> \\<emptyset>\"\n    apply (rule contrapos_nn)\n    using b7\n    apply (simp only:)\n    apply (auto)\n    done\n  then obtain P where\n    b9: \"P \\<in> \\<P>\"\n    by (auto)\n  from b7 b2 [OF b5 b9] have\n    b10: \"countable (P \\<union> (A \\<setminus> (\\<Union>\\<P>))) \\<and> infinite (P \\<union> (A \\<setminus> (\\<Union>\\<P>)))\"\n    by (simp add: countable_finite)\n  let\n    ?P' = \"P \\<union> (A \\<setminus> (\\<Union>\\<P>))\" \n  let\n    ?\\<P>' = \"insert ?P' (\\<P> \\<setminus> {P})\"\n  from b5 b10 have\n    b11: \"(\\<forall> P \\<bullet> P \\<in> ?\\<P>' \\<Rightarrow> countable P \\<and> infinite P)\"\n    by (auto)\n  from b5 b9 b3' [OF b5 b9 b9] have\n    b12: \"(\\<forall> P Q \\<bullet> P \\<in> ?\\<P>' \\<and> Q \\<in> ?\\<P>' \\<Rightarrow> P \\<inter> Q \\<noteq> \\<emptyset> \\<Leftrightarrow> P = Q)\"\n  proof (mauto_full(inference) msimp add: Disjoint_def' disjoint_def mdel: iffI)\n    fix\n      Q\n    assume\n      c1: \"Q \\<in> \\<P>\" and\n      c2: \"Q \\<noteq> P\"\n    from c2 b3 [OF b5 b9 c1] have\n      c3: \"P \\<inter> Q = \\<emptyset>\"\n      by (auto)\n    from b4 [OF b5] c1 have\n      c4: \"(A \\<setminus> (\\<Union>\\<P>)) \\<inter> Q = \\<emptyset>\"\n      by (auto)\n    from c3 c4 have\n      c5: \"?P' \\<inter> Q = \\<emptyset>\"\n      by (auto)\n    from c5 b3' [OF b5 b9 b9] have\n      c6: \"?P' \\<noteq> Q\"\n      by (auto)\n    from c5 c6 show\n      \"?P' \\<inter> Q \\<noteq> \\<emptyset> \\<Leftrightarrow> ?P' = Q\"\n      by (auto)\n    then show\n      \"Q \\<inter> ?P' \\<noteq> \\<emptyset> \\<Leftrightarrow> Q = ?P'\"\n      by (auto)\n  qed\n  from b4 [OF b5] b9 have\n    b13: \"\\<Union>?\\<P>' = A\"\n    by (auto)\n  from b11 b12 b13 show\n    \"?thesis\"\n    apply (witness \"insert (P \\<union> (A \\<setminus> (\\<Union>\\<P>))) (\\<P> \\<setminus> {P})\")\n    apply (simp add: Disjoint_def' disjoint_def)\n    done\nqed  \n\nlemma nat_sum_card:\n  \"\\<^EP>{:\\<univ>-[\\<nat>] <+> \\<univ>-[\\<nat>]:}{:\\<univ>-[\\<nat>]:}\"\n  apply (rule equipotentI [of \"\\<graphof> sum_encode\"])\n  apply (mauto(fspace) mintro!: functionalI)\n  using\n    bij_sum_encode [THEN bij_is_inj, THEN injD]\n    bij_sum_encode [THEN bij_is_surj, THEN surjD]\n  apply (auto simp add: graph_of_def glambda_def Z_ran_def)\n  done\n\nlemma countable_inf_part:\n  assumes\n    a1: \"countable_inf A\" \n  shows\n    \"(\\<exists> B C | B \\<subseteq> A \\<and> C \\<subseteq> A \\<and> disjoint B C \\<bullet> \n       \\<^EP>{:B:}{:A:} \\<and> \\<^EP>{:C:}{:A:} \\<and> B \\<union> C = A)\"\nproof -\n  from equipotent_trans [OF a1 [THEN countable_infD] nat_sum_card [symmetric]]  obtain f where\n    b1: \"f \\<in> A \\<zbij> (\\<univ>-[\\<nat>] <+> \\<univ>-[\\<nat>])\"\n    by (auto simp add: equipotent_def)\n  let\n    ?L = \"range Inl\"\n  have \n    b2: \"(\\<glambda> n::\\<nat> \\<bullet> Inl n) \\<in> \\<univ>-[\\<nat>] \\<zbij> ?L\"\n    apply (mauto(fspace))\n    apply (auto simp add: Z_dom_def Z_ran_def glambda_mem)\n    done\n  let\n    ?R = \"range Inr\"\n  have \n    b3: \"(\\<glambda> n::\\<nat> \\<bullet> Inr n) \\<in> \\<univ>-[\\<nat>] \\<zbij> ?R\"\n    apply (mauto(fspace))\n    apply (auto simp add: Z_dom_def Z_ran_def glambda_mem)\n    done\n  let\n    ?AL = \"{ a | a \\<in> A \\<and> f\\<cdot>a \\<in> ?L }\" and\n    ?AR = \"{ a | a \\<in> A \\<and> f\\<cdot>a \\<in> ?R }\"\n  have\n    b4: \"disjoint ?AL ?AR\"\n    by (auto simp add: disjoint_def)\n  from b1 [THEN bij_dom] have\n    b5: \"?AL \\<union> ?AR = A\"\n    apply (auto simp add: b1 [THEN bij_beta] image_def)\n    apply (rule sum.exhaust)\n    apply (rule exI)\n    apply (auto)\n    done\n  from b1 have\n    b6: \"?AL \\<zdres> f \\<in> ?AL \\<zbij> ?L\"\n    apply (mauto(fspace) mintro!: dres_functional dres_conv_functional)\n    apply (simp_all add: bij_dom [OF b1])\n  proof -\n    show\n      \"\\<zdom> (?AL \\<zdres> f) = ?AL\"\n      by (auto simp add: Z_dres_dom bij_dom [OF b1])\n    show\n      \"\\<zran> (?AL \\<zdres> f) = ?L\"\n    proof (auto simp add: dres_mem Z_ran_def bij_beta [OF b1])\n      fix\n        n :: \"\\<nat>\"\n      from bij_ran [OF b1] have\n        c1: \"Inl n \\<in> \\<zran> f\"\n        by (auto)\n      then obtain a where\n        c2: \"(a \\<mapsto> Inl n) \\<in> f\"\n        by (auto)\n      with bij_dom [OF b1] have\n        c3: \"a \\<in> A\"\n        by (auto)\n      show\n        \"(\\<exists> a \\<bullet> a \\<in> A \\<and> f\\<cdot>a \\<in> range Inl \\<and> (a, Inl n) \\<in> f)\"\n        apply (witness \"a\")\n        apply (simp add: c2 c3 bij_beta [OF b1 c2])\n        done\n    qed\n  qed\n  from \n    b6 [THEN equipotentI] \n    b2 [THEN equipotentI, symmetric] \n    a1 [THEN countable_infD, symmetric]\n  have\n    b7: \"\\<^EP>{:?AL:}{:A:}\"\n    by (auto intro: equipotent_trans)\n  from b1 have\n    b8: \"?AR \\<zdres> f \\<in> ?AR \\<zbij> ?R\"\n    apply (mauto(fspace) mintro!: dres_functional dres_conv_functional)\n    apply (simp_all add: bij_dom [OF b1])\n  proof -\n    show\n      \"\\<zdom> (?AR \\<zdres> f) = ?AR\"\n      by (auto simp add: Z_dres_dom bij_dom [OF b1])\n    show\n      \"\\<zran> (?AR \\<zdres> f) = ?R\"\n    proof (auto simp add: dres_mem Z_ran_def bij_beta [OF b1])\n      fix\n        n :: \"\\<nat>\"\n      from bij_ran [OF b1] have\n        c1: \"Inr n \\<in> \\<zran> f\"\n        by (auto)\n      then obtain a where\n        c2: \"(a \\<mapsto> Inr n) \\<in> f\"\n        by (auto)\n      with bij_dom [OF b1] have\n        c3: \"a \\<in> A\"\n        by (auto)\n      show\n        \"(\\<exists> a \\<bullet> a \\<in> A \\<and> f\\<cdot>a \\<in> range Inr \\<and> (a, Inr n) \\<in> f)\"\n        apply (witness \"a\")\n        apply (simp add: c2 c3 bij_beta [OF b1 c2])\n        done\n    qed\n  qed\n  from \n    b8 [THEN equipotentI] \n    b3 [THEN equipotentI, symmetric] \n    a1 [THEN countable_infD, symmetric]\n  have\n    b9: \"\\<^EP>{:?AR:}{:A:}\"\n    by (auto intro: equipotent_trans)\n  from b7 b9 b4 b5 show\n    \"?thesis\"\n    apply (witness \"?AL\")\n    apply (witness \"?AR\")\n    apply (auto)\n    done\nqed\n\nlemma infinite_part:\n  assumes\n    a1: \"infinite A\" \n  shows\n    \"(\\<exists> B C | B \\<subseteq> A \\<and> C \\<subseteq> A \\<and> disjoint B C \\<bullet> \n       \\<^EP>{:B:}{:A:} \\<and> \\<^EP>{:C:}{:A:} \\<and> B \\<union> C = A)\"\nproof -\n  from infinite_partition [OF a1] obtain \\<P> where\n    b1 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> countable_inf P)\" and\n    b2: \"Disjoint \\<P>\" and\n    b3: \"\\<Union>\\<P> = A\"\n    by (auto)\n  have\n    \"(\\<forall> P | P \\<in> \\<P> \\<bullet> \n      (\\<exists> X Y | X \\<subseteq> P \\<and> Y \\<subseteq> P \\<and> disjoint X Y \\<bullet> \n        \\<^EP>{:X:}{:P:} \\<and> \\<^EP>{:Y:}{:P:} \\<and> X \\<union> Y = P))\"\n    by (mauto(inference) mintro: countable_inf_part [OF b1])\n  then obtain l r where\n    b4 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> \n        l P \\<subseteq> P \\<and> r P \\<subseteq> P \\<and> disjoint (l P) (r P) \\<and>\n        \\<^EP>{:l P:}{:P:} \\<and> \\<^EP>{:r P:}{:P:} \\<and> (l P) \\<union> (r P) = P)\" and\n    b41 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> l P \\<subseteq> P)\" and\n    b42 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> r P \\<subseteq> P)\" and\n    b43 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> disjoint (l P) (r P))\" and\n    b44 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> \\<^EP>{:l P:}{:P:})\" and\n    b45 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> \\<^EP>{:r P:}{:P:})\" and\n    b46 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> (l P) \\<union> (r P) = P)\"\n    apply (subst (asm) qual_ax_choice_eq)\n    apply (subst (asm) qual_ax_choice_eq)\n    apply (auto)\n    done\n  have\n    b50 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> l P \\<noteq> \\<emptyset>)\"\n  proof (mauto(inference))\n    fix\n      P\n    assume\n      c1: \"P \\<in> \\<P>\"\n    from b44 [OF c1, THEN equipotentD2] b2 [THEN DisjointD0] c1 empty_glb [of \"P\"] show\n      \"l P \\<noteq> \\<emptyset>\"\n    by (auto)\n  qed\n  have\n    b5: \"inj_on l \\<P>\"\n  proof (rule inj_onI)\n    fix\n      P P'\n    assume\n      c1: \"P \\<in> \\<P>\" and\n      c2: \"P' \\<in> \\<P>\" and\n      c3: \"l P = l P'\"\n    from b50 [OF c1] have\n      c4: \"l P \\<noteq> \\<emptyset>\"\n      by (auto)\n    from b41 [OF c1] b41 [OF c2] c3 c4 have\n      c5: \"\\<not> disjoint P P'\"\n      by (auto simp add: disjoint_def)\n    from DisjointD1' [OF b2 c1 c2 c5]  show\n      \"P = P'\"\n      by (this)\n  qed\n  have\n    b60 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> r P \\<noteq> \\<emptyset>)\"\n  proof (mauto(inference))\n    fix\n      P\n    assume\n      c1: \"P \\<in> \\<P>\"\n    from b45 [OF c1, THEN equipotentD2] b2 [THEN DisjointD0] c1 empty_glb [of \"P\"] show\n      \"r P \\<noteq> \\<emptyset>\"\n    by (auto)\n  qed\n  have\n    b6: \"inj_on r \\<P>\"\n  proof (rule inj_onI)\n    fix\n      P P'\n    assume\n      c1: \"P \\<in> \\<P>\" and\n      c2: \"P' \\<in> \\<P>\" and\n      c3: \"r P = r P'\"\n    from b60 [OF c1] have\n      c4: \"r P \\<noteq> \\<emptyset>\"\n      by (auto)\n    from b42 [OF c1] b42 [OF c2] c3 c4 have\n      c5: \"\\<not> disjoint P P'\"\n      by (auto simp add: disjoint_def)\n    from DisjointD1' [OF b2 c1 c2 c5]  show\n      \"P = P'\"\n      by (this)\n  qed\n  have\n    b7: \"Disjoint { P | P \\<in> \\<P> \\<bullet> l P }\"\n    apply (rule DisjointI)\n    apply (mauto_full(inference))\n    using b50\n    apply (fast)\n    apply (rule disjoint_left_mono [OF b41])\n    apply (assumption)\n    apply (rule disjoint_right_mono [OF b41])\n    apply (assumption)\n    apply (rule b2 [THEN DisjointD1])\n    using b5 [THEN inj_on_iff]\n    apply (auto)\n    done\n  have\n    b8: \"Disjoint { P | P \\<in> \\<P> \\<bullet> r P }\"\n    apply (rule DisjointI)\n    apply (mauto_full(inference))\n    using b60\n    apply (fast)\n    apply (rule disjoint_left_mono [OF b42])\n    apply (assumption)\n    apply (rule disjoint_right_mono [OF b42])\n    apply (assumption)\n    apply (rule b2 [THEN DisjointD1])\n    using b6 [THEN inj_on_iff]\n    apply (auto)\n    done\n  let\n    ?AL = \"(\\<Union> P | P \\<in> \\<P> \\<bullet> l P)\" and\n    ?AR = \"(\\<Union> P | P \\<in> \\<P> \\<bullet> r P)\"\n  show\n    \"?thesis\"\n    apply (witness \"?AL\")\n    apply (witness \"?AR\")\n  proof (mauto(inference))\n    from b3 b4 show\n      \"?AL \\<subseteq> A\"\n      by (auto simp add: eind_def)\n  next\n    from b3 b4 show\n      \"?AR \\<subseteq> A\"\n      by (auto simp add: eind_def)\n  next\n    have \n      \"?AL \\<union> ?AR\n      = (\\<Union> P | P \\<in> \\<P> \\<bullet> l P \\<union> r P)\"\n      by (auto)\n    also have \"\\<dots>\n      = \\<Union>\\<P>\"\n      using b46 \n      by (auto simp add: eind_def) \n    finally show\n      \"?AL \\<union> ?AR = A\"\n      by (simp add: b3)\n  next\n    from b4 have\n      c1 [rule_format]: \"(\\<forall> P | P \\<in> \\<P> \\<bullet> disjoint (l P) (r P))\"\n      by (auto)\n    show\n      \"disjoint (\\<Union> P | P \\<in> \\<P> \\<bullet> l P) (\\<Union> P | P \\<in> \\<P> \\<bullet> r P)\"\n    proof (auto simp add: disjoint_right_Union_iff disjoint_left_Union_iff)\n      fix\n        P Q\n      assume\n        d1: \"P \\<in> \\<P>\" and\n        d2: \"Q \\<in> \\<P>\"\n      then show\n        \"disjoint (l P) (r Q)\"\n        apply (cases \"P = Q\")\n        apply (simp add: c1)\n        apply (rule disjoint_right_mono)\n        apply (rule b42)\n        apply (assumption)\n        apply (rule disjoint_left_mono)\n        apply (rule b41)\n        apply (assumption)\n        apply (rule DisjointD1)\n        apply (rule b2)\n        apply (auto)\n        done\n    qed\n  next\n    have\n      \"\\<^EP>{:(\\<Union> P | P \\<in> \\<P> \\<bullet> l P):}{:(\\<Union> P | P \\<in> \\<P> \\<bullet> P):}\"\n      apply (rule equipotent_iUnion)\n      using b7 b2 b5 inj_on_id [of \"\\<P>\"] b44\n      apply (auto simp add: eind_def)\n      done\n    with b3 show\n      \"\\<^EP>{:(\\<Union> P | P \\<in> \\<P> \\<bullet> l P):}{:A:}\"\n      by (simp add: eind_def)\n  next\n    have\n      \"\\<^EP>{:(\\<Union> P | P \\<in> \\<P> \\<bullet> r P):}{:(\\<Union> P | P \\<in> \\<P> \\<bullet> P):}\"\n      apply (rule equipotent_iUnion)\n      using b8 b2 b6 inj_on_id [of \"\\<P>\"] b45\n      apply (auto simp add: eind_def)\n      done\n    with b3 show\n      \"\\<^EP>{:(\\<Union> P | P \\<in> \\<P> \\<bullet> r P):}{:A:}\"\n      by (simp add: eind_def)\n  qed\nqed\n  \nlemma infinite_sum_part:\n  fixes\n    A :: \"'a set\"\n  assumes\n    a1: \"infinite A\" \n  shows\n    \"(\\<exists> (B::'a set) (C::'a set) \\<bullet> \n       \\<^EP>{:B:}{:A:} \\<and> \\<^EP>{:C:}{:A:} \\<and> \\<^EP>{:B <+> C:}{:A:})\"\nproof -\n  from infinite_part [OF a1] obtain B C where\n    b1: \"B \\<subseteq> A\" and\n    b2: \"C \\<subseteq> A\" and\n    b3: \"disjoint B C\" and\n    b4: \"\\<^EP>{:B:}{:A:}\" and\n    b5: \"\\<^EP>{:C:}{:A:}\" and\n    b6: \"B \\<union> C = A\"\n    by (auto)\n  from equipotent_Plus_union [OF b3] b4 b5 show\n    \"?thesis\"\n    by (auto simp add: b6)\nqed\n\nlemma infinite_sum_part':\n  fixes\n    A :: \"'a set\"\n  assumes\n    a1: \"\\<^sEP>{:\\<univ>-['a]:}{:\\<univ>-['b]:}\" and\n    a2: \"\\<^sEP>{:\\<univ>-['a]:}{:\\<univ>-['c]:}\" and\n    a3: \"infinite A\" \n  shows\n    \"(\\<exists> (B::'b set) (C::'c set) \\<bullet> \n       \\<^EP>{:B:}{:A:} \\<and> \\<^EP>{:C:}{:A:} \\<and> \\<^EP>{:B <+> C:}{:A:})\"\nproof -\n  from infinite_sum_part [OF a3] obtain B' :: \"'a set\" and C' :: \"'a set\" where\n    b1: \"\\<^EP>{:B':}{:A:}\" and\n    b2: \"\\<^EP>{:C':}{:A:}\" and\n    b3: \"\\<^EP>{:B' <+> C':}{:A:}\"\n    by (auto)\n  from a1 obtain f where\n    b4: \"f \\<in> \\<univ>-['a] \\<zinj> \\<univ>-['b]\"\n    by (auto simp add: subequipotent_def)\n  then have\n    b4': \"B' \\<zdres> f \\<in> B' \\<zinj> \\<univ>-['b]\"\n    apply (mauto(fspace))\n    apply (simp add: Z_dres_dom)\n    done\n  note b4'' = equipotentIinj_on' [OF fun_of_f_inj_on [OF b4'], symmetric]\n  from a2 obtain g where\n    b5: \"g \\<in> \\<univ>-['a] \\<zinj> \\<univ>-['c]\"\n    by (auto simp add: subequipotent_def)\n  then have\n    b5': \"C' \\<zdres> g \\<in> C' \\<zinj> \\<univ>-['c]\"\n    apply (mauto(fspace))\n    apply (simp add: Z_dres_dom)\n    done\n  note b5'' = equipotentIinj_on' [OF fun_of_f_inj_on [OF b5'], symmetric]\n  note b6 = equipotent_Plus_cong [OF b4'' b5'']\n  from \n    equipotent_trans [OF b4'' b1]  \n    equipotent_trans [OF b5'' b2]\n    equipotent_trans [OF b6 b3]\n  show\n    \"?thesis\"\n    by (auto)\nqed    \n\nlemma infinite_sum':\n  fixes\n    A :: \"'a set\"\n  assumes\n    a1: \"infinite A\"\n  shows\n    \"\\<^EP>{:A <+> A:}{:A:}\"\nproof -\n  from infinite_sum_part [OF a1] obtain B' :: \"'a set\" and C' :: \"'a set\" where\n    b1: \"\\<^EP>{:B':}{:A:}\" and\n    b2: \"\\<^EP>{:C':}{:A:}\" and\n    b3: \"\\<^EP>{:B' <+> C':}{:A:}\"\n    by (auto)\n  from equipotent_Plus_cong [OF b1 b2, symmetric] b3 show\n    \"?thesis\"\n    by (rule equipotent_trans)\nqed\n\ndefinition\n  \"sum_encode_map A = (\\<some> f | f \\<in> (A <+> A) \\<zbij> A)\"\n\nlemma sum_encode_map_bij:\n  assumes\n    a1: \"infinite A\"\n  shows\n    \"sum_encode_map A \\<in> (A <+> A) \\<zbij> A\"\n  using a1 [THEN infinite_sum']\n  apply (simp add: sum_encode_map_def equipotent_def)  \n  apply (rule someI_ex)\n  apply (assumption)\n  done\n\ndefinition\n  \"sum_decode_map A = (sum_encode_map A)\\<^sup>\\<sim>\"\n\nlemma sum_decode_map_bij:\n  assumes\n    a1: \"infinite A\"\n  shows\n    \"sum_decode_map A \\<in> A \\<zbij> (A <+> A)\"\n  apply (simp add: sum_decode_map_def)\n  apply (rule bij_inv_bij)\n  apply (rule sum_encode_map_bij [OF a1])\n  done\n\ncontext infinite\nbegin\n\ndefinition\n  \"sum_encode_op = \\<opof>(sum_encode_map \\<univ>-['a])\"\n\nlemma sum_encode_op_bij:\n  \"bij sum_encode_op\"\n  apply (simp add: sum_encode_op_def)\n  apply (rule fun_of_f_bij)\n  using sum_encode_map_bij [OF infinite_UNIV]\n  apply (simp)\n  done\n\ndefinition\n  \"iInl x = sum_encode_op (Inl x)\"\n\ndefinition\n  \"iInr x = sum_encode_op (Inr x)\"\n\ndefinition\n  \"sum_decode_op = \\<opof>(sum_decode_map \\<univ>-['a])\"\n\nlemma sum_decode_op_bij:\n  \"bij sum_decode_op\"\n  apply (simp add: sum_decode_op_def)\n  apply (rule fun_of_f_bij)\n  using sum_decode_map_bij [OF infinite_UNIV]\n  apply (simp)\n  done\n\nlemma sum_encode_op_inv:\n  \"sum_decode_op (sum_encode_op x) = x\"\n  apply (simp add: sum_decode_op_def sum_encode_op_def sum_decode_map_def)\n  apply (rule bij_inv_beta2 [OF sum_encode_map_bij])\n  apply (auto simp add: infinite_UNIV)\n  done\n\nlemma sum_decode_op_inv:\n  \"sum_encode_op (sum_decode_op x) = x\"\n  apply (simp add: sum_decode_op_def sum_encode_op_def sum_decode_map_def)\n  apply (rule bij_inv_beta1 [OF sum_encode_map_bij])\n  apply (auto simp add: infinite_UNIV)\n  done\n\nlemma isumE: \n  assumes \n   a1: \"\\<And> x::'a \\<bullet> s = iInl x \\<turnstile> P\" and \n   a2: \"\\<And> y::'a \\<bullet> s = iInr y \\<turnstile> P\"\n  shows \n    \"P\"\n  apply (cases \"sum_decode_op s\")\n  apply (rule a1)\n  apply (simp add: iInl_def)\n  apply (rule arg_cong [of \"sum_decode_op s\" _ \"sum_encode_op\", simplified sum_decode_op_inv])\n  apply (assumption)\n  apply (rule a2)\n  apply (simp add: iInr_def)\n  apply (rule arg_cong [of \"sum_decode_op s\" _ \"sum_encode_op\", simplified sum_decode_op_inv])\n  apply (assumption)\n  done\n\ndefinition\n  \"isum_case f g z = \\<case> sum_decode_op z \\<of> Inl a \\<longrightarrow> f a | Inr b \\<longrightarrow> g b \\<esac>\"\n\nend\n\nlemma infinite_sum:\n  assumes\n    a1: \"infinite B\" and\n    a2: \"\\<^sEP>{:A:}{:B:}\"\n  shows\n    \"\\<^EP>{:A <+> B:}{:B:}\"\nproof (rule subequipotent_antisym)\n  from subequipotent_Plus_cong [OF a2 subequipotent_refl] infinite_sum' [OF a1] show\n    \"\\<^sEP>{:A <+> B:}{:B:}\"\n    by (rule subeq_eq_trans)\nnext\n  show\n    \"\\<^sEP>{:B:}{:A <+> B:}\"\n    apply (rule subequipotent_trans [OF _ subset_subequipotent])\n    apply (rule equipotentIinj_on' [OF inj_Inr, THEN equipotentD1, of \"B\"])\n    apply (auto)\n    done\nqed\n\nlemma nat_prod_card:\n  \"\\<^EP>{:\\<univ>-[\\<nat>] \\<times> \\<univ>-[\\<nat>]:}{:\\<univ>-[\\<nat>]:}\"\n  apply (rule equipotentI [of \"\\<graphof> prod_encode\"])\n  apply (mauto(fspace) mintro!: functionalI)\n  using\n    bij_prod_encode [THEN bij_is_inj, THEN injD]\n    bij_prod_encode [THEN bij_is_surj, THEN surjD]\n  apply (auto simp add: graph_of_def glambda_def Z_ran_def eind_def)\n  done\n\nlemma countable_inf_prod:\n  assumes\n    a1: \"countable_inf A\" \n  shows\n    \"\\<^EP>{:A \\<times> A:}{:A:}\"\nproof -\n  note b1 = a1 [THEN countable_inf_card [THEN iffD1]] \n  from\n    equipotent_prod_cong [OF b1 b1]\n    nat_prod_card \n    b1 [symmetric]\n  show\n    \"?thesis\"\n    by (auto intro: equipotent_trans)\nqed\n\nlemma Times_empty' [simp]:\n  \"\\<emptyset> = A \\<times> B \\<Leftrightarrow> A = \\<emptyset> \\<or> B = \\<emptyset>\"\n  using Times_empty [of \"A\" \"B\"]\n  by (auto)\n\nlemma finite_prod_card:\n  fixes\n    A::\"'a set\" and\n    B::\"'b set\"\n  assumes\n    a1: \"finite A\" and\n    a2: \"finite B\"\n  shows\n    \"card (A \\<times> B) = (card A) * (card B)\"\n  using a1\nproof (induct \"A\" set: finite)\n  show\n    \"card (\\<emptyset> \\<times> B) = (card \\<emptyset>) * (card B)\"\n    by (auto)\nnext\n  fix\n    a::\"'a\" and\n    A::\"'a set\"\n  assume\n    b1: \"finite A\" and\n    b2: \"card (A \\<times> B) = (card A) * (card B)\" and\n    b3: \"a \\<notin> A\"\n  have\n    \"(insert a A) \\<times> B \n    = {a} \\<times> B \\<union> A \\<times> B\"\n    by (auto)\n  also have\n    b6: \"card ({a} \\<times> B \\<union> A \\<times> B) \n    = card ({a} \\<times> B) + card (A \\<times> B)\"\n    apply (rule card_Un_disjoint)\n    using a2 b1 b3\n    apply (auto simp add: linsert_def eind_def)\n    done\n  also from a2 have\n    b5: \"card ({a} \\<times> B) = card B\"\n    apply (induct \"B\" set: finite)\n    apply (auto simp add: linsert_def eind_def)\n    done\n  finally show \n    \"card ((insert a A) \\<times> B) = (card (insert a A)) * (card B)\"\n    using a2 b1 b3\n    by (auto)\nqed\n\nlemma finite_card_wit:\n  \"\\<card>A = Suc N \\<Leftrightarrow> (\\<exists> x A' \\<bullet> x \\<notin> A' \\<and> finite A' \\<and> A = insert x A' \\<and> \\<card>A' = N)\"\nproof (auto)\n  assume\n    b1: \"\\<card>A = Suc N\"\n  then have\n    b2: \"finite A\"\n    apply (rule contrapos_pp)\n    apply (simp add: card_infinite)\n    done\n  from b1 have\n    b3: \"A \\<noteq> \\<emptyset>\"\n        by (auto)\n  then obtain x where\n    b4: \"x \\<in> A\"\n    by (auto)\n  then have\n    b5: \"A = insert x (A \\<setminus> {x})\"\n    by (auto)\n  from b2 have\n    b6: \"finite (A \\<setminus> {x})\"\n    apply (rule rev_finite_subset)\n    apply (auto)\n    done\n  from b6 b2 b4 b1 show\n    \"(\\<exists> x A' \\<bullet> x \\<notin> A' \\<and> finite A' \\<and> A = insert x A' \\<and> \\<card>A' = N)\"\n    apply (witness \"x\")\n    apply (witness \"A \\<setminus> {x}\")\n    apply (auto)\n    done\nqed\n\nlemma rel_oride_inverse:\n  \"(f \\<oplus> g)\\<^sup>\\<sim> = ((\\<zdom> g \\<zdsub> f)\\<^sup>\\<sim>) \\<union> (g\\<^sup>\\<sim>)\"\n  by (auto simp add: rel_oride_def)  \n\nlemma infinite_prod':\n  assumes\n    a1: \"infinite A\" \n  shows\n    \"\\<^EP>{:A \\<times> A:}{:A:}\"\nproof -\n  let\n    ?\\<A> = \"{ S f | S \\<subseteq> A \\<and> f \\<in> (S \\<times> S) \\<zbij> S \\<bullet> f }\"\n  have  \n    \"(\\<exists> f \\<bullet> f \\<in> ?\\<A> \\<and> (\\<forall> f' \\<bullet> f' \\<in> ?\\<A> \\<Rightarrow> f \\<subseteq> f' \\<Rightarrow> f' = f))\"\n  proof (rule subset_Zorn' [of \"?\\<A>\", simplified Ball_def Bex_def])\n    fix \n      C\n    assume\n      c1: \"subset.chain ?\\<A> C\"\n    then have\n      c2: \"C \\<subseteq> ?\\<A>\" \n      by (auto simp add: pred_on.chain_def)\n    then have\n      c2' [rule_format]: \"(\\<forall> f | f \\<in> C \\<bullet> (\\<exists> S | S \\<subseteq> A \\<bullet> f \\<in> (S \\<times> S) \\<zbij> S))\"\n      by (auto simp add: eind_def)\n    from pred_on.chain_total [OF c1] have\n      c3 [rule_format]: \"(\\<forall> f f' | f \\<in> C \\<and> f' \\<in> C \\<bullet> f \\<subseteq> f' \\<or> f' \\<subseteq> f)\"\n      by (auto)\n    from c1 have\n      c4: \"subset.chain { S f | S \\<subseteq> A \\<and> f \\<in> S \\<zbij> (S \\<times> S) \\<bullet> f } { f | f \\<in> C \\<bullet> f\\<^sup>\\<sim> }\"\n      by (simp add: pred_on.chain_def Z_inverse_mono subset_def bij_inv_bij_iff) \n    then have\n      c5: \"{ f | f \\<in> C \\<bullet> f\\<^sup>\\<sim> } \\<subseteq> { S f | S \\<subseteq> A \\<and> f \\<in> S \\<zbij> (S \\<times> S) \\<bullet> f }\" \n      by (auto simp add: pred_on.chain_def)\n    then have\n      c5' [rule_format]: \"(\\<forall> f | f \\<in> C \\<bullet> (\\<exists> S | S \\<subseteq> A \\<bullet> f\\<^sup>\\<sim> \\<in> S \\<zbij> (S \\<times> S)))\"\n      by (auto simp add: eind_def)\n    show\n      \"\\<Union>C \\<in> ?\\<A>\"\n      apply (simp)\n      apply (witness \"(\\<Union> f | f \\<in> C \\<bullet> \\<zran> f)\")\n      apply (mauto(inference))\n    proof -\n      show\n        \"(\\<Union> f | f \\<in> C \\<bullet> \\<zran> f) \\<subseteq> A\"\n        apply (auto dest!: c2')\n        apply (subst (3) bij_beta [symmetric])\n        apply (assumption)+\n        apply (rule subsetD)\n        apply (assumption)+\n        apply (rule bij_range)\n        apply (assumption)+\n        apply (subst (2) bij_dom [symmetric])\n        apply (assumption)\n        apply (auto)\n        done\n    next\n      show\n        \"\\<Union>C \\<in> ((\\<Union> f | f \\<in> C \\<bullet> \\<zran> f) \\<times> (\\<Union> f | f \\<in> C \\<bullet> \\<zran> f)) \\<zbij> (\\<Union> f | f \\<in> C \\<bullet> \\<zran> f)\"\n        apply (mauto(fspace))\n        apply (rule chain_Union_functional [OF c1])\n        apply (mauto(inference) mdest!: c2')\n        apply (fast intro!: bij_functional)\n        apply (simp add: converse_Union)\n        apply (rule chain_Union_functional [OF c4])\n        apply (mauto_full(inference) mdest!: c5')\n        apply (fast intro!: bij_functional)\n        apply (auto del: RangeE DomainE simp add: rel_Union_dom eind_def)\n      proof -\n        fix\n          a b f \n        assume\n          d1: \"(a \\<mapsto> b) \\<in> \\<zdom> f\" and\n          d2: \"f \\<in> C\"\n        with c2' [OF d2] show\n          \"(\\<exists> f \\<bullet> f \\<in> C \\<and> a \\<in> \\<zran> f)\"\n          \"(\\<exists> f \\<bullet> f \\<in> C \\<and> b \\<in> \\<zran> f)\"\n          by (auto del: RangeE DomainE simp add: bij_dom bij_ran)\n      next\n        fix\n          a b f g\n        assume\n          d1: \"a \\<in> \\<zran> f\" and\n          d2: \"f \\<in> C\" and\n          d3: \"b \\<in> \\<zran> g\" and\n          d4: \"g \\<in> C\"\n        from c3 [OF d2 d4] show\n          \"(\\<exists> f \\<bullet> f \\<in> C \\<and> (a, b) \\<in> \\<zdom> f)\"\n        proof (mauto(inference))\n          assume\n            e1: \"f \\<subseteq> g\"\n          from Z_ran_mono [OF e1] d1 have\n            e2: \"a \\<in> \\<zran> g\"\n            by (auto)\n          with d3 c2' [OF d4] d4 show\n            \"(\\<exists> f \\<bullet> f \\<in> C \\<and> (a, b) \\<in> \\<zdom> f)\"\n            by (auto del: RangeE DomainE simp add: bij_dom bij_ran)\n        next\n          assume\n            e1: \"g \\<subseteq> f\"\n          from Z_ran_mono [OF e1] d3 have\n            e2: \"b \\<in> \\<zran> f\"\n            by (auto)\n          with d1 c2' [OF d2] d2 show\n            \"(\\<exists> f \\<bullet> f \\<in> C \\<and> (a, b) \\<in> \\<zdom> f)\"\n            by (auto del: RangeE DomainE simp add: bij_dom bij_ran)\n        qed\n      qed (auto)\n    qed\n  qed\n  then obtain f S where  \n    b2: \"S \\<subseteq> A\" and\n    b3: \"f \\<in> (S \\<times> S) \\<zbij> S\" and\n    b4: \"(\\<forall> f' \\<bullet> f' \\<in> ?\\<A> \\<Rightarrow> f \\<subseteq> f' \\<Rightarrow> f' = f)\"\n    by (auto)\n  obtain T where\n    b5: \"T = A \\<setminus> S\"\n    by (auto)\n  from b2 have\n    b6: \"A = T \\<union> S\"\n    by (auto simp add: b5)\n  from linear_sEP [of \"S\" \"T\"] show\n    \"?thesis\"\n  proof (elim disjE)\n    assume\n      c1: \"T \\<preceq> S\"\n    from b2 b5 have\n      c2: \"disjoint T S\"\n      by (auto simp add: disjoint_def)\n    from a1 seq_not_infinite_finite [OF c1] have\n      c3: \"infinite S\"\n      by (auto simp add: b6)\n    have\n      \"A \n      \\<asymp> T \\<union> S\"\n      by (simp add: b6 equipotent_refl)\n    also from equipotent_Plus_union [OF c2] have \"\\<dots>\n      \\<asymp> T <+> S\"\n      by (rule equipotent_sym)\n    also from infinite_sum [OF c3 c1] have \"\\<dots>\n      \\<asymp> S\"\n      by (this)\n    finally have \n      c4: \"A \\<asymp> S\"\n      by (this)\n    from c4 c4 have\n      \"A \\<times> A \n      \\<asymp> S \\<times> S\"\n      by (rule equipotent_prod_cong)\n    also have \"\\<dots>\n      \\<asymp> S\"\n      by (rule equipotentI [OF b3])\n    also from c4 have \"\\<dots>\n      \\<asymp> A\"\n      by (rule equipotent_sym)\n    finally show\n      \"?thesis\"\n      by (this)\n  next\n    assume\n      c1: \"S \\<preceq> T\"\n    show\n      \"?thesis\"\n    proof (cases \"finite S\")\n      assume\n        d1: \"infinite S\"\n      from c1 obtain T' where\n        d2: \"S \\<asymp> T'\" and\n        d3: \"T' \\<subseteq> T\"\n        by (auto elim: subep_subsetE)\n      from b5 d3 b2 have\n        d4: \"disjoint S T'\"\n        by (auto simp add: disjoint_def)\n       have\n        \"S \\<times> T' \\<union> T' \\<times> S \\<union> T' \\<times> T'\n        \\<asymp> (S \\<times> T' <+> T' \\<times> S) <+> T' \\<times> T'\"\n        apply (rule equipotent_sym)\n        apply (intro equipotent_Plus_unionIl)\n        apply (rule equipotent_refl)\n        using d4\n        apply (auto simp add: disjoint_def)\n        done\n      also have \"\\<dots>\n        \\<asymp> (S \\<times> S <+> S \\<times> S) <+> S \\<times> S\"\n        by (intro equipotent_Plus_cong equipotent_prod_cong equipotent_refl d2 [symmetric])\n      also have \"\\<dots>\n        \\<asymp> (S <+> S) <+> S\"\n        by (intro equipotent_Plus_cong equipotentI [OF b3])\n      also have \"\\<dots>\n        \\<asymp> T'\"\n        apply (rule equipotent_trans [OF _ d2])\n        apply (rule equipotent_trans [OF _ infinite_sum' [OF d1]])\n        apply (intro equipotent_Plus_cong infinite_sum' [OF d1] equipotent_refl)\n        done\n      finally obtain g where\n        d5: \"g \\<in> (S \\<times> T' \\<union> T' \\<times> S \\<union> T' \\<times> T') \\<zbij> T'\"\n        by (auto simp add: equipotent_def)\n      from b3 d5 have\n        d6: \"f \\<union> g \\<in> ((S \\<union> T') \\<times> (S \\<union> T')) \\<zbij> (S \\<union> T')\"\n        apply (mauto(fspace) \n                mintro!: disjoint_dres_empty \n                msimp: converse_union Z_inverse_dom Z_rel_union_dom)\n        using d4\n        apply (auto simp add: bij_ran [OF d5] bij_ran [OF b3] disjoint_def)\n        done\n      have\n        \"f \\<union> g \\<noteq> f\"\n      proof -\n        from infinite_ep_infinite [OF d1 d2] have\n          \"T' \\<noteq> \\<emptyset>\"\n          by (auto)\n        then obtain x where\n          l1: \"x \\<in> T'\"\n          by (auto)\n        have \n          l2: \"( (x, x) \\<mapsto> g\\<cdot>(x, x) ) \\<in> g\"\n          apply (rule bij_appl [OF d5]) \n          using l1\n          apply (auto)\n          done\n        from disjointD2 [OF d4 l1] bij_dom [OF b3] have \n          l3: \"( (x, x) \\<mapsto> g\\<cdot>(x, x) ) \\<notin> f\"\n          by (auto)\n        from l2 l3 show\n          \"?thesis\"\n          by (auto)\n      qed\n      moreover have\n        \"f \\<union> g = f\"\n        apply (rule b4 [rule_format, OF _ Un_upper1, of \"g\"])\n        apply (simp)\n        apply (witness \"(S \\<union> T')\")\n        using b2 b6 d3 d6\n        apply (auto)\n        done\n      ultimately show\n        \"?thesis\"\n        by (contradiction)\n    next\n      assume\n        d1: \"finite S\"\n      with b6 a1 have\n        d2: \"infinite T\"\n        by (auto)\n      from d2 [THEN infinite_card'' [THEN iffD1]] obtain T' where\n        d3: \"countable_inf T'\" and\n        d4: \"T' \\<subseteq> T\"\n        by (auto)\n      from b5 d4 b2 have\n        d5: \"disjoint S T'\"\n        by (auto simp add: disjoint_def)\n      from countable_inf_prod [OF d3] have\n        d6: \"T' \\<times> T' \\<asymp> T'\"\n        by (this)\n      have\n        \"S \\<times> T' \\<union> T' \\<times> S \\<union> T' \\<times> T'\n        \\<asymp> (S \\<times> T' <+> T' \\<times> S) <+> T' \\<times> T'\"\n        apply (rule equipotent_sym)\n        apply (intro equipotent_Plus_unionIl)\n        apply (rule equipotent_refl)\n        using d5\n        apply (auto simp add: disjoint_def)\n        done\n      also have \"\\<dots>\n        \\<asymp> T' \\<times> T'\"\n        apply (rule infinite_sum)\n        apply (rule infinite_ep_infinite [OF _ d6 [symmetric]])\n        apply (simp add: d3)\n        apply (rule subequipotent_trans)\n        apply (rule subequipotent_Plus_cong)\n        apply (rule subeq_prod_cong [OF finite_sub_infinite [OF d1, of \"T'\"] subequipotent_refl])\n        apply (simp add: d3)\n        apply (rule subeq_prod_cong [OF subequipotent_refl finite_sub_infinite [OF d1, of \"T'\"]])\n        apply (simp add: d3)\n        apply (rule equipotentD1)\n        apply (rule infinite_sum')\n        apply (rule infinite_ep_infinite [OF _ d6 [symmetric]])\n        apply (simp add: d3)\n        done\n      also have \"\\<dots>\n        \\<asymp> T'\"\n        by (rule d6)\n      finally obtain g where\n        d7: \"g \\<in> (S \\<times> T' \\<union> T' \\<times> S \\<union> T' \\<times> T') \\<zbij> T'\"\n        by (auto simp add: equipotent_def)\n      from b3 d7 have\n        d8: \"f \\<union> g \\<in> ((S \\<union> T') \\<times> (S \\<union> T')) \\<zbij> (S \\<union> T')\"\n        apply (mauto(fspace) \n                mintro!: disjoint_dres_empty \n                msimp: converse_union Z_inverse_dom Z_rel_union_dom)\n        using d5\n        apply (auto simp add: bij_ran [OF d7] bij_ran [OF b3] disjoint_def)\n        done\n      have\n        \"f \\<union> g \\<noteq> f\"\n      proof -\n        from d3 have\n          \"T' \\<noteq> \\<emptyset>\"\n          by (auto)\n        then obtain x where\n          l1: \"x \\<in> T'\"\n          by (auto)\n        have \n          l2: \"( (x, x) \\<mapsto> g\\<cdot>(x, x) ) \\<in> g\"\n          apply (rule bij_appl [OF d7]) \n          using l1\n          apply (auto)\n          done\n        from disjointD2 [OF d5 l1] bij_dom [OF b3] have \n          l3: \"( (x, x) \\<mapsto> g\\<cdot>(x, x) ) \\<notin> f\"\n          by (auto)\n        from l2 l3 show\n          \"?thesis\"\n          by (auto)\n      qed\n      moreover have\n        \"f \\<union> g = f\"\n        apply (rule b4 [rule_format, OF _ Un_upper1, of \"g\"])\n        apply (simp)\n        apply (witness \"(S \\<union> T')\")\n        using b2 b6 d4 d8\n        apply (auto)\n        done\n      ultimately show\n        \"?thesis\"\n        by (contradiction)\n    qed\n  qed\nqed\n\ndefinition\n  \"prod_encode_map A = (\\<some> f | f \\<in> (A \\<times> A) \\<zbij> A)\"\n\nlemma prod_encode_map_bij:\n  assumes\n    a1: \"infinite A\"\n  shows\n    \"prod_encode_map A \\<in> (A \\<times> A) \\<zbij> A\"\n  using a1 [THEN infinite_prod']\n  apply (simp add: prod_encode_map_def equipotent_def)  \n  apply (rule  someI_ex)\n  apply (assumption)\n  done\n\ndefinition\n  \"prod_decode_map A = (prod_encode_map A)\\<^sup>\\<sim>\"\n\nlemma prod_decode_map_bij:\n  assumes\n    a1: \"infinite A\"\n  shows\n    \"prod_decode_map A \\<in> A \\<zbij> (A \\<times> A)\"\n  apply (simp add: prod_decode_map_def)\n  apply (rule bij_inv_bij)\n  apply (rule prod_encode_map_bij [OF a1])\n  done\n\ncontext infinite\nbegin\n\ndefinition\n  \"prod_encode_op = \\<opof>(prod_encode_map \\<univ>-['a])\"\n\nlemma prod_encode_op_bij:\n  \"bij prod_encode_op\"\n  apply (simp add: prod_encode_op_def)\n  apply (rule fun_of_f_bij)\n  using prod_encode_map_bij [OF infinite_UNIV]\n  apply (simp)\n  done\n\ndefinition\n  \"prod_decode_op = \\<opof>(prod_decode_map \\<univ>-['a])\"\n\nlemma prod_decode_op_bij:\n  \"bij prod_decode_op\"\n  apply (simp add: prod_decode_op_def)\n  apply (rule fun_of_f_bij)\n  using prod_decode_map_bij [OF infinite_UNIV]\n  apply (simp)\n  done\n\nlemma prod_encode_op_inv:\n  \"prod_decode_op (prod_encode_op x) = x\"\n  apply (simp add: prod_decode_op_def prod_encode_op_def prod_decode_map_def)\n  apply (rule bij_inv_beta2 [OF prod_encode_map_bij])\n  apply (auto simp add: infinite_UNIV)\n  done\n\nlemma prod_decode_op_inv:\n  \"prod_encode_op (prod_decode_op x) = x\"\n  apply (simp add: prod_decode_op_def prod_encode_op_def prod_decode_map_def)\n  apply (rule bij_inv_beta1 [OF prod_encode_map_bij])\n  apply (auto simp add: infinite_UNIV)\n  done\n\ndefinition\n  \"iPair a b = prod_encode_op (Pair a b)\"\n\ndefinition\n  \"ifst x = fst (prod_decode_op x)\"\n\ndefinition\n  \"isnd x = snd (prod_decode_op x)\"\n\nlemma iprodE: \n  assumes \n   a1: \"\\<And> (x::'a) (y::'a) \\<bullet> s = iPair x y \\<turnstile> P\"\n  shows \n    \"P\"\n  apply (cases \"prod_decode_op s\")\n  apply (rule a1)\n  apply (simp add: iPair_def)\n  apply (rule arg_cong [of \"prod_decode_op s\" _ \"prod_encode_op\", simplified prod_decode_op_inv])\n  apply (assumption)\n  done\n\ndefinition\n  \"iprod_case f z = \\<case> prod_decode_op z \\<of> (a, b) \\<longrightarrow> f a b \\<esac>\"\n\nend\n\nlemma subep_nempty_prod:\n  assumes\n    a1: \"A \\<noteq> \\<emptyset>\"\n  shows\n    \"B \\<preceq> A \\<times> B\"\nproof -\n  from a1 obtain x where\n    b1: \"x \\<in> A\"\n    by (auto)\n  show\n    \"?thesis\"\n    apply (rule subepIinj_on [of \"(\\<olambda> b \\<bullet> (x, b))\"])\n    apply (auto intro: inj_onI simp add: b1)\n    done\nqed\n\nlemma infinite_prod:\n  assumes\n    a1: \"infinite B\" and\n    a2: \"A \\<noteq> \\<emptyset>\" and\n    a3: \"A \\<preceq> B\"\n  shows\n    \"\\<^EP>{:A \\<times> B:}{:B:}\"\n  apply (rule subequipotent_antisym [OF _ subep_nempty_prod [OF a2]])\n  apply (rule subequipotent_trans)\n  apply (rule subeq_prod_cong [OF a3 subequipotent_refl])\n  apply (rule equipotentD1)\n  apply (rule infinite_prod' [OF a1])\n  done\n\ntext {*\n\nFunction spaces have strictly higher (infinite) cardinality.\n\n*}\n\nlemma Cantor_cor_graphs:\n  fixes\n    X :: \"'a set\" and\n    Y :: \"'b set\"\n  assumes\n    a1: \"\\<^sEP>{:\\<univ>-[\\<bool>]:}{:Y:}\"\n  shows\n    \"\\<not>(\\<exists> f \\<bullet> f \\<in> (X \\<ztfun> Y) \\<zinj> X)\"\nproof (auto)\n  fix\n    f\n  assume\n    b1: \"f \\<in> (X \\<ztfun> Y) \\<zinj> X\"\n  have\n    b2: \"\\<not>(\\<exists> f \\<bullet> f \\<in> (X \\<ztfun> \\<univ>-[\\<bool>]) \\<zinj> X)\"\n  proof (auto)\n    fix\n      f\n    assume\n      c1: \"f \\<in> (X \\<ztfun> \\<univ>-[\\<bool>]) \\<zinj> X\"\n    have \n      c2 [rule_format]: \"(\\<forall> Y | Y \\<in> \\<pset> X \\<bullet> (\\<glambda> x | x \\<in> X \\<bullet> x \\<in> Y) \\<in> X \\<ztfun> \\<univ>-[\\<bool>])\"\n      apply (auto)\n      apply (mauto_full(fspace) msimp add: glambda_dom)\n      done\n    let  \n      ?g = \"(\\<olambda> Y \\<bullet> \\<if> Y \\<in> \\<pset> X \\<then> f\\<cdot>(\\<glambda> x | x \\<in> X \\<bullet> x \\<in> Y) \\<else> \\<arb> \\<fi>)\"\n    have\n      c3: \"inj_on ?g (\\<pset> X)\"\n      apply (rule inj_onI)\n      using c2 \n      apply (simp add: tinj_inj_iff [OF c1] glambda_eq)\n      apply (auto)\n      done\n    from Cantor' [of \"X\" \"inv_into (\\<pset> X) ?g\"] obtain Y where\n      c4: \"Y \\<in> \\<pset> X\" and\n      c5: \"Y \\<notin> (inv_into (\\<pset> X) ?g)\\<lparr>X\\<rparr>\"\n      by (auto)\n    have \n      c6: \"Y \\<in> (inv_into (\\<pset> X) ?g)\\<lparr>X\\<rparr>\"\n      apply (subst inv_into_f_f [OF c3 c4, symmetric])\n      apply (rule imageI)\n      using c4\n      apply (simp add: tinj_range [OF c1] c2)\n      done\n    from c5 c6 show\n      \"\\<False>\"\n      by (contradiction)\n  qed\n  from a1 obtain g where\n    b3: \"g \\<in> \\<univ>-[\\<bool>] \\<zinj> Y\"\n    by (auto simp add: subequipotent_def)\n  let\n    ?h = \"(\\<olambda> A \\<bullet> (\\<glambda> x | x \\<in> X \\<bullet> g\\<cdot>(A\\<cdot>x)))\"\n  from b3 have\n    b4 [rule_format]: \"(\\<forall> A | A \\<in> (X \\<ztfun> \\<univ>-[\\<bool>]) \\<bullet> ?h A \\<in> (X \\<ztfun> Y))\"\n  proof (auto)\n    fix\n      A\n    assume\n      c1: \"A \\<in> X \\<ztfun> \\<univ>-[\\<bool>]\"\n    show\n      \"?h A \\<in> X \\<ztfun> Y\"\n      apply (mauto_full(fspace) msimp add: glambda_dom glambda_ran)\n      apply (auto intro!: tinj_range [OF b3] tfun_range [OF c1])\n      done\n  qed\n  let\n    ?f' = \"(\\<glambda> A | A \\<in> X \\<ztfun> \\<univ>-[\\<bool>] \\<bullet> f\\<cdot>(?h A))\"\n  have\n    b5: \"?f' \\<in> (X \\<ztfun> \\<univ>-[\\<bool>]) \\<zinj> X\"\n    apply (mauto_full(fspace) msimp add: glambda_dom glambda_ran)\n    apply (msafe_no_assms(inference))\n  proof -\n    fix \n      A B\n    assume\n      c1: \"A \\<in> X \\<ztfun> \\<univ>-[\\<bool>]\" and\n      c2: \"B \\<in> X \\<ztfun> \\<univ>-[\\<bool>]\" and\n      c3: \"f\\<cdot>(?h A) = f\\<cdot>(?h B)\" \n    show\n      \"A = B\"\n      apply (rule tfun_eqI [OF c1 c2])\n      using c3 c1 c2 b4\n      apply (simp add: tinj_inj_iff [OF b1] glambda_eq tinj_inj_iff [OF b3] tfun_range [OF c1] tfun_range [OF c2])\n      done\n  next\n    show\n      \"{ A | A \\<in> X \\<ztfun> UNIV-[\\<bool>] \\<bullet> f\\<cdot>(\\<glambda> x | x \\<in> X \\<bullet> g\\<cdot>(A\\<cdot>x)) } \\<subseteq> X\"\n      apply (auto)\n      apply (rule tinj_range [OF b1])\n      apply (mauto_full(fspace) msimp add: glambda_dom glambda_ran)\n      apply (auto)\n      apply (rule tinj_range [OF b3])\n      apply (simp)\n      done\n  qed (simp)\n  with b2 show\n    \"\\<False>\" \n    by (auto)\nqed\n\nlemma power_not_equipotent:\n  \"\\<^sEPne>{:X:}{:\\<pset> X:}\"\nproof (rule conjI)\n  show\n    \"\\<^sEP>{:X:}{:\\<pset> X:}\"\n    apply (rule subequipotentI [of \"(\\<glambda> x | x \\<in> X \\<bullet> {x})\"])\n    apply (mauto_full(fspace) msimp add: glambda_dom glambda_ran)\n    apply (auto)\n    done\n  from Cantor_cor' [of \"X\"] have\n    \"\\<not>\\<^sEP>{:\\<pset> X:}{:X:}\"\n    by (auto simp add: subequipotent_eq_inj_on)\n  then show\n    \"\\<not>(X \\<asymp> \\<pset> X)\"\n    apply (rule contrapos_nn)  \n    apply (rule equipotentD2)\n    apply (assumption)\n    done\nqed\n\nsection {* Cardinals *}\n\ntypedef 'a cardinal = \"\\<^qspace>{:\\<univ>-['a set]:}{:equipotent:}\"\n  apply (witness \"\\<^eclass>{:\\<emptyset>-['a]:}{:equipotent:}\")\n  apply (auto simp add: quot_set_def)\n  done\n\ninstantiation\n  cardinal :: (type) ord\nbegin\n\ndefinition\n  lesseq_cardinal_def: \"\\<opleT>-[('a::type) cardinal] \\<defs> induce_ord Rep_cardinal \\<^quotord>{:subequipotent:}{:equipotent:}\"\n\ndefinition\n  less_cardinal_def: \"\\<opltT>-[('a::type) cardinal] \\<defs> derefl \\<opleT>\"\n\ninstance\n  by (intro_classes)\n\nend\n\ninstance\n  cardinal :: (type) linorder\n  apply (rule typedefs_linorder_classI)\n  apply (rule type_definition_cardinal)\n  apply (rule cardqord.order)\n  apply (simp add: lesseq_cardinal_def)\n  apply (simp add: less_cardinal_def)\n  done\n\nlemma cardinalI:\n  \"\\<^eclass>{:A:}{:equipotent:} \\<in> \\<^qspace>{:\\<univ>-['a set]:}{:equipotent:}\"\n  by (simp add: equi_equiv.quot_set_mem_ec)\n\ndefinition\n  card_of :: \"'a set \\<rightarrow> 'a cardinal\"\nwhere\n  \"card_of A \\<defs> Abs_cardinal \\<^eclass>{:A:}{:equipotent:}\"\n\nlemma card_of_equipotent:\n  \"card_of A = card_of B \\<Leftrightarrow> \\<^EP>{:A:}{:B:}\"\n  by (simp add: card_of_def Abs_cardinal_inject equi_equiv.quot_set_mem_ec equi_equiv.equiv_class_eq cardinalI)\n\nlemma card_of_subequipotent:\n  \"card_of A \\<le> card_of B \\<Leftrightarrow> \\<^sEP>{:A:}{:B:}\"\n  apply (auto intro!: exI equi_equiv.refl simp add: lesseq_cardinal_def quot_order_def card_of_def induce_ord_def Abs_cardinal_inverse cardinalI rel2op_def equi_equiv.equiv_class_eq equi_equiv.refl)\n  apply (auto intro: subequipotent_trans dest: equipotentD1 equipotentD2)\n  done\n\ndefinition\n  card_char :: \"'a cardinal \\<rightarrow> 'a set\"\nwhere\n  \"card_char a \\<defs> \\<^qchar>{:Rep_cardinal a:}{:equipotent:}\"\n\nlemma card_char_inverse:\n  \"card_of (card_char a) = a\"\nproof - \n  from Rep_cardinal [of \"a\"] have\n    \"\\<^eclass>{:\\<^qchar>{:Rep_cardinal a:}{:equipotent:}:}{:equipotent:} = Rep_cardinal a\"\n    by (simp add: equi_equiv.quot_char_class)\n  then show\n    \"?thesis\"\n    by (simp add: card_of_def card_char_def Rep_cardinal_inverse)\nqed\n\nlemma card_char_equipotent:\n  \"a = b \\<Leftrightarrow> \\<^EP>{:card_char a:}{:card_char b:}\"\n  apply (subst (2) card_char_inverse [symmetric])\n  apply (subst card_char_inverse [symmetric])\n  apply (simp add: card_of_equipotent)\n  done\n\nlemma card_char_subequipotent:\n  \"a \\<le> b \\<Leftrightarrow> \\<^sEP>{:card_char a:}{:card_char b:}\"\n  apply (subst (2) card_char_inverse [symmetric])\n  apply (subst card_char_inverse [symmetric])\n  apply (simp add: card_of_subequipotent)\n  done\n\nend\n"}
{"text": "{-#OPTIONS_GHC -w#-}\nmodule Plots (plotAndSave2D') where\n\n-- import Data.Colour\n-- import Data.Colour.Names\nimport           Graphics.Rendering.Chart.Backend.Cairo\nimport           Graphics.Rendering.Chart.Easy\nimport           Numeric.LinearAlgebra                  as L (Vector (..), size,\n                                                              toList)\nimport           System.FilePath                        (takeBaseName)\n\nplotAndSave2D' :: FilePath\n               -> Int\n               -> Int\n               -> (Int, Int)\n               -> [L.Vector Double]\n               -> IO ()\nplotAndSave2D' file len basePoint (gn, pn) results =\n  if (L.size . head $ results) /= 2\n    then error \"This function only works for 2D points!\"\n    else do\n      putStrLn \"Plotting...\"\n      toFile def plotFileName $ chartPlot2D results'\n      putStrLn $ \"Writing data points to file: \" ++ dataFileName\n      pp2DResults' dataFileName results'\n  where\n    actualFileName = takeBaseName file\n    baseOutputName = actualFileName ++ \"-\"\n                                       ++ \"base\" ++ show basePoint ++\n                                                    \"-\" ++ show gn ++ \"-\" ++ show pn\n    plotFileName = baseOutputName ++ \".png\"\n    dataFileName = baseOutputName ++ \".txt\"\n    results' = map ((\\[a, b] -> (a, b)) . L.toList) results\n\nchartPlot2D results = do\n  layout_title .= \"Normal Coordinates\"\n  setColors [opaque red]\n  plot (points \"points\" results)\n\npp2DResults' :: FilePath -> [(Double,Double)] -> IO ()\npp2DResults' file xs = writeFile file . transPairLine $ xs\n  where\n    transPairLine = concatMap (\\x -> show (fst x) ++ \" \" ++ show (snd x) ++ \"\\n\")\n"}
{"text": "/-\n\nOne of the reference works for proving theorems about programming languages is\nPhil Wadler's Programming Language Foundations in Agda.\n\nInference rules are frequently used in the programming languages community to express\nseveral aspects of programming like type checking and semantics, among others.\n\n\nBy defining our rules as axioms, we are building a logical framework on top of \nwhich we will prove theorems.\n\n-/\n\n\n/-\n\nThis micro-language receives strings from the user, has an escape operator\nand a consume function, that should receive only escaped values. Think of this\nlanguage as a safe alternative to my_sql_escape in PHP that prevents SQL\ninjection.\n -/\ninductive Expr : Type\n| from_user : string \u2192 Expr\n| escape : Expr \u2192 Expr\n| consume : Expr \u2192 Expr\n| concat : Expr \u2192 Expr \u2192 Expr\n\nopen Expr\n\n/- This axiom will allow us to express whether a given expression is safe or not. -/\naxiom is_safe : Expr \u2192 Prop\n\n\n/-\n\nBelow are our inference rules that define our \"type system\".\nNotice how we are abusing lean's comments to fake the horizontal line.\n\n -/\n\naxiom from_user_unsafe {s}:\n\n------------------------\n\u00ac is_safe (from_user s)\n\n\naxiom escape_makes_it_safe {e}:\n\n-------------------------\nis_safe (escape e)\n\n\naxiom consume_requires_safe {e}:\nis_safe e \u2194\n---------------------------\nis_safe (consume e)\n\n\naxiom concat_requires_both_safe {e1 e2}:\nis_safe e1 \u2227 is_safe e2 \u2194\n---------------------------\nis_safe (concat e1 e2)\n\n\n\n\n\n/-\n\nLet us prove that a simple program is valid.\n\nApply works by applying a function from the goal towards the context. In Haskell it is similar to:\n\nbToC :: b -> c\n\nf :: a -> b -> c\nf x = bToC\n\nIn lean, we would write \"apply bToC\" to bring the goal of writing f from c to b. The last step of\nthe proof is done, we just have to get to point b.\n\n\n-/\n\nexample :\n    is_safe (consume (concat (escape (from_user \"a\")) (escape (from_user \"b\")))) :=\nbegin\n    apply consume_requires_safe.mp,\n    apply concat_requires_both_safe.mp,\n    {\n        split,\n        {\n            apply escape_makes_it_safe,\n        }, {\n            apply escape_makes_it_safe,\n        }\n    }\nend\n\n\ndef has_any_escape : Expr \u2192 Prop\n| (from_user s) := false\n| (escape e) := true\n| (consume e) := has_any_escape e\n| (concat e1 e2) := has_any_escape e1 \u2228 has_any_escape e2\n\n\n/-\n\nThe is_safe was written in the second language.\nhas_any_escape was written in the first language, but could as well be written in the second.\n\nHere is the proof that any program that is safe, has at least one escape.\n\n-/\n\ntheorem if_is_safe_has_some_escape {e} :\n    is_safe e \u2192 has_any_escape e :=\nbegin\n    intro ise,\n    induction e,\n    {\n        -- from_user\n        have useful_proof := from_user_unsafe ise,\n        rw has_any_escape,\n        exact useful_proof,\n    },\n    {\n        -- escape\n        rw has_any_escape,\n        cc,\n    },\n    {\n        -- consume\n        rw has_any_escape,\n        apply e_ih,\n        apply consume_requires_safe.mpr ise,\n    },\n    {\n        -- concat\n        rw has_any_escape,\n        left,\n        apply e_ih_a,\n        have helper := concat_requires_both_safe.mpr ise,\n        have helper_ex := helper.left,\n        exact helper_ex,\n    }\nend"}
{"text": "[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 K = RingHom.fieldRange ofReal \u2228 K = \u22a4\n[PROOFSTEP]\nsuffices range (ofReal' : \u211d \u2192 \u2102) \u2286 K\n  by\n  rw [range_subset_iff, \u2190 coe_algebraMap] at this \n  have :=\n    (Subalgebra.isSimpleOrder_of_finrank finrank_real_complex).eq_bot_or_eq_top\n      (Subfield.toIntermediateField K this).toSubalgebra\n  simp_rw [\u2190 SetLike.coe_set_eq] at this \u22a2\n  convert this using 2\n  simp only [RingHom.coe_fieldRange, Algebra.coe_bot, coe_algebraMap]\n  rfl\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis : range ofReal' \u2286 \u2191K\n\u22a2 K = RingHom.fieldRange ofReal \u2228 K = \u22a4\n[PROOFSTEP]\nrw [range_subset_iff, \u2190 coe_algebraMap] at this \n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis : \u2200 (y : \u211d), \u2191(algebraMap \u211d \u2102) y \u2208 \u2191K\n\u22a2 K = RingHom.fieldRange ofReal \u2228 K = \u22a4\n[PROOFSTEP]\nhave :=\n  (Subalgebra.isSimpleOrder_of_finrank finrank_real_complex).eq_bot_or_eq_top\n    (Subfield.toIntermediateField K this).toSubalgebra\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis\u271d : \u2200 (y : \u211d), \u2191(algebraMap \u211d \u2102) y \u2208 \u2191K\nthis : (Subfield.toIntermediateField K this\u271d).toSubalgebra = \u22a5 \u2228 (Subfield.toIntermediateField K this\u271d).toSubalgebra = \u22a4\n\u22a2 K = RingHom.fieldRange ofReal \u2228 K = \u22a4\n[PROOFSTEP]\nsimp_rw [\u2190 SetLike.coe_set_eq] at this \u22a2\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis\u271d : \u2200 (y : \u211d), \u2191(algebraMap \u211d \u2102) y \u2208 \u2191K\nthis :\n  \u2191(Subfield.toIntermediateField K this\u271d).toSubalgebra = \u2191\u22a5 \u2228 \u2191(Subfield.toIntermediateField K this\u271d).toSubalgebra = \u2191\u22a4\n\u22a2 \u2191K = \u2191(RingHom.fieldRange ofReal) \u2228 \u2191K = \u2191\u22a4\n[PROOFSTEP]\nconvert this using 2\n[GOAL]\ncase h.e'_1.h.e'_3\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis\u271d : \u2200 (y : \u211d), \u2191(algebraMap \u211d \u2102) y \u2208 \u2191K\nthis :\n  \u2191(Subfield.toIntermediateField K this\u271d).toSubalgebra = \u2191\u22a5 \u2228 \u2191(Subfield.toIntermediateField K this\u271d).toSubalgebra = \u2191\u22a4\n\u22a2 \u2191(RingHom.fieldRange ofReal) = \u2191\u22a5\n[PROOFSTEP]\nsimp only [RingHom.coe_fieldRange, Algebra.coe_bot, coe_algebraMap]\n[GOAL]\ncase h.e'_1.h.e'_3\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis\u271d : \u2200 (y : \u211d), \u2191(algebraMap \u211d \u2102) y \u2208 \u2191K\nthis :\n  \u2191(Subfield.toIntermediateField K this\u271d).toSubalgebra = \u2191\u22a5 \u2228 \u2191(Subfield.toIntermediateField K this\u271d).toSubalgebra = \u2191\u22a4\n\u22a2 range \u2191ofReal = range ofReal'\n[PROOFSTEP]\nrfl\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal' \u2286 \u2191K\n[PROOFSTEP]\nsuffices range (ofReal' : \u211d \u2192 \u2102) \u2286 closure (Set.range ((ofReal' : \u211d \u2192 \u2102) \u2218 ((\u2191) : \u211a \u2192 \u211d)))\n  by\n  refine' subset_trans this _\n  rw [\u2190 IsClosed.closure_eq hc]\n  apply closure_mono\n  rintro _ \u27e8_, rfl\u27e9\n  simp only [Function.comp_apply, ofReal_rat_cast, SetLike.mem_coe, SubfieldClass.coe_rat_mem]\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis : range ofReal' \u2286 closure (range (ofReal' \u2218 Rat.cast))\n\u22a2 range ofReal' \u2286 \u2191K\n[PROOFSTEP]\nrefine' subset_trans this _\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis : range ofReal' \u2286 closure (range (ofReal' \u2218 Rat.cast))\n\u22a2 closure (range (ofReal' \u2218 Rat.cast)) \u2286 \u2191K\n[PROOFSTEP]\nrw [\u2190 IsClosed.closure_eq hc]\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis : range ofReal' \u2286 closure (range (ofReal' \u2218 Rat.cast))\n\u22a2 closure (range (ofReal' \u2218 Rat.cast)) \u2286 closure \u2191K\n[PROOFSTEP]\napply closure_mono\n[GOAL]\ncase h\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis : range ofReal' \u2286 closure (range (ofReal' \u2218 Rat.cast))\n\u22a2 range (ofReal' \u2218 Rat.cast) \u2286 \u2191K\n[PROOFSTEP]\nrintro _ \u27e8_, rfl\u27e9\n[GOAL]\ncase h.intro\nK : Subfield \u2102\nhc : IsClosed \u2191K\nthis : range ofReal' \u2286 closure (range (ofReal' \u2218 Rat.cast))\nw\u271d : \u211a\n\u22a2 (ofReal' \u2218 Rat.cast) w\u271d \u2208 \u2191K\n[PROOFSTEP]\nsimp only [Function.comp_apply, ofReal_rat_cast, SetLike.mem_coe, SubfieldClass.coe_rat_mem]\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal' \u2286 closure (range (ofReal' \u2218 Rat.cast))\n[PROOFSTEP]\nnth_rw 1 [range_comp]\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal' \u2286 closure (ofReal' '' range Rat.cast)\n[PROOFSTEP]\nrefine' subset_trans _ (image_closure_subset_closure_image continuous_ofReal)\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal' \u2286 ofReal' '' closure (range Rat.cast)\n[PROOFSTEP]\nrw [DenseRange.closure_range Rat.denseEmbedding_coe_real.dense]\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal' \u2286 ofReal' '' univ\n[PROOFSTEP]\nsimp only [image_univ]\n[GOAL]\nK : Subfield \u2102\nhc : IsClosed \u2191K\n\u22a2 range ofReal' \u2286 range ofReal'\n[PROOFSTEP]\nrfl\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nletI : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nletI : TopologicalRing K.topologicalClosure := Subring.instTopologicalRing K.topologicalClosure.toSubring\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nset \u03b9 : K \u2192 K.topologicalClosure := \u21d1(Subfield.inclusion K.le_topologicalClosure)\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nhave ui : UniformInducing \u03b9 :=\n  \u27e8by\n    erw [uniformity_subtype, uniformity_subtype, Filter.comap_comap]\n    congr\u27e9\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\n\u22a2 Filter.comap (fun x => (\u03b9 x.fst, \u03b9 x.snd)) (uniformity { x // x \u2208 Subfield.topologicalClosure K }) =\n    uniformity { x // x \u2208 K }\n[PROOFSTEP]\nerw [uniformity_subtype, uniformity_subtype, Filter.comap_comap]\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\n\u22a2 Filter.comap ((fun q => (\u2191q.fst, \u2191q.snd)) \u2218 fun x => (\u03b9 x.fst, \u03b9 x.snd)) (uniformity \u2102) =\n    Filter.comap (fun q => (\u2191q.fst, \u2191q.snd)) (uniformity \u2102)\n[PROOFSTEP]\ncongr\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nlet di := ui.denseInducing (?_ : DenseRange \u03b9)\n[GOAL]\ncase refine_2\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nlet ext\u03c8 := DenseInducing.extendRingHom ui di.dense hc\n[GOAL]\ncase refine_2\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nhaveI h\u03c8 := (uniformContinuous_uniformly_extend ui di.dense hc).continuous\n[GOAL]\ncase refine_2\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\ncases' Complex.subfield_eq_of_closed (Subfield.isClosed_topologicalClosure K) with h h\n[GOAL]\ncase refine_2.inl\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nleft\n[GOAL]\ncase refine_2.inl.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K)\n[PROOFSTEP]\nlet j := RingEquiv.subfieldCongr h\n[GOAL]\ncase refine_2.inl.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K)\n[PROOFSTEP]\nlet \u03c8\u2081 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp j.symm.toRingHom ofReal.rangeRestrict)\n      -- porting note: was `by continuity!` and was used inline\n[GOAL]\ncase refine_2.inl.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K)\n[PROOFSTEP]\nhave h\u03c8\u2081 : Continuous \u03c8\u2081 := by simpa only [RingHom.coe_comp] using h\u03c8.comp ((continuous_algebraMap \u211d \u2102).subtype_mk _)\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\n\u22a2 Continuous \u2191\u03c8\u2081\n[PROOFSTEP]\nsimpa only [RingHom.coe_comp] using h\u03c8.comp ((continuous_algebraMap \u211d \u2102).subtype_mk _)\n[GOAL]\ncase refine_2.inl.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K)\n[PROOFSTEP]\next1 x\n[GOAL]\ncase refine_2.inl.h.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) x = \u2191(Subfield.subtype K) x\n[PROOFSTEP]\nrsuffices \u27e8r, hr\u27e9 : \u2203 r : \u211d, ofReal.rangeRestrict r = j (\u03b9 x)\n[GOAL]\ncase refine_2.inl.h.h.intro\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\nr : \u211d\nhr : \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) x = \u2191(Subfield.subtype K) x\n[PROOFSTEP]\nhave := RingHom.congr_fun (ringHom_eq_ofReal_of_continuous h\u03c8\u2081) r\n[GOAL]\ncase refine_2.inl.h.h.intro\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d\u00b9 : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis\u271d : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\nr : \u211d\nhr : \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\nthis : \u2191\u03c8\u2081 r = \u2191ofReal r\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) x = \u2191(Subfield.subtype K) x\n[PROOFSTEP]\nrw [RingHom.comp_apply, RingHom.comp_apply, hr, RingEquiv.toRingHom_eq_coe] at this \n[GOAL]\ncase refine_2.inl.h.h.intro\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d\u00b9 : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis\u271d : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\nr : \u211d\nhr : \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\nthis : \u2191ext\u03c8 (\u2191\u2191(RingEquiv.symm j) (\u2191j (\u03b9 x))) = \u2191ofReal r\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) x = \u2191(Subfield.subtype K) x\n[PROOFSTEP]\nconvert this using 1\n[GOAL]\ncase h.e'_2\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d\u00b9 : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis\u271d : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\nr : \u211d\nhr : \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\nthis : \u2191ext\u03c8 (\u2191\u2191(RingEquiv.symm j) (\u2191j (\u03b9 x))) = \u2191ofReal r\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) x = \u2191ext\u03c8 (\u2191\u2191(RingEquiv.symm j) (\u2191j (\u03b9 x)))\n[PROOFSTEP]\nexact (DenseInducing.extend_eq di hc.continuous _).symm\n[GOAL]\ncase h.e'_3\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d\u00b9 : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis\u271d : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\nr : \u211d\nhr : \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\nthis : \u2191ext\u03c8 (\u2191\u2191(RingEquiv.symm j) (\u2191j (\u03b9 x))) = \u2191ofReal r\n\u22a2 \u2191(Subfield.subtype K) x = \u2191ofReal r\n[PROOFSTEP]\nrw [\u2190 ofReal.coe_rangeRestrict, hr]\n[GOAL]\ncase h.e'_3\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d\u00b9 : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis\u271d : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\nr : \u211d\nhr : \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\nthis : \u2191ext\u03c8 (\u2191\u2191(RingEquiv.symm j) (\u2191j (\u03b9 x))) = \u2191ofReal r\n\u22a2 \u2191(Subfield.subtype K) x = \u2191(\u2191j (\u03b9 x))\n[PROOFSTEP]\nrfl\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\n\u22a2 \u2203 r, \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\n[PROOFSTEP]\nobtain \u27e8r, hr\u27e9 := SetLike.coe_mem (j (\u03b9 x))\n[GOAL]\ncase intro\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = RingHom.fieldRange ofReal\nj : { x // x \u2208 Subfield.topologicalClosure K } \u2243+* { x // x \u2208 RingHom.fieldRange ofReal } := RingEquiv.subfieldCongr h\n\u03c8\u2081 : \u211d \u2192+* \u2102 := RingHom.comp ext\u03c8 (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm j)) (RingHom.rangeRestrict ofReal))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nx : { x // x \u2208 K }\nr : \u211d\nhr : \u2191ofReal r = \u2191(\u2191j (\u03b9 x))\n\u22a2 \u2203 r, \u2191(RingHom.rangeRestrict ofReal) r = \u2191j (\u03b9 x)\n[PROOFSTEP]\nexact \u27e8r, Subtype.ext hr\u27e9\n[GOAL]\ncase refine_2.inr\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = \u22a4\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nlet \u03c8\u2081 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.subfieldCongr h).symm.toRingHom (@Subfield.topEquiv \u2102 _).symm.toRingHom)\n      -- porting note: was `by continuity!` and was used inline\n[GOAL]\ncase refine_2.inr\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nhave h\u03c8\u2081 : Continuous \u03c8\u2081 := by simpa only [RingHom.coe_comp] using h\u03c8.comp (continuous_id.subtype_mk _)\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\n\u22a2 Continuous \u2191\u03c8\u2081\n[PROOFSTEP]\nsimpa only [RingHom.coe_comp] using h\u03c8.comp (continuous_id.subtype_mk _)\n[GOAL]\ncase refine_2.inr\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\ncases' ringHom_eq_id_or_conj_of_continuous h\u03c8\u2081 with h h\n[GOAL]\ncase refine_2.inr.inl\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = RingHom.id \u2102\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nleft\n[GOAL]\ncase refine_2.inr.inl.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = RingHom.id \u2102\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K)\n[PROOFSTEP]\next1 z\n[GOAL]\ncase refine_2.inr.inl.h.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = RingHom.id \u2102\nz : { x // x \u2208 K }\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) z = \u2191(Subfield.subtype K) z\n[PROOFSTEP]\nconvert RingHom.congr_fun h z using 1\n[GOAL]\ncase h.e'_2\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = RingHom.id \u2102\nz : { x // x \u2208 K }\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) z = \u2191\u03c8\u2081 \u2191z\n[PROOFSTEP]\nexact (DenseInducing.extend_eq di hc.continuous z).symm\n[GOAL]\ncase refine_2.inr.inr\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = starRingEnd \u2102\n\u22a2 \u03c8.toFun = \u2191(Subfield.subtype K) \u2228 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\nright\n[GOAL]\ncase refine_2.inr.inr.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = starRingEnd \u2102\n\u22a2 \u03c8.toFun = \u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)\n[PROOFSTEP]\next1 z\n[GOAL]\ncase refine_2.inr.inr.h.h\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = starRingEnd \u2102\nz : { x // x \u2208 K }\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) z = (\u2191(starRingEnd \u2102) \u2218 \u2191(Subfield.subtype K)) z\n[PROOFSTEP]\nconvert RingHom.congr_fun h z using 1\n[GOAL]\ncase h.e'_2\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\ndi : DenseInducing \u03b9 := UniformInducing.denseInducing ui ?refine_1\next\u03c8 : { x // x \u2208 Subfield.topologicalClosure K } \u2192+* \u2102 := DenseInducing.extendRingHom ui (_ : DenseRange \u03b9) hc\nh\u03c8 : Continuous (DenseInducing.extend (_ : DenseInducing \u03b9) \u2191\u03c8)\nh\u271d : Subfield.topologicalClosure K = \u22a4\n\u03c8\u2081 : \u2102 \u2192+* \u2102 :=\n  RingHom.comp ext\u03c8\n    (RingHom.comp (RingEquiv.toRingHom (RingEquiv.symm (RingEquiv.subfieldCongr h\u271d)))\n      (RingEquiv.toRingHom (RingEquiv.symm Subfield.topEquiv)))\nh\u03c8\u2081 : Continuous \u2191\u03c8\u2081\nh : \u03c8\u2081 = starRingEnd \u2102\nz : { x // x \u2208 K }\n\u22a2 OneHom.toFun (\u2191\u2191\u03c8) z = \u2191\u03c8\u2081 \u2191z\n[PROOFSTEP]\nexact (DenseInducing.extend_eq di hc.continuous z).symm\n[GOAL]\ncase refine_1\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\n\u22a2 DenseRange \u03b9\n[PROOFSTEP]\nlet j : { x // x \u2208 closure (id '' {x | (K : Set \u2102) x}) } \u2192 (K.topologicalClosure : Set \u2102) := fun x =>\n  \u27e8x, by\n    convert x.prop\n    simp only [id.def, Set.image_id']\n    rfl\u27e9\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nx : { x // x \u2208 closure (id '' {x | \u2191K x}) }\n\u22a2 \u2191x \u2208 \u2191(Subfield.topologicalClosure K)\n[PROOFSTEP]\nconvert x.prop\n[GOAL]\ncase h.e'_5\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nx : { x // x \u2208 closure (id '' {x | \u2191K x}) }\n\u22a2 \u2191(Subfield.topologicalClosure K) = closure (id '' {x | \u2191K x})\n[PROOFSTEP]\nsimp only [id.def, Set.image_id']\n[GOAL]\ncase h.e'_5\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nx : { x // x \u2208 closure (id '' {x | \u2191K x}) }\n\u22a2 \u2191(Subfield.topologicalClosure K) = closure {x | \u2191K x}\n[PROOFSTEP]\nrfl\n[GOAL]\ncase refine_1\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nj : { x // x \u2208 closure (id '' {x | \u2191K x}) } \u2192 \u2191\u2191(Subfield.topologicalClosure K) :=\n  fun x => { val := \u2191x, property := (_ : \u2191x \u2208 \u2191(Subfield.topologicalClosure K)) }\n\u22a2 DenseRange \u03b9\n[PROOFSTEP]\nconvert\n  DenseRange.comp (Function.Surjective.denseRange _) (DenseEmbedding.subtype denseEmbedding_id (K : Set \u2102)).dense\n    (by continuity : Continuous j)\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nj : { x // x \u2208 closure (id '' {x | \u2191K x}) } \u2192 \u2191\u2191(Subfield.topologicalClosure K) :=\n  fun x => { val := \u2191x, property := (_ : \u2191x \u2208 \u2191(Subfield.topologicalClosure K)) }\n\u22a2 Continuous j\n[PROOFSTEP]\ncontinuity\n[GOAL]\ncase refine_1\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nj : { x // x \u2208 closure (id '' {x | \u2191K x}) } \u2192 \u2191\u2191(Subfield.topologicalClosure K) :=\n  fun x => { val := \u2191x, property := (_ : \u2191x \u2208 \u2191(Subfield.topologicalClosure K)) }\n\u22a2 Function.Surjective j\n[PROOFSTEP]\nrintro \u27e8y, hy\u27e9\n[GOAL]\ncase refine_1.mk\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nj : { x // x \u2208 closure (id '' {x | \u2191K x}) } \u2192 \u2191\u2191(Subfield.topologicalClosure K) :=\n  fun x => { val := \u2191x, property := (_ : \u2191x \u2208 \u2191(Subfield.topologicalClosure K)) }\ny : \u2102\nhy : y \u2208 \u2191(Subfield.topologicalClosure K)\n\u22a2 \u2203 a, j a = { val := y, property := hy }\n[PROOFSTEP]\nuse\u27e8y, by\n    convert hy\n    simp only [id.def, Set.image_id']\n    rfl\u27e9\n[GOAL]\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nj : { x // x \u2208 closure (id '' {x | \u2191K x}) } \u2192 \u2191\u2191(Subfield.topologicalClosure K) :=\n  fun x => { val := \u2191x, property := (_ : \u2191x \u2208 \u2191(Subfield.topologicalClosure K)) }\ny : \u2102\nhy : y \u2208 \u2191(Subfield.topologicalClosure K)\n\u22a2 y \u2208 closure (id '' {x | \u2191K x})\n[PROOFSTEP]\nconvert hy\n[GOAL]\ncase h.e'_5\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nj : { x // x \u2208 closure (id '' {x | \u2191K x}) } \u2192 \u2191\u2191(Subfield.topologicalClosure K) :=\n  fun x => { val := \u2191x, property := (_ : \u2191x \u2208 \u2191(Subfield.topologicalClosure K)) }\ny : \u2102\nhy : y \u2208 \u2191(Subfield.topologicalClosure K)\n\u22a2 closure (id '' {x | \u2191K x}) = \u2191(Subfield.topologicalClosure K)\n[PROOFSTEP]\nsimp only [id.def, Set.image_id']\n[GOAL]\ncase h.e'_5\nK : Subfield \u2102\n\u03c8 : { x // x \u2208 K } \u2192+* \u2102\nhc : UniformContinuous \u2191\u03c8\nthis\u271d : TopologicalDivisionRing \u2102 := TopologicalDivisionRing.mk\nthis : TopologicalRing { x // x \u2208 Subfield.topologicalClosure K } :=\n  Subring.instTopologicalRing (Subfield.topologicalClosure K).toSubring\n\u03b9 : { x // x \u2208 K } \u2192 { x // x \u2208 Subfield.topologicalClosure K } :=\n  \u2191(Subfield.inclusion (_ : K \u2264 Subfield.topologicalClosure K))\nui : UniformInducing \u03b9\nj : { x // x \u2208 closure (id '' {x | \u2191K x}) } \u2192 \u2191\u2191(Subfield.topologicalClosure K) :=\n  fun x => { val := \u2191x, property := (_ : \u2191x \u2208 \u2191(Subfield.topologicalClosure K)) }\ny : \u2102\nhy : y \u2208 \u2191(Subfield.topologicalClosure K)\n\u22a2 closure {x | \u2191K x} = \u2191(Subfield.topologicalClosure K)\n[PROOFSTEP]\nrfl\n"}
{"text": "section\\<open>Examples of Intuitionistic Reasoning\\<close>\n\ntheory IFOL_examples imports IFOL begin\n\ntext\\<open>Quantifier example from the book Logic and Computation\\<close>\nlemma \"(EX y. ALL x. Q(x,y)) -->  (ALL x. EX y. Q(x,y))\"\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (rule impI)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (rule allI)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (rule exI)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (erule exE)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (erule allE)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\ntxt\\<open>Now \\<open>apply assumption\\<close> fails\\<close>\noops\n\ntext\\<open>Trying again, with the same first two steps\\<close>\nlemma \"(EX y. ALL x. Q(x,y)) -->  (ALL x. EX y. Q(x,y))\"\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (rule impI)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (rule allI)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (erule exE)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (rule exI)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (erule allE)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply assumption\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\ndone\n\nlemma \"(EX y. ALL x. Q(x,y)) -->  (ALL x. EX y. Q(x,y))\"\nby (tactic \\<open>IntPr.fast_tac \\<^context> 1\\<close>)\n\ntext\\<open>Example of Dyckhoff's method\\<close>\nlemma \"~ ~ ((P-->Q) | (Q-->P))\"\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (unfold not_def)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (rule impI)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (erule disj_impE)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply (erule imp_impE)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\n apply (erule imp_impE)\n  \\<comment> \\<open>@{subgoals[display,indent=0,margin=65]}\\<close>\napply assumption \napply (erule FalseE)+\ndone\n\nend\n"}
{"text": "[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\n\u22a2 \u2203 p, p \u2208 Ideal.minimalPrimes I \u2227 p \u2264 J\n[PROOFSTEP]\nsuffices\n  \u2203 m \u2208 {p : (Ideal R)\u1d52\u1d48 | Ideal.IsPrime p \u2227 I \u2264 OrderDual.ofDual p},\n    OrderDual.toDual J \u2264 m \u2227 \u2200 z \u2208 {p : (Ideal R)\u1d52\u1d48 | Ideal.IsPrime p \u2227 I \u2264 p}, m \u2264 z \u2192 z = m\n  by\n  obtain \u27e8p, h\u2081, h\u2082, h\u2083\u27e9 := this\n  simp_rw [\u2190 @eq_comm _ p] at h\u2083 \n  exact \u27e8p, \u27e8h\u2081, fun a b c => le_of_eq (h\u2083 a b c)\u27e9, h\u2082\u27e9\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\nthis :\n  \u2203 m,\n    m \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p} \u2227\n      \u2191OrderDual.toDual J \u2264 m \u2227 \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 {p | IsPrime p \u2227 I \u2264 p} \u2192 m \u2264 z \u2192 z = m\n\u22a2 \u2203 p, p \u2208 Ideal.minimalPrimes I \u2227 p \u2264 J\n[PROOFSTEP]\nobtain \u27e8p, h\u2081, h\u2082, h\u2083\u27e9 := this\n[GOAL]\ncase intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\np : (Ideal R)\u1d52\u1d48\nh\u2081 : p \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nh\u2082 : \u2191OrderDual.toDual J \u2264 p\nh\u2083 : \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 {p | IsPrime p \u2227 I \u2264 p} \u2192 p \u2264 z \u2192 z = p\n\u22a2 \u2203 p, p \u2208 Ideal.minimalPrimes I \u2227 p \u2264 J\n[PROOFSTEP]\nsimp_rw [\u2190 @eq_comm _ p] at h\u2083 \n[GOAL]\ncase intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\np : (Ideal R)\u1d52\u1d48\nh\u2081 : p \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nh\u2082 : \u2191OrderDual.toDual J \u2264 p\nh\u2083 : \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 {p | IsPrime p \u2227 I \u2264 p} \u2192 p \u2264 z \u2192 p = z\n\u22a2 \u2203 p, p \u2208 Ideal.minimalPrimes I \u2227 p \u2264 J\n[PROOFSTEP]\nexact \u27e8p, \u27e8h\u2081, fun a b c => le_of_eq (h\u2083 a b c)\u27e9, h\u2082\u27e9\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\n\u22a2 \u2203 m,\n    m \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p} \u2227\n      \u2191OrderDual.toDual J \u2264 m \u2227 \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 {p | IsPrime p \u2227 I \u2264 p} \u2192 m \u2264 z \u2192 z = m\n[PROOFSTEP]\napply zorn_nonempty_partialOrder\u2080\n[GOAL]\ncase ih\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\n\u22a2 \u2200 (c : Set (Ideal R)\u1d52\u1d48),\n    c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p} \u2192\n      IsChain (fun x x_1 => x \u2264 x_1) c \u2192\n        \u2200 (y : (Ideal R)\u1d52\u1d48),\n          y \u2208 c \u2192 \u2203 ub, ub \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p} \u2227 \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 c \u2192 z \u2264 ub\ncase hxs\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\n\u22a2 \u2191OrderDual.toDual J \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\n[PROOFSTEP]\nswap\n[GOAL]\ncase hxs\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\n\u22a2 \u2191OrderDual.toDual J \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\n[PROOFSTEP]\nrefine' \u27e8show J.IsPrime by infer_instance, e\u27e9\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\n\u22a2 IsPrime J\n[PROOFSTEP]\ninfer_instance\n[GOAL]\ncase ih\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\n\u22a2 \u2200 (c : Set (Ideal R)\u1d52\u1d48),\n    c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p} \u2192\n      IsChain (fun x x_1 => x \u2264 x_1) c \u2192\n        \u2200 (y : (Ideal R)\u1d52\u1d48),\n          y \u2208 c \u2192 \u2203 ub, ub \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p} \u2227 \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 c \u2192 z \u2264 ub\n[PROOFSTEP]\nrintro (c : Set (Ideal R)) hc hc' J' hJ'\n[GOAL]\ncase ih\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\nc : Set (Ideal R)\nhc : c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nhc' : IsChain (fun x x_1 => x \u2264 x_1) c\nJ' : (Ideal R)\u1d52\u1d48\nhJ' : J' \u2208 c\n\u22a2 \u2203 ub, ub \u2208 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p} \u2227 \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 c \u2192 z \u2264 ub\n[PROOFSTEP]\nrefine' \u27e8OrderDual.toDual (sInf c), \u27e8Ideal.sInf_isPrime_of_isChain \u27e8J', hJ'\u27e9 hc'.symm fun x hx => (hc hx).1, _\u27e9, _\u27e9\n[GOAL]\ncase ih.refine'_1\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\nc : Set (Ideal R)\nhc : c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nhc' : IsChain (fun x x_1 => x \u2264 x_1) c\nJ' : (Ideal R)\u1d52\u1d48\nhJ' : J' \u2208 c\n\u22a2 I \u2264 \u2191OrderDual.ofDual (\u2191OrderDual.toDual (sInf c))\n[PROOFSTEP]\nrw [OrderDual.ofDual_toDual, le_sInf_iff]\n[GOAL]\ncase ih.refine'_1\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\nc : Set (Ideal R)\nhc : c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nhc' : IsChain (fun x x_1 => x \u2264 x_1) c\nJ' : (Ideal R)\u1d52\u1d48\nhJ' : J' \u2208 c\n\u22a2 \u2200 (b : Ideal R), b \u2208 c \u2192 I \u2264 b\n[PROOFSTEP]\nexact fun _ hx => (hc hx).2\n[GOAL]\ncase ih.refine'_2\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\nc : Set (Ideal R)\nhc : c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nhc' : IsChain (fun x x_1 => x \u2264 x_1) c\nJ' : (Ideal R)\u1d52\u1d48\nhJ' : J' \u2208 c\n\u22a2 \u2200 (z : (Ideal R)\u1d52\u1d48), z \u2208 c \u2192 z \u2264 \u2191OrderDual.toDual (sInf c)\n[PROOFSTEP]\nrintro z hz\n[GOAL]\ncase ih.refine'_2\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\nc : Set (Ideal R)\nhc : c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nhc' : IsChain (fun x x_1 => x \u2264 x_1) c\nJ' : (Ideal R)\u1d52\u1d48\nhJ' : J' \u2208 c\nz : (Ideal R)\u1d52\u1d48\nhz : z \u2208 c\n\u22a2 z \u2264 \u2191OrderDual.toDual (sInf c)\n[PROOFSTEP]\nrw [OrderDual.le_toDual]\n[GOAL]\ncase ih.refine'_2\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime J\ne : I \u2264 J\nc : Set (Ideal R)\nhc : c \u2286 {p | IsPrime p \u2227 I \u2264 \u2191OrderDual.ofDual p}\nhc' : IsChain (fun x x_1 => x \u2264 x_1) c\nJ' : (Ideal R)\u1d52\u1d48\nhJ' : J' \u2208 c\nz : (Ideal R)\u1d52\u1d48\nhz : z \u2208 c\n\u22a2 sInf c \u2264 \u2191OrderDual.ofDual z\n[PROOFSTEP]\nexact sInf_le hz\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 Ideal.minimalPrimes (radical I) = Ideal.minimalPrimes I\n[PROOFSTEP]\nrw [Ideal.minimalPrimes, Ideal.minimalPrimes]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 radical I \u2264 p} =\n    minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 I \u2264 p}\n[PROOFSTEP]\ncongr\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 radical I \u2264 p} =\n    minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 I \u2264 p}\n[PROOFSTEP]\next p\n[GOAL]\ncase h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\n\u22a2 p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 radical I \u2264 p} \u2194\n    p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 I \u2264 p}\n[PROOFSTEP]\nrefine' \u27e8_, _\u27e9\n[GOAL]\ncase h.refine'_1\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\n\u22a2 p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 radical I \u2264 p} \u2192\n    p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 I \u2264 p}\n[PROOFSTEP]\nrintro \u27e8\u27e8a, ha\u27e9, b\u27e9\n[GOAL]\ncase h.refine'_2\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\n\u22a2 p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 I \u2264 p} \u2192\n    p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 radical I \u2264 p}\n[PROOFSTEP]\nrintro \u27e8\u27e8a, ha\u27e9, b\u27e9\n[GOAL]\ncase h.refine'_1.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\nb : \u2200 \u2983b : Ideal R\u2984, b \u2208 {p | IsPrime p \u2227 radical I \u2264 p} \u2192 (fun x x_1 => x \u2264 x_1) b p \u2192 (fun x x_1 => x \u2264 x_1) p b\na : IsPrime p\nha : radical I \u2264 p\n\u22a2 p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 I \u2264 p}\n[PROOFSTEP]\nrefine' \u27e8\u27e8a, a.radical_le_iff.1 ha\u27e9, _\u27e9\n[GOAL]\ncase h.refine'_1.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\nb : \u2200 \u2983b : Ideal R\u2984, b \u2208 {p | IsPrime p \u2227 radical I \u2264 p} \u2192 (fun x x_1 => x \u2264 x_1) b p \u2192 (fun x x_1 => x \u2264 x_1) p b\na : IsPrime p\nha : radical I \u2264 p\n\u22a2 \u2200 \u2983b : Ideal R\u2984, b \u2208 {p | IsPrime p \u2227 I \u2264 p} \u2192 (fun x x_1 => x \u2264 x_1) b p \u2192 (fun x x_1 => x \u2264 x_1) p b\n[PROOFSTEP]\nsimp only [Set.mem_setOf_eq, and_imp] at *\n[GOAL]\ncase h.refine'_1.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\na : IsPrime p\nha : radical I \u2264 p\nb : \u2200 \u2983b : Ideal R\u2984, IsPrime b \u2192 radical I \u2264 b \u2192 b \u2264 p \u2192 p \u2264 b\n\u22a2 \u2200 \u2983b : Ideal R\u2984, IsPrime b \u2192 I \u2264 b \u2192 b \u2264 p \u2192 p \u2264 b\n[PROOFSTEP]\nexact fun _ h2 h3 h4 => b h2 (h2.radical_le_iff.2 h3) h4\n[GOAL]\ncase h.refine'_2.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\nb : \u2200 \u2983b : Ideal R\u2984, b \u2208 {p | IsPrime p \u2227 I \u2264 p} \u2192 (fun x x_1 => x \u2264 x_1) b p \u2192 (fun x x_1 => x \u2264 x_1) p b\na : IsPrime p\nha : I \u2264 p\n\u22a2 p \u2208 minimals (fun x x_1 => x \u2264 x_1) {p | IsPrime p \u2227 radical I \u2264 p}\n[PROOFSTEP]\nrefine' \u27e8\u27e8a, a.radical_le_iff.2 ha\u27e9, _\u27e9\n[GOAL]\ncase h.refine'_2.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\nb : \u2200 \u2983b : Ideal R\u2984, b \u2208 {p | IsPrime p \u2227 I \u2264 p} \u2192 (fun x x_1 => x \u2264 x_1) b p \u2192 (fun x x_1 => x \u2264 x_1) p b\na : IsPrime p\nha : I \u2264 p\n\u22a2 \u2200 \u2983b : Ideal R\u2984, b \u2208 {p | IsPrime p \u2227 radical I \u2264 p} \u2192 (fun x x_1 => x \u2264 x_1) b p \u2192 (fun x x_1 => x \u2264 x_1) p b\n[PROOFSTEP]\nsimp only [Set.mem_setOf_eq, and_imp] at *\n[GOAL]\ncase h.refine'_2.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J p : Ideal R\na : IsPrime p\nha : I \u2264 p\nb : \u2200 \u2983b : Ideal R\u2984, IsPrime b \u2192 I \u2264 b \u2192 b \u2264 p \u2192 p \u2264 b\n\u22a2 \u2200 \u2983b : Ideal R\u2984, IsPrime b \u2192 radical I \u2264 b \u2192 b \u2264 p \u2192 p \u2264 b\n[PROOFSTEP]\nexact fun _ h2 h3 h4 => b h2 (h2.radical_le_iff.1 h3) h4\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 sInf (Ideal.minimalPrimes I) = radical I\n[PROOFSTEP]\nrw [I.radical_eq_sInf]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 sInf (Ideal.minimalPrimes I) = sInf {J | I \u2264 J \u2227 IsPrime J}\n[PROOFSTEP]\napply le_antisymm\n[GOAL]\ncase a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 sInf (Ideal.minimalPrimes I) \u2264 sInf {J | I \u2264 J \u2227 IsPrime J}\n[PROOFSTEP]\nintro x hx\n[GOAL]\ncase a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nx : R\nhx : x \u2208 sInf (Ideal.minimalPrimes I)\n\u22a2 x \u2208 sInf {J | I \u2264 J \u2227 IsPrime J}\n[PROOFSTEP]\nrw [Ideal.mem_sInf] at hx \u22a2\n[GOAL]\ncase a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nx : R\nhx : \u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 Ideal.minimalPrimes I \u2192 x \u2208 I_1\n\u22a2 \u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 {J | I \u2264 J \u2227 IsPrime J} \u2192 x \u2208 I_1\n[PROOFSTEP]\nrintro J \u27e8e, hJ\u27e9\n[GOAL]\ncase a.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J\u271d : Ideal R\nx : R\nhx : \u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 Ideal.minimalPrimes I \u2192 x \u2208 I_1\nJ : Ideal R\ne : I \u2264 J\nhJ : IsPrime J\n\u22a2 x \u2208 J\n[PROOFSTEP]\nobtain \u27e8p, hp, hp'\u27e9 := Ideal.exists_minimalPrimes_le e\n[GOAL]\ncase a.intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J\u271d : Ideal R\nx : R\nhx : \u2200 \u2983I_1 : Ideal R\u2984, I_1 \u2208 Ideal.minimalPrimes I \u2192 x \u2208 I_1\nJ : Ideal R\ne : I \u2264 J\nhJ : IsPrime J\np : Ideal R\nhp : p \u2208 Ideal.minimalPrimes I\nhp' : p \u2264 J\n\u22a2 x \u2208 J\n[PROOFSTEP]\nexact hp' (hx hp)\n[GOAL]\ncase a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 sInf {J | I \u2264 J \u2227 IsPrime J} \u2264 sInf (Ideal.minimalPrimes I)\n[PROOFSTEP]\napply sInf_le_sInf _\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 Ideal.minimalPrimes I \u2286 {J | I \u2264 J \u2227 IsPrime J}\n[PROOFSTEP]\nintro I hI\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J I : Ideal R\nhI : I \u2208 Ideal.minimalPrimes I\u271d\n\u22a2 I \u2208 {J | I\u271d \u2264 J \u2227 IsPrime J}\n[PROOFSTEP]\nexact hI.1.symm\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\n\u22a2 \u2203 p', IsPrime p' \u2227 comap f p' = p\n[PROOFSTEP]\nhave := H.1.1\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis : IsPrime p\n\u22a2 \u2203 p', IsPrime p' \u2227 comap f p' = p\n[PROOFSTEP]\nhave : Nontrivial (Localization (Submonoid.map f p.primeCompl)) :=\n  by\n  refine' \u27e8\u27e81, 0, _\u27e9\u27e9\n  convert\n    (IsLocalization.map_injective_of_injective p.primeCompl (Localization.AtPrime p)\n          (Localization <| p.primeCompl.map f) hf).ne\n      one_ne_zero\n  \u00b7 rw [map_one]\n  \u00b7 rw [map_zero]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis : IsPrime p\n\u22a2 Nontrivial (Localization (Submonoid.map f (primeCompl p)))\n[PROOFSTEP]\nrefine' \u27e8\u27e81, 0, _\u27e9\u27e9\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis : IsPrime p\n\u22a2 1 \u2260 0\n[PROOFSTEP]\nconvert\n  (IsLocalization.map_injective_of_injective p.primeCompl (Localization.AtPrime p) (Localization <| p.primeCompl.map f)\n        hf).ne\n    one_ne_zero\n[GOAL]\ncase h.e'_2\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis : IsPrime p\n\u22a2 1 =\n    \u2191(IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n      1\n[PROOFSTEP]\nrw [map_one]\n[GOAL]\ncase h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis : IsPrime p\n\u22a2 0 =\n    \u2191(IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n      0\n[PROOFSTEP]\nrw [map_zero]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\n\u22a2 \u2203 p', IsPrime p' \u2227 comap f p' = p\n[PROOFSTEP]\nobtain \u27e8M, hM\u27e9 := Ideal.exists_maximal (Localization (Submonoid.map f p.primeCompl))\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\n\u22a2 \u2203 p', IsPrime p' \u2227 comap f p' = p\n[PROOFSTEP]\nrefine' \u27e8M.comap (algebraMap S <| Localization (Submonoid.map f p.primeCompl)), inferInstance, _\u27e9\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\n\u22a2 comap f (comap (algebraMap S (Localization (Submonoid.map f (primeCompl p)))) M) = p\n[PROOFSTEP]\nrw [Ideal.comap_comap, \u2190\n  @IsLocalization.map_comp _ _ _ _ _ _ _ _ Localization.isLocalization _ _ _ _ p.primeCompl.le_comap_map _\n    Localization.isLocalization,\n  \u2190 Ideal.comap_comap]\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\n\u22a2 comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M) =\n    p\n[PROOFSTEP]\nsuffices _ \u2264 p by exact this.antisymm (H.2 \u27e8inferInstance, bot_le\u27e9 this)\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d\u00b9 : IsPrime p\nthis\u271d : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\nthis : ?m.48761 \u2264 p\n\u22a2 comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M) =\n    p\n[PROOFSTEP]\nexact this.antisymm (H.2 \u27e8inferInstance, bot_le\u27e9 this)\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\n\u22a2 comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M) \u2264\n    p\n[PROOFSTEP]\nintro x hx\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\nx : R\nhx :\n  x \u2208\n    comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M)\n\u22a2 x \u2208 p\n[PROOFSTEP]\nby_contra h\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\nx : R\nhx :\n  x \u2208\n    comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M)\nh : \u00acx \u2208 p\n\u22a2 False\n[PROOFSTEP]\napply hM.ne_top\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\nx : R\nhx :\n  x \u2208\n    comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M)\nh : \u00acx \u2208 p\n\u22a2 M = \u22a4\n[PROOFSTEP]\napply M.eq_top_of_isUnit_mem hx\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\nx : R\nhx :\n  x \u2208\n    comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M)\nh : \u00acx \u2208 p\n\u22a2 IsUnit\n    (\u2191(IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n      (\u2191(algebraMap R (Localization (primeCompl p))) x))\n[PROOFSTEP]\napply IsUnit.map\n[GOAL]\ncase intro.h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nf : R \u2192+* S\nhf : Function.Injective \u2191f\np : Ideal R\nH : p \u2208 minimalPrimes R\nthis\u271d : IsPrime p\nthis : Nontrivial (Localization (Submonoid.map f (primeCompl p)))\nM : Ideal (Localization (Submonoid.map f (primeCompl p)))\nhM : IsMaximal M\nx : R\nhx :\n  x \u2208\n    comap (algebraMap R (Localization (primeCompl p)))\n      (comap\n        (IsLocalization.map (Localization (Submonoid.map f (primeCompl p))) f\n          (_ : primeCompl p \u2264 Submonoid.comap f (Submonoid.map f (primeCompl p))))\n        M)\nh : \u00acx \u2208 p\n\u22a2 IsUnit (\u2191(algebraMap R (Localization (primeCompl p))) x)\n[PROOFSTEP]\napply IsLocalization.map_units _ (show p.primeCompl from \u27e8x, h\u27e9)\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\n\u22a2 \u2203 p', IsPrime p' \u2227 I \u2264 p' \u2227 comap f p' = p\n[PROOFSTEP]\nhave := H.1.1\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis : IsPrime p\n\u22a2 \u2203 p', IsPrime p' \u2227 I \u2264 p' \u2227 comap f p' = p\n[PROOFSTEP]\nlet f' := (Ideal.Quotient.mk I).comp f\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\n\u22a2 \u2203 p', IsPrime p' \u2227 I \u2264 p' \u2227 comap f p' = p\n[PROOFSTEP]\nhave e : RingHom.ker f' = I.comap f := by\n  ext1\n  exact Submodule.Quotient.mk_eq_zero _\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\n\u22a2 RingHom.ker f' = comap f I\n[PROOFSTEP]\next1\n[GOAL]\ncase h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\nx\u271d : R\n\u22a2 x\u271d \u2208 RingHom.ker f' \u2194 x\u271d \u2208 comap f I\n[PROOFSTEP]\nexact Submodule.Quotient.mk_eq_zero _\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\n\u22a2 \u2203 p', IsPrime p' \u2227 I \u2264 p' \u2227 comap f p' = p\n[PROOFSTEP]\nhave : RingHom.ker (Ideal.Quotient.mk <| RingHom.ker f') \u2264 p :=\n  by\n  rw [Ideal.mk_ker, e]\n  exact H.1.2\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\n\u22a2 RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\n[PROOFSTEP]\nrw [Ideal.mk_ker, e]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\n\u22a2 comap f I \u2264 p\n[PROOFSTEP]\nexact H.1.2\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\n\u22a2 \u2203 p', IsPrime p' \u2227 I \u2264 p' \u2227 comap f p' = p\n[PROOFSTEP]\nsuffices _\n  by\n  have \u27e8p', hp\u2081, hp\u2082\u27e9 :=\n    Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective (RingHom.kerLift_injective f')\n      (p.map <| Ideal.Quotient.mk <| RingHom.ker f') this\n  refine' \u27e8p'.comap <| Ideal.Quotient.mk I, Ideal.IsPrime.comap _, _, _\u27e9\n  \u00b7 exact Ideal.mk_ker.symm.trans_le (Ideal.comap_mono bot_le)\n  \u00b7 convert congr_arg (Ideal.comap <| Ideal.Quotient.mk <| RingHom.ker f') hp\u2082\n    rwa [Ideal.comap_map_of_surjective (Ideal.Quotient.mk <| RingHom.ker f') Ideal.Quotient.mk_surjective, eq_comm,\n      sup_eq_left]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d\u00b9 : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis\u271d : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nthis : ?m.53321\n\u22a2 \u2203 p', IsPrime p' \u2227 I \u2264 p' \u2227 comap f p' = p\n[PROOFSTEP]\nhave \u27e8p', hp\u2081, hp\u2082\u27e9 :=\n  Ideal.exists_comap_eq_of_mem_minimalPrimes_of_injective (RingHom.kerLift_injective f')\n    (p.map <| Ideal.Quotient.mk <| RingHom.ker f') this\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d\u00b9 : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis\u271d : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nthis : map (Quotient.mk (RingHom.ker f')) p \u2208 minimalPrimes (R \u29f8 RingHom.ker f')\np' : Ideal (S \u29f8 I)\nhp\u2081 : IsPrime p'\nhp\u2082 : comap (RingHom.kerLift f') p' = map (Quotient.mk (RingHom.ker f')) p\n\u22a2 \u2203 p', IsPrime p' \u2227 I \u2264 p' \u2227 comap f p' = p\n[PROOFSTEP]\nrefine' \u27e8p'.comap <| Ideal.Quotient.mk I, Ideal.IsPrime.comap _, _, _\u27e9\n[GOAL]\ncase refine'_1\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d\u00b9 : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis\u271d : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nthis : map (Quotient.mk (RingHom.ker f')) p \u2208 minimalPrimes (R \u29f8 RingHom.ker f')\np' : Ideal (S \u29f8 I)\nhp\u2081 : IsPrime p'\nhp\u2082 : comap (RingHom.kerLift f') p' = map (Quotient.mk (RingHom.ker f')) p\n\u22a2 I \u2264 comap (Quotient.mk I) p'\n[PROOFSTEP]\nexact Ideal.mk_ker.symm.trans_le (Ideal.comap_mono bot_le)\n[GOAL]\ncase refine'_2\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d\u00b9 : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis\u271d : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nthis : map (Quotient.mk (RingHom.ker f')) p \u2208 minimalPrimes (R \u29f8 RingHom.ker f')\np' : Ideal (S \u29f8 I)\nhp\u2081 : IsPrime p'\nhp\u2082 : comap (RingHom.kerLift f') p' = map (Quotient.mk (RingHom.ker f')) p\n\u22a2 comap f (comap (Quotient.mk I) p') = p\n[PROOFSTEP]\nconvert congr_arg (Ideal.comap <| Ideal.Quotient.mk <| RingHom.ker f') hp\u2082\n[GOAL]\ncase h.e'_3\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d\u00b9 : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis\u271d : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nthis : map (Quotient.mk (RingHom.ker f')) p \u2208 minimalPrimes (R \u29f8 RingHom.ker f')\np' : Ideal (S \u29f8 I)\nhp\u2081 : IsPrime p'\nhp\u2082 : comap (RingHom.kerLift f') p' = map (Quotient.mk (RingHom.ker f')) p\n\u22a2 p = comap (Quotient.mk (RingHom.ker f')) (map (Quotient.mk (RingHom.ker f')) p)\n[PROOFSTEP]\nrwa [Ideal.comap_map_of_surjective (Ideal.Quotient.mk <| RingHom.ker f') Ideal.Quotient.mk_surjective, eq_comm,\n  sup_eq_left]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\n\u22a2 map (Quotient.mk (RingHom.ker f')) p \u2208 minimalPrimes (R \u29f8 RingHom.ker f')\n[PROOFSTEP]\nrefine' \u27e8\u27e8_, bot_le\u27e9, _\u27e9\n[GOAL]\ncase refine'_1\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\n\u22a2 IsPrime (map (Quotient.mk (RingHom.ker f')) p)\n[PROOFSTEP]\napply Ideal.map_isPrime_of_surjective _ this\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\n\u22a2 Function.Surjective \u2191(Quotient.mk (RingHom.ker f'))\n[PROOFSTEP]\nexact Ideal.Quotient.mk_surjective\n[GOAL]\ncase refine'_2\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\n\u22a2 \u2200 \u2983b : Ideal (R \u29f8 RingHom.ker f')\u2984,\n    b \u2208 {p | IsPrime p \u2227 \u22a5 \u2264 p} \u2192\n      (fun x x_1 => x \u2264 x_1) b (map (Quotient.mk (RingHom.ker f')) p) \u2192\n        (fun x x_1 => x \u2264 x_1) (map (Quotient.mk (RingHom.ker f')) p) b\n[PROOFSTEP]\nrintro q \u27e8hq, -\u27e9 hq'\n[GOAL]\ncase refine'_2.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 map (Quotient.mk (RingHom.ker f')) p \u2264 q\n[PROOFSTEP]\nrw [\u2190\n  Ideal.map_comap_of_surjective (Ideal.Quotient.mk (RingHom.ker ((Ideal.Quotient.mk I).comp f)))\n    Ideal.Quotient.mk_surjective q]\n[GOAL]\ncase refine'_2.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 map (Quotient.mk (RingHom.ker f')) p \u2264\n    map (Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f)))\n      (comap (Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f))) q)\n[PROOFSTEP]\napply Ideal.map_mono\n[GOAL]\ncase refine'_2.intro.h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 p \u2264 comap (Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f))) q\n[PROOFSTEP]\napply H.2\n[GOAL]\ncase refine'_2.intro.h.a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 comap (Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f))) q \u2208 {p | IsPrime p \u2227 comap f I \u2264 p}\n[PROOFSTEP]\nrefine' \u27e8inferInstance, (Ideal.mk_ker.trans e).symm.trans_le (Ideal.comap_mono bot_le)\u27e9\n[GOAL]\ncase refine'_2.intro.h.a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 comap (Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f))) q \u2264 p\n[PROOFSTEP]\nrefine' (Ideal.comap_mono hq').trans _\n[GOAL]\ncase refine'_2.intro.h.a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 comap (Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f))) (map (Quotient.mk (RingHom.ker f')) p) \u2264 p\n[PROOFSTEP]\nrw [Ideal.comap_map_of_surjective]\n[GOAL]\ncase refine'_2.intro.h.a\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 p \u2294 comap (Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f))) \u22a5 \u2264 p\ncase refine'_2.intro.h.a.hf\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\nthis\u271d : IsPrime p\nf' : R \u2192+* S \u29f8 I := RingHom.comp (Quotient.mk I) f\ne : RingHom.ker f' = comap f I\nthis : RingHom.ker (Quotient.mk (RingHom.ker f')) \u2264 p\nq : Ideal (R \u29f8 RingHom.ker f')\nhq : IsPrime q\nhq' : q \u2264 map (Quotient.mk (RingHom.ker f')) p\n\u22a2 Function.Surjective \u2191(Quotient.mk (RingHom.ker (RingHom.comp (Quotient.mk I) f)))\n[PROOFSTEP]\nexacts [sup_le rfl.le this, Ideal.Quotient.mk_surjective]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\n\u22a2 \u2203 p', p' \u2208 Ideal.minimalPrimes I \u2227 comap f p' = p\n[PROOFSTEP]\nobtain \u27e8p', h\u2081, h\u2082, h\u2083\u27e9 := Ideal.exists_comap_eq_of_mem_minimalPrimes f p H\n[GOAL]\ncase intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\np' : Ideal S\nh\u2081 : IsPrime p'\nh\u2082 : I \u2264 p'\nh\u2083 : comap f p' = p\n\u22a2 \u2203 p', p' \u2208 Ideal.minimalPrimes I \u2227 comap f p' = p\n[PROOFSTEP]\nobtain \u27e8q, hq, hq'\u27e9 := Ideal.exists_minimalPrimes_le h\u2082\n[GOAL]\ncase intro.intro.intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\np' : Ideal S\nh\u2081 : IsPrime p'\nh\u2082 : I \u2264 p'\nh\u2083 : comap f p' = p\nq : Ideal S\nhq : q \u2208 Ideal.minimalPrimes I\nhq' : q \u2264 p'\n\u22a2 \u2203 p', p' \u2208 Ideal.minimalPrimes I \u2227 comap f p' = p\n[PROOFSTEP]\nrefine' \u27e8q, hq, Eq.symm _\u27e9\n[GOAL]\ncase intro.intro.intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\np' : Ideal S\nh\u2081 : IsPrime p'\nh\u2082 : I \u2264 p'\nh\u2083 : comap f p' = p\nq : Ideal S\nhq : q \u2208 Ideal.minimalPrimes I\nhq' : q \u2264 p'\n\u22a2 p = comap f q\n[PROOFSTEP]\nhave := hq.1.1\n[GOAL]\ncase intro.intro.intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\np' : Ideal S\nh\u2081 : IsPrime p'\nh\u2082 : I \u2264 p'\nh\u2083 : comap f p' = p\nq : Ideal S\nhq : q \u2208 Ideal.minimalPrimes I\nhq' : q \u2264 p'\nthis : IsPrime q\n\u22a2 p = comap f q\n[PROOFSTEP]\nhave := (Ideal.comap_mono hq').trans_eq h\u2083\n[GOAL]\ncase intro.intro.intro.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nI : Ideal S\nf : R \u2192+* S\np : Ideal R\nH : p \u2208 Ideal.minimalPrimes (comap f I)\np' : Ideal S\nh\u2081 : IsPrime p'\nh\u2082 : I \u2264 p'\nh\u2083 : comap f p' = p\nq : Ideal S\nhq : q \u2208 Ideal.minimalPrimes I\nhq' : q \u2264 p'\nthis\u271d : IsPrime q\nthis : comap f q \u2264 p\n\u22a2 p = comap f q\n[PROOFSTEP]\nexact (H.2 \u27e8inferInstance, Ideal.comap_mono hq.1.2\u27e9 this).antisymm this\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\n\u22a2 comap f J \u2208 Ideal.minimalPrimes (comap f I)\n[PROOFSTEP]\nhave := h.1.1\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis : IsPrime J\n\u22a2 comap f J \u2208 Ideal.minimalPrimes (comap f I)\n[PROOFSTEP]\nrefine' \u27e8\u27e8inferInstance, Ideal.comap_mono h.1.2\u27e9, _\u27e9\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis : IsPrime J\n\u22a2 \u2200 \u2983b : Ideal R\u2984,\n    b \u2208 {p | IsPrime p \u2227 comap f I \u2264 p} \u2192 (fun x x_1 => x \u2264 x_1) b (comap f J) \u2192 (fun x x_1 => x \u2264 x_1) (comap f J) b\n[PROOFSTEP]\nrintro K \u27e8hK, e\u2081\u27e9 e\u2082\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis : IsPrime J\nK : Ideal R\nhK : IsPrime K\ne\u2081 : comap f I \u2264 K\ne\u2082 : K \u2264 comap f J\n\u22a2 comap f J \u2264 K\n[PROOFSTEP]\nhave : RingHom.ker f \u2264 K := (Ideal.comap_mono bot_le).trans e\u2081\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis\u271d : IsPrime J\nK : Ideal R\nhK : IsPrime K\ne\u2081 : comap f I \u2264 K\ne\u2082 : K \u2264 comap f J\nthis : RingHom.ker f \u2264 K\n\u22a2 comap f J \u2264 K\n[PROOFSTEP]\nrw [\u2190 sup_eq_left.mpr this, RingHom.ker_eq_comap_bot, \u2190 Ideal.comap_map_of_surjective f hf]\n[GOAL]\ncase intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis\u271d : IsPrime J\nK : Ideal R\nhK : IsPrime K\ne\u2081 : comap f I \u2264 K\ne\u2082 : K \u2264 comap f J\nthis : RingHom.ker f \u2264 K\n\u22a2 comap f J \u2264 comap f (map f K)\n[PROOFSTEP]\napply Ideal.comap_mono _\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis\u271d : IsPrime J\nK : Ideal R\nhK : IsPrime K\ne\u2081 : comap f I \u2264 K\ne\u2082 : K \u2264 comap f J\nthis : RingHom.ker f \u2264 K\n\u22a2 J \u2264 map f K\n[PROOFSTEP]\napply h.2 _ _\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis\u271d : IsPrime J\nK : Ideal R\nhK : IsPrime K\ne\u2081 : comap f I \u2264 K\ne\u2082 : K \u2264 comap f J\nthis : RingHom.ker f \u2264 K\n\u22a2 map f K \u2208 {p | IsPrime p \u2227 I \u2264 p}\n[PROOFSTEP]\nexact \u27e8Ideal.map_isPrime_of_surjective hf this, Ideal.le_map_of_comap_le_of_surjective f hf e\u2081\u27e9\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nh : J \u2208 Ideal.minimalPrimes I\nthis\u271d : IsPrime J\nK : Ideal R\nhK : IsPrime K\ne\u2081 : comap f I \u2264 K\ne\u2082 : K \u2264 comap f J\nthis : RingHom.ker f \u2264 K\n\u22a2 map f K \u2264 J\n[PROOFSTEP]\nexact Ideal.map_le_of_le_comap e\u2082\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI : Ideal S\n\u22a2 Ideal.minimalPrimes (comap f I) = comap f '' Ideal.minimalPrimes I\n[PROOFSTEP]\next J\n[GOAL]\ncase h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI : Ideal S\nJ : Ideal R\n\u22a2 J \u2208 Ideal.minimalPrimes (comap f I) \u2194 J \u2208 comap f '' Ideal.minimalPrimes I\n[PROOFSTEP]\nconstructor\n[GOAL]\ncase h.mp\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI : Ideal S\nJ : Ideal R\n\u22a2 J \u2208 Ideal.minimalPrimes (comap f I) \u2192 J \u2208 comap f '' Ideal.minimalPrimes I\n[PROOFSTEP]\nintro H\n[GOAL]\ncase h.mp\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI : Ideal S\nJ : Ideal R\nH : J \u2208 Ideal.minimalPrimes (comap f I)\n\u22a2 J \u2208 comap f '' Ideal.minimalPrimes I\n[PROOFSTEP]\nobtain \u27e8p, h, rfl\u27e9 := Ideal.exists_minimalPrimes_comap_eq f J H\n[GOAL]\ncase h.mp.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI p : Ideal S\nh : p \u2208 Ideal.minimalPrimes I\nH : comap f p \u2208 Ideal.minimalPrimes (comap f I)\n\u22a2 comap f p \u2208 comap f '' Ideal.minimalPrimes I\n[PROOFSTEP]\nexact \u27e8p, h, rfl\u27e9\n[GOAL]\ncase h.mpr\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI : Ideal S\nJ : Ideal R\n\u22a2 J \u2208 comap f '' Ideal.minimalPrimes I \u2192 J \u2208 Ideal.minimalPrimes (comap f I)\n[PROOFSTEP]\nrintro \u27e8J, hJ, rfl\u27e9\n[GOAL]\ncase h.mpr.intro.intro\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI\u271d J\u271d : Ideal R\nf : R \u2192+* S\nhf : Function.Surjective \u2191f\nI J : Ideal S\nhJ : J \u2208 Ideal.minimalPrimes I\n\u22a2 comap f J \u2208 Ideal.minimalPrimes (comap f I)\n[PROOFSTEP]\nexact Ideal.mimimal_primes_comap_of_surjective hf hJ\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\n\u22a2 Ideal.minimalPrimes I = comap (Quotient.mk I) '' minimalPrimes (R \u29f8 I)\n[PROOFSTEP]\nrw [minimalPrimes, \u2190 Ideal.comap_minimalPrimes_eq_of_surjective Ideal.Quotient.mk_surjective, \u2190\n  RingHom.ker_eq_comap_bot, Ideal.mk_ker]\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nhI : IsPrimary I\n\u22a2 Ideal.minimalPrimes I = {radical I}\n[PROOFSTEP]\next J\n[GOAL]\ncase h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J\u271d : Ideal R\nhI : IsPrimary I\nJ : Ideal R\n\u22a2 J \u2208 Ideal.minimalPrimes I \u2194 J \u2208 {radical I}\n[PROOFSTEP]\nconstructor\n[GOAL]\ncase h.mp\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J\u271d : Ideal R\nhI : IsPrimary I\nJ : Ideal R\n\u22a2 J \u2208 Ideal.minimalPrimes I \u2192 J \u2208 {radical I}\n[PROOFSTEP]\nexact fun H =>\n  let e := H.1.1.radical_le_iff.mpr H.1.2\n  (H.2 \u27e8Ideal.isPrime_radical hI, Ideal.le_radical\u27e9 e).antisymm e\n[GOAL]\ncase h.mpr\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J\u271d : Ideal R\nhI : IsPrimary I\nJ : Ideal R\n\u22a2 J \u2208 {radical I} \u2192 J \u2208 Ideal.minimalPrimes I\n[PROOFSTEP]\nrintro (rfl : J = I.radical)\n[GOAL]\ncase h.mpr\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b9 : CommRing R\ninst\u271d : CommRing S\nI J : Ideal R\nhI : IsPrimary I\n\u22a2 radical I \u2208 Ideal.minimalPrimes I\n[PROOFSTEP]\nexact \u27e8\u27e8Ideal.isPrime_radical hI, Ideal.le_radical\u27e9, fun _ H _ => H.1.radical_le_iff.mpr H.2\u27e9\n[GOAL]\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J : Ideal R\ninst\u271d : IsPrime I\n\u22a2 Ideal.minimalPrimes I = {I}\n[PROOFSTEP]\next J\n[GOAL]\ncase h\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J\u271d : Ideal R\ninst\u271d : IsPrime I\nJ : Ideal R\n\u22a2 J \u2208 Ideal.minimalPrimes I \u2194 J \u2208 {I}\n[PROOFSTEP]\nconstructor\n[GOAL]\ncase h.mp\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J\u271d : Ideal R\ninst\u271d : IsPrime I\nJ : Ideal R\n\u22a2 J \u2208 Ideal.minimalPrimes I \u2192 J \u2208 {I}\n[PROOFSTEP]\nexact fun H => (H.2 \u27e8inferInstance, rfl.le\u27e9 H.1.2).antisymm H.1.2\n[GOAL]\ncase h.mpr\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nI J\u271d : Ideal R\ninst\u271d : IsPrime I\nJ : Ideal R\n\u22a2 J \u2208 {I} \u2192 J \u2208 Ideal.minimalPrimes I\n[PROOFSTEP]\nrintro (rfl : J = I)\n[GOAL]\ncase h.mpr\nR : Type u_1\nS : Type u_2\ninst\u271d\u00b2 : CommRing R\ninst\u271d\u00b9 : CommRing S\nJ\u271d J : Ideal R\ninst\u271d : IsPrime J\n\u22a2 J \u2208 Ideal.minimalPrimes J\n[PROOFSTEP]\nrefine' \u27e8\u27e8inferInstance, rfl.le\u27e9, fun _ h _ => h.2\u27e9\n"}
{"text": "import fibonacci_world.key  -- hide\n\n/-\n## The Final Boss\n\nIn this final level, you will prove that the Fibonacci number $F_k$ always divides $F_{kn}$,\nfor arbitrary natural numbers $k$ and $n$. You will need to use plain induction (`induction`), as well\nas the key lemma `Fib_general` proved before.\n-/\n\n/- Lemma : no-side-bar\nFor all $k$ and $n$, $F_{k}$ divides $F_{kn}$.\n-/\nlemma final_boss (k n : \u2115) : Fib k \u2223 Fib (k*n) :=\nbegin\n  apply induction n,\n  { -- simp works\n    use 0,\n    ring,\n  },\n  {\n    apply induction k,\n    { -- simp works\n      intros n hn,\n      rw show 0 * (n+1) = 0, by ring,\n    },\n    {\n      intros r hr m hm,\n      clear hr,\n      rw show (r + 1)*(m + 1) = (r + 1) * m + r + 1, by ring,\n      rw Fib_general,\n      apply divides_add,\n      {\n        apply divides_mul_left,\n        use 1,\n        ring,\n      },\n      {\n        cases hm with d hd,\n        rw hd,\n        apply divides_mul_right,\n        apply divides_mul_left,\n        use 1,\n        ring,\n      }\n    }\n  }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nend"}
{"text": "lemmas has_derivative_Re [derivative_intros] = bounded_linear.has_derivative[OF bounded_linear_Re]"}
{"text": "(* This file is generated by Why3's Coq driver *)\n(* Beware! Only edit allowed sections below    *)\nRequire Import ZArith.\nRequire Import Rbase.\nRequire Import Rbasic_fun.\nRequire Import R_sqrt.\nRequire Import Rtrigo.\nRequire Import AltSeries. (* for def of pi *)\nRequire real.Real.\nRequire real.Abs.\nRequire real.FromInt.\nRequire int.Int.\nRequire real.Square.\nRequire floating_point.Rounding.\nRequire floating_point.SingleFormat.\nRequire floating_point.Single.\n\nAxiom Pi_interval : ((314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196 / 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)%R < PI)%R /\\\n  (PI < (314159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038197 / 100000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000)%R)%R.\n\nAxiom Cos_plus_pi : forall (x:R),\n  ((Rtrigo_def.cos (x + PI)%R) = (-(Rtrigo_def.cos x))%R).\n\nAxiom Sin_plus_pi : forall (x:R),\n  ((Rtrigo_def.sin (x + PI)%R) = (-(Rtrigo_def.sin x))%R).\n\nAxiom Cos_plus_pi2 : forall (x:R),\n  ((Rtrigo_def.cos (x + ((05 / 10)%R * PI)%R)%R) = (-(Rtrigo_def.sin x))%R).\n\nAxiom Sin_plus_pi2 : forall (x:R),\n  ((Rtrigo_def.sin (x + ((05 / 10)%R * PI)%R)%R) = (Rtrigo_def.cos x)).\n\nAxiom Cos_neg : forall (x:R), ((Rtrigo_def.cos (-x)%R) = (Rtrigo_def.cos x)).\n\nAxiom Sin_neg : forall (x:R),\n  ((Rtrigo_def.sin (-x)%R) = (-(Rtrigo_def.sin x))%R).\n\nAxiom Cos_sum : forall (x:R) (y:R),\n  ((Rtrigo_def.cos (x + y)%R) = (((Rtrigo_def.cos x) * (Rtrigo_def.cos y))%R - ((Rtrigo_def.sin x) * (Rtrigo_def.sin y))%R)%R).\n\nAxiom Sin_sum : forall (x:R) (y:R),\n  ((Rtrigo_def.sin (x + y)%R) = (((Rtrigo_def.sin x) * (Rtrigo_def.cos y))%R + ((Rtrigo_def.cos x) * (Rtrigo_def.sin y))%R)%R).\n\nParameter atan: R -> R.\n\nAxiom Tan_atan : forall (x:R), ((Rtrigo.tan (atan x)) = x).\n\nRequire Import Interval_tactic.\n\n(* Why3 goal *)\nTheorem MethodError : forall (x:R), ((Rabs x) <= (1 / 32)%R)%R ->\n  ((Rabs ((1%R - ((05 / 10)%R * (x * x)%R)%R)%R - (Rtrigo_def.cos x))%R) <= (1 / 16777216)%R)%R.\n(* YOU MAY EDIT THE PROOF BELOW *)\nintros x H.\ninterval with (i_bisect_diff x).\nQed.\n\n\n"}
{"text": "{-# OPTIONS  #-}\n-----------------------------------------------------------------------------\n-- |\n-- Module      : Language.Scheme.R5RS.Parser.Token\n-- Copyright   : (c) Tyler Prete \n-- License     : BSD-style\n-- Maintainer  : psyonic@gmail.com\n-- Stability   : experimental\n-- Portability : ghc\n--\n-- Lexical tokens for the Scheme R5RS lexer.\n-- See: <http://people.csail.mit.edu/jaffer/r5rs_9.html#SEC72>\n-----------------------------------------------------------------------------\n\nmodule Language.Scheme.R5RS.Parser.Token ( Token (..) )\nwhere\nimport Language.Scheme.R5RS.Syntax.Expression (Number)\n--import Data.Complex -- for Complex Float\n\n-- | Lexical tokens.\ndata Token\n    -- Identifier\n    = Identifier !String\n    | Boolean Bool\n    | Number Number\n    | Character Char\n    | String !String\n    | LeftParen\n    | RightParen\n    | PoundLeftParen\n    | Tick\n    | BackTick\n    | Comma\n    | CommaAt\n    | Dot\n    deriving (Eq, Show, Ord)\n"}
{"text": "\\<^marker>\\<open>creator \"Kevin Kappelmann\"\\<close>\nsubsubsection \\<open>Basic Order Properties\\<close>\ntheory Transport_Natural_Functors_Order_Base\n  imports\n    Transport_Natural_Functors_Base\nbegin\n\nlemma reflexive_on_in_field_FrelI:\n  assumes \"reflexive_on (in_field R1) R1\"\n  and \"reflexive_on (in_field R2) R2\"\n  and \"reflexive_on (in_field R3) R3\"\n  defines \"R \\<equiv> Frel R1 R2 R3\"\n  shows \"reflexive_on (in_field R) R\"\n  apply (subst reflexive_on_iff_eq_restrict_left_le)\n  apply (subst Frel_eq[symmetric])\n  apply (unfold R_def)\n  apply (subst in_field_Frel_eq_Fpred_in_in_field)\n  apply (subst restrict_left_sup_eq)\n  apply (subst Frel_restrict_left_Fpred_eq_Frel_restrict_left)+\n  apply (rule le_supI;\n    rule Frel_mono;\n    subst reflexive_on_iff_eq_restrict_left_le[symmetric],\n    rule reflexive_on_if_le_pred_if_reflexive_on,\n    rule assms,\n    rule le_predI[OF in_field_if_in_dom]\n      le_predI[OF in_field_if_in_codom],\n    assumption)\n  done\n\nlemma transitive_FrelI:\n  assumes \"transitive R1\"\n  and \"transitive R2\"\n  and \"transitive R3\"\n  shows \"transitive (Frel R1 R2 R3)\"\n  apply (subst transitive_iff_rel_comp_le_self)\n  apply (subst Frel_comp_eq_Frel_rel_comp)\n  apply (rule Frel_mono;\n    subst transitive_iff_rel_comp_le_self[symmetric],\n    rule assms)\n  done\n\nlemma preorder_on_in_field_FrelI:\n  assumes \"preorder_on (in_field R1) R1\"\n  and \"preorder_on (in_field R2) R2\"\n  and \"preorder_on (in_field R3) R3\"\n  defines \"R \\<equiv> Frel R1 R2 R3\"\n  shows \"preorder_on (in_field R) R\"\n  apply (unfold R_def)\n  apply (insert assms)\n  apply (elim preorder_on_in_fieldE)\n  apply (rule preorder_onI)\n  apply (rule reflexive_on_in_field_FrelI; assumption)\n  apply (subst transitive_on_in_field_iff_transitive)\n  apply (rule transitive_FrelI; assumption)\n  done\n\nlemma symmetric_FrelI:\n  assumes \"symmetric R1\"\n  and \"symmetric R2\"\n  and \"symmetric R3\"\n  shows \"symmetric (Frel R1 R2 R3)\"\n  apply (subst symmetric_iff_rel_inv_eq_self)\n  apply (subst Frel_rel_inv_eq_rel_inv_Frel[symmetric])\n  apply (subst rel_inv_eq_self_if_symmetric, fact)+\n  apply (rule refl)\n  done\n\nlemma partial_equivalence_rel_FrelI:\n  assumes \"partial_equivalence_rel R1\"\n  and \"partial_equivalence_rel R2\"\n  and \"partial_equivalence_rel R3\"\n  shows \"partial_equivalence_rel (Frel R1 R2 R3)\"\n  apply (insert assms)\n  apply (elim partial_equivalence_relE preorder_on_in_fieldE)\n  apply (rule partial_equivalence_relI;\n    rule transitive_FrelI symmetric_FrelI;\n    assumption)\n  done\n\ncontext transport_natural_functor\nbegin\n\nlemmas reflexive_on_in_field_leftI = reflexive_on_in_field_FrelI\n  [of L1 L2 L3, folded transport_defs]\n\nlemmas transitive_leftI = transitive_FrelI[of L1 L2 L3, folded transport_defs]\n\nlemmas preorder_on_in_field_leftI = preorder_on_in_field_FrelI\n  [of L1 L2 L3, folded transport_defs]\n\nlemmas symmetricI = symmetric_FrelI[of L1 L2 L3, folded transport_defs]\n\nlemmas partial_equivalence_rel_leftI = partial_equivalence_rel_FrelI\n  [of L1 L2 L3, folded transport_defs]\n\nend\n\n\nend"}
{"text": "lemma and_trans (P Q R : Prop) : P \u2227 Q \u2192 Q \u2227 R \u2192 P \u2227 R :=\nbegin\nintros f h,\nsplit,\ncc,\ncc,\nend\n"}
{"text": "Home / Kentucky / DAIKIN APPLIED AMERICAS INC.\nDAIKIN APPLIED AMERICAS INC. was formed in Kentucky by C T CORPORATION SYSTEM located at 13600 INDUSTRIAL PARK BLVD., MINNEAPOLIS, MN 55441. It is no longer active.\nKentucky had a net population increase between 2010 and 2012 of .9%, according to the Census Bureau."}
{"text": "\nimport eta_injective_pq\n\nimport pq_induction_principles\n\nuniverses u1 u2\n\nsection pq_injective\n\nvariables {Q1 : Type u1} [power_quandle Q1] {Q2 : Type u2} [power_quandle Q2]\n\ntheorem pq_injective_if_L_injective (f : Q1 \u2192 Q2) (hf : is_pq_morphism f) (hLf : function.injective (L_of_morph f hf)) (hQ1 : eta_injective Q1) : function.injective f :=\nbegin\n  intros x y hxy,\n  apply hQ1,\n  apply hLf,\n  rw L_of_morph_of,\n  rw L_of_morph_of,\n  apply congr_arg,\n  exact hxy,\nend\n\n\nend pq_injective\n"}
{"text": "* Example from the C source of Andreas Podelski \n*\n* In case : I = K -1, there are no bound violations, \n* but we have to set at least :\n* setproperty SEMANTICS_FIX_POINT_OPERATOR \"derivative\"\n* activate TRANSFORMERS_INTER_FULL\n* #activate PRECONDITIONS_INTER_FULL\n* so that PIPS can prove it\n* \n* In case : I = K, there are bound violations\n\n      SUBROUTINE INSERTIONSORT(A, N)\n      REAL A(0:N-1), X\n      INTEGER N\n      \n      INTEGER I,K   \n      \n      DO 100 K=1,N-1\n         X = A(K)\n         I = K\nC         I = K-1\n         DO WHILE ((I .GE. 0).AND.( A(I) .GT. X))\n            A(I+1) = A(I)\n            I = I-1\n         ENDDO\n         A(I+1)=X\n 100  CONTINUE\n                                      \n      END\n\n"}
{"text": "From iris.program_logic Require Export language ectx_language ectxi_language.\nFrom iris_io.prelude Require Export base.\nFrom iris_io Require Export proph_erasure lang_proph_erased\n     lang_fully_erased.\nFrom stdpp Require Import gmap.\n\nRequire Import Coq.Logic.FunctionalExtensionality.\nRequire Import Coq.Logic.PropExtensionality.\nRequire Import Coq.Logic.Classical.\n\nDefinition prefix_closed (M : ioSpec) :=\n  \u2200 \u03c4 \u03c4', M (\u03c4 ++ \u03c4') \u2192 M \u03c4.\n\nDefinition IO_performed\n           (\u03c3 : language.state PE_lang) (\u03c3' : language.state PFE_lang) M\n  := (EHeap \u03c3) = (FEHeap \u03c3') \u2227 (EProph \u03c3) = (FEProph \u03c3') \u2227\n     (EioState \u03c3) = (\u03bb \u03c4, M ((FEIO \u03c3') ++ \u03c4)) \u2227 (\u2203 \u03c4, M ((FEIO \u03c3') ++ \u03c4)).\n\nDefinition make_ioSpec (\u03c3 : language.state PFE_lang) M :\n  language.state PE_lang :=\n  {| EHeap := FEHeap \u03c3; EProph := FEProph \u03c3;\n     EioState := \u03bb \u03c4, M ((FEIO \u03c3) ++ \u03c4) |}.\n\nLemma make_ioSpec_IO_performed \u03c3 (M : ioSpec):\n  M (FEIO \u03c3) \u2192 IO_performed (make_ioSpec \u03c3 M) \u03c3 M.\nProof.\n  destruct \u03c3 as [h p i]; repeat split; simpl in *; eauto.\n  by eexists nil; rewrite app_nil_r.\nQed.\n\nLemma fully_erased_reachable_reachable th1 h1 th2 \u03c32 (M : ioSpec) :\n  prefix_closed M \u2192\n  M (FEIO \u03c32) \u2192\n  rtc (@step PFE_lang) (th1, {| FEHeap := h1; FEProph := \u2205; FEIO := [] |})\n      (th2, \u03c32) \u2192\n  rtc (@step PE_lang)\n      (th1, {| EHeap := h1; EProph := \u2205; EioState := M |})\n      (th2, make_ioSpec \u03c32 M).\nProof.\n  intros Mpc.\n  remember (th1, {| FEHeap := h1; FEProph := \u2205; FEIO := [] |}) as cfg.\n  remember (th2, \u03c32) as cfg'.\n  intros HM Hrtc; revert HM.\n  revert th1 h1 th2 \u03c32 Heqcfg Heqcfg'.\n  simpl in *.\n  eapply (rtc_ind_r_weak\n            (\u03bb z z', \u2200 (th1 : list (language.expr PFE_lang))\n                       (h1 : gmap loc val)\n                       (th2 : list (language.expr PFE_lang))\n                       (\u03c32 : language.state PFE_lang),\n                z = (th1,\n                     {| FEHeap := h1; FEProph := \u2205; FEIO := [] |})\n                \u2192 z' = (th2, \u03c32) \u2192\n                M (FEIO \u03c32) \u2192\n                rtc (@step PE_lang)\n                    (th1, {| EHeap := h1; EProph := \u2205; EioState := M |})\n                    (th2, make_ioSpec \u03c32 M)));\n    last eauto.\n  - intros x th1 h1 th2 \u03c32 Heqcfg Heqcfg'; simplify_eq.\n    left; split; simpl; eauto; econstructor.\n  - intros x y z Hxy Hyz IH th1 h1 th2 \u03c32 Heqcfg Heqcfg' HM;\n      simplify_eq; simpl in *.\n    destruct y as [yh yp].\n    inversion Hyz as [? ? ? ? ? ? ? ? ? Hpr]; simplify_eq.\n    inversion Hpr as [? ? ? ? ? Hestp]; simpl in *; simplify_eq.\n    inversion Hestp; simplify_eq;\n      repeat match goal with\n      | H : is_Some _ |- _ => destruct H\n      end;\n      try (by eapply rtc_r; first (by apply IH); repeat econstructor; eauto).\n    eapply rtc_r; first apply IH; eauto.\n    + simpl in HM; eapply Mpc; eauto.\n    + unfold make_ioSpec; simpl.\n      replace (\u03bb \u03c4, M ((FEIO \u03c31 ++ [(t, v, v')]) ++ \u03c4)) with\n        (\u03bb \u03c4, M (FEIO \u03c31 ++ [(t, v, v')] ++ \u03c4)); last first.\n    { extensionality \u03c4. by rewrite -assoc. }\n    repeat econstructor; eauto; simpl.\n    apply (EIOS t e v v' {| EioState := \u03bb \u03c4, M (FEIO \u03c31 ++ \u03c4) |}); eauto.\nQed.\n\nDefinition fully_erased_safe e (M : ioSpec) :=\n  \u2200 th2 \u03c32,\n    M (FEIO \u03c32) \u2192\n    rtc (@step PFE_lang) ([e], {| FEHeap := \u2205; FEProph := \u2205; FEIO := [] |})\n        (th2, \u03c32) \u2192\n    \u2200 e, e \u2208 th2 \u2192 AsVal e \u2228\n                   (\u2203 e' \u03c3'' efs,\n                       @language.prim_step PFE_lang e \u03c32 e' \u03c3'' efs\n                       \u2227 \u2200 t v v', FEIO \u03c3'' = FEIO \u03c32 ++ [(t, v, v')] \u2192\n                                   \u2203 v'', M (FEIO \u03c32 ++ [(t, v, v'')])).\n\nInstance fully_erased_safe_impl e :\n  Proper ((\u2261) ==> impl) (fully_erased_safe e).\nProof.\n  intros M M' HMM HM th2 \u03c32 HM' Hrtc e' He'.\n  destruct (HM th2 \u03c32 (proj2 (HMM _) HM') Hrtc e' He') as\n      [| (e'' & \u03c3'' & efs & Hstp & Hrd)];\n    first auto.\n  right. eexists _, _, _; split; eauto.\n  intros t v v' Hvv'. destruct (Hrd _ _ _ Hvv') as [v'' Hrd'].\n  eexists; eapply HMM; eauto.\nQed.\n\nInstance fully_erased_safe_equiv e :\n  Proper ((\u2261) ==> iff) (fully_erased_safe e).\nProof.\n  intros M M' HMM; split => HL.\n  - eapply fully_erased_safe_impl; eauto.\n  - symmetry in HMM. eapply fully_erased_safe_impl; eauto.\nQed.\n\nLemma fully_erased_safe_union e (F : ioSpec \u2192 Prop) :\n  (\u2200 M, F M \u2192 fully_erased_safe e M) \u2192\n  fully_erased_safe e (\u03bb io, \u2203 M, F M \u2227 M io).\nProof.\n  intros Hfa th2 \u03c32 [M [HFM HM\u03c32]] Hrtc e' He'.\n  destruct (Hfa M HFM th2 \u03c32 HM\u03c32 Hrtc e' He') as\n      [?|(e'' & \u03c3'' & efs & Hstp & Hrd)];\n    first auto; simpl in *.\n  right; do 3 eexists; split; eauto.\n  intros t v v' Ht.\n  destruct (Hrd t v v' Ht) as [v'' HM].\n  exists v'', M; split; auto.\nQed.\n\nLemma reducible_fully_erase_reducible e \u03c3 \u03c3' M :\n  IO_performed \u03c3 \u03c3' M \u2192\n  @language.reducible PE_lang e \u03c3 \u2192\n  \u2203 e' \u03c3'' efs,\n    @language.prim_step PFE_lang e \u03c3' e' \u03c3'' efs\n    \u2227 \u2200 t v v', FEIO \u03c3'' = FEIO \u03c3' ++ [(t, v, v')] \u2192\n                \u2203 v'', M (FEIO \u03c3' ++ [(t, v, v'')]).\nProof.\n  intros Hsp (e'&\u03c32&efs&Hrd); simpl in *.\n  inversion Hrd as [K e1' e2' ? ? Hhrd]; simpl in *; subst.\n  destruct \u03c3 as [\u03c3h \u03c3p]; destruct \u03c3' as [\u03c3'h \u03c3'p];\n    destruct Hsp as [? [? [? ?]]]; simpl in *; simplify_eq.\n  inversion Hhrd; subst;\n    repeat match goal with A : is_Some _ |- _ => destruct A as [? ?] end;\n    simpl in *;\n    try (by (unshelve (repeat econstructor; eauto)); simpl in *;\n            try match goal with\n                | H : ?A = ?A ++ [_] |- _ =>\n                  let H' := fresh in\n                  pose proof (f_equal length H) as H';\n                  rewrite app_length in H'; simpl in H'; omega\n                end).\n  - eexists _, _, _; split; first by unshelve (repeat econstructor; eauto).\n    intros ? ? ? ?; simpl in *;\n      match goal with\n      | H: ?A ++ [_] = ?A ++ [_] |- _ =>\n        apply app_inv_head in H; simplify_eq; simpl in *; eauto\n      end.\nQed.\n\nLemma soundness_io e M :\n  prefix_closed M \u2192 erased_safe e M \u2192 fully_erased_safe e M.\nProof.\n  intros Hpc Hs th2 \u03c32 HM\u03c32 Hrtc re Hre.\n  assert (rtc (@language.step PE_lang)\n              ([e], {| EHeap := \u2205; EProph := \u2205; EioState := M |})\n              (th2, make_ioSpec \u03c32 M)) as Hrtc'.\n  { eapply fully_erased_reachable_reachable; eauto. }\n  edestruct Hs as [?|Hred]; eauto.\n  right. eapply reducible_fully_erase_reducible; eauto.\n  by apply make_ioSpec_IO_performed.\nQed.\n"}
{"text": "theory Ex044 \n  imports Main \nbegin \n  \ntheorem \"\\<lbrakk>\\<not>(\\<not>(A \\<longrightarrow> B) \\<and> \\<not>B) ; \\<not>C \\<longrightarrow> A \\<rbrakk> \\<Longrightarrow> C \\<or> B\" \nproof - \n  assume a:\"\\<not>(\\<not>(A \\<longrightarrow> B) \\<and> \\<not>B)\"\n  and b:\"\\<not>C \\<longrightarrow> A\"\n  {\n    assume c:\"\\<not>(C \\<or> B)\"\n    {\n      assume d:\"\\<not>C\"\n      {\n        assume e:\"\\<not>B\"\n        {\n          assume f:\"A \\<longrightarrow> B\"\n          from b d have A by (rule mp)\n          with f have B by (rule mp)\n          with e have False by contradiction\n        }\n        hence \"\\<not>(A \\<longrightarrow> B)\" by (rule notI)\n        from this e have \"\\<not>(A \\<longrightarrow> B) \\<and> \\<not>B\" by (rule conjI)\n        with a have False by (rule notE)\n      }\n      hence \"\\<not>\\<not>B\" by (rule notI)\n      hence B by (rule notnotD)\n      hence \"C \\<or> B\" by (rule disjI2)\n      with c have False by (rule notE)\n    }\n    hence \"\\<not>\\<not>C\" by (rule notI)\n    hence C by (rule notnotD)\n    hence \"C \\<or> B\" by (rule disjI1)\n    with c have False by (rule notE)\n  }\n  hence \"\\<not>\\<not> (C \\<or> B)\" by (rule notI)\n  thus \"C \\<or> B\" by (rule notnotD)\nqed\n\n"}
{"text": "# system/z-test.jl\n\nusing Test\n\n@test ir_lm_test_getindex_cumsum()\n@test hcat_lm(:test)\n"}
{"text": "lemma Reals_induct [case_names of_real, induct set: Reals]: \"q \\<in> \\<real> \\<Longrightarrow> (\\<And>r. P (of_real r)) \\<Longrightarrow> P q\""}
{"text": "import LMT\n\nvariable {I} [Nonempty I] {E} [Nonempty E] [Nonempty (A I E)]\n\nexample {a1 a2 a3 : A I E} :\n        (v1) \u2260 ((((a2).write i3 (v1)).write i1 (v1)).read i3) \u2192 False := by\n  arr\n"}
{"text": "Require Import Frap.\n\nTheorem another_important_theorem : length [1; 2; 3] = 1 + length [4; 5].\nProof.\n  simplify.\n  equality.\nQed.\n\nTheorem length_concat : forall A (xs ys : list A), length (xs ++ ys) = length xs + length ys.\nProof.\n  induct xs.\n  induct ys.\n  simplify.\n  equality.\n\n  simplify.\n  equality.\n\n  simplify.\n  f_equal.\n  rewrite IHxs.\n  equality.\nQed.\n\nTheorem length_rev : forall A (xs : list A), length xs = length (rev xs).\nProof.\n  induct xs.\n  simplify.\n  equality.\n  simplify.\n  rewrite length_concat.\n  simplify.\n  linear_arithmetic.\nQed."}
{"text": "lemma continuous_on_discrete [simp]: \"continuous_on A (f :: 'a :: discrete_topology \\<Rightarrow> _)\""}
{"text": "variables (real : Type) [ordered_ring real]\nvariables (log exp : real \u2192 real)\nvariable  log_exp_eq : \u2200 x, log (exp x) = x\nvariable  exp_log_eq : \u2200 {x}, x > 0 \u2192 exp (log x) = x\nvariable  exp_pos    : \u2200 x, exp x > 0\nvariable  exp_add    : \u2200 x y, exp (x + y) = exp x * exp y\n\n-- this ensures the assumptions are available in tactic proofs\ninclude log_exp_eq exp_log_eq exp_pos exp_add\n\nexample (x y z : real) :\n  exp (x + y + z) = exp x * exp y * exp z :=\nby rw [exp_add, exp_add]\n\nexample (y : real) (h : y > 0)  : exp (log y) = y :=\nexp_log_eq h\n\ntheorem log_mul {x y : real} (hx : x > 0) (hy : y > 0) :\n  log (x * y) = log x + log y :=\ncalc log (x * y)\n    = log (exp (log x) * exp (log y)) : by rw [exp_log_eq hx, exp_log_eq hy]\n... = log (exp (log x + log y))       : by rw exp_add\n... = log x + log y                   : by rw log_exp_eq\n"}
{"text": "theory ForExperiments\n\n(* Trying to explore/clarify the conditions under which\nwe can obtain a while rule *)\n\nimports \"./ImpCtl\" \"../Hoare/Hoare_Core\"\n\nbegin\n\nlemma WhileHelper :\n  assumes H0 : \"gs = \\<lparr> s_sem = pcomps' fs \\<rparr>\"\n  (*assumes H1 : \"seq_sem_l_gen lfts \\<in> set fs\" *)\n  assumes HF : \"f = imp_sem_l_gen lfts\"\n  assumes Hpres : \"sups_pres (set fs)\"\n  assumes Hnemp : \"g \\<in> set fs\"\n  assumes Hdom_while : \"(f \\<downharpoonleft> (set fs) SwhileC')\"\n  assumes Hdom_skip : \"(f \\<downharpoonleft> (set fs) Sskip')\"\n  assumes Hwhile : \"lfts SwhileC' = SwhileC\"\n  assumes Hskip : \"lfts Sskip' = ImpCtl.Sskip\"\n  (* TODO: generalize. these should be expressed using valid-sets *)\n  assumes Cond : \"get_cond (payload st) = Some True\"\n  assumes Cont : \"s_cont st = Inl ((G SwhileC' [G Sskip' l]) # c') \\<or>\n                  s_cont st = Inl ((G Sskip' l) # (G SwhileC' [G Sskip' l]) # c')\"\n  assumes Exec : \"sem_exec_p gs st st'\"\n\nshows \"payload st' = payload st \\<and>\n       (s_cont st' = Inl ((G SwhileC' [G Sskip' l]) # c') \\<or>\n        s_cont st' = Inl ((G Sskip' l) # (G SwhileC' [G Sskip' l]) # c'))\"\n  using Exec Cond Cont unfolding sem_exec_p_def\nproof(induction arbitrary: c' rule:converse_rtranclp_induct)\n  case base\n  then show ?case by auto\nnext\n  case (step y z)\n\n  show ?case\n  proof(cases \"sem_step gs y\")\n    case (Inr bad)\n\n    then have False using H0 step.prems\n      by(auto simp add: sem_step_def)\n\n    then show ?thesis by auto\n  next\n    case (Inl y')\n\n    have Zeq : \"y' = z\"\n      using Inl step.hyps unfolding sem_step_p_eq by auto\n\n    consider\n      (CaseA) \"s_cont y = Inl (G SwhileC' [G Sskip' l] # c')\" |\n      (CaseB) \"s_cont y = Inl (G Sskip' l # G SwhileC' [G Sskip' l] # c')\"\n      using step.prems by auto\n    then show ?thesis\n    proof cases\n      case CaseA\n\n      then have F_eq : \"sem_step \\<lparr> s_sem = f \\<rparr> y = Inl y'\"\n        using sym[OF dominant_pcomps'[OF Hpres Hnemp Hdom_while]] step.prems Inl H0\n        by(auto simp add: sem_step_def)\n\n\n      have C1 : \"payload z = payload y\"\n        using Hwhile H0 F_eq CaseA step.prems(1) unfolding HF Zeq\n        by(cases y; cases y'; \n            auto simp add: s_cont_def sem_step_def imp_sem_l_gen_def imp_ctl_sem_def imp_sem_lifting_gen_def\n            schem_lift_defs \n            merge_l_def fst_l_def snd_l_def prio_l_def triv_l_def option_l_def LNew_def\n            get_cond_def\n            split: md_prio.splits md_triv.splits option.splits)\n\n      hence C2 : \"get_cond (payload z) = Some True\" using step.prems by auto\n\n      have \"s_cont z = Inl (G Sskip' l # G SwhileC' [G Sskip' l] # c')\"\n        using Hwhile H0 F_eq CaseA step.prems(1) unfolding HF Zeq\n        by(cases y; cases y'; \n            auto simp add: s_cont_def sem_step_def imp_sem_l_gen_def imp_ctl_sem_def imp_sem_lifting_gen_def\n            schem_lift_defs \n            merge_l_def fst_l_def snd_l_def prio_l_def triv_l_def option_l_def LNew_def\n            get_cond_def\n            split: md_prio.splits md_triv.splits option.splits)\n\n      hence C3 : \"s_cont z = Inl (G SwhileC' [G Sskip' l] # c') \\<or>\n        s_cont z = Inl (G Sskip' l # G SwhileC' [G Sskip' l] # c')\"\n        by auto\n\n      then show ?thesis using step.IH[OF C2 C3] CaseA unfolding C1\n        by auto\n    next\n      case CaseB\n\n      then have F_eq : \"sem_step \\<lparr> s_sem = f \\<rparr> y = Inl y'\"\n        using sym[OF dominant_pcomps'[OF Hpres Hnemp Hdom_skip]] step.prems Inl H0\n        by(auto simp add: sem_step_def)\n\n\n      have C1 : \"payload z = payload y\"\n        using Hwhile H0 F_eq CaseB step.prems(1) unfolding HF Zeq\n        by(cases y;\n            auto simp add: s_cont_def sem_step_def imp_sem_l_gen_def imp_ctl_sem_def imp_sem_lifting_gen_def\n            schem_lift_defs \n            merge_l_def fst_l_def snd_l_def prio_l_def triv_l_def option_l_def LNew_def\n            get_cond_def\n            split: md_prio.splits md_triv.splits option.splits)\n\n      hence C2 : \"get_cond (payload z) = Some True\" using step.prems by auto\n\n      have C3' : \"s_cont z = Inl (G SwhileC' [G Sskip' l] # c')\"\n        using Hskip H0 F_eq CaseB step.prems(1) unfolding HF Zeq\n        by(cases y;\n            auto simp add: s_cont_def sem_step_def imp_sem_l_gen_def imp_ctl_sem_def imp_sem_lifting_gen_def\n            schem_lift_defs \n            merge_l_def fst_l_def snd_l_def prio_l_def triv_l_def option_l_def LNew_def\n            get_cond_def\n            split: md_prio.splits md_triv.splits option.splits)\n\n      hence C3 : \"s_cont z = Inl (G SwhileC' [G Sskip' l] # c') \\<or>\n        s_cont z = Inl (G Sskip' l # G SwhileC' [G Sskip' l] # c')\"\n        by auto\n\n      then show ?thesis using step.IH[OF C2 C3] CaseB C3' unfolding C1\n        by(auto)\n    qed\n  qed\nqed\n\nlemma WhileHelper1 :\n  assumes H0 : \"gs = \\<lparr> s_sem = pcomps' fs \\<rparr>\"\n  (*assumes H1 : \"seq_sem_l_gen lfts \\<in> set fs\" *)\n  assumes HF : \"f = imp_sem_l_gen lfts\"\n  assumes Hpres : \"sups_pres (set fs)\"\n  assumes Hnemp : \"g \\<in> set fs\"\n  assumes Hdom_while : \"(f \\<downharpoonleft> (set fs) SwhileC')\"\n  assumes Hdom_skip : \"(f \\<downharpoonleft> (set fs) Sskip')\"\n  assumes Hwhile : \"lfts SwhileC' = SwhileC\"\n  assumes Hskip : \"lfts Sskip' = ImpCtl.Sskip\"\n  (* TODO: generalize. these should be expressed using valid-sets *)\n  assumes Cond : \"\\<And> st . P1 st \\<Longrightarrow> get_cond st = Some True\"\n\n  assumes Htrue : \"|gs| {- P1 -} [body]\n                        {- P1 -}\"\nshows \"|gs| {- P1  -} replicate n body @ [(G SwhileC' [G Sskip' l])] {- (\\<lambda> st . False ) -}\"\nproof(induction n arbitrary: )\n  case 0\n\n  have \"|gs| {-P1-} [G SwhileC' [G Sskip' l]] {-C False-}\"\n  proof\n    fix c'\n    assume Hc' : \"|gs| {\\<lambda> x. False} c'\"\n\n    show \"|gs| {P1} [G SwhileC' [G Sskip' l]] @ c'\"\n    proof\n      fix m :: \"('a, 'b) state\"\n      assume Pay : \"P1 (payload m)\" \n      assume Cont : \"s_cont m = Inl ([G SwhileC' [G Sskip' l]] @ c')\"\n\n      hence Cont' : \"s_cont m = Inl (G SwhileC' [G Sskip' l] # c')\" by auto\n\n      have Cond : \"get_cond (payload m) = Some True\"\n        using Cond[OF Pay] by auto\n\n      show \"safe gs m\"\n      proof\n        fix m' :: \"('a, 'b) state\"\n        assume Exec : \"sem_exec_p gs m m'\"\n\n        have Cont'' : \"s_cont m = Inl (G SwhileC' [G Sskip' l] # c') \\<or>\n           s_cont m = Inl (G Sskip' l # G SwhileC' [G Sskip' l] # c')\"\n          using disjI1[OF Cont'] by auto\n\n        have Cases : \"(s_cont m' = Inl (G SwhileC' [G Sskip' l] # c') \\<or>\n         s_cont m' = Inl (G Sskip' l # G SwhileC' [G Sskip' l] # c'))\"\n          using WhileHelper[OF H0 HF Hpres Hnemp Hdom_while Hdom_skip Hwhile Hskip Cond Cont'' Exec]\n          by auto\n\n        consider (CaseA) \"s_cont m' = Inl (G SwhileC' [G Sskip' l] # c')\" |\n                 (CaseB) \"s_cont m' = Inl (G Sskip' l # G SwhileC' [G Sskip' l] # c')\"\n          using Cases by auto\n\n        then show \"imm_safe gs m'\" \n        proof cases\n          case CaseA\n\n          then show ?thesis\n          proof(cases \"sem_step gs m'\")\n            case (Inr bad)\n            then have False using H0 CaseA\n              by(auto simp add: sem_step_def)\n        \n            then show ?thesis by auto\n          next\n            case (Inl m'')\n            then show ?thesis \n              unfolding imm_safe_def sem_step_p_eq by blast\n          qed\n        next\n          case CaseB\n          then show ?thesis\n          proof(cases \"sem_step gs m'\")\n            case (Inr bad)\n            then have False using H0 CaseB\n              by(auto simp add: sem_step_def)\n        \n            then show ?thesis by auto\n          next\n            case (Inl m'')\n            then show ?thesis \n              unfolding imm_safe_def sem_step_p_eq by blast\n          qed\n        qed\n      qed\n    qed\n  qed\n\n  thus ?case by auto\nnext\n    \n  case (Suc n)\n\n  have \"|gs| {-P1-} body # replicate ( n) body @ [G SwhileC' [G Sskip' l]] {-C False-}\"\n    using HCat[OF Htrue Suc.IH] by auto\n\n  then show ?case by auto\nqed\n\n(* use notion of absorption, again from Appel paper. \n\"separation logic for small step cminor\"\n*)\n\ntype_synonym 'full only_control =\n\"'full gensyn list md_triv option md_prio * String.literal md_triv option md_prio\"\n\n(* do we need to partition out the continuation from the state here? *)\ndefinition absorbs :: \"('syn, 'mstate) semc \\<Rightarrow> 'syn gensyn \\<Rightarrow> 'mstate \\<Rightarrow> nat \\<Rightarrow> bool\" where\n\"absorbs gs st m n =\n  (\\<forall> j . j \\<le> n \\<longrightarrow> \n    (\\<exists> prefix st' .  \n      (\\<forall> k m_full .\n        s_cont m_full = Inl (st # k) \\<longrightarrow> \n        payload m_full = m \\<longrightarrow>\n        (\\<exists> m_full' . \n          sem_exec_c_p gs m_full j m_full' \\<and> \n          payload m_full' = st' \\<and>\n          s_cont m_full' = Inl (prefix @ k)))))\"\n\nlemma absorbs_0 :\n  \"absorbs gs st m 0\"\nproof-\n\n  have 0: \"(\\<And> a aa k . s_cont (a, aa, m) = Inl (st # k) \\<Longrightarrow>\n        \\<exists>ab ac.\n          sem_exec_c_p gs (a, aa, m) 0 (ab, ac, m) \\<and>\n          s_cont (ab, ac, m) = Inl (st # k)) \\<Longrightarrow> absorbs gs st m 0\"\n    unfolding absorbs_def\n    apply(auto)\n    apply(rule_tac x = \"[st]\" in exI)\n    apply(rule_tac x = m in exI)\n    apply(auto)\n    done\n\n  have 1: \"\\<And> a aa k . s_cont (a, aa, m) = Inl (st # k) \\<Longrightarrow>\n        \\<exists>ab ac.\n          sem_exec_c_p gs (a, aa, m) 0 (ab, ac, m) \\<and>\n          s_cont (ab, ac, m) = Inl (st # k)\"\n  proof-\n    fix a aa k\n    assume H: \"s_cont (a, aa, m) = Inl (st# k)\"\n\n    show \"\\<exists>ab ac.\n          sem_exec_c_p gs (a, aa, m) 0 (ab, ac, m) \\<and>\n          s_cont (ab, ac, m) = Inl (st # k)\"\n      using sem_exec_c_p.intros(1)[of gs \"(a, aa, m)\"] H\n      by auto\n  qed\n\n  show \"absorbs gs st m 0\" using 0 1\n    by auto\nqed\n\n\nlemma absorbs_less :\n  assumes H : \"absorbs gs st m (Suc n)\"\n  shows \"absorbs gs st m n\" using H\n  unfolding absorbs_def\nproof(step)\n  fix j\n\n  assume H0 : \"\\<forall>j\\<le>Suc n.\n            \\<exists>prefix st'.\n               \\<forall>k m_full.\n                  s_cont m_full = Inl (st # k) \\<longrightarrow>\n                  payload m_full = m \\<longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full j m_full' \\<and> payload m_full' = st' \\<and> s_cont m_full' = Inl (prefix @ k))\"\n  assume H1: \"j \\<le> n\"\n\n  have H0' : \"\\<exists>prefix st'.\n               \\<forall>k m_full.\n                  s_cont m_full = Inl (st # k) \\<longrightarrow>\n                  payload m_full = m \\<longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full j m_full' \\<and> payload m_full' = st' \\<and> s_cont m_full' = Inl (prefix @ k))\"\n    using H0 H1\n    by auto\n\n  then obtain prefix st' where Hpfx :\n    \"\\<And> k m_full . s_cont m_full = Inl (st # k) \\<Longrightarrow>\n                  payload m_full = m \\<Longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full j m_full' \\<and> payload m_full' = st' \\<and> s_cont m_full' = Inl (prefix @ k))\"\n    by blast\n\n  then show \" \\<exists>prefix st'.\n            \\<forall>k m_full.\n               s_cont m_full = Inl (st # k) \\<longrightarrow> payload m_full = m \\<longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full j m_full' \\<and> payload m_full' = st' \\<and> s_cont m_full' = Inl (prefix @ k))\"\n    by blast\nqed\n  \n\nlemma absorbs_at_most :\n  assumes H: \"\\<not> absorbs gs st m n\"\n  shows \"\\<exists> i . i < n \\<and> absorbs gs st m i \\<and> \\<not> absorbs gs st m (Suc i)\" using H\nproof(induction n arbitrary: m)\n  case 0\n\n  then have False using absorbs_0[of gs st m] by auto\n\n  then show ?case by auto\nnext\n  case (Suc n)\n\n  then show ?case\n  proof(cases \"absorbs gs st m n\")\n    case False\n\n    have \"\\<exists>i<n. absorbs gs st m i \\<and> \\<not> absorbs gs st m (Suc i)\"\n      using Suc.IH[OF False] by auto\n\n    then obtain i where Li : \"i < n\" and Ai : \"absorbs gs st m i\" and Nai : \"\\<not> absorbs gs st m (Suc i)\"\n      by blast\n\n    have C1 : \"i < Suc n\" using Li by auto\n  \n    show ?thesis using C1 Ai Nai by blast\n  next\n    case True\n\n    have C1 : \"n < Suc n\" by auto\n\n    show ?thesis using Suc.prems C1 True by blast\n  qed\nqed\n\n\nlemma HWhile_gen0 :\n  assumes H0 : \"gs = \\<lparr> s_sem = pcomps' fs \\<rparr>\"\n  (*assumes H1 : \"seq_sem_l_gen lfts \\<in> set fs\" *)\n  assumes HF : \"f = imp_sem_l_gen lfts\"\n  assumes Hpres : \"sups_pres (set fs)\"\n  assumes Hnemp : \"g \\<in> set fs\"\n  assumes Hdom_while : \"(f \\<downharpoonleft> (set fs) SwhileC')\"\n  assumes Hdom_skip : \"(f \\<downharpoonleft> (set fs) Sskip')\"\n  assumes Hwhile : \"lfts SwhileC' = SwhileC\"\n  assumes Hskip : \"lfts Sskip' = ImpCtl.Sskip\"\n  (* TODO: generalize. these should be expressed using valid-sets *)\n  assumes P1_valid : \"\\<And> st.  P1 st \\<Longrightarrow> get_cond st = Some True\"\n  assumes Htrue : \"|gs| {- P1 -} [body]\n                        {- P1 -}\"\n  shows \"|gs| {- P1  -} [(G Swhile'C [body])] {- (\\<lambda> st . False ) -}\"\nproof\n\n  fix c'\n  assume Guard : \"|gs| {\\<lambda>st. False } c'\"\n\n  show \"|gs| {P1} [(G Swhile'C [body])] @ c'\"\n  proof\n    fix m :: \"('a, 'b) state\"\n    assume P : \"P1 (payload m)\"\n\n    assume Cont : \"s_cont m = Inl (([G Swhile'C [body]]) @ c')\"\n\n    hence Cont' : \"s_cont m = Inl ((G Swhile'C [body]) # c')\"\n      by auto\n\n    show \"safe gs m\"\n    proof\n      fix m' :: \"('a, 'b) state\"\n\n      assume Exec : \"sem_exec_p gs m m'\"\n\n      obtain n where N : \"sem_exec_c_p gs m n m'\"\n        using exec_p_imp_exec_c_p[OF Exec]\n        by auto\n\n      have Unfold : \"|gs| {-P1-} replicate n body @\n                [G SwhileC' [G Sskip' []]] {-C False-}\"\n        using WhileHelper1[OF H0 HF Hpres Hnemp Hdom_while Hdom_skip Hwhile Hskip\n            P1_valid _ ] Htrue\n        by fastforce\n\n      have Guard' : \"|gs| {P1} (replicate n body @ [G SwhileC' [G Sskip' []]]) @ c'\" \n        using HTE[OF Unfold Guard] by auto\n\n\n      (* gross low-level deconstruction of m to build a new state *)\n      obtain m1 m2xx m3 m4 m5 where Mcomp : \"m = (m1, m2xx, m3, m4, m5)\"\n        by(cases m; auto)\n\n      obtain malt :: \"('a, 'b) state\" where Malt :\n        \"malt = (mdp 0 (Some (mdt (replicate n body @ [G SwhileC' [G Sskip' []]] @ c'))), \n                 mdp 0 None,\n                 m3,\n                 m4,\n                 m5)\" by simp\n\n      have Malt_pl : \"payload malt = payload m\" using Malt Mcomp by auto\n\n      hence Malt_P : \"P1 (payload malt)\" using P unfolding Malt_pl by auto\n\n      have Malt_cont : \"s_cont malt = Inl (((replicate n body @ [G SwhileC' [G Sskip' []]]) @ c'))\"\n        using Malt by (auto simp add: s_cont_def)\n        \n      have Malt_safe : \"safe gs malt\" using guardedD[OF Guard' Malt_P Malt_cont] by auto\n\n      obtain m2 where M2 : \"sem_step_p gs m m2\" and M2_cont : \"s_cont m2 = Inl (body # ([G Swhile'C [body]] @ c'))\" and M2_pay : \"payload m2 = payload m\"\n        sorry\n\n      obtain maltb :: \"('a, 'b) state\" where Maltb :\n        \"maltb = (mdp 0 (Some (mdt (body # []))), \n                 mdp 0 None,\n                 m3,\n                 m4,\n                 m5)\" by simp\n\n      have Maltb_pl : \"payload maltb = payload m\" using Maltb Mcomp by auto\n\n      hence Maltb_P : \"P1 (payload maltb)\" using P unfolding Maltb_pl by auto\n\n      have Maltb_cont : \"s_cont maltb = Inl (body # [])\"\n        using Maltb by (auto simp add: s_cont_def)\n\n\n      show \"imm_safe gs m'\" using N\n      proof(cases rule: sem_exec_c_p.cases)\n        case Excp_0\n\n        have \"imm_safe gs m\" sorry\n\n        then show ?thesis using Excp_0 by auto\n      next\n        (* We are just doing this to get the fact that n > 0. or should be we doing an actual induction? *)\n        case (Excp_Suc mz2 n')\n   \n        have Malt_cont' : \"s_cont malt = Inl (body # ((replicate n' body @ [G SwhileC' [G Sskip' []]]) @ c'))\"\n          using Excp_Suc Malt_cont\n          by auto\n\n        show \"imm_safe gs m'\"\n        proof(cases \"absorbs gs body (payload m) n\")\n          case True\n  \n          have \"\\<exists>prefix st'.\n                \\<forall>k m_full.\n                   s_cont m_full = Inl (body # k) \\<longrightarrow>\n                   payload m_full = payload m \\<longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full n m_full' \\<and> payload m_full' = st' \\<and> s_cont m_full' = Inl (prefix @ k))\"\n            using True unfolding absorbs_def by auto\n  \n  \n          then obtain prefix and m'x :: \"(bool md_triv option md_prio * int md_triv option md_prio * 'b)\" where \n              Absorbed : \"\\<forall>k m_full.\n                   s_cont m_full = Inl (body # k) \\<longrightarrow>\n                   payload m_full = payload m \\<longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full n m_full' \\<and> payload m_full' = m'x \\<and> s_cont m_full' = Inl (prefix @ k))\"\n            by blast\n  \n          then obtain malt' ::\"('a, 'b) state\"  where\n            \"(sem_exec_c_p gs malt n malt' \\<and> payload malt' = m'x \\<and> s_cont malt' = Inl (prefix @ ((replicate n' body @ [G SwhileC' [G Sskip' []]]) @ c')))\"\n            using Malt_cont' Malt_pl\n            by blast\n\n          have \"imm_safe gs malt'\" sorry (* since malt is known to be safe *)\n\n          obtain m2' ::\"('a, 'b) state\" where \"sem_exec_c_p gs m2 n m2' \\<and> payload m2' = m'x \\<and> s_cont m2' = Inl (prefix @ ([G Swhile'C [body]] @ c'))\"\n            using M2_cont M2_pay Absorbed\n            by blast\n\n          hence M2'_exec : \"sem_exec_c_p gs m2 n m2' \" by auto\n\n          have \"imm_safe gs m2'\" (* since prefix will be enough to guarantee safety *) sorry\n\n          have Exec_m2' : \"sem_exec_c_p gs m (n+1) m2'\" using sem_exec_c_p.intros(2)[OF M2 M2'_exec] by auto\n\n          have Duh : \"n \\<le> n + 1\" by simp\n\n          obtain m'_copy where M'_copy1 : \"sem_exec_c_p gs m n m'_copy\" and M'_copy2 : \"sem_exec_c_p gs m'_copy (n + 1 - n) m2'\" using exec_c_p_split[OF Exec_m2' Duh] \n            by auto\n\n          have M'_copy_m' : \"m'_copy = m'\" using exec_c_p_determ[OF N M'_copy1]\n            by auto\n\n          have Last_step : \"sem_exec_c_p gs m'_copy (1) m2'\" using M'_copy2 by auto\n\n          hence \"sem_step_p gs m' m2'\"\n            using Excp_1'[OF Last_step] unfolding M'_copy_m' by auto\n  \n          then show ?thesis unfolding imm_safe_def by blast\n        next\n          case False\n\n          obtain i where\n            Ilt : \"i < n\" and Iabs : \"absorbs gs body (payload m) i\" and Imax : \"\\<not> absorbs gs body (payload m) (Suc i)\"\n            using absorbs_at_most[OF False] by blast\n\n          have M2_cont' : \"s_cont m2 = Inl (body # ([G Swhile'C [body]] @ c'))\" using M2_cont by auto\n\n          have \"\\<exists>prefix st'.\n                \\<forall>k m_full.\n                   s_cont m_full = Inl (body # k) \\<longrightarrow>\n                   payload m_full = payload m \\<longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full i m_full' \\<and> payload m_full' = st' \\<and> s_cont m_full' = Inl (prefix @ k))\"\n            using Iabs unfolding absorbs_def by auto\n  \n  \n          then obtain prefix and m'x :: \"(bool md_triv option md_prio * int md_triv option md_prio * 'b)\" where \n              Absorbed : \"\\<forall>k m_full.\n                   s_cont m_full = Inl (body # k) \\<longrightarrow>\n                   payload m_full = payload m \\<longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full i m_full' \\<and> payload m_full' = m'x \\<and> s_cont m_full' = Inl (prefix @ k))\"\n            by blast\n\n          hence Absorbed' :\n            \"\\<And> k m_full.\n                   s_cont m_full = Inl (body # k) \\<Longrightarrow>\n                   payload m_full = payload m \\<Longrightarrow> (\\<exists>m_full'. sem_exec_c_p gs m_full i m_full' \\<and> payload m_full' = m'x \\<and> s_cont m_full' = Inl (prefix @ k))\"\n            by blast\n  \n          obtain m2' ::\"('a, 'b) state\"  where M2_exec :\n            \"(sem_exec_c_p gs m2 i m2' \\<and> payload m2' = m'x \\<and> s_cont m2' = Inl (prefix @ (([G Swhile'C [body]] @ c'))))\"\n            using Absorbed'[OF M2_cont'  M2_pay]\n            by blast\n\n          obtain malt' ::\"('a, 'b) state\"  where Malt_exec :\n            \"(sem_exec_c_p gs malt i malt' \\<and> payload malt' = m'x \\<and> s_cont malt' = Inl (prefix @ ((replicate n' body @ [G SwhileC' [G Sskip' []]]) @ c')))\"\n            using Absorbed' Malt_cont' Malt_pl\n            by blast\n\n          have \"imm_safe gs malt'\" sorry (* since malt is known to be safe *)\n\n          obtain maltb' ::\"('a, 'b) state\"  where Maltb' :\n            \"(sem_exec_c_p gs maltb i maltb' \\<and> payload maltb' = m'x \\<and> s_cont maltb' = Inl (prefix @ []))\"\n            using Absorbed'[OF Maltb_cont Maltb_pl] Maltb_cont\n            by blast\n\n          obtain j where \n            Jleq : \"j \\<le> Suc i\"\n            and Imax' : \"\\<not> (\\<exists>prefix st'.\n                          \\<forall>k m_full.\n                             s_cont m_full = Inl (body # k) \\<longrightarrow>\n                             payload m_full = payload m \\<longrightarrow>\n                             (\\<exists>m_full'.\n                                 sem_exec_c_p gs m_full j m_full' \\<and>\n                                 payload m_full' = st' \\<and>\n                                 s_cont m_full' = Inl (prefix @ k)))\"\n            using Imax unfolding absorbs_def\n            by auto\n\n          show \"imm_safe gs m'\"\n          proof(cases \"j = Suc i\")\n            case False' : False\n\n            hence Jleq' : \"j \\<le> i\" using Jleq by auto\n\n            have Uhoh : \"(\\<exists>prefix st'.\n                          \\<forall>k m_full.\n                             s_cont m_full = Inl (body # k) \\<longrightarrow>\n                             payload m_full = payload m \\<longrightarrow>\n                             (\\<exists>m_full'.\n                                 sem_exec_c_p gs m_full j m_full' \\<and>\n                                 payload m_full' = st' \\<and>\n                                 s_cont m_full' = Inl (prefix @ k)))\"\n              using Iabs Jleq' unfolding absorbs_def\n              by blast\n\n            have False\n              using Imax' Uhoh by blast\n\n            then show ?thesis by auto\n          next\n            case True' : True\n(* case split on whether prefix is [].\nif it is nil, \"apply induction on the case n-j\" (i.e., spill over into next iteration *)\n\n(* if prefix is non-nil, we need some fact about how the resulting continuation\nwill be the same between malt' and m2'\n\n*)\n\n            show \"imm_safe gs m'\"\n            proof(cases prefix)\n              case Nil\n              then show ?thesis (* do an inductive thingy, n - j < n *) sorry\n            next\n              case (Cons preh pret)\n\n              obtain mfin1 mfin1p kfin1 where \"sem_exec_c_p gs m2' 1 mfin1 \\<and> payload mfin1 = mfin1p \\<and> s_cont mfin1 = kfin1\" sorry\n\n(* we know we are safe here (malt') *)\n\n              obtain mfin2 mfin2p kfin2 where \"sem_exec_c_p gs malt' 1 mfin2 \\<and> payload mfin2 = mfin2p \\<and> s_cont mfin2 = kfin2\"\n                sorry\n\n              show \"imm_safe gs m'\"\n                using HTE[OF Htrue] \n\n(* idea: we are looking at some kind of function f where \nf ((ph#pt) @ ((replicate n' body @ [G SwhileC' [G Sskip' []]]) @ c'))) =\nf ((ph#pt) @ (([G Swhile'C [body]] @ c')))\n*)\n\n(* executing preh should be imm. safe - regardless of whether this happens in maltb' or malt' *)\n(* we need to be able to use the fact that lack of suffix implies escape happens. but unlike appel's system,\nour continuations might be too free-form to make this work.\n\n*)\n              then show ?thesis sorry\n            qed\n\n\n(*\n\"\\<And>prefix a aa b.\n       (\\<And> k m_full.\n          s_cont m_full = Inl (body # k) \\<Longrightarrow>\n          payload m_full = payload m \\<Longrightarrow>\n          (\\<exists>m_full'.\n              sem_exec_c_p gs m_full j m_full' \\<and>\n              payload m_full' = (a, aa, b) \\<and> s_cont m_full' = Inl (prefix @ k))) \\<Longrightarrow> False\"\n*)\n\n(* idea: 2 possibilities at this point\n- stepping into prefix results in an empty continuation \\<Rightarrow> we are done\n- stepping into the prefix results in \"escape\" beyond the loop.\nhowever, can we cheat at this point? use information from the continuation list to do\ndifferent things in different cases in a way that is bad?\n*)\n\n(* we still have n-i steps to go ... we need to know something about the behavior of the prefix. *)\n\n(* one idea: prefix cannot choose whether to fail based on data (or shape) of continuation *)\n(* another idea: just based on data of continuation *)\n\n(* prefix should be safe for any state that was produced from running body starting at P1 *)\n(* {-?-} prefix {-P1-} *)\n\n            have \"|gs| {-(\\<lambda> st . st = m'x)-} prefix {-P1-}\"\n            proof\n              fix cx\n\n              assume G : \"|gs| {P1} cx\"\n              show \"|gs| {\\<lambda>st. st = m'x} prefix @ cx\"\n              proof\n                fix mp :: \"('a, 'b) state\"\n                assume Hmp : \"(payload mp) = m'x\"\n                assume Hmpc : \"s_cont mp = Inl (prefix @ cx)\"\n\n                have \"|gs| {P1} [body] @ cx\" using HTE[OF Htrue G] by auto\n\n                show \"safe gs mp\" \n                proof\n                  fix mp'\n\n                  assume \"sem_exec_p gs mp mp'\"\n                  show \"imm_safe gs mp'\"\n\n\n            then show ?thesis \n          qed\n\n          have False using Imax Iabs unfolding absorbs_def\n\n(*\nexists Suc i where\nforall prefix st'\nexists k, m_full where\ns_cont m_full \\<noteq> Inl (body # k) \\<and>\npayload m_full \n*)\n\n(* idea: we know prefix must be something that throws away the continuation. the appel paper does a specific case analysis on \"non-local\"\ncontrol flow at this point. perhaps we need to do the same? this would require a \"closed world\" of non-local control flow when we instantiate\nthis theorem, which isn't unreasonable. *)\n          then show ?thesis using  Imax unfolding absorbs_def\n        qed\n      qed\n    qed\n  qed\nqed\n\n\n(*\nlemma HWhile_gen0 :\n  assumes H0 : \"gs = \\<lparr> s_sem = pcomps' fs \\<rparr>\"\n  (*assumes H1 : \"seq_sem_l_gen lfts \\<in> set fs\" *)\n  assumes HF : \"f = imp_sem_l_gen lfts\"\n  assumes Hpres : \"sups_pres (set fs)\"\n  assumes Hnemp : \"g \\<in> set fs\"\n  assumes Hdom_while : \"(f \\<downharpoonleft> (set fs) SwhileC')\"\n  assumes Hdom_skip : \"(f \\<downharpoonleft> (set fs) Sskip')\"\n  assumes Hwhile : \"lfts SwhileC' = SwhileC\"\n  assumes Hskip : \"lfts Sskip' = ImpCtl.Sskip\"\n  (* TODO: generalize. these should be expressed using valid-sets *)\n  assumes P1_valid : \"\\<And> st.  P1 st \\<Longrightarrow> get_cond st = Some True\"\n  assumes Htrue : \"|gs| {- P1 -} [body]\n                        {- P1 -}\"\n  shows \"|gs| {- P1  -} [(G Swhile'C [body])] {- (\\<lambda> st . False ) -}\"\nproof\n  fix c'\n  assume Guard : \" |gs| {C False} c'\"\n\n  show \"|gs| {P1} ([G Swhile'C [body]]) @ c'\"\n  proof\n    fix m :: \"('a, 'b) state\"\n    assume Mp : \"P1 (payload m)\"\n    assume Mc : \"s_cont m = Inl (([G Swhile'C [body]]) @ c')\"\n    show \"safe gs m\"\n    proof\n      fix m' :: \"('a, 'b) state\"\n\n      assume Exec : \"sem_exec_p gs m m'\"\n\n      obtain cnt where Exec' : \"sem_exec_c_p gs m cnt m'\"\n        using exec_p_imp_exec_c_p[OF Exec] by auto\n\n      have \"|gs| {- P1  -} replicate cnt body @ [(G Swhile'C [body])] {- (\\<lambda> st . False ) -}\"\n\n      then show \"imm_safe gs m'\" using Guard Mp Mc\n      proof(induction arbitrary: c' rule: sem_exec_c_p.induct)\n        case (Excp_0 m0)\n        then show ?case unfolding imm_safe_def sorry\n      next\n        case (Excp_Suc m1 m2 n m3)\n        then show ?case \n      qed\n*)\nend"}
{"text": "theory ExF018 \n  imports Main \nbegin \n  \nlemma \"(\\<forall>x. \\<forall>y. (P x \\<longleftrightarrow> P y)  \\<longrightarrow> (x \\<longleftrightarrow> y)) \\<Longrightarrow> (\\<forall>x. \\<forall>y. (x \\<longleftrightarrow> y) \\<longrightarrow> (P x \\<longleftrightarrow> P y)) \\<Longrightarrow> (\\<forall>x. P (P x) \\<longleftrightarrow> x)\" \nproof -\n  {\n    assume \"(\\<forall>x. \\<forall>y. (P x \\<longleftrightarrow> P y)  \\<longrightarrow> (x \\<longleftrightarrow> y))\"\n    {\n      assume \"(\\<forall>x. \\<forall>y. (x \\<longleftrightarrow> y) \\<longrightarrow> (P x \\<longleftrightarrow> P y))\" \n      {\n        assume \"\\<forall>x. P (P x)\" \n        {\n          "}
{"text": "lemma homotopic_paths: \"homotopic_paths s p q \\<longleftrightarrow> (\\<exists>h. continuous_on ({0..1} \\<times> {0..1}) h \\<and> h ` ({0..1} \\<times> {0..1}) \\<subseteq> s \\<and> (\\<forall>x \\<in> {0..1}. h(0,x) = p x) \\<and> (\\<forall>x \\<in> {0..1}. h(1,x) = q x) \\<and> (\\<forall>t \\<in> {0..1::real}. pathstart(h \\<circ> Pair t) = pathstart p \\<and> pathfinish(h \\<circ> Pair t) = pathfinish p))\""}
{"text": "[STATEMENT]\nlemma Deq_enabled: \n    \"\\<And>q. basevars (ic,q,oc) \\<Longrightarrow> \\<turnstile> Enabled (<Deq ic q oc>_(ic,q,oc)) = (q \\<noteq> #[])\"\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. basevars (ic, q, oc) \\<Longrightarrow> \\<turnstile> Enabled (<Deq ic q oc>_(ic, q, oc)) = (q \\<noteq> #[])\n[PROOF STEP]\napply (unfold Deq_visible [temp_rewrite])\n[PROOF STATE]\nproof (prove)\ngoal (1 subgoal):\n 1. \\<And>q. basevars (ic, q, oc) \\<Longrightarrow> \\<turnstile> Enabled Deq ic q oc = (q \\<noteq> #[])\n[PROOF STEP]\napply (force elim!: base_enabled [temp_use] enabledE [temp_use] simp: Deq_def)\n[PROOF STATE]\nproof (prove)\ngoal:\nNo subgoals!\n[PROOF STEP]\ndone"}
{"text": "lemma fract_poly_0 [simp]: \"fract_poly 0 = 0\""}
{"text": "(** Formal Reasoning About Programs <http://adam.chlipala.net/frap/>\n  * Chapter 7: Model Checking\n  * Author: Adam Chlipala\n  * License: https://creativecommons.org/licenses/by-nc-nd/4.0/ *)\n\nSet Warnings \"-notation-overridden\". (* <-- needed while we play with defining one\n                                      * of the book's notations ourselves locally *)\nRequire Import Frap TransitionSystems.\n\nSet Implicit Arguments.\n\n\n(* Coming up with invariants ourselves can be tedious!  Let's investigate how we\n * can automate the choice of invariants, for systems with only finitely many\n * reachable states.  This style is known as model checking. *)\nDefinition oneStepClosure_current {state} (sys : trsys state)\n           (invariant1 invariant2 : state -> Prop) :=\n  forall st, invariant1 st\n             -> invariant2 st.\n\nDefinition oneStepClosure_new {state} (sys : trsys state)\n           (invariant1 invariant2 : state -> Prop) :=\n  forall st st', invariant1 st\n                 -> sys.(Step) st st'\n                 -> invariant2 st'.\n\nDefinition oneStepClosure {state} (sys : trsys state)\n           (invariant1 invariant2 : state -> Prop) :=\n  oneStepClosure_current sys invariant1 invariant2\n  /\\ oneStepClosure_new sys invariant1 invariant2.\n\nTheorem prove_oneStepClosure : forall state (sys : trsys state) (inv1 inv2 : state -> Prop),\n  (forall st, inv1 st -> inv2 st)\n  -> (forall st st', inv1 st -> sys.(Step) st st' -> inv2 st')\n  -> oneStepClosure sys inv1 inv2.\nProof.\n  unfold oneStepClosure.\n  propositional.\nQed.\n\nTheorem oneStepClosure_done : forall state (sys : trsys state) (invariant : state -> Prop),\n  (forall st, sys.(Initial) st -> invariant st)\n  -> oneStepClosure sys invariant invariant\n  -> invariantFor sys invariant.\nProof.\n  unfold oneStepClosure, oneStepClosure_current, oneStepClosure_new.\n  propositional.\n  apply invariant_induction.\n  assumption.\n  simplify.\n  eapply H2.\n  eassumption.\n  assumption.\nQed.\n\nInductive multiStepClosure {state} (sys : trsys state)\n  : (state -> Prop) -> (state -> Prop) -> Prop :=\n\n(* We might be done, if one-step closure has no effect. *)\n| MscDone : forall inv,\n    oneStepClosure sys inv inv\n    -> multiStepClosure sys inv inv\n\n(* Or we might need to run another one-step closure and recurse. *)\n| MscStep : forall inv inv' inv'',\n    oneStepClosure sys inv inv'\n    -> multiStepClosure sys inv' inv''\n    -> multiStepClosure sys inv inv''.\n\nLemma multiStepClosure_ok' : forall state (sys : trsys state) (inv inv' : state -> Prop),\n  multiStepClosure sys inv inv'\n  -> (forall st, sys.(Initial) st -> inv st)\n  -> invariantFor sys inv'.\nProof.\n  induct 1; simplify.\n\n  apply oneStepClosure_done.\n  assumption.\n  assumption.\n\n  apply IHmultiStepClosure.\n  simplify.\n  unfold oneStepClosure, oneStepClosure_current in *.\n  propositional.\n  apply H3.\n  apply H1.\n  assumption.\nQed.\n\nTheorem multiStepClosure_ok : forall state (sys : trsys state) (inv : state -> Prop),\n  multiStepClosure sys sys.(Initial) inv\n  -> invariantFor sys inv.\nProof.\n  simplify.\n  eapply multiStepClosure_ok'.\n  eassumption.\n  propositional.\nQed.\n\nTheorem oneStepClosure_empty : forall state (sys : trsys state),\n  oneStepClosure sys (constant nil) (constant nil).\nProof.\n  unfold oneStepClosure, oneStepClosure_current, oneStepClosure_new; propositional.\nQed.\n\nTheorem oneStepClosure_split : forall state (sys : trsys state) st sts (inv1 inv2 : state -> Prop),\n  (forall st', sys.(Step) st st' -> inv1 st')\n  -> oneStepClosure sys (constant sts) inv2\n  -> oneStepClosure sys (constant (st :: sts)) ({st} \\cup inv1 \\cup inv2).\nProof.\n  unfold oneStepClosure, oneStepClosure_current, oneStepClosure_new; propositional.\n\n  invert H0.\n\n  left.\n  (* [left] and [right]: prove a disjunction by proving the left or right case,\n   *   respectively.  Note that here, we are using the fact that set union\n   *   [\\cup] is defined in terms of disjunction. *)\n  left.\n  simplify.\n  propositional.\n\n  right.\n  apply H1.\n  assumption.\n\n  simplify.\n  propositional.\n  \n  right.\n  left.\n  apply H.\n  equality.\n\n  right.\n  right.\n  eapply H2.\n  eassumption.\n  assumption.\nQed.\n\nTheorem singleton_in : forall {A} (x : A) rest,\n  ({x} \\cup rest) x.\nProof.\n  simplify.\n  left.\n  simplify.\n  equality.\nQed.\n\n(* OK, back to our example from last chapter, of factorial as a transition\n * system.  Here's a good overall correctness condition, which we didn't bother\n * to state before. *)\nDefinition fact_correct (original_input : nat) (st : fact_state) : Prop :=\n  match st with\n  | AnswerIs ans => fact original_input = ans\n  | WithAccumulator _ _ => True\n  end.\n\n(* Let's also restate the initial-states set using a singleton set. *)\nTheorem fact_init_is : forall original_input,\n  fact_init original_input = {WithAccumulator original_input 1}.\nProof.\n  simplify.\n  apply sets_equal; simplify.\n  propositional.\n\n  invert H.\n  equality.\n\n  rewrite <- H0.\n  constructor.\nQed.\n\n(* Now we will prove that factorial is correct, for the input 2, without needing\n * to write out an inductive invariant ourselves. *)\nTheorem factorial_ok_2 :\n  invariantFor (factorial_sys 2) (fact_correct 2).\nProof.\n  simplify.\n  eapply invariant_weaken.\n\n  apply multiStepClosure_ok.\n  simplify.\n  rewrite fact_init_is.\n\n  eapply MscStep.\n  apply oneStepClosure_split.\n  simplify.\n  invert H.\n  simplify.\n  apply singleton_in.\n  apply oneStepClosure_empty.\n  simplify.\n\n  eapply MscStep.\n  apply oneStepClosure_split.\n  simplify.\n  invert H.\n  simplify.\n  apply singleton_in.\n  apply oneStepClosure_split.\n  simplify.\n  invert H.\n  simplify.\n  apply singleton_in.\n  apply oneStepClosure_empty.\n  simplify.\n\n  eapply MscStep.\n  apply oneStepClosure_split.\n  simplify.\n  invert H.\n  simplify.\n  apply singleton_in.\n  apply oneStepClosure_split.\n  simplify.\n  invert H.\n  simplify.\n  apply singleton_in.\n  apply oneStepClosure_split.\n  simplify.\n  invert H.\n  simplify.\n  apply singleton_in.\n  apply oneStepClosure_empty.\n  simplify.\n\n  apply MscDone.\n  apply prove_oneStepClosure; simplify.\n  assumption.\n  propositional; subst; invert H0; simplify; propositional.\n\n  simplify.\n  unfold fact_correct.\n  propositional; subst; trivial.\nQed.\n\n(* BEGIN CODE THAT WILL NOT BE EXPLAINED IN DETAIL! *)\n\nLocal Hint Rewrite fact_init_is.\n\nLtac model_check_done :=\n  apply MscDone; apply prove_oneStepClosure; simplify; propositional; subst;\n  repeat match goal with\n         | [ H : _ |- _ ] => invert H\n         end; simplify; equality.\n\nTheorem singleton_in_other : forall {A} (x : A) (s1 s2 : set A),\n  s2 x\n  -> (s1 \\cup s2) x.\nProof.\n  simplify.\n  right.\n  right.\n  assumption.\nQed.\n\nLtac singletoner :=\n  repeat match goal with\n         | _ => apply singleton_in\n         | [ |- (_ \\cup _) _ ] => apply singleton_in_other\n         end.\n\nLtac model_check_step0 :=\n  eapply MscStep; [\n    repeat ((apply oneStepClosure_empty; simplify)\n            || (apply oneStepClosure_split; [ simplify;\n                                              repeat match goal with\n                                                     | [ H : _ |- _ ] => invert H; try congruence\n                                                     end; solve [ singletoner ] | ]))\n  | simplify ].\n\nLtac model_check_step :=\n  match goal with\n  | [ |- multiStepClosure _ ?inv1 _ ] =>\n    model_check_step0;\n    match goal with\n    | [ |- multiStepClosure _ ?inv2 _ ] =>\n      (assert (inv1 = inv2) by compare_sets; fail 3)\n      || idtac\n    end\n  end.\n\nLtac model_check_steps1 := model_check_step || model_check_done.\nLtac model_check_steps := repeat model_check_steps1.\n\nLtac model_check_finish := simplify; propositional; subst; simplify; equality.\n\nLtac model_check_infer :=\n  apply multiStepClosure_ok; simplify; model_check_steps.\n\nLtac model_check_find_invariant :=\n  simplify; eapply invariant_weaken; [ model_check_infer | ]; cbv beta in *.\n\nLtac model_check := model_check_find_invariant; model_check_finish.\n\n(* END CODE THAT WILL NOT BE EXPLAINED IN DETAIL! *)\n\n(* Now watch this.  We can check various instances of factorial\n * automatically. *)\n\nTheorem factorial_ok_2_snazzy :\n  invariantFor (factorial_sys 2) (fact_correct 2).\nProof.\n  model_check.\nQed.\n\nTheorem factorial_ok_3 :\n  invariantFor (factorial_sys 3) (fact_correct 3).\nProof.\n  model_check.\nQed.\n\nTheorem factorial_ok_5 :\n  invariantFor (factorial_sys 5) (fact_correct 5).\nProof.\n  model_check.\nQed.\n\n(* Let's see that last one broken into two steps, so that we get a look at the\n * inferred invariant. *)\nTheorem factorial_ok_5_again :\n  invariantFor (factorial_sys 5) (fact_correct 5).\nProof.\n  model_check_find_invariant.\n  model_check_finish.\nQed.\n\n\n(** * Abstraction *)\n\nInductive isEven : nat -> Prop :=\n| EvenO : isEven 0\n| EvenSS : forall n, isEven n -> isEven (S (S n)).\n\nInductive add2_thread :=\n| Read\n| Write (local : nat).\n\nInductive add2_init : threaded_state nat add2_thread -> Prop :=\n| Add2Init : add2_init {| Shared := 0; Private := Read |}.\n\nInductive add2_step : threaded_state nat add2_thread -> threaded_state nat add2_thread -> Prop :=\n| StepRead : forall global,\n    add2_step {| Shared := global; Private := Read |}\n              {| Shared := global; Private := Write global |}\n| StepWrite : forall global local,\n    add2_step {| Shared := global; Private := Write local |}\n              {| Shared := S (S local); Private := Read |}.\n\nDefinition add2_sys1 := {|\n  Initial := add2_init;\n  Step := add2_step\n|}.\n\nDefinition add2_sys := parallel add2_sys1 add2_sys1.\n\nDefinition add2_correct (st : threaded_state nat (add2_thread * add2_thread)) :=\n  isEven st.(Shared).\n\nInductive simulates state1 state2 (R : state1 -> state2 -> Prop)\n  (* [R] is a relation connecting the states of the two systems. *)\n  (sys1 : trsys state1) (sys2 : trsys state2) : Prop :=\n| Simulates :\n  (* Every initial state of [sys1] has some matching initial state of [sys2]. *)\n  (forall st1, sys1.(Initial) st1\n               -> exists st2, R st1 st2\n                              /\\ sys2.(Initial) st2)\n\n  (* Starting from a pair of related states, every step in [sys1] can be matched\n   * in [sys2], to destinations that are also related. *)\n  -> (forall st1 st2, R st1 st2\n                      -> forall st1', sys1.(Step) st1 st1'\n                                      -> exists st2', R st1' st2'\n                                                      /\\ sys2.(Step) st2 st2')\n\n  -> simulates R sys1 sys2.\n\n(* Given an invariant for [sys2], we now have a generic way of defining an\n * invariant for [sys1], by composing with [R]. *)\nInductive invariantViaSimulation state1 state2 (R : state1 -> state2 -> Prop)\n  (inv2 : state2 -> Prop)\n  : state1 -> Prop :=\n| InvariantViaSimulation : forall st1 st2, R st1 st2\n  -> inv2 st2\n  -> invariantViaSimulation R inv2 st1.\n\n(* By way of a lemma, let's prove that, given a simulation, any\n * invariant-via-simulation really is an invariant for the original system. *)\nLemma invariant_simulates' : forall state1 state2 (R : state1 -> state2 -> Prop)\n  (sys1 : trsys state1) (sys2 : trsys state2),\n  (forall st1 st2, R st1 st2\n                   -> forall st1', sys1.(Step) st1 st1'\n                                   ->  exists st2', R st1' st2'\n                                                    /\\ sys2.(Step) st2 st2')\n  -> forall st1 st1', sys1.(Step)^* st1 st1'\n                      -> forall st2, R st1 st2\n                                     -> exists st2', R st1' st2'\n                                                     /\\ sys2.(Step)^* st2 st2'.\nProof.\n  induct 2.\n\n  simplify.\n  exists st2.\n  (* [exists E]: prove [exists x, P(x)] by proving [P(E)]. *)\n  propositional.\n  constructor.\n\n  simplify.\n  eapply H in H2.\n  first_order.\n  (* [first_order]: simplify first-order logic structure.  Be forewarned: this\n   *   one is especially likely to run forever! *)\n  apply IHtrc in H2.\n  first_order.\n  exists x1.\n  propositional.\n  econstructor.\n  eassumption.\n  assumption.\n  assumption.\nQed.\n\nTheorem invariant_simulates : forall state1 state2 (R : state1 -> state2 -> Prop)\n  (sys1 : trsys state1) (sys2 : trsys state2) (inv2 : state2 -> Prop),\n  simulates R sys1 sys2\n  -> invariantFor sys2 inv2\n  -> invariantFor sys1 (invariantViaSimulation R inv2).\nProof.\n  simplify.\n  invert H.\n  unfold invariantFor; simplify.\n  apply H1 in H.\n  first_order.\n  apply invariant_simulates' with (sys2 := sys2) (R := R) (st2 := x) in H3; try assumption.\n  first_order.\n  unfold invariantFor in H0.\n  apply H0 with (s' := x0) in H4; try assumption.\n  econstructor.\n  eassumption.\n  assumption.\nQed.\n\n(*Theorem add2_ok :\n  invariantFor add2_sys add2_correct.\nProof.\nAdmitted.*)\n\nInductive add2_bthread :=\n| BRead\n| BWrite (local : bool).\n\nInductive add2_binit : threaded_state bool add2_bthread -> Prop :=\n| Add2BInit : add2_binit {| Shared := true; Private := BRead |}.\n\nInductive add2_bstep : threaded_state bool add2_bthread -> threaded_state bool add2_bthread -> Prop :=\n| StepBRead : forall global,\n    add2_bstep {| Shared := global; Private := BRead |}\n               {| Shared := global; Private := BWrite global |}\n| StepBWrite : forall global local,\n    add2_bstep {| Shared := global; Private := BWrite local |}\n               {| Shared := local; Private := BRead |}.\n\nDefinition add2_bsys1 := {|\n  Initial := add2_binit;\n  Step := add2_bstep\n|}.\n\nDefinition add2_bsys := parallel add2_bsys1 add2_bsys1.\n\n(* This invariant formalizes the connection between local states of threads, in\n * the original and abstracted systems. *)\nInductive R_private1 : add2_thread -> add2_bthread -> Prop :=\n| RpRead : R_private1 Read BRead\n| RpWrite : forall n b, (b = true <-> isEven n)\n                        -> R_private1 (Write n) (BWrite b).\n\n(* We lift [R_private1] to a relation over whole states. *)\nInductive add2_R : threaded_state nat (add2_thread * add2_thread)\n                   -> threaded_state bool (add2_bthread * add2_bthread)\n                   -> Prop :=\n| Add2_R : forall n b th1 th2 th1' th2',\n  (b = true <-> isEven n)\n  -> R_private1 th1 th1'\n  -> R_private1 th2 th2'\n  -> add2_R {| Shared := n; Private := (th1, th2) |}\n            {| Shared := b; Private := (th1', th2') |}.\n\n(* Let's also recharacterize the initial states via a singleton set. *)\nTheorem add2_init_is :\n  parallel_init add2_binit add2_binit = { {| Shared := true; Private := (BRead, BRead) |} }.\nProof.\n  simplify.\n  apply sets_equal; simplify.\n  propositional.\n\n  invert H.\n  invert H2.\n  invert H4.\n  equality.\n\n  invert H0.\n  constructor.\n  constructor.\n  constructor.\nQed.\n\n(* We ask Coq to remember this lemma as a hint, which will be used by the\n * model-checking tactics that we refrain from explaining in detail. *)\nLocal Hint Rewrite add2_init_is.\n\n(* Now, let's verify the original system. *)\nTheorem add2_ok :\n  invariantFor add2_sys add2_correct.\nProof.\n  (* First step: strengthen the invariant.  We leave an underscore for the\n   * unknown invariant, to be found by model checking. *)\n  eapply invariant_weaken with (invariant1 := invariantViaSimulation add2_R _).\n\n  (* One way to find an invariant-by-simulation is to find an invariant for the\n   * abstracted system, as this step asks to do. *)\n  apply invariant_simulates with (sys2 := add2_bsys).\n\n  (* Now we must prove that the simulation via [add2_R] is valid, which is\n   * routine. *)\n  constructor; simplify.\n\n  invert H.\n  invert H0.\n  invert H1.\n  exists {| Shared := true; Private := (BRead, BRead) |}; simplify.\n  propositional.\n  constructor.\n  propositional.\n  constructor.\n  constructor.\n  constructor.\n\n  invert H.\n  invert H0; simplify.\n\n  invert H7.\n\n  invert H2.\n  exists {| Shared := b; Private := (BWrite b, th2') |}.\n  propositional.\n  constructor.\n  propositional.\n  constructor.\n  propositional.\n  assumption.\n  constructor.\n  constructor.\n\n  invert H2.\n  exists {| Shared := b0; Private := (BRead, th2') |}.\n  propositional.\n  constructor.\n  propositional.\n  constructor.\n  assumption.\n  invert H0.\n  propositional.\n  constructor.\n  assumption.\n  constructor.\n  constructor.\n\n  invert H7.\n\n  invert H3.\n  exists {| Shared := b; Private := (th1', BWrite b) |}.\n  propositional.\n  constructor.\n  propositional.\n  assumption.\n  constructor.\n  propositional.\n  constructor.\n  constructor.\n\n  invert H3.\n  exists {| Shared := b0; Private := (th1', BRead) |}.\n  propositional.\n  constructor.\n  propositional.\n  constructor.\n  assumption.\n  invert H0.\n  propositional.\n  assumption.\n  constructor.\n  constructor.\n  constructor.\n\n  (* OK, we're glad to have that over with!  Such a process could also be\n   * automated, but we won't bother doing so here.  However, we are now in a\n   * good state, where our model checker can find the invariant\n   * automatically. *)\n  model_check_infer.\n  (* It finds exactly four reachable states.  We finish by showing that they all\n   * obey the original invariant. *)\n\n  invert 1.\n  invert H0.\n  simplify.\n  unfold add2_correct.\n  simplify.\n  propositional; subst.\n\n  invert H.\n  propositional.\n\n  invert H1.\n  propositional.\n\n  invert H.\n  propositional.\n\n  invert H1.\n  propositional.\nQed.\n\n\n(** * Another abstraction example *)\n\nInductive pc :=\n| i_gets_0\n| j_gets_0\n| Loop\n| i_add_n\n| j_add_n\n| n_sub_1\n| Done.\n\nRecord vars := {\n  N : nat;\n  I : nat;\n  J : nat\n}.\n\nRecord state := {\n  Pc : pc;\n  Vars : vars\n}.\n\nInductive initial : state -> Prop :=\n| Init : forall vs, initial {| Pc := i_gets_0; Vars := vs |}.\n\nInductive step : state -> state -> Prop :=\n| Step_i_gets_0 : forall n i j,\n  step {| Pc := i_gets_0; Vars := {| N := n;\n                                     I := i;\n                                     J := j |} |}\n       {| Pc := j_gets_0; Vars := {| N := n;\n                                     I := 0;\n                                     J := j |} |}\n| Step_j_gets_0 : forall n i j,\n  step {| Pc := j_gets_0; Vars := {| N := n;\n                                     I := i;\n                                     J := j |} |}\n       {| Pc := Loop; Vars := {| N := n;\n                                 I := i;\n                                 J := 0 |} |}\n| Step_Loop_done : forall i j,\n  step {| Pc := Loop; Vars := {| N := 0;\n                                 I := i;\n                                 J := j |} |}\n       {| Pc := Done; Vars := {| N := 0;\n                                 I := i;\n                                 J := j |} |}\n| Step_Loop_enter : forall n i j,\n  step {| Pc := Loop; Vars := {| N := S n;\n                                 I := i;\n                                 J := j |} |}\n       {| Pc := i_add_n; Vars := {| N := S n;\n                                    I := i;\n                                    J := j |} |}\n| Step_i_add_n : forall n i j,\n  step {| Pc := i_add_n; Vars := {| N := n;\n                                    I := i;\n                                    J := j |} |}\n       {| Pc := j_add_n; Vars := {| N := n;\n                                    I := i + n;\n                                    J := j |} |}\n| Step_j_add_n : forall n i j,\n  step {| Pc := j_add_n; Vars := {| N := n;\n                                    I := i;\n                                    J := j |} |}\n       {| Pc := n_sub_1; Vars := {| N := n;\n                                    I := i;\n                                    J := j + n |} |}\n| Step_n_sub_1 : forall n i j,\n  step {| Pc := n_sub_1; Vars := {| N := n;\n                                    I := i;\n                                    J := j |} |}\n       {| Pc := Loop; Vars := {| N := n - 1;\n                                 I := i;\n                                 J := j |} |}.\n\nDefinition loopy_sys := {|\n  Initial := initial;\n  Step := step\n|}.\n\nDefinition loopy_correct (st : state) :=\n  st.(Pc) = Done -> st.(Vars).(I) = st.(Vars).(J).\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n(* Spoiler alert: here's a good abstraction! *)\nInductive absvars :=\n| Unknown\n  (* We don't know anything about the values of the variables. *)\n| i_is_0\n  (* We know [i == 0]. *)\n| i_eq_j\n  (* We know [i == j]. *)\n| i_eq_j_plus_n.\n  (* We know [i == j + n]. *)\n\n(* To get our abstract states, we keep the same program counters and just change\n * out the variable state. *)\nRecord absstate := {\n  APc : pc;\n  AVars : absvars\n}.\n\n(* Here's the rather boring new abstract step relation.  Note the clever state\n * transformations, in terms of our new abstraction. *)\nInductive absstep : absstate -> absstate -> Prop :=\n| AStep_i_gets_0 : forall vs,\n  absstep {| APc := i_gets_0; AVars := vs |}\n          {| APc := j_gets_0; AVars := i_is_0 |}\n| AStep_j_gets_0_i_is_0 :\n  absstep {| APc := j_gets_0; AVars := i_is_0 |}\n          {| APc := Loop; AVars := i_eq_j |}\n| AStep_j_gets_0_Other : forall vs,\n  vs <> i_is_0\n  -> absstep {| APc := j_gets_0; AVars := vs |}\n             {| APc := Loop; AVars := Unknown |}\n| AStep_Loop_done : forall vs,\n  absstep {| APc := Loop; AVars := vs |}\n          {| APc := Done; AVars := vs |}\n| AStep_Loop_enter : forall vs,\n  absstep {| APc := Loop; AVars := vs |}\n          {| APc := i_add_n; AVars := vs |}\n| AStep_i_add_n_i_eq_j :\n  absstep {| APc := i_add_n; AVars := i_eq_j |}\n          {| APc := j_add_n; AVars := i_eq_j_plus_n |}\n| AStep_i_add_n_Other : forall vs,\n  vs <> i_eq_j\n  -> absstep {| APc := i_add_n; AVars := vs |}\n             {| APc := j_add_n; AVars := Unknown |}\n| AStep_j_add_n_i_eq_j_plus_n :\n  absstep {| APc := j_add_n; AVars := i_eq_j_plus_n |}\n          {| APc := n_sub_1; AVars := i_eq_j |}\n| AStep_j_add_n_i_Other : forall vs,\n  vs <> i_eq_j_plus_n\n  -> absstep {| APc := j_add_n; AVars := vs |}\n             {| APc := n_sub_1; AVars := Unknown |}\n| AStep_n_sub_1_bad :\n  absstep {| APc := n_sub_1; AVars := i_eq_j_plus_n |}\n          {| APc := Loop; AVars := Unknown |}\n| AStep_n_sub_1_good : forall vs,\n  vs <> i_eq_j_plus_n\n  -> absstep {| APc := n_sub_1; AVars := vs |}\n             {| APc := Loop; AVars := vs |}.\n\nDefinition absloopy_sys := {|\n  Initial := { {| APc := i_gets_0; AVars := Unknown |} };\n  Step := absstep\n|}.\n\n(* Now we need our simulation relation.  First, we define one just at the level\n * of local-variable state.  It formalizes our intuition about those values. *)\nInductive Rvars : vars -> absvars -> Prop :=\n| Rv_Unknown : forall vs, Rvars vs Unknown\n| Rv_i_is_0 : forall vs, vs.(I) = 0 -> Rvars vs i_is_0\n| Rv_i_eq_j : forall vs, vs.(I) = vs.(J) -> Rvars vs i_eq_j\n| Rv_i_eq_j_plus_n : forall vs, vs.(I) = vs.(J) + vs.(N) -> Rvars vs i_eq_j_plus_n.\n\n(* We lift to full states in the obvious way. *)\nInductive R : state -> absstate -> Prop :=\n| Rcon : forall pc vs avs, Rvars vs avs -> R {| Pc := pc; Vars := vs |}\n                                             {| APc := pc; AVars := avs |}.\n\n(* Now we are ready to prove the original system correct. *)\nTheorem loopy_ok :\n  invariantFor loopy_sys loopy_correct.\nProof.\n  eapply invariant_weaken with (invariant1 := invariantViaSimulation R _).\n  apply invariant_simulates with (sys2 := absloopy_sys).\n\n  (* Here comes another boring simulation proof. *)\n  constructor; simplify.\n\n  invert H.\n  exists {| APc := i_gets_0; AVars := Unknown |}.\n  propositional.\n  constructor.\n  constructor.\n\n  invert H0.\n\n  invert H.\n  exists {| APc := j_gets_0; AVars := i_is_0 |}.\n  propositional; repeat constructor.\n\n  invert H.\n  invert H3.\n  exists {| APc := Loop; AVars := Unknown |}; propositional; repeat constructor; equality.\n  exists {| APc := Loop; AVars := i_eq_j |}; propositional; repeat constructor; equality.\n  exists {| APc := Loop; AVars := Unknown |}; propositional; repeat constructor; equality.\n  exists {| APc := Loop; AVars := Unknown |}; propositional; repeat constructor; equality.\n\n  exists {| APc := Done; AVars := st2.(AVars) |}.\n  invert H; simplify; propositional; repeat constructor; equality.\n\n  exists {| APc := i_add_n; AVars := st2.(AVars) |}.\n  invert H; simplify; propositional; repeat constructor; equality.\n\n  invert H.\n  invert H3.\n  exists {| APc := j_add_n; AVars := Unknown |}; repeat constructor; equality.\n  exists {| APc := j_add_n; AVars := Unknown |}; repeat constructor; equality.\n  exists {| APc := j_add_n; AVars := i_eq_j_plus_n |}; repeat constructor; simplify; equality.\n  exists {| APc := j_add_n; AVars := Unknown |}; repeat constructor; equality.\n\n  invert H.\n  invert H3.\n  exists {| APc := n_sub_1; AVars := Unknown |}; repeat constructor; equality.\n  exists {| APc := n_sub_1; AVars := Unknown |}; repeat constructor; equality.\n  exists {| APc := n_sub_1; AVars := Unknown |}; repeat constructor; equality.\n  exists {| APc := n_sub_1; AVars := i_eq_j |}; repeat constructor; simplify; equality.\n\n  invert H.\n  invert H3.\n  exists {| APc := Loop; AVars := Unknown |}; propositional; repeat constructor; equality.\n  exists {| APc := Loop; AVars := i_is_0 |}; propositional; repeat constructor; equality.\n  exists {| APc := Loop; AVars := i_eq_j |}; propositional; repeat constructor; equality.\n  exists {| APc := Loop; AVars := Unknown |}; propositional; repeat constructor; equality.\n\n  (* Finally, we can call the model checker to find an invariant of the abstract\n   * system. *)\n  model_check_infer.\n  (* We get 7 neat little states, one per program counter.  Next, we prove that\n   * each of them implies the original invariant. *)\n\n  invert 1. (* Note that this [1] means \"first premise below the double\n             * line.\" *)\n  invert H0.\n  unfold loopy_correct.\n  simplify.\n  propositional; subst.\n\n  (* Most of the hypotheses we invert are contradictory, implying that distinct\n   * program counters are equal. *)\n\n  invert H2.\n\n  invert H1.\n\n  invert H2.\n\n  invert H1.\n  invert H.\n  assumption.\n\n  invert H2.\n\n  invert H1.\n\n  invert H2.\nQed.\n\n\n(** * Modularity *)\n\nInductive stepWithInterference shared private (inv : shared -> Prop)\n          (step : threaded_state shared private -> threaded_state shared private -> Prop)\n          : threaded_state shared private -> threaded_state shared private -> Prop :=\n\n(* First kind of step: this thread runs in the normal way. *)\n| StepSelf : forall st st',\n  step st st'\n  -> stepWithInterference inv step st st'\n\n(* Second kind of step: other threads change shared state to some new value\n * satisfying [inv]. *)\n| StepEnvironment : forall sh pr sh',\n  inv sh'\n  -> stepWithInterference inv step\n                          {| Shared := sh; Private := pr |}\n                          {| Shared := sh'; Private := pr |}.\n\n(* Via this relation, we have an operator to build a new transition system from\n * an old one, given [inv]. *)\nDefinition withInterference shared private (inv : shared -> Prop)\n           (sys : trsys (threaded_state shared private))\n  : trsys (threaded_state shared private) := {|\n  Initial := sys.(Initial);\n  Step := stepWithInterference inv sys.(Step)\n|}.\n\n(* Tired of simulation proofs yet?  Then you'll love this theorem, which shows\n * a free simulation for any use of [withInterference]!  We even get to pick the\n * trivial simulation relation, state equality. *)\nTheorem withInterference_abstracts : forall shared private (inv : shared -> Prop)\n                                           (sys : trsys (threaded_state shared private)),\n  simulates (fun st st' => st = st') sys (withInterference inv sys).\nProof.\n  simplify.\n  constructor; simplify.\n\n  exists st1; propositional.\n\n  exists st1'; propositional.\n  constructor.\n  equality.\nQed.\n\nLemma withInterference_parallel_init : forall shared private1 private2\n                                          (invs : shared -> Prop)\n                                          (sys1 : trsys (threaded_state shared private1))\n                                          (sys2 : trsys (threaded_state shared private2))\n                                          st st',\n  (withInterference invs (parallel sys1 sys2)).(Step)^* st st'\n  -> forall st1 st2,\n      (forall st1', (withInterference invs sys1).(Step)^* st1 st1' -> invs st1'.(Shared))\n      -> (forall st2', (withInterference invs sys2).(Step)^* st2 st2' -> invs st2'.(Shared))\n      -> (withInterference invs sys1).(Step)^* st1\n                                            {| Shared := st.(Shared);\n                                               Private := fst st.(Private) |}\n      -> (withInterference invs sys2).(Step)^* st2\n                                            {| Shared := st.(Shared);\n                                               Private := snd st.(Private) |}\n      -> (withInterference invs sys1).(Step)^* st1\n                                            {| Shared := st'.(Shared);\n                                               Private := fst st'.(Private) |}.\nProof.\n  induct 1; simplify.\n\n  assumption.\n\n  invert H; simplify.\n  invert H5; simplify.\n\n  apply IHtrc with (st2 := {| Shared := sh'; Private := pr2 |}).\n  simplify.\n  apply H1.\n  assumption.\n  simplify.\n  eapply H2.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').\n  apply H1 with (st1' := {| Shared := sh'; Private := pr1' |}).\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  econstructor.\n  eassumption.\n  constructor.\n  assumption.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  econstructor.\n  eassumption.\n  constructor.\n  constructor.\n\n  apply IHtrc with (st2 := {| Shared := sh'; Private := pr2' |}).\n  assumption.\n  simplify.\n  apply H2.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  constructor.\n  eassumption.\n  eassumption.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').\n  apply H2 with (st2' := {| Shared := sh'; Private := pr2' |}).\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  econstructor.\n  eassumption.\n  constructor.\n  constructor.\n  constructor.\n\n  apply IHtrc with (st2 := {| Shared := sh'; Private := snd pr |}).\n  assumption.\n  simplify.\n  eapply H2.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').\n  assumption.\n  assumption.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').  \n  assumption.\n  constructor.\n  constructor.\nQed.\n\nLemma withInterference_parallel_step : forall shared private1 private2\n                                              (invs : shared -> Prop)\n                                              (sys1 : trsys (threaded_state shared private1))\n                                              (sys2 : trsys (threaded_state shared private2))\n                                              st st',\n  (withInterference invs (parallel sys1 sys2)).(Step)^* st st'\n  -> forall st1 st2,\n      (forall st1', (withInterference invs sys1).(Step)^* st1 st1' -> invs st1'.(Shared))\n      -> (forall st2', (withInterference invs sys2).(Step)^* st2 st2' -> invs st2'.(Shared))\n      -> (withInterference invs sys1).(Step)^* st1\n                                            {| Shared := st.(Shared);\n                                               Private := fst st.(Private) |}\n      -> (withInterference invs sys2).(Step)^* st2\n                                            {| Shared := st.(Shared);\n                                               Private := snd st.(Private) |}\n      -> (withInterference invs sys2).(Step)^* st2\n                                            {| Shared := st'.(Shared);\n                                               Private := snd st'.(Private) |}.\nProof.\n  induct 1; simplify.\n\n  assumption.\n\n  invert H; simplify.\n  invert H5; simplify.\n\n  apply IHtrc with (st1 := {| Shared := sh'; Private := pr1' |}).\n  simplify.\n  apply H1.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  econstructor.\n  eassumption.\n  assumption.\n  assumption.\n  constructor.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').\n  apply H1 with (st1' := {| Shared := sh'; Private := pr1' |}).\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  econstructor.\n  eassumption.\n  constructor.\n  constructor.\n\n  apply IHtrc with (st1 := {| Shared := sh'; Private := pr1 |}).\n  simplify.\n  apply H1.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').\n  apply H2 with (st2' := {| Shared := sh'; Private := pr2' |}).\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  constructor.\n  eassumption.\n  constructor.\n  assumption.\n  assumption.\n  constructor.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  constructor.\n  eassumption.\n  constructor.\n\n  apply IHtrc with (st1 := {| Shared := sh'; Private := fst pr |}).\n  simplify.\n  eapply H1.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').\n  assumption.\n  assumption.\n  assumption.\n  constructor.\n  eapply trc_trans.\n  eassumption.\n  eapply TrcFront.\n  apply StepEnvironment with (sh' := sh').  \n  assumption.\n  constructor.\nQed.\n\nTheorem withInterference_parallel : forall shared private1 private2\n                                           (invs : shared -> Prop)\n                                           (sys1 : trsys (threaded_state shared private1))\n                                           (sys2 : trsys (threaded_state shared private2)),\n    invariantFor (withInterference invs sys1)\n                 (fun st => invs st.(Shared))\n    -> invariantFor (withInterference invs sys2)\n                    (fun st => invs st.(Shared))\n    -> invariantFor (withInterference invs (parallel sys1 sys2))\n                    (fun st => invs st.(Shared)).\nProof.\n  unfold invariantFor.\n  simplify.\n  invert H1.\n\n  (* [assert P]: first prove proposition [P], then continue with it as a new\n   *   hypothesis. *)\n  assert ((withInterference invs sys1).(Step)^*\n             {| Shared := sh; Private := pr1 |}\n             {| Shared := s'.(Shared); Private := fst s'.(Private) |}).\n  apply withInterference_parallel_init with (sys2 := sys2)\n                                            (st := {| Shared := sh; Private := (pr1, pr2) |})\n                                            (st2 := {| Shared := sh; Private := pr2 |});\n    simplify; propositional.\n  apply H in H1; propositional.\n  apply H0 in H1; propositional.\n  constructor.\n  constructor.\n\n  assert ((withInterference invs sys2).(Step)^*\n             {| Shared := sh; Private := pr2 |}\n             {| Shared := s'.(Shared); Private := snd s'.(Private) |}).\n  apply withInterference_parallel_step with (sys1 := sys1)\n                                            (st := {| Shared := sh; Private := (pr1, pr2) |})\n                                            (st1 := {| Shared := sh; Private := pr1 |});\n    simplify; propositional.\n  apply H in H5; propositional.\n  apply H0 in H5; propositional.\n  constructor.\n  constructor.\n\n  apply H in H1; try assumption.\nQed.\n\n\nInductive twoadd_pc := ReadIt | Add3 | Add7 | WriteIt.\n\nDefinition twoadd_initial := { {| Shared := 0; Private := (ReadIt, 0) |} }.\n\nInductive twoadd_step : threaded_state nat (twoadd_pc * nat)\n                        -> threaded_state nat (twoadd_pc * nat) -> Prop :=\n| Step_ReadIt : forall g l,\n  twoadd_step {| Shared := g; Private := (ReadIt, l) |}\n              {| Shared := g; Private := (Add3, g) |}\n| Step_Add3 : forall g l,\n  twoadd_step {| Shared := g; Private := (Add3, l) |}\n              {| Shared := g; Private := (Add7, 3 + l) |}\n| Step_Add7 : forall g l,\n  twoadd_step {| Shared := g; Private := (Add7, l) |}\n              {| Shared := g; Private := (WriteIt, 7 + l) |}\n| Step_WriteIt : forall g l,\n  twoadd_step {| Shared := g; Private := (WriteIt, l) |}\n              {| Shared := l; Private := (ReadIt, l) |}.\n\nDefinition twoadd_sys := {|\n  Initial := twoadd_initial;\n  Step := twoadd_step\n|}.\n\n(* Invariant to prove: the global variable is always even, again. *)\nDefinition twoadd_correct private (st : threaded_state nat private) :=\n  isEven st.(Shared).\n\n(* Here's an abstract version of the system where, much like before, we model\n * integers as Booleans, recording whether they are even or not. *)\n\nDefinition twoadd_ainitial := { {| Shared := true; Private := (ReadIt, true) |} }.\n\nInductive twoadd_astep : threaded_state bool (twoadd_pc * bool)\n                        -> threaded_state bool (twoadd_pc * bool) -> Prop :=\n| AStep_ReadIt : forall g l,\n  twoadd_astep {| Shared := g; Private := (ReadIt, l) |}\n               {| Shared := g; Private := (Add3, g) |}\n| AStep_Add3 : forall g l,\n  twoadd_astep {| Shared := g; Private := (Add3, l) |}\n               {| Shared := g; Private := (Add7, negb l) |}\n| AStep_Add7 : forall g l,\n  twoadd_astep {| Shared := g; Private := (Add7, l) |}\n               {| Shared := g; Private := (WriteIt, negb l) |}\n| AStep_WriteIt : forall g l,\n  twoadd_astep {| Shared := g; Private := (WriteIt, l) |}\n               {| Shared := l; Private := (ReadIt, l) |}\n| AStep_Someone_Made_It_Even : forall g pr,\n  twoadd_astep {| Shared := g; Private := pr |}\n               {| Shared := true; Private := pr |}.\n\nDefinition twoadd_asys := {|\n  Initial := twoadd_ainitial;\n  Step := twoadd_astep\n|}.\n\n(* Here's a simulation relation at the level of integers and their Boolean\n * counterparts. *)\nDefinition even_R (n : nat) (b : bool) :=\n  isEven n <-> b = true.\n\n(* A few unsurprising properties hold of [even_R]. *)\n\nLemma even_R_0 : even_R 0 true.\nProof.\n  unfold even_R; propositional.\n  constructor.\nQed.\n\nLemma even_R_forward : forall n, isEven n -> even_R n true.\nProof.\n  unfold even_R; propositional.\nQed.\n\nLemma even_R_backward : forall n, even_R n true -> isEven n.\nProof.\n  unfold even_R; propositional.\nQed.\n\nLemma even_R_add2 : forall n b,\n  even_R n b\n  -> even_R (S (S n)) b.\nProof.\n  unfold even_R; propositional.\n  invert H; propositional.\n  constructor; assumption.\nQed.\n\n(* The cases for evenness of an integer and its successor *)\nLemma isEven_decide : forall n,\n  (isEven n /\\ ~isEven (S n)) \\/ (~isEven n /\\ isEven (S n)).\nProof.\n  induct n; simplify; propositional.\n\n  left; propositional.\n  constructor.\n  invert H.\n\n  right; propositional.\n  constructor; assumption.\n\n  left; propositional.\n  invert H.\n  propositional.\nQed.\n\nLemma even_R_add1 : forall n b,\n  even_R n b\n  -> even_R (S n) (negb b).\nProof.\n  unfold even_R; simplify.\n  assert ((isEven n /\\ ~isEven (S n)) \\/ (~isEven n /\\ isEven (S n))).\n  apply isEven_decide.\n  cases b; simplify; propositional.\n  equality.\n  equality.\nQed.\n\n(* Here's the top-level simulation relation for our choice of abstraction. *)\nInductive twoadd_R : threaded_state nat (twoadd_pc * nat)\n                     -> threaded_state bool (twoadd_pc * bool) -> Prop :=\n| Twoadd_R : forall pc gn ln gb lb,\n  even_R gn gb\n  -> even_R ln lb\n  -> twoadd_R {| Shared := gn; Private := (pc, ln) |}\n              {| Shared := gb; Private := (pc, lb) |}.\n\n(* Step 1 of main proof: model-check an individual thread. *)\nLemma twoadd_ok :\n  invariantFor (withInterference isEven twoadd_sys)\n               (fun st => isEven (Shared st)).\nProof.\n  eapply invariant_weaken.\n  apply invariant_simulates with (sys2 := twoadd_asys) (R := twoadd_R).\n\n  (* Boring simulation proof begins here. *)\n  constructor; simplify.\n\n  invert H.\n  exists {| Shared := true; Private := (ReadIt, true) |}; propositional.\n  constructor; propositional.\n  apply even_R_0.\n  apply even_R_0.\n  constructor.\n  equality.\n  simplify.\n  propositional.\n\n  invert H0.\n  invert H1.\n\n  invert H.\n  exists {| Shared := gb; Private := (Add3, gb) |}; propositional.\n  constructor; propositional.\n  constructor.\n\n  invert H.\n  exists {| Shared := gb; Private := (Add7, negb lb) |}; propositional.\n  constructor; propositional.\n  apply even_R_add2.\n  apply even_R_add1.\n  assumption.\n  constructor.\n\n  invert H.\n  exists {| Shared := gb; Private := (WriteIt, negb lb) |}; propositional.\n  constructor; propositional.\n  repeat apply even_R_add2.\n  apply even_R_add1.\n  assumption.\n  constructor.\n\n  invert H.\n  exists {| Shared := lb; Private := (ReadIt, lb) |}; propositional.\n  constructor; propositional.\n  constructor.\n\n  invert H.\n  exists {| Shared := true; Private := (pc0, lb) |}; propositional.\n  constructor; propositional.\n  apply even_R_forward.\n  assumption.\n  constructor.\n\n  (* Now find an invariant automatically. *)\n  model_check_infer.\n\n  (* Now prove that the invariant implies the correctness condition. *)\n  invert 1.\n  invert H0.\n  simplify.\n  propositional.\n\n  invert H0.\n  apply even_R_backward.\n  assumption.\n\n  invert H1.\n  apply even_R_backward.\n  assumption.\n\n  invert H0.\n  apply even_R_backward.\n  assumption.\n\n  invert H1.\n  apply even_R_backward.\n  assumption.\nQed.\n\n(* Step 2: lift that result to the two-thread system, with no new model\n * checking. *) \nTheorem twoadd2_ok :\n  invariantFor (parallel twoadd_sys twoadd_sys) (twoadd_correct (private := _)).\nProof.\n  eapply invariant_weaken.\n  eapply invariant_simulates.\n  apply withInterference_abstracts.\n  apply withInterference_parallel.\n  apply twoadd_ok.\n  apply twoadd_ok.\n  \n  unfold twoadd_correct.\n  invert 1.\n  assumption.\nQed.\n\n(* In fact, this modularity technique is so powerful that we now get correctness\n * for any number of threads, \"for free\"!  Here's a tactic definition, which we\n * won't explain, but which is able to derive correctness for any number of\n * threads, just by repeating use of [withInterference_parallel] and\n * [twoadd_ok]. *)\nLtac twoadd := eapply invariant_weaken; [ eapply invariant_simulates; [\n                                          apply withInterference_abstracts\n                                          | repeat (apply withInterference_parallel\n                                                    || apply twoadd_ok) ]\n                                        | unfold twoadd_correct; invert 1; assumption ].\n\n(* For instance, let's verify the three-thread version. *)\nTheorem twoadd3_ok :\n  invariantFor (parallel twoadd_sys (parallel twoadd_sys twoadd_sys)) (twoadd_correct (private := _)).\nProof.\n  twoadd.\nQed.\n\n(* To save us time defining versions with many threads, here's a recursive\n * function, creating exponentially many threads with respect to its\n * parameter. *)\nFixpoint manyadds_state (n : nat) : Type :=\n  match n with\n  | O => twoadd_pc * nat\n  | S n' => manyadds_state n' * manyadds_state n'\n  end%type.\n\nFixpoint manyadds (n : nat) : trsys (threaded_state nat (manyadds_state n)) :=\n  match n with\n  | O => twoadd_sys\n  | S n' => parallel (manyadds n') (manyadds n')\n  end.\n\n(* Here are some examples of the systems we produce. *)\nEval simpl in manyadds 0.\nEval simpl in manyadds 1.\nEval simpl in manyadds 2.\nEval simpl in manyadds 3.\n\nTheorem twoadd4_ok :\n  invariantFor (manyadds 4) (twoadd_correct (private := _)).\nProof.\n  twoadd.\nQed.\n\nTheorem twoadd6_ok :\n  invariantFor (manyadds 6) (twoadd_correct (private := _)).\nProof.\n  twoadd.\nQed.\n"}
{"text": "Formal statement is: lemma Re_complex_of_real [simp]: \"Re (complex_of_real z) = z\" Informal statement is: The real part of a real number is the number itself."}
{"text": "import Mt.Reservation\nimport Mt.Task.Basic\n\nnamespace Mt.TaskM\n\nvariable {spec : Spec}\nlocal instance : IsReservation spec.Reservation :=spec.is_reservation\n\n/-- Validation primitive for reasoning for composable tasks.\n\n  Validation may assume `assuming` and must ensure the following:\n  * The task has to behave conform to the specification at all times\n  * The task never panics\n  * Finally, `motive` holds after the task completes\n\n  ### Proving `valid`\n  The definition is rather cumbersome to work with. You should use\n  helper theorems like `valid_pure`, `valid_bind`, `valid_rmr`, ...\n\n  They are designed to be used with the `apply` tactic.\n\n  ### Blocking predicate: `assuming`\n  When validating our task, we can assume `assuming state = true`. However,\n  in most cases we have `assuming = \u03bb _ => true`, i.e. our hypothesis does\n  not provide anything useful.\n\n  There is one important exception: Blocking threads. If a thread\n  waits for a certain condition before it continues its task, we can\n  safely assume that this condition holds when the task is excuting.\n\n  ### Final goal: `motive`\n  A valid thread must drop its reservations in the end. Therefore, the\n  final goal on those tasks is `\u03bb _ r => r = IsReservation.empty`.\n  However, intermediate tasks (i.e. single operations) do not need to\n  share this goal.\n  \n  In fact, they usally do not. If one operation\n  prepares the next operation, it usually creates some reservation to\n  ensure that no other thread undos this preparation. In this example,\n  the motive should encode that the preparation has been made.\n\n  `motive` is the only way to pass facts from one iteration to the next.\n  See `valid_bind` for more information.\n-/\ndef valid {T : Type} (p : TaskM spec T) (r : spec.Reservation)\n  (assuming : spec.State -> Bool)\n  (motive : T -> spec.Reservation -> Prop)\n  : Prop :=\u2200 env_r s,\n    assuming s \u2192\n    spec.validate (env_r + r) s \u2192 \u2203 r' : spec.Reservation,\n    match h : p.iterate s with\n    | IterationResult.Done s' t => spec.validate (env_r + r') s' \u2227 motive t r'\n    | IterationResult.Panic .. => False\n    | IterationResult.Running s' block_until cont =>\n        spec.validate (env_r + r') s' \u2227\n        cont.valid r' block_until motive\ntermination_by valid => p\ndecreasing_by simp_wf ; exact is_direct_cont.running h\n\n/-- To prove that `pure t` is valid you need to prove that the `motive` holds -/\ntheorem valid_pure {T : Type} {t : T} {r assuming motive}\n  (is_valid : motive t r)\n  : valid (spec :=spec) (pure t) r assuming motive :=by\n  rw [valid]\n  intro env_r s _ initial_valid\n  exists r\n\n/-- To prove that `a >>= f` is valid you need to prove that both `a` and `f u`\n  for all results `u` are valid.\n\n  In many cases, `a` does something to prepare `f u`. Since only `f u` needs\n  to fulfil the final motive, we can choose an arbitrary motive to validate `a`\n  as \"intermediate goal\".\n\n  To validate `f u` with the original `motive`, we can use the fact that the\n  intermediate goal `motive_u` has been ensured by `a`. Motives use only results\n  and reservations, which cannot be changed by other threads. Therefore, they\n  stay valid even if other threads become active between `a` and `f u`. \n-/\ntheorem valid_bind {U V : Type}\n  {mu : TaskM spec U}\n  {f : U -> TaskM spec V}\n  {r assuming motive}\n  (motive_u : U -> spec.Reservation -> Prop)\n  (mu_valid : mu.valid r assuming motive_u)\n  (f_valid : \u2200 r' u,\n    motive_u u r' \u2192\n    (f u).valid r' (\u03bb _ => true) motive)\n  : valid (mu >>= f) r assuming motive :=by\n  rw [valid]\n  intro env_r s assuming_true initial_valid\n  rw [iterate_bind]\n  rw [valid] at mu_valid\n  cases iteration : iterate mu s\n  all_goals (\n    simp only []\n    have mu_valid :=mu_valid env_r s assuming_true initial_valid\n    rw [iteration] at mu_valid\n    simp only [] at mu_valid\n    cases mu_valid ; rename_i r' mu_valid\n    exists r'\n  )\n  . exact \u27e8mu_valid.left, f_valid _ _ mu_valid.right\u27e9\n  . constructor\n    . exact mu_valid.left\n    . have :=is_direct_cont.running iteration\n      exact valid_bind motive_u mu_valid.right f_valid\ntermination_by valid_bind => mu\n\ntheorem valid_rmr {T : Type}\n  {f : spec.State -> T \u00d7 spec.State}\n  {r assuming motive}\n  (f_valid : \u2200 env_r s,\n    assuming s \u2192\n    spec.validate (env_r + r) s \u2192 \u2203 r' : spec.Reservation,\n    match f s with\n    | \u27e8t, s'\u27e9 => spec.validate (env_r + r') s' \u2227 motive t r'\n  )\n  : (atomic_read_modify_read f).valid r assuming motive :=by\n  rw [valid]\n  intro env_r s assuming_true initial_valid\n  rw [iterate_rmr]\n  exact f_valid env_r s assuming_true initial_valid\n\ntheorem valid_rm\n  {f : spec.State -> spec.State}\n  {r assuming motive}\n  (f_valid : \u2200 env_r s,\n    assuming s \u2192\n    spec.validate (env_r + r) s \u2192 \u2203 r' : spec.Reservation,\n    match f s with\n    | s' => spec.validate (env_r + r') s' \u2227 motive \u27e8\u27e9 r')\n  : (atomic_read_modify f).valid r assuming motive :=valid_rmr f_valid\n\ntheorem valid_read\n  {f : spec.State -> T}\n  {r assuming motive}\n  (f_valid : \u2200 env_r s,\n    assuming s \u2192\n    spec.validate (env_r + r) s \u2192 \u2203 r' : spec.Reservation,\n    match f s with\n    | t => spec.validate (env_r + r') s \u2227 motive t r')\n  : (atomic_read f).valid r assuming motive :=valid_rmr f_valid\n\ntheorem valid_assert\n  {cond : spec.State -> Bool}\n  {r assuming motive}\n  (motive_holds : motive \u27e8\u27e9 r)\n  (assertion_succeeds : \u2200 env_r s,\n    assuming s \u2192\n    spec.validate (env_r + r) s \u2192\n    cond s)\n  : (atomic_assert cond).valid r assuming motive :=by\n  rw [valid]\n  intro env_r s assuming_true initial_valid\n  rw [iterate_assert]\n  have cond_true :=assertion_succeeds env_r s assuming_true initial_valid\n  rw [cond_true]\n  exists r\n\ntheorem valid_blocking_rmr\n  {block_until : spec.State -> Bool}\n  {f : spec.State -> T \u00d7 spec.State}\n  {r assuming motive}\n  (f_valid : \u2200 env_r s,\n    block_until s \u2192\n    spec.validate (env_r + r) s \u2192 \u2203 r' : spec.Reservation,\n    match f s with\n    | \u27e8t, s'\u27e9 => spec.validate (env_r + r') s' \u2227 motive t r'\n  )\n  : (atomic_blocking_rmr block_until f).valid r assuming motive :=by\n  rw [valid]\n  intro env_r s _ initial_valid\n  simp only [iterate_blocking_rmr, initial_valid, true_and]\n  \n  exists r\n  exact \u27e8initial_valid, valid_rmr f_valid\u27e9\n\nend Mt.TaskM"}
{"text": " The Galveston County Daily News , founded in 1842 , is the city 's primary newspaper and the oldest continuously printed newspaper in Texas . It currently serves as the newspaper of record for the city and the Texas City Post serves as the newspaper of record for the County . Radio station <unk> , on air from 1947 @-@ 2010 , has previously served as a local media outlet . Television station KHOU signed on the air as KGUL @-@ TV on March 23 , 1953 . Originally licensed in Galveston , KGUL was the second television station to launch in the Houston area after <unk> @-@ TV . One of the original investors in the station was actor James Stewart , along with a small group of other Galveston investors . In June 1959 , KGUL changed its call sign to KHOU and moved their main office to Houston . The local hip hop name for Galveston is \" G @-@ town . \" \n"}
{"text": "data \u22a5 : Set where -- keep this on the first line!!\n\nType = Set  -- This should not be gobbled up under the data declaration\n\n-- Andreas, 2021-04-15, issue #1145\n-- Allow stacking of layout keywords on the same line.\n\n-- This files contains tests for the new layout rules\n-- and also tests from debugging the original implementation.\n--\n-- Some original failures where influenced by whether\n-- there were comments or black lines, so please don't\n-- \"clean up\" this file.\n\npostulate A : Set; B : Set\n          C : Set\n\n-- First example\n\nprivate postulate  -- Bar\n  D : Set\n  _>>_ : Set \u2192 Set \u2192 Set\n\nmodule _ where\n  private {- this block comment\n             removes the line breaks\n             between the layout keywords -} postulate\n    D1 : Set\n    E1 : Set\n\n-- Second example\n\nprivate module PM where              -- stack\n  module PMM where\n  private module PMPM1 where\n          module PMPM2 where private -- stack\n            module PMPM2M where\n  module PMM2 where\n\n-- Testing whether do-notation still works\n\ntest = do A; B\n          C\n\nlet-example =\n   let X = A\n       in  B\n\ndo-example = do\n  Set\n  where\n    Y : Set\n    Y = A\n\nF = Set\n\nprivate\n  doey = do\n    Set\n    where postulate poey : Set\n\nE = Set\n"}
{"text": "/-\nCopyright 2022 Google LLC\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nAuthors: Moritz Firsching\n-/\nimport tactic\n/-!\n# Pigeon-hole and double counting\n\n## TODO\n  - statement\n  - 1. Numbers\n    - Claim\n    - Claim\n  - 2. Sequences\n    - Claim\n      - proof\n  - 3. Sums\n    - Claim\n  - Double Counting\n  - 4. Numbers again\n  - 5. Graphs\n    - Theorem\n      - proof\n    - Claim\n  - 6. Sperner's Lemma\n    - proof\n    - Proof of Brouwer's fixed point theorem (for $n = 2$)\n-/\n"}
{"text": "# Get dtm data ------------------------------------------------------------\nif (file.exists(\"data/fal_school_dtm.tif\")) {\n  fal_school = raster(\"data/fal_school_dtm.tif\")\n} else {\n  #Get lidar data\n  fal_school = get_from_xy(\n    xy = c(179011, 033245),\n    radius = 500,\n    resolution = 0.5,\n    model_type = 'DSM'\n  )\n}\n# Get bike route data -----------------------------------------------------\np = read_sf(\"data/full_track.gpx\", layer = \"tracks\")\npp = read_sf(\"data/full_track.gpx\", layer = \"track_points\") # track points\nresting_area = sf::read_sf(\"data/Resting-Area/Resting-area.shp\")\n"}
{"text": "import combinatorics.simple_graph.coloring\n\n\n--OUTPUT 1\ntheorem graph_2_colorable_iff_bipartite : \u2200 G : graph, (\u2203 c : coloring G 2, @is_valid_coloring G c) \u2194 is_bipartite G :=\nbegin\n  -- Let $G$ be a 2-colorable graph, which means we can color every vertex either red or blue,\n  -- and no edge will have both endpoints colored the same color.\n  assume (G : graph),\n  have h1 : \u2200 c : coloring G 2, (@is_valid_coloring G c), from \n        by {\n          assume (c : coloring G 2),\n          sorry,\n        },\n\n  -- Let $A$ denote the subset of vertices colored red, and let $B$ denote the subset of vertices colored blue.\n  have h2 : \u2200 c : coloring G 2, (@is_valid_coloring G c) \u2192\n              (\u2203 A : set (vertex G), \u2203 B : set (vertex G), \n                  (\u2200 v : vertex G, c v = red \u2194 v \u2208 A) \u2227 (\u2200 v : vertex G, c v = blue \u2194 v \u2208 B)), from \n        by {\n          assume (c : coloring G 2) (h2 : @is_valid_coloring G c),\n          sorry,\n        },\n\n  -- $A$ and $B$ are subsets of vertics of $G$, by definition of valid coloring.\n  have h3 : \u2200 c : coloring G 2, (@is_valid_coloring G c) \u2192\n              (\u2203 A : set (vertex G), \u2203 B : set (vertex G), \n                  (\u2200 v : vertex G, c v = red \u2194 v \u2208 A) \u2227 (\u2200 v : vertex G, c v = blue \u2194 v \u2208 B) \u2227\n                  A \u2286 vertex G \u2227 B \u2286 vertex G), from \n        by {\n          assume (c : coloring G 2) (h3 : @is_valid_coloring G c),\n          sorry,\n        },\n\n  -- Since all vertices of $A$ are red, there are no edges within $A$,\n  -- and similarly for $B$.\n  have h4 : \u2200 c : coloring G 2, (@is_valid_coloring G c) \u2192\n              (\u2203 A : set (vertex G), \u2203 B : set (vertex G), \n                  (\u2200 v : vertex G, c v = red \u2194 v \u2208 A) \u2227 (\u2200 v : vertex G, c v = blue \u2194 v \u2208 B) \u2227\n                  A \u2286 vertex G \u2227 B \u2286 vertex G \u2227 \u2200 e : edge G, (source e \u2208 A \u2227 target e \u2208 A) \u2228 (source e \u2208 B \u2227 target e \u2208 B)), from \n        by {\n          assume (c : coloring G 2) (h4 : @is_valid_coloring G c),\n          sorry,\n        },\n\n  -- This implies that every edge has one endpoint in $A$ and the other in $B$,\n  -- which means $G$ is bipartite.\n  have h5 : \u2200 c : coloring G 2, (@is_valid_coloring G c) \u2192\n              (\u2203 A : set (vertex G), \u2203 B : set (vertex G), \n                  (\u2200 v : vertex G, c v = red \u2194 v \u2208 A) \u2227 (\u2200 v : vertex G, c v = blue \u2194 v \u2208 B) \u2227\n                  A \u2286 vertex G \u2227 B \u2286 vertex G \u2227 (\u2200 e : edge G, source e \u2208 A \u2228 source e \u2208 B) \u2227 (\u2200 e : edge G, target e \u2208 A \u2228 target e \u2208 B)), from \n        by {\n          assume (c : coloring G 2) (h5 : @is_valid_coloring G c),\n          sorry,\n        },\n\n  -- Hence the existence of a valid coloring implies that the graph is bipartite.\n  have h6 : \u2200 c : coloring G 2, (@is_valid_coloring G c) \u2192 (\u2203 A : set (vertex G), \u2203 B : set (vertex G), \n                  (\u2200 v : vertex G, c v = red \u2194 v \u2208 A) \u2227 (\u2200 v : vertex G, c v = blue \u2194 v \u2208 B) \u2227\n                  A \u2286 vertex G \u2227 B \u2286 vertex G \u2227 A \u22a5 B \u2227 A \u222a B = vertex G), \n        from \n        by {\n          assume (c : coloring G 2) (h6 : @is_valid_coloring G c),\n          sorry,\n        },\n\n  -- Conversely,\n  have h7 : \u2200 A B : set (vertex G), A \u22a5 B \u2192 A \u2286 vertex G \u2227 B \u2286 vertex G \u2192 A \u222a B = vertex G \u2192 \n              (\u2203 c : coloring G 2, @is_valid_coloring G c \u2227\n                  (\u2200 v : vertex G, c v = red \u2194 v \u2208 A) \u2227 (\u2200 v : vertex G, c v = blue \u2194 v \u2208 B)), from \n        by {\n          assume (A B : set (vertex G)) (h7 : A \u22a5 B) (h8 : A \u2286 vertex G \u2227 B \u2286 vertex G) (h9 : A \u222a B = vertex G),\n          sorry,\n        },\n\n  -- Suppose $G$ is bipartite,\n  have h8 : \u2200 A B : set (vertex G), A \u22a5 B \u2192 A \u2286 vertex G \u2227 B \u2286 vertex G \u2192 A \u222a B = vertex G \u2192 \n              is_bipartite G, from \n        by {\n          assume (A B : set (vertex G)) (h8 : A \u22a5 B) (h9 : A \u2286 vertex G \u2227 B \u2286 vertex G) (h10 : A \u222a B = vertex G),\n          sorry,\n        },\n\n  -- Hence the existence of a valid coloring is equivalent to the graph being bipartite.\n  sorry,\nend\n\n--OUTPUT 2\ntheorem two_colorable_bipartite {G : Type*} : two_colorable G \u2194 bipartite G := sorry\n\n/--`theorem`\nPositive Real Numbers are Closed Under Multiplication\nLet $x, y$ be positive real numbers. Then $x y$ is a positive real number.\n`proof`\nLet $x, y$ be positive real numbers, i.e. $\\exists z \\in \\R : z > 0$. Now,\n\n{{begin-eqn}}\n{{eqn | l = z \\times z\n      | r = z \\times z + z \\times z\n      | c = Real numbers can be multiplied\n}}\n{{eqn | r = z \\times z\n      | c = Real numbers are commutative with multiplication\n}}\n{{eqn | r = z^{2}\n      | c = Real numbers exponentiation is multiplication\n}}\n{{eqn | r = x^{2}\n      | c = Real numbers are equal if the difference is zero\n}}\n{{eqn | r = y^{2}\n      | c = Real numbers are equal if the difference is zero\n}}\n{{eqn | r = (x y)^{2}\n      | c = Real numbers exponentiation is multiplication\n}}\n{{eqn | r = (x y) \\times (x y)\n      | c = Real numbers exponentiation is multiplication\n}}\n{{eqn | r = x \\times (x y)\n      | c = Real numbers are commutative with multiplication\n}}\n{{eqn | r = x \\times y\n      | c = Real numbers are commutative with multiplication\n}}\n{{end-eqn}\n\nNote that we've shown that $z > 0 \\implies z^{2} > 0$.\n{{qed}}\n-/\ntheorem positive_real_multiply_closed : \u2200 x y : \u211d, x > 0 \u2192 y > 0 \u2192 x*y > 0 :=\nbegin\n  -- Let x, y be positive real numbers\n  assume (x y : \u211d) (hx : x > 0) (hy : y > 0),\n  -- Then $x y$ is a positive real number\n  have h1 : x * y > 0, from sorry,\n  show x * y > 0, from h1,\nend\n\n--OUTPUT 3\ntheorem bipartite_colorable (G : Type*) [graph G] :\n  \u2200 red blue, \n  \u2200 v : G, v \u2208 red \u2228 v \u2208 blue :=\nbegin\n  sorry,\nend\n\n--OUTPUT 4\ntheorem two_colorable_bipartite (G : Type*) : sorry := sorry\n\n/-\njarrick\n\n`theorem`\n`proof`\n-/\n\n/--`theorem`\n`proof`\n-/\n\n/--`theorem`\n`proof`\n-/\n\n/--`theorem`\n`proof`\n-/\n\n/--`theorem`\n`proof`\n-/\n\n/--`theorem`\n`proof`\n-/\n\n/--`theorem`\n`proof`\n-/\nend\n\n--OUTPUT 5\ntheorem bipartite_graph_two_colorable {G : Type*} [graph G] : (\u2203 c : G \u2192 \u2115, c valid) \u2194 is_bipartite G := \nbegin\n  have h1 : \u2203 c : G \u2192 \u2115, c valid \u2192 is_bipartite G, from sorry,\n  have h2 : is_bipartite G \u2192 \u2203 c : G \u2192 \u2115, c valid, from sorry,\n  show (\u2203 c : G \u2192 \u2115, c valid) \u2194 is_bipartite G, from sorry,\nend\n\n--OUTPUT 6\ntheorem bipartite_graph_colorable {G : Type*} [graph G] : bipartite G \u2194 2-colorable G :=\nbegin\n  -- Let G be a 2-colorable graph, which means we can color every vertex either red or blue, and no edge will have both endpoints colored the same color\n  have h1 : 2-colorable G \u2192 \u2200 a b : G, \u2203! v : G, (a, v) \u2208 edges G \u2228 (v, a) \u2208 edges G, from sorry,\n  -- Let A denote the subset of vertices colored red, and let B denote the subset of vertices colored blue\n  have h2 : 2-colorable G \u2192 \u2203 A B : set G, \u2200 v : G, (v \u2208 A \u2227 \u00ac v \u2208 B) \u2228 (v \u2208 B \u2227 \u00ac v \u2208 A), from sorry,\n  -- Since all vertices of A are red, there are no edges within A\n  have h3 : 2-colorable G \u2192 \u2200 A B : set G, \u2203! v : G, (v \u2208 A \u2227 \u00ac v \u2208 B) \u2228 (v \u2208 B \u2227 \u00ac v \u2208 A) \u2192 \u2200 a, b \u2208 A, (a, b) \u2209 edges G, from sorry,\n  -- similarly for B\n  have h4 : 2-colorable G \u2192 \u2200 A B : set G, \u2203! v : G, (v \u2208 A \u2227 \u00ac v \u2208 B) \u2228 (v \u2208 B \u2227 \u00ac v \u2208 A) \u2192 \u2200 a, b \u2208 B, (a, b) \u2209 edges G, from sorry,\n  -- This implies that every edge has one endpoint in A and the other in B\n  have h5 : 2-colorable G \u2192 \u2200 A B : set G, \u2203! v : G, (v \u2208 A \u2227 \u00ac v \u2208 B) \u2228 (v \u2208 B \u2227 \u00ac v \u2208 A) \u2192 \u2200 e : G \u00d7 G, e \u2208 edges G \u2192 e.1 \u2208 A \u2228 e.2 \u2208 B, from sorry,\n  -- which means G is bipartite\n  have h6 : 2-colorable G \u2192 \u2200 A B : set G, \u2203! v : G, (v \u2208 A \u2227 \u00ac v \u2208 B) \u2228 (v \u2208 B \u2227 \u00ac v \u2208 A) \u2192 \u2200 e : G \u00d7 G, e \u2208 edges G \u2192 e.1 \u2208 A \u2228 e.2 \u2208 B \u2192 bipartite G, from sorry,\n  -- Conversely, suppose G is bipartite, that is, we can partition the vertices into two subsets V1, V2 every edge has one endpoint in V1 and the other in V2\n  have h7 : bipartite G \u2192 \u2203 A B : set G, \u2200 e : G \u00d7 G, e \u2208 edges G \u2192 e.1 \u2208 A \u2228 e.2 \u2208 B, from sorry,\n  -- Then coloring every vertex of V1 red and every vertex of V2 blue yields a valid coloring\n  have h8 : bipartite G \u2192 \u2203 A B : set G, \u2200 e : G \u00d7 G, e \u2208 edges G \u2192 e.1 \u2208 A \u2228 e.2 \u2208 B \u2192 \u2203! v : G, (v \u2208 A \u2227 \u00ac v \u2208 B) \u2228 (v \u2208 B \u2227 \u00ac v \u2208 A), from sorry,\n  -- so G is 2-colorable\n  have h9 : bipartite G \u2192 \u2203 A B : set G, \u2200 e : G \u00d7 G, e \u2208 edges G \u2192 e.1 \u2208 A \u2228 e.2 \u2208 B \u2192 \u2203! v : G, (v \u2208 A \u2227 \u00ac v \u2208 B) \u2228 (v \u2208 B \u2227 \u00ac v \u2208 A) \u2192 2-colorable G, from sorry,\n\n  show bipartite G \u2194 2-colorable G, from by {\n    sorry,\n  }\nend\n\n--OUTPUT 7\ntheorem two_colorable_bipartite (G : Type*) [graph G] : is_two_colorable G \u2194 is_bipartite G :=\nbegin\n    -- Let $G$ be a 2-colorable graph, which means we can color every vertex either red or blue, and no edge will have both endpoints colored the same color. Let $A$ denote the subset of vertices colored red, and let $B$ denote the subset of vertices colored blue. Since all vertices of $A$ are red, there are no edges within $A$, and similarly for $B$. This implies that every edge has one endpoint in $A$ and the other in $B$, which means $G$ is bipartite.\n    assume h1 : is_two_colorable G,\n    have h2 : \u2203 A B : set G, \u2200 a : G, (a \u2208 A \u2228 a \u2208 B) \u2227 (\u2200 v\u2081 : G, \u2200 v\u2082 : G, \u00ac (a = v\u2081 \u2227 a = v\u2082)), from sorry,\n    have h3 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a = v\u2081 \u2227 a = v\u2082), from sorry,\n    have h4 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, (a = v\u2081 \u2227 a = v\u2082) \u2192 false, from sorry,\n    have h5 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, (a = v\u2081 \u2227 a = v\u2082) \u2192 \u22a5, from sorry,\n    have h6 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 A \u2227 v\u2081 \u2208 A \u2227 v\u2082 \u2208 A \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h7 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 B \u2227 v\u2081 \u2208 B \u2227 v\u2082 \u2208 B \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h8 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 A \u2227 v\u2081 \u2208 A \u2227 v\u2082 \u2208 B \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h9 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 B \u2227 v\u2081 \u2208 B \u2227 v\u2082 \u2208 A \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    show is_bipartite G, from sorry,\n    -- Conversely, suppose $G$ is bipartite, that is, we can partition the vertices into two subsets $V_{1}, V_{2}$ every edge has one endpoint in $V_{1}$ and the other in $V_{2}$. Then coloring every vertex of $V_{1}$ red and every vertex of $V_{2}$ blue yields a valid coloring, so $G$ is 2-colorable.\n    assume h1 : is_bipartite G,\n    have h2 : \u2203 (A B : set G) (f : G \u2192 Prop \u2227 Prop), \u2200 a : G, (a \u2208 A \u2228 a \u2208 B) \u2227 (\u2200 v\u2081 v\u2082 : G, \u00ac (a = v\u2081 \u2227 a = v\u2082)) \n      \u2227 (\u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 A \u2227 v\u2081 \u2208 A \u2227 v\u2082 \u2208 A \u2227 (v\u2081, v\u2082) \u2208 E a)) \n      \u2227 (\u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 B \u2227 v\u2081 \u2208 B \u2227 v\u2082 \u2208 B \u2227 (v\u2081, v\u2082) \u2208 E a)) \n      \u2227 (\u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 A \u2227 v\u2081 \u2208 A \u2227 v\u2082 \u2208 B \u2227 (v\u2081, v\u2082) \u2208 E a)) \n      \u2227 (\u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 B \u2227 v\u2081 \u2208 B \u2227 v\u2082 \u2208 A \u2227 (v\u2081, v\u2082) \u2208 E a)) \n      \u2227 \u2200 a : G, f a = (a \u2208 A, a \u2208 B), from sorry,\n    have h3 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a = v\u2081 \u2227 a = v\u2082), from sorry,\n    have h4 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 A \u2227 v\u2081 \u2208 A \u2227 v\u2082 \u2208 A \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h5 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 B \u2227 v\u2081 \u2208 B \u2227 v\u2082 \u2208 B \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h6 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 A \u2227 v\u2081 \u2208 A \u2227 v\u2082 \u2208 B \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h7 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 B \u2227 v\u2081 \u2208 B \u2227 v\u2082 \u2208 A \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h8 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 A \u2227 v\u2081 \u2208 B \u2227 v\u2082 \u2208 A \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    have h9 : \u2200 a : G, \u2200 v\u2081 v\u2082 : G, \u00ac (a \u2208 B \u2227 v\u2081 \u2208 A \u2227 v\u2082 \u2208 B \u2227 (v\u2081, v\u2082) \u2208 E a), from sorry,\n    show is_two_colorable G, from by {\n      use A \u222a B, \n      use sorry,\n      use sorry,\n      use sorry,\n      use sorry,\n      use sorry,\n      use sorry,\n    },\nend\n\n--OUTPUT 8\ntheorem two_colorable_iff_bipartite (G : Type*) [pgraph G] : two_colorable G \u2194 bipartite G :=\nbegin\n  -- $G$ is 2-colorable, \n  assume (h1 : two_colorable G),\n  -- We can color every vertex either red or blue, \n  have h2 : \u2203 f : finset (vertex G) \u2192 finset (vertex G), \u2200 (x : vertex G), x \u2208 f x \u2228 x \u2208 f ((finset.univ : finset (vertex G))\\(f x)), from sorry,\n  -- No edge will have both endpoints colored the same color. \n  have h3 : \u2200 (x y : vertex G), x \u2260 y \u2192 x \u2208 f x \u2192 y \u2208 f ((finset.univ : finset (vertex G))\\(f x)), from sorry,\n  let f : finset (vertex G) \u2192 finset (vertex G) := fml,\n  let A : finset (vertex G) := finset.image f (finset.univ : finset (vertex G)),\n  let B : finset (vertex G) := finset.univ\\A,\n  -- $A$ denote the subset of vertices colored red, \n  have h4 : \u2200 (x : vertex G), x \u2208 A \u2194 x \u2208 f x, from sorry,\n  -- $B$ denote the subset of vertices colored blue, \n  have h5 : \u2200 (x : vertex G), x \u2208 B \u2194 x \u2209 f x, from sorry,\n  -- Since all vertices of $A$ are red, \n  have h6 : \u2200 (x : vertex G), x \u2208 A \u2192 x \u2209 B, from sorry,\n  -- There are no edges within $A$, \n  have h7 : \u2200 (x y : vertex G), x \u2208 A \u2192 y \u2208 A \u2192 \u00ac edge G x y, from sorry,\n  -- Similarly, there are no edges within $B$, \n  have h8 : \u2200 (x y : vertex G), x \u2208 B \u2192 y \u2208 B \u2192 \u00ac edge G x y, from sorry,\n  -- This implies that every edge has one endpoint in $A$ and the other in $B$, \n  -- which means $G$ is bipartite.\n  have h9 : bipartite G, from sorry,\n  show bipartite G, from sorry,\n\n  -- Conversely, suppose $G$ is bipartite, \n  assume (h1 : bipartite G),\n  -- That is, we can partition the vertices into two subsets $V_1, V_2$ \n  have h2 : \u2203 A B : finset (vertex G), is_independent_set G A \u2227 is_independent_set G B \u2227 \u2200 (x : vertex G), x \u2209 A \u2228 x \u2209 B, from sorry,\n  let (A B : finset (vertex G)) := fml,\n  assume (h3 : is_independent_set G A),\n  assume (h4 : is_independent_set G B),\n  assume (h5 : \u2200 (x : vertex G), x \u2209 A \u2228 x \u2209 B),\n  -- Every edge has one endpoint in $V_1$ and the other in $V_2$\n  have h6 : \u2200 (x y : vertex G), edge G x y \u2192 x \u2209 A \u2192 y \u2209 A, from sorry,\n  have h7 : \u2200 (x y : vertex G), edge G x y \u2192 x \u2209 B \u2192 y \u2209 B, from sorry,\n  \n  -- Then coloring every vertex of $V_1$ red and every vertex of $V_2$ blue \n  have h8 : two_colorable G, from sorry,\n  show two_colorable G, from sorry,\nend\n\n--OUTPUT 9\ntheorem bipartite_is_two_colorable (G : Type*):\n(\u2200 v : \u2115, v \u2208 G \u2228 v \u2209 G) \u2192\n(\u2200 u v : \u2115, (u \u2260 v) \u2227 (v \u2208 G) \u2227 (u \u2208 G) \u2192 u \u2194 v) \u2192\n(\u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (\u2200 v : \u2115, v \u2208 A \u222a B) \u2227 ((v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B))) \u2192\n\u2203 (A B : \u2115 \u2192 Prop), \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2227 ((v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B))\n\n:= by {\n\n    -- Let $G$ be a 2-colorable graph, which means we can color every vertex either red or blue, and no edge will have both endpoints colored the same color. \n    assume (h1 : \u2200 v : \u2115, v \u2208 G \u2228 v \u2209 G),\n    have h2 : \u2200 u v : \u2115, (u \u2260 v) \u2227 (v \u2208 G) \u2227 (u \u2208 G) \u2192 u \u2194 v, from sorry,\n    have h3 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (\u2200 v : \u2115, v \u2208 A \u222a B) \u2227 ((v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B)), from sorry,\n    -- Let $A$ denote the subset of vertices colored red, and let $B$ denote the subset of vertices colored blue. \n    show \u2203 (A B : \u2115 \u2192 Prop), \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2227 ((v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B)), from by {\n        show \u2203 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2227 ((v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B)), from sorry,\n        -- Since all vertices of $A$ are red, there are no edges within $A$, and similarly for $B$. \n        have h4 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 v \u2208 A \u2192 w \u2208 A \u2192 \u00ac (v \u2194 w), from sorry,\n        have h5 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 v \u2208 B \u2192 w \u2208 B \u2192 \u00ac (v \u2194 w), from sorry,\n        -- This implies that every edge has one endpoint in $A$ and the other in $B$, which means $G$ is bipartite.\n        have h6 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B) \u2192 v \u2194 w, from sorry,\n        have h6 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B) \u2192 v \u2208 G \u2227 w \u2208 G, from sorry,\n        have h7 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B) \u2192 v \u2194 w, from sorry,\n        have h8 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B) \u2192 (\u2200 v w : \u2115, v \u2208 A \u2227 w \u2208 B) \u2227 (\u2200 v w : \u2115, v \u2208 B \u2227 w \u2208 A), from sorry,\n        have h9 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B) \u2192 (\u2200 v w : \u2115, v \u2208 A \u2227 w \u2208 B) \u2227 (\u2200 v w : \u2115, v \u2208 B \u2227 w \u2208 A), from sorry,\n        have h10 : \u2200 A B : \u2115 \u2192 Prop, \u2200 v w : \u2115, (\u2200 u : \u2115, u \u2208 G \u2192 (u \u2208 A \u2192 \u00ac u \u2208 B) \u2227 (u \u2208 B \u2192 \u00ac u \u2208 A)) \u2192 (v \u2208 A \u2227 w \u2208 B) \u2228 (v \u2208 B \u2227 w \u2208 A) \u2228 (v \u2208 A \u2227 w \u2208 A) \u2228 (v \u2208 B \u2227 w \u2208 B) \u2192 (\u2203 A B : \u2115 \u2192\nend --Needs more than 2000 tokens!\n\n--OUTPUT 10\ntheorem is_2_colorable_iff_bipartite (G : Type*) [graph G] : 2-colorable G \u2194 bipartite G :=\nbegin\n  assume (h1 : colorable G 2),\n\n  -- Let $G$ be a 2-colorable graph, which means we can color every vertex either red or blue, and no edge will have both endpoints colored the same color. Let $A$ denote the subset of vertices colored red, and let $B$ denote the subset of vertices colored blue.\n  have h2 : \u2203 red blue : G, (\u2200 vertex : G, vertex \u2208 red \u2228 vertex \u2208 blue) \u2227 (\u2200 {u v}, edge u v \u2192 u \u2208 red \u2227 v \u2208 blue \u2228 u \u2208 blue \u2227 v \u2208 red), from sorry,\n  let h3 : \u2203 red blue : G, (\u2200 vertex : G, vertex \u2208 red \u2228 vertex \u2208 blue) \u2227 (\u2200 {u v}, edge u v \u2192 u \u2208 red \u2227 v \u2208 blue \u2228 u \u2208 blue \u2227 v \u2208 red) := h2,\n  let red blue := classical.some h3,\n  let h4 : (\u2200 vertex : G, vertex \u2208 red \u2228 vertex \u2208 blue) \u2227 (\u2200 {u v}, edge u v \u2192 u \u2208 red \u2227 v \u2208 blue \u2228 u \u2208 blue \u2227 v \u2208 red) := classical.some_spec h3,\n  let h5 : \u2200 vertex : G, vertex \u2208 red \u2228 vertex \u2208 blue := h4.left,\n  let h6 : \u2200 {u v}, edge u v \u2192 u \u2208 red \u2227 v \u2208 blue \u2228 u \u2208 blue \u2227 v \u2208 red := h4.right,\n\n  -- Since all vertices of $A$ are red, there are no edges within $A$, and similarly for $B$.\n  have h7 : \u2200 {u v}, edge u v \u2192 u \u2208 red \u2227 v \u2208 blue \u2228 u \u2208 blue \u2227 v \u2208 red, from\n  begin\n    assume (u v : G) (h7 : edge u v),\n    show u \u2208 red \u2227 v \u2208 blue \u2228 u \u2208 blue \u2227 v \u2208 red, from sorry,\n  end,\n  have h8 : \u2200 {u v}, u \u2208 red \u2227 v \u2208 blue \u2192 edge u v, from\n  begin\n    assume (u v : G) (h8 : u \u2208 red \u2227 v \u2208 blue),\n    show edge u v, from sorry,\n  end,\n  have h9 : \u2200 {u v}, u \u2208 blue \u2227 v \u2208 red \u2192 edge u v, from\n  begin\n    assume (u v : G) (h9 : u \u2208 blue \u2227 v \u2208 red),\n    show edge u v, from sorry,\n  end,\n  have h10 : \u2200 {u v}, u \u2208 red \u2227 v \u2208 red \u2192 \u00ac edge u v, from\n  begin\n    assume (u v : G) (h10 : u \u2208 red \u2227 v \u2208 red),\n    have h11 : u \u2209 red \u2228 v \u2209 red, from sorry,\n    have h12 : \u00ac (u \u2208 red \u2227 v \u2208 blue), from sorry,\n    show \u00ac edge u v, from sorry,\n  end,\n  have h11 : \u2200 {u v}, u \u2208 blue \u2227 v \u2208 blue \u2192 \u00ac edge u v, from\n  begin\n    assume (u v : G) (h11 : u \u2208 blue \u2227 v \u2208 blue),\n    have h12 : u \u2209 blue \u2228 v \u2209 blue, from sorry,\n    have h13 : \u00ac (u \u2208 blue \u2227 v \u2208 red), from sorry,\n    show \u00ac edge u v, from sorry,\n  end,\n\n  -- This implies that every edge has one endpoint in $A$ and the other in $B$, which means $G$ is bipartite.\n  have h12 : bipartite G, from sorry,\n  have h13 : \u2203! c : colorable G 2, bipartite G, from\n  begin\n    use h1,\n    show bipartite G, from sorry,\n  end,\n  have h14 : \u2200 c : colorable G 2, bipartite G, from\n  begin\n    assume (c : colorable G 2),\n    show bipartite G, from sorry,\n  end,\n\n  show 2-colorable G \u2194 bipartite G, from sorry,\nend\n\n/- FEW SHOT PROMPTS TO CODEX(START)\n/--`theorem`\nPower Set is Closed under Intersection\nLet $S$ be a set.\n\nLet $\\powerset S$ be the power set of $S$.\n\n\nThen:\n:$\\forall A, B \\in \\powerset S: A \\cap B \\in \\powerset S$\n`proof`\nLet $A, B \\in \\powerset S$.\n\nThen by the definition of power set, $A \\subseteq S$ and $B \\subseteq S$.\n\nFrom Intersection is Subset we have that $A \\cap B \\subseteq A$.\n\nIt follows from Subset Relation is Transitive that $A \\cap B \\subseteq S$.\n\nThus $A \\cap B \\in \\powerset S$ and closure is proved.\n{{qed}}\n-/\ntheorem power_set_intersection_closed {\u03b1 : Type*} (S : set \u03b1) : \u2200 A B \u2208 \ud835\udcab S, (A \u2229 B) \u2208 \ud835\udcab S :=\nbegin\n  -- $A$ and $B$ are sets. $A$ and $B$ belong to power set of $S$\n  assume (A : set \u03b1) (hA : A \u2208 \ud835\udcab S) (B : set \u03b1) (hB : B \u2208 \ud835\udcab S),\n  -- Then $A \u2286 S$ and $B \u2286 S$, by power set definition\n  have h1 : (A \u2286 S) \u2227 (B \u2286 S), from sorry,\n  -- Then $(A \u2229 B) \u2286 A$, by intersection of set is a subset\n  have h2 : (A \u2229 B) \u2286 A, from sorry,\n  -- Then $(A \u2229 B) \u2286 S$, by subset relation is transitive \n  have h3 : (A \u2229 B) \u2286 S, from sorry,\n  -- Hence $(A \u2229 B) \u2208  \ud835\udcab S$, by power set definition\n  show (A \u2229 B) \u2208  \ud835\udcab S, from sorry,\nend\n\n/--`theorem`\nSquare of Sum\n :$\\forall x, y \\in \\R: \\paren {x + y}^2 = x^2 + 2 x y + y^2$\n`proof`\nFollows from the distribution of multiplication over addition:\n\n{{begin-eqn}}\n{{eqn | l = \\left({x + y}\\right)^2\n      | r = \\left({x + y}\\right) \\cdot \\left({x + y}\\right)\n}}\n{{eqn | r = x \\cdot \\left({x + y}\\right) + y \\cdot \\left({x + y}\\right)\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x \\cdot x + x \\cdot y + y \\cdot x + y \\cdot y\n      | c = Real Multiplication Distributes over Addition\n}}\n{{eqn | r = x^2 + 2xy + y^2\n      | c = \n}}\n{{end-eqn}}\n{{qed}}\n-/\ntheorem square_of_sum (x y : \u211d) : (x + y)^2 = (x^2 + 2*x*y + y^2) := \nbegin\n  -- expand the power\n  calc (x + y)^2 = (x+y)*(x+y) : by sorry\n  -- distributive property of multiplication over addition gives:\n  ... = x*(x+y) + y*(x+y) : by sorry\n  -- applying the above property further gives:\n  ... = x*x + x*y + y*x + y*y : by sorry\n  -- rearranging the terms using commutativity and adding gives:\n  ... = x^2 + 2*x*y + y^2 : by sorry,\nend\n\n/--`theorem`\nIdentity of Group is Unique\nLet $\\struct {G, \\circ}$ be a group. Then there is a unique identity element $e \\in G$.\n`proof`\nFrom Group has Latin Square Property, there exists a unique $x \\in G$ such that:\n:$a x = b$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = b$\n\nSetting $b = a$, this becomes:\n\nThere exists a unique $x \\in G$ such that:\n:$a x = a$\n\nand there exists a unique $y \\in G$ such that:\n:$y a = a$\n\nThese $x$ and $y$ are both $e$, by definition of identity element.\n{{qed}}\n-/\ntheorem group_identity_unique {G : Type*} [group G] : \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a :=\nbegin\n  -- Group has Latin Square Property\n  have h1 : \u2200 a b : G, \u2203! x : G, a * x = b, from sorry,\n  have h2 : \u2200 a b : G, \u2203! y : G, y * a = b, from sorry,\n\n  -- Setting $b = a$, this becomes:\n  have h3 : \u2200 a : G, \u2203! x : G, a * x = a, from sorry,\n  have h4 : \u2200 a : G, \u2203! y : G, y * a = a, from sorry,\n\n  -- These $x$ and $y$ are both $(1 : G)$, by definition of identity element\n  have h5 : \u2200 a : G, classical.some (h3 a) = (1 : G), from sorry,\n  have h6 : \u2200 a : G, classical.some (h4 a) = (1 : G), from sorry,\n\n  show \u2203! e : G, \u2200 a : G, e * a = a \u2227 a * e = a, from by {\n    use (1 : G),\n    have h7 : \u2200 e : G, (\u2200 a : G, e * a = a \u2227 a * e = a) \u2192 e = 1, from by {\n      assume (e : G) (h7 : \u2200 a : G, e * a = a \u2227 a * e = a),\n      have h8 : \u2200 a : G, e = classical.some (h3 a), from sorry,\n      have h9 : \u2200 a : G, e = classical.some (h4 a), from sorry,\n      show e = (1 : G), from sorry,     \n    },\n    sorry,\n  }\nend\n\n/--`theorem`\nBipartite Graph is two colorable\nLet $G$ be a graph. Then $G$ is 2-colorable if and only if $G$ is bipartite.\n`proof`\nLet $G$ be a 2-colorable graph, which means we can color every vertex either red or blue, and no edge will have both endpoints colored the same color. Let $A$ denote the subset of vertices colored red, and let $B$ denote the subset of vertices colored blue. Since all vertices of $A$ are red, there are no edges within $A$, and similarly for $B$. This implies that every edge has one endpoint in $A$ and the other in $B$, which means $G$ is bipartite.\n\nConversely, suppose $G$ is bipartite, that is, we can partition the vertices into two subsets $V_{1}, V_{2}$ every edge has one endpoint in $V_{1}$ and the other in $V_{2}$. Then coloring every vertex of $V_{1}$ red and every vertex of $V_{2}$ blue yields a valid coloring, so $G$ is 2-colorable.\n\nQED\n\n-/\ntheorem \nFEW SHOT PROMPTS TO CODEX(END)-/\n"}
{"text": "C02W82DBHV2R:~ i847419$ coqtop\nWelcome to Coq 8.8.0 (April 2018)\n\nCoq < Require Import Classical.\n\nCoq < \nCoq < Theorem exp002: (forall I R : Prop, ((I /\\ ~R) /\\ ~I) -> R).\n1 subgoal\n  \n  ============================\n  forall I R : Prop, (I /\\ ~ R) /\\ ~ I -> R\n\nexp002 < intros.\n1 subgoal\n  \n  I, R : Prop\n  H : (I /\\ ~ R) /\\ ~ I\n  ============================\n  R\n\nexp002 < destruct H.\n1 subgoal\n  \n  I, R : Prop\n  H : I /\\ ~ R\n  H0 : ~ I\n  ============================\n  R\n\nexp002 < destruct H.\n1 subgoal\n  \n  I, R : Prop\n  H : I\n  H1 : ~ R\n  H0 : ~ I\n  ============================\n  R\n\nexp002 < tauto.\nNo more subgoals.\n\nexp002 < Qed.\nexp002 is defined\n\nCoq < \n"}
